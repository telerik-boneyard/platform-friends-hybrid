if (typeof define !== "undefined" && define.amd) { define(function () { return Everlive; }); }(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],2:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],3:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;

function drainQueue() {
    if (draining) {
        return;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        var i = -1;
        while (++i < len) {
            currentQueue[i]();
        }
        len = queue.length;
    }
    draining = false;
}
process.nextTick = function (fun) {
    queue.push(fun);
    if (!draining) {
        setTimeout(drainQueue, 0);
    }
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],4:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],5:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":4,"_process":3,"inherits":2}],6:[function(require,module,exports){
/**
 * This script gives you the zone info key representing your device's time zone setting.
 *
 * @name jsTimezoneDetect
 * @version 1.0.5
 * @author Jon Nylander
 * @license MIT License - http://www.opensource.org/licenses/mit-license.php
 *
 * For usage and examples, visit:
 * http://pellepim.bitbucket.org/jstz/
 *
 * Copyright (c) Jon Nylander
 */

/*jslint undef: true */
/*global console, exports*/

(function(root) {
  /**
   * Namespace to hold all the code for timezone detection.
   */
  var jstz = (function () {
      'use strict';
      var HEMISPHERE_SOUTH = 's',
          
          /**
           * Gets the offset in minutes from UTC for a certain date.
           * @param {Date} date
           * @returns {Number}
           */
          get_date_offset = function (date) {
              var offset = -date.getTimezoneOffset();
              return (offset !== null ? offset : 0);
          },

          get_date = function (year, month, date) {
              var d = new Date();
              if (year !== undefined) {
                d.setFullYear(year);
              }
              d.setMonth(month);
              d.setDate(date);
              return d;
          },

          get_january_offset = function (year) {
              return get_date_offset(get_date(year, 0 ,2));
          },

          get_june_offset = function (year) {
              return get_date_offset(get_date(year, 5, 2));
          },

          /**
           * Private method.
           * Checks whether a given date is in daylight saving time.
           * If the date supplied is after august, we assume that we're checking
           * for southern hemisphere DST.
           * @param {Date} date
           * @returns {Boolean}
           */
          date_is_dst = function (date) {
              var is_southern = date.getMonth() > 7,
                  base_offset = is_southern ? get_june_offset(date.getFullYear()) : 
                                              get_january_offset(date.getFullYear()),
                  date_offset = get_date_offset(date),
                  is_west = base_offset < 0,
                  dst_offset = base_offset - date_offset;
                  
              if (!is_west && !is_southern) {
                  return dst_offset < 0;
              }

              return dst_offset !== 0;
          },

          /**
           * This function does some basic calculations to create information about
           * the user's timezone. It uses REFERENCE_YEAR as a solid year for which
           * the script has been tested rather than depend on the year set by the
           * client device.
           *
           * Returns a key that can be used to do lookups in jstz.olson.timezones.
           * eg: "720,1,2". 
           *
           * @returns {String}
           */

          lookup_key = function () {
              var january_offset = get_january_offset(),
                  june_offset = get_june_offset(),
                  diff = january_offset - june_offset;

              if (diff < 0) {
                  return january_offset + ",1";
              } else if (diff > 0) {
                  return june_offset + ",1," + HEMISPHERE_SOUTH;
              }

              return january_offset + ",0";
          },

          /**
           * Uses get_timezone_info() to formulate a key to use in the olson.timezones dictionary.
           *
           * Returns a primitive object on the format:
           * {'timezone': TimeZone, 'key' : 'the key used to find the TimeZone object'}
           *
           * @returns Object
           */
          determine = function () {
              var key = lookup_key();
              return new jstz.TimeZone(jstz.olson.timezones[key]);
          },

          /**
           * This object contains information on when daylight savings starts for
           * different timezones.
           *
           * The list is short for a reason. Often we do not have to be very specific
           * to single out the correct timezone. But when we do, this list comes in
           * handy.
           *
           * Each value is a date denoting when daylight savings starts for that timezone.
           */
          dst_start_for = function (tz_name) {

            var ru_pre_dst_change = new Date(2010, 6, 15, 1, 0, 0, 0), // In 2010 Russia had DST, this allows us to detect Russia :)
                dst_starts = {
                    'America/Denver': new Date(2011, 2, 13, 3, 0, 0, 0),
                    'America/Mazatlan': new Date(2011, 3, 3, 3, 0, 0, 0),
                    'America/Chicago': new Date(2011, 2, 13, 3, 0, 0, 0),
                    'America/Mexico_City': new Date(2011, 3, 3, 3, 0, 0, 0),
                    'America/Asuncion': new Date(2012, 9, 7, 3, 0, 0, 0),
                    'America/Santiago': new Date(2012, 9, 3, 3, 0, 0, 0),
                    'America/Campo_Grande': new Date(2012, 9, 21, 5, 0, 0, 0),
                    'America/Montevideo': new Date(2011, 9, 2, 3, 0, 0, 0),
                    'America/Sao_Paulo': new Date(2011, 9, 16, 5, 0, 0, 0),
                    'America/Los_Angeles': new Date(2011, 2, 13, 8, 0, 0, 0),
                    'America/Santa_Isabel': new Date(2011, 3, 5, 8, 0, 0, 0),
                    'America/Havana': new Date(2012, 2, 10, 2, 0, 0, 0),
                    'America/New_York': new Date(2012, 2, 10, 7, 0, 0, 0),
                    'Europe/Helsinki': new Date(2013, 2, 31, 5, 0, 0, 0),
                    'Pacific/Auckland': new Date(2011, 8, 26, 7, 0, 0, 0),
                    'America/Halifax': new Date(2011, 2, 13, 6, 0, 0, 0),
                    'America/Goose_Bay': new Date(2011, 2, 13, 2, 1, 0, 0),
                    'America/Miquelon': new Date(2011, 2, 13, 5, 0, 0, 0),
                    'America/Godthab': new Date(2011, 2, 27, 1, 0, 0, 0),
                    'Europe/Moscow': ru_pre_dst_change,
                    'Asia/Amman': new Date(2013, 2, 29, 1, 0, 0, 0),
                    'Asia/Beirut': new Date(2013, 2, 31, 2, 0, 0, 0),
                    'Asia/Damascus': new Date(2013, 3, 6, 2, 0, 0, 0),
                    'Asia/Jerusalem': new Date(2013, 2, 29, 5, 0, 0, 0),
                    'Asia/Yekaterinburg': ru_pre_dst_change,
                    'Asia/Omsk': ru_pre_dst_change,
                    'Asia/Krasnoyarsk': ru_pre_dst_change,
                    'Asia/Irkutsk': ru_pre_dst_change,
                    'Asia/Yakutsk': ru_pre_dst_change,
                    'Asia/Vladivostok': ru_pre_dst_change,
                    'Asia/Baku': new Date(2013, 2, 31, 4, 0, 0),
                    'Asia/Yerevan': new Date(2013, 2, 31, 3, 0, 0),
                    'Asia/Kamchatka': ru_pre_dst_change,
                    'Asia/Gaza': new Date(2010, 2, 27, 4, 0, 0),
                    'Africa/Cairo': new Date(2010, 4, 1, 3, 0, 0),
                    'Europe/Minsk': ru_pre_dst_change,
                    'Pacific/Apia': new Date(2010, 10, 1, 1, 0, 0, 0),
                    'Pacific/Fiji': new Date(2010, 11, 1, 0, 0, 0),
                    'Australia/Perth': new Date(2008, 10, 1, 1, 0, 0, 0)
                };

              return dst_starts[tz_name];
          };

      return {
          determine: determine,
          date_is_dst: date_is_dst,
          dst_start_for: dst_start_for 
      };
  }());

  /**
   * Simple object to perform ambiguity check and to return name of time zone.
   */
  jstz.TimeZone = function (tz_name) {
      'use strict';
        /**
         * The keys in this object are timezones that we know may be ambiguous after
         * a preliminary scan through the olson_tz object.
         *
         * The array of timezones to compare must be in the order that daylight savings
         * starts for the regions.
         */
      var AMBIGUITIES = {
              'America/Denver':       ['America/Denver', 'America/Mazatlan'],
              'America/Chicago':      ['America/Chicago', 'America/Mexico_City'],
              'America/Santiago':     ['America/Santiago', 'America/Asuncion', 'America/Campo_Grande'],
              'America/Montevideo':   ['America/Montevideo', 'America/Sao_Paulo'],
              'Asia/Beirut':          ['Asia/Amman', 'Asia/Jerusalem', 'Asia/Beirut', 'Europe/Helsinki','Asia/Damascus'],
              'Pacific/Auckland':     ['Pacific/Auckland', 'Pacific/Fiji'],
              'America/Los_Angeles':  ['America/Los_Angeles', 'America/Santa_Isabel'],
              'America/New_York':     ['America/Havana', 'America/New_York'],
              'America/Halifax':      ['America/Goose_Bay', 'America/Halifax'],
              'America/Godthab':      ['America/Miquelon', 'America/Godthab'],
              'Asia/Dubai':           ['Europe/Moscow'],
              'Asia/Dhaka':           ['Asia/Yekaterinburg'],
              'Asia/Jakarta':         ['Asia/Omsk'],
              'Asia/Shanghai':        ['Asia/Krasnoyarsk', 'Australia/Perth'],
              'Asia/Tokyo':           ['Asia/Irkutsk'],
              'Australia/Brisbane':   ['Asia/Yakutsk'],
              'Pacific/Noumea':       ['Asia/Vladivostok'],
              'Pacific/Tarawa':       ['Asia/Kamchatka', 'Pacific/Fiji'],
              'Pacific/Tongatapu':    ['Pacific/Apia'],
              'Asia/Baghdad':         ['Europe/Minsk'],
              'Asia/Baku':            ['Asia/Yerevan','Asia/Baku'],
              'Africa/Johannesburg':  ['Asia/Gaza', 'Africa/Cairo']
          },

          timezone_name = tz_name,
          
          /**
           * Checks if a timezone has possible ambiguities. I.e timezones that are similar.
           *
           * For example, if the preliminary scan determines that we're in America/Denver.
           * We double check here that we're really there and not in America/Mazatlan.
           *
           * This is done by checking known dates for when daylight savings start for different
           * timezones during 2010 and 2011.
           */
          ambiguity_check = function () {
              var ambiguity_list = AMBIGUITIES[timezone_name],
                  length = ambiguity_list.length,
                  i = 0,
                  tz = ambiguity_list[0];

              for (; i < length; i += 1) {
                  tz = ambiguity_list[i];

                  if (jstz.date_is_dst(jstz.dst_start_for(tz))) {
                      timezone_name = tz;
                      return;
                  }
              }
          },

          /**
           * Checks if it is possible that the timezone is ambiguous.
           */
          is_ambiguous = function () {
              return typeof (AMBIGUITIES[timezone_name]) !== 'undefined';
          };

      if (is_ambiguous()) {
          ambiguity_check();
      }

      return {
          name: function () {
              return timezone_name;
          }
      };
  };

  jstz.olson = {};

  /*
   * The keys in this dictionary are comma separated as such:
   *
   * First the offset compared to UTC time in minutes.
   *
   * Then a flag which is 0 if the timezone does not take daylight savings into account and 1 if it
   * does.
   *
   * Thirdly an optional 's' signifies that the timezone is in the southern hemisphere,
   * only interesting for timezones with DST.
   *
   * The mapped arrays is used for constructing the jstz.TimeZone object from within
   * jstz.determine_timezone();
   */
  jstz.olson.timezones = {
      '-720,0'   : 'Pacific/Majuro',
      '-660,0'   : 'Pacific/Pago_Pago',
      '-600,1'   : 'America/Adak',
      '-600,0'   : 'Pacific/Honolulu',
      '-570,0'   : 'Pacific/Marquesas',
      '-540,0'   : 'Pacific/Gambier',
      '-540,1'   : 'America/Anchorage',
      '-480,1'   : 'America/Los_Angeles',
      '-480,0'   : 'Pacific/Pitcairn',
      '-420,0'   : 'America/Phoenix',
      '-420,1'   : 'America/Denver',
      '-360,0'   : 'America/Guatemala',
      '-360,1'   : 'America/Chicago',
      '-360,1,s' : 'Pacific/Easter',
      '-300,0'   : 'America/Bogota',
      '-300,1'   : 'America/New_York',
      '-270,0'   : 'America/Caracas',
      '-240,1'   : 'America/Halifax',
      '-240,0'   : 'America/Santo_Domingo',
      '-240,1,s' : 'America/Santiago',
      '-210,1'   : 'America/St_Johns',
      '-180,1'   : 'America/Godthab',
      '-180,0'   : 'America/Argentina/Buenos_Aires',
      '-180,1,s' : 'America/Montevideo',
      '-120,0'   : 'America/Noronha',
      '-120,1'   : 'America/Noronha',
      '-60,1'    : 'Atlantic/Azores',
      '-60,0'    : 'Atlantic/Cape_Verde',
      '0,0'      : 'UTC',
      '0,1'      : 'Europe/London',
      '60,1'     : 'Europe/Berlin',
      '60,0'     : 'Africa/Lagos',
      '60,1,s'   : 'Africa/Windhoek',
      '120,1'    : 'Asia/Beirut',
      '120,0'    : 'Africa/Johannesburg',
      '180,0'    : 'Asia/Baghdad',
      '180,1'    : 'Europe/Moscow',
      '210,1'    : 'Asia/Tehran',
      '240,0'    : 'Asia/Dubai',
      '240,1'    : 'Asia/Baku',
      '270,0'    : 'Asia/Kabul',
      '300,1'    : 'Asia/Yekaterinburg',
      '300,0'    : 'Asia/Karachi',
      '330,0'    : 'Asia/Kolkata',
      '345,0'    : 'Asia/Kathmandu',
      '360,0'    : 'Asia/Dhaka',
      '360,1'    : 'Asia/Omsk',
      '390,0'    : 'Asia/Rangoon',
      '420,1'    : 'Asia/Krasnoyarsk',
      '420,0'    : 'Asia/Jakarta',
      '480,0'    : 'Asia/Shanghai',
      '480,1'    : 'Asia/Irkutsk',
      '525,0'    : 'Australia/Eucla',
      '525,1,s'  : 'Australia/Eucla',
      '540,1'    : 'Asia/Yakutsk',
      '540,0'    : 'Asia/Tokyo',
      '570,0'    : 'Australia/Darwin',
      '570,1,s'  : 'Australia/Adelaide',
      '600,0'    : 'Australia/Brisbane',
      '600,1'    : 'Asia/Vladivostok',
      '600,1,s'  : 'Australia/Sydney',
      '630,1,s'  : 'Australia/Lord_Howe',
      '660,1'    : 'Asia/Kamchatka',
      '660,0'    : 'Pacific/Noumea',
      '690,0'    : 'Pacific/Norfolk',
      '720,1,s'  : 'Pacific/Auckland',
      '720,0'    : 'Pacific/Tarawa',
      '765,1,s'  : 'Pacific/Chatham',
      '780,0'    : 'Pacific/Tongatapu',
      '780,1,s'  : 'Pacific/Apia',
      '840,0'    : 'Pacific/Kiritimati'
  };

  if (typeof exports !== 'undefined') {
    exports.jstz = jstz;
  } else {
    root.jstz = jstz;
  }
})(this);


},{}],7:[function(require,module,exports){
// Mingo.js 0.4.0
// Copyright (c) 2015 Francis Asante <kofrasa@gmail.com>
// MIT

(function (root, undefined) {

  "use strict";

  // global on the server, window in the browser
  var Mingo = {}, previousMingo;
  var _;

  // backup previous Mingo
  if (root != null) {
    previousMingo = root.Mingo;
  }

  Mingo.noConflict = function () {
    root.Mingo = previousMingo;
    return Mingo;
  };

  var nativeScriptEnabled = Boolean(((typeof android !== 'undefined' && android && android.widget && android.widget.Button)
  || (typeof UIButton !== 'undefined' && UIButton)));

  var nodeEnabled = ('undefined' !== typeof exports && 'undefined' !== typeof require && 'undefined' === typeof window && !nativeScriptEnabled);

  var browserifyEnabled = 'undefined' !== typeof exports && 'undefined' !== typeof require;

  // Export the Mingo object for Node.js
  if (nodeEnabled || nativeScriptEnabled || browserifyEnabled) {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = Mingo;
    } else {
      exports = Mingo;
    }
    _ = require("underscore"); // get a reference to underscore
  } else {
    root.Mingo = Mingo;
    _ = root._; // get a reference to underscore
  }

  // quick reference for
  var primitives = [
    _.isString, _.isBoolean, _.isNumber, _.isDate, _.isNull, _.isRegExp
  ];

  function normalize(expr) {
    // normalized primitives
    for (var i = 0; i < primitives.length; i++) {
      if (primitives[i](expr)) {
        if (_.isRegExp(expr)) {
          return {"$regex": expr};
        } else {
          return {"$eq": expr};
        }
      }
    }
    // normalize object expression
    if (_.isObject(expr)) {
      var keys = _.keys(expr);
      var notQuery = _.intersection(Ops.queryOperators, keys).length === 0;

      // no valid query operator found, so we do simple comparison
      if (notQuery) {
        return {"$eq": expr};
      }

      // ensure valid regex
      if (_.contains(keys, "$regex")) {
        var regex = expr['$regex'];
        var options = expr['$options'] || "";
        var modifiers = "";
        if (_.isString(regex)) {
          modifiers += (regex.ignoreCase || options.indexOf("i") >= 0) ? "i" : "";
          modifiers += (regex.multiline || options.indexOf("m") >= 0) ? "m" : "";
          modifiers += (regex.global || options.indexOf("g") >= 0) ? "g" : "";
          regex = new RegExp(regex, modifiers);
        }
        expr['$regex'] = regex;
        delete expr['$options'];
      }
    }

    return expr;
  }

  // Settings used by Mingo internally
  var settings = {
    key: "_id"
  };

  /**
   * Setup default settings for Mingo
   * @param options
   */
  Mingo.setup = function (options) {
    _.extend(settings, options || {});
  };


  /**
   * Query object to test collection elements with
   * @param criteria the pass criteria for the query
   * @param projection optional projection specifiers
   * @constructor
   */
  Mingo.Query = function (criteria, projection) {
    if (!(this instanceof Mingo.Query))
      return new Mingo.Query(criteria, projection);

    this._criteria = criteria;
    this._projection = projection;
    this._compiled = [];
    this._compile();
  };

  Mingo.Query.prototype = {

    _compile: function () {

      if (_.isEmpty(this._criteria)) return;

      if (_.isArray(this._criteria) || _.isFunction(this._criteria) || !_.isObject(this._criteria)) {
        throw new Error("Invalid type for criteria");
      }

      for (var field in this._criteria) {
        if (this._criteria.hasOwnProperty(field)) {
          var expr = this._criteria[field];
          if (_.contains(['$and', '$or', '$nor', '$where'], field)) {
            this._processOperator(field, field, expr);
          } else {
            // normalize expression
            expr = normalize(expr);
            for (var op in expr) {
              if (expr.hasOwnProperty(op)) {
                this._processOperator(field, op, expr[op]);
              }
            }
          }
        }
      }
    },

    _processOperator: function (field, operator, value) {
      var compiledSelector;
      if (_.contains(Ops.simpleOperators, operator)) {
        compiledSelector = {
          test: function (obj) {
            var actualValue = resolve(obj, field);
            // value of operator must already be fully resolved.
            return simpleOperators[operator](actualValue, value);
          }
        };
      } else if (_.contains(Ops.compoundOperators, operator)) {
        compiledSelector = compoundOperators[operator](field, value);
      } else {
        throw new Error("Invalid query operator '" + operator + "' detected");
      }
      this._compiled.push(compiledSelector);
    },

    /**
     * Checks if the object passes the query criteria. Returns true if so, false otherwise.
     * @param obj
     * @returns {boolean}
     */
    test: function (obj) {
      for (var i = 0; i < this._compiled.length; i++) {
        if (!this._compiled[i].test(obj)) {
          return false;
        }
      }
      return true;
    },

    /**
     * Performs a query on a collection and returns a cursor object.
     * @param collection
     * @param projection
     * @returns {Mingo.Cursor}
     */
    find: function (collection, projection) {
      return new Mingo.Cursor(collection, this, projection);
    },

    /**
     * Remove matched documents from the collection returning the remainder
     * @param collection
     * @returns {Array}
     */
    remove: function (collection) {
      var arr = [];
      for (var i = 0; i < collection.length; i++) {
        if (!this.test(collection[i])) {
          arr.push(collection[i]);
        }
      }
      return arr;
    }
  };

  if (nodeEnabled) {

    var Transform = require('stream').Transform;
    var util = require('util');

    Mingo.Query.prototype.stream = function (options) {
      return new Mingo.Stream(this, options);
    };

    /**
     * Create a Transform class
     * @param query
     * @param options
     * @returns {Mingo.Stream}
     * @constructor
     */
    Mingo.Stream = function (query, options) {

      if (!(this instanceof Mingo.Stream))
        return new Mingo.Stream(query, options);

      options = options || {};
      _.extend(options, {objectMode: true});
      Transform.call(this, options);
      // query for this stream
      this._query = query;
    };
    // extend Transform
    util.inherits(Mingo.Stream, Transform);

    Mingo.Stream.prototype._transform = function (chunk, encoding, done) {
      if (_.isObject(chunk) && this._query.test(chunk)) {
        if (_.isEmpty(this._query._projection)) {
          this.push(chunk);
        } else {
          var cursor = new Mingo.Cursor([chunk], this._query);
          if (cursor.hasNext()) {
            this.push(cursor.next());
          }
        }
      }
      done();
    };
  }

  /**
   * Cursor to iterate and perform filtering on matched objects
   * @param collection
   * @param query
   * @param projection
   * @constructor
   */
  Mingo.Cursor = function (collection, query, projection) {

    if (!(this instanceof Mingo.Cursor))
      return new Mingo.Cursor(collection, query, projection);

    this._query = query;
    this._collection = collection;
    this._projection = projection || query._projection;
    this._operators = {};
    this._result = false;
    this._position = 0;
  };

  Mingo.Cursor.prototype = {

    _fetch: function () {
      var self = this;

      if (this._result !== false) {
        return this._result;
      }

      // inject projection operator
      if (_.isObject(this._projection)) {
        _.extend(this._operators, {"$project": this._projection});
      }

      if (!_.isArray(this._collection) && !_.isObject(this._collection)) {
        throw new Error("Input collection is not of valid type. Must be an Array.");
      }

      // filter collection
      this._result = _.filter(this._collection, this._query.test, this._query);
      var pipeline = [];

      _.each(['$sort', '$skip', '$limit', '$project'], function (op) {
        if (_.has(self._operators, op)) {
          pipeline.push(_.pick(self._operators, op));
        }
      });

      if (pipeline.length > 0) {
        var aggregator = new Mingo.Aggregator(pipeline);
        this._result = aggregator.run(this._result, this._query);
      }
      return this._result;
    },

    /**
     * Fetch and return all matched results
     * @returns {Array}
     */
    all: function () {
      return this._fetch();
    },

    /**
     * Fetch and return the first matching result
     * @returns {Object}
     */
    first: function () {
      return this.count() > 0 ? this._fetch()[0] : null;
    },

    /**
     * Fetch and return the last matching object from the result
     * @returns {Object}
     */
    last: function () {
      return this.count() > 0 ? this._fetch()[this.count() - 1] : null;
    },

    /**
     * Counts the number of matched objects found
     * @returns {Number}
     */
    count: function () {
      return this._fetch().length;
    },

    /**
     * Returns a cursor that begins returning results only after passing or skipping a number of documents.
     * @param {Number} n the number of results to skip.
     * @return {Mingo.Cursor} Returns the cursor, so you can chain this call.
     */
    skip: function (n) {
      _.extend(this._operators, {"$skip": n});
      return this;
    },

    /**
     * Constrains the size of a cursor's result set.
     * @param {Number} n the number of results to limit to.
     * @return {Mingo.Cursor} Returns the cursor, so you can chain this call.
     */
    limit: function (n) {
      _.extend(this._operators, {"$limit": n});
      return this;
    },

    /**
     * Returns results ordered according to a sort specification.
     * @param {Object} modifier an object of key and values specifying the sort order. 1 for ascending and -1 for descending
     * @return {Mingo.Cursor} Returns the cursor, so you can chain this call.
     */
    sort: function (modifier) {
      _.extend(this._operators, {"$sort": modifier});
      return this;
    },

    /**
     * Returns the next document in a cursor.
     * @returns {Object | Boolean}
     */
    next: function () {
      if (this.hasNext()) {
        return this._fetch()[this._position++];
      }
      return null;
    },

    /**
     * Returns true if the cursor has documents and can be iterated.
     * @returns {boolean}
     */
    hasNext: function () {
      return this.count() > this._position;
    },

    /**
     * Specifies the exclusive upper bound for a specific field
     * @param expr
     * @returns {Number}
     */
    max: function (expr) {
      return groupOperators.$max(this._fetch(), expr);
    },

    /**
     * Specifies the inclusive lower bound for a specific field
     * @param expr
     * @returns {Number}
     */
    min: function (expr) {
      return groupOperators.$min(this._fetch(), expr);
    },

    /**
     * Applies a function to each document in a cursor and collects the return values in an array.
     * @param callback
     * @returns {Array}
     */
    map: function (callback) {
      return _.map(this._fetch(), callback);
    },

    /**
     * Applies a JavaScript function for every document in a cursor.
     * @param callback
     */
    forEach: function (callback) {
      _.each(this._fetch(), callback);
    }

  };

  /**
   * Aggregator for defining filter using mongoDB aggregation pipeline syntax
   * @param operators an Array of pipeline operators
   * @constructor
   */
  Mingo.Aggregator = function (operators) {
    if (!(this instanceof Mingo.Aggregator))
      return new Mingo.Aggregator(operators);

    this._operators = operators;
  };

  Mingo.Aggregator.prototype = {

    /**
     * Apply the pipeline operations over the collection by order of the sequence added
     * @param collection an array of objects to process
     * @param query the `Mingo.Query` object to use as context
     * @returns {Array}
     */
    run: function (collection, query) {
      if (!_.isEmpty(this._operators)) {
        // run aggregation pipeline
        for (var i = 0; i < this._operators.length; i++) {
          var operator = this._operators[i];
          for (var key in operator) {
            if (operator.hasOwnProperty(key)) {
              if (query instanceof Mingo.Query) {
                collection = pipelineOperators[key].call(query, collection, operator[key]);
              } else {
                collection = pipelineOperators[key](collection, operator[key]);
              }
            }
          }
        }
      }
      return collection;
    }
  };

  /**
   * Retrieve the value of a given key on an object
   * @param obj
   * @param field
   * @returns {*}
   * @private
   */
  function getValue(obj, field) {
    return _.result(obj, field);
  }

  /**
   * Resolve the value of the field (dot separated) on the given object
   * @param obj
   * @param field
   * @returns {*}
   */
  function resolve(obj, field) {
    if (!field) {
      return undefined;
    }
    var names = field.split(".");
    var value = obj;
    var isText;

    for (var i = 0; i < names.length; i++) {
      isText = names[i].match(/^\d+$/) === null;

      if (isText && _.isArray(value)) {
        var res = [];
        _.each(value, function (item) {
          if (_.isObject(item)) {
            res.push(resolve(item, names[i]));
          }
        });
        value = res;
      } else {
        value = getValue(value, names[i]);
      }

      if (value === undefined) {
        break;
      }
    }

    return value;
  }

  /**
   * Performs a query on a collection and returns a cursor object.
   * @param collection
   * @param criteria
   * @param projection
   * @returns {Mingo.Cursor}
   */
  Mingo.find = function (collection, criteria, projection) {
    return (new Mingo.Query(criteria)).find(collection, projection);
  };

  /**
   * Returns a new array without objects which match the criteria
   * @param collection
   * @param criteria
   * @returns {Array}
   */
  Mingo.remove = function (collection, criteria) {
    return (new Mingo.Query(criteria)).remove(collection);
  };

  /**
   * Return the result collection after running the aggregation pipeline for the given collection
   * @param collection
   * @param pipeline
   * @returns {Array}
   */
  Mingo.aggregate = function (collection, pipeline) {
    if (!_.isArray(pipeline)) {
      throw new Error("Aggregation pipeline must be an array")
    }
    return (new Mingo.Aggregator(pipeline)).run(collection);
  };

  /**
   * Mixin for Backbone.Collection objects
   */
  Mingo.CollectionMixin = {
    /**
     * Runs a query and returns a cursor to the result
     * @param criteria
     * @param projection
     * @returns {Mingo.Cursor}
     */
    query: function (criteria, projection) {
      return Mingo.find(this.toJSON(), criteria, projection);
    },

    /**
     * Runs the given aggregation operators on this collection
     * @params pipeline
     * @returns {Array}
     */
    aggregate: function (pipeline) {
      var args = [this.toJSON(), pipeline];
      return Mingo.aggregate.apply(null, args);
    }
  };

  var pipelineOperators = {

    /**
     * Groups documents together for the purpose of calculating aggregate values based on a collection of documents.
     *
     * @param collection
     * @param expr
     * @returns {Array}
     */
    $group: function (collection, expr) {
      // lookup key for grouping
      var idKey = expr[settings.key];
      var indexes = [];
      // group collection by key
      var groups = _.groupBy(collection, function (obj) {
        var key = computeValue(obj, idKey, idKey);
        indexes.push(key);
        return key;
      });

      // group indexes
      indexes = _.uniq(indexes);

      // remove the group key
      expr = _.omit(expr, settings.key);

      var result = [];
      _.each(indexes, function (index) {
        var obj = {};
        obj[settings.key] = index;
        // compute remaining keys in expression
        for (var key in expr) {
          if (expr.hasOwnProperty(key)) {
            obj[key] = accumulate(groups[index], key, expr[key]);
          }
        }
        result.push(obj);
      });

      return result;
    },

    /**
     * Filters the document stream, and only allows matching documents to pass into the next pipeline stage.
     * $match uses standard MongoDB queries.
     *
     * @param collection
     * @param expr
     * @returns {Array|*}
     */
    $match: function (collection, expr) {
      return (new Mingo.Query(expr)).find(collection).all();
    },

    /**
     * Reshapes a document stream.
     * $project can rename, add, or remove fields as well as create computed values and sub-documents.
     *
     * @param collection
     * @param expr
     * @returns {Array}
     */
    $project: function (collection, expr) {

      if (_.isEmpty(expr)) {
        return collection;
      }

      // result collection
      var projected = [];
      var objKeys = _.keys(expr);
      var idOnlyExcludedExpression = false;

      if (_.contains(objKeys, settings.key)) {
        var id = expr[settings.key];
        if (id === 0 || id === false) {
          objKeys = _.without(objKeys, settings.key);
          if (_.isEmpty(objKeys)) {
            idOnlyExcludedExpression = true;
          }
        }
      } else {
        // if not specified the add the ID field
        objKeys.push(settings.key);
      }

      for (var i = 0; i < collection.length; i++) {
        var obj = collection[i];
        var cloneObj = {};
        var foundSlice = false;
        var foundExclusion = false;
        var dropKeys = [];
        if (idOnlyExcludedExpression) {
          dropKeys.push(settings.key);
        }
        _.each(objKeys, function (key) {

          var subExpr = expr[key];
          var newValue;
          if (key !== settings.key && subExpr === 0) {
            foundExclusion = true;
          }

          // tiny optimization here to skip over id
          if (key === settings.key && _.isEmpty(subExpr)) {
            newValue = obj[key];
          } else if (_.isString(subExpr)) {
            newValue = computeValue(obj, subExpr, key);
          } else if (subExpr === 1 || subExpr === true) {
            newValue = _.result(obj, key);
          } else if (_.isObject(subExpr)) {
            var operator = _.keys(subExpr);
            operator = operator.length > 1 ? false : operator[0];
            if (operator !== false && _.contains(Ops.projectionOperators, operator)) {
              // apply the projection operator on the operator expression for the key
              var temp = projectionOperators[operator](obj, subExpr[operator], key);
              if (!_.isUndefined(temp)) {
                newValue = temp;
              }
              if (operator == '$slice') {
                foundSlice = true;
              }
            } else {
              // compute the value for the sub expression for the key
              newValue = computeValue(obj, subExpr, key);
            }
          } else {
            dropKeys.push(key);
          }

          if (newValue !== undefined) {
            cloneObj[key] = _.isObject(newValue) ? _.clone(newValue) : newValue;
          }
        });
        // if projection included $slice operator
        // Also if exclusion fields are found or we want to exclude only the id field
        // include keys that were not explicitly excluded
        if (foundSlice || foundExclusion || idOnlyExcludedExpression) {
          cloneObj = _.defaults(cloneObj, _.omit(obj, dropKeys));
        }
        projected.push(cloneObj);
      }

      return projected;
    },

    /**
     * Restricts the number of documents in an aggregation pipeline.
     *
     * @param collection
     * @param value
     * @returns {Object|*}
     */
    $limit: function (collection, value) {
      return _.first(collection, value);
    },

    /**
     * Skips over a specified number of documents from the pipeline and returns the rest.
     *
     * @param collection
     * @param value
     * @returns {*}
     */
    $skip: function (collection, value) {
      return _.rest(collection, value);
    },

    /**
     * Takes an array of documents and returns them as a stream of documents.
     *
     * @param collection
     * @param expr
     * @returns {Array}
     */
    $unwind: function (collection, expr) {
      var result = [];
      var field = expr.substr(1);
      for (var i = 0; i < collection.length; i++) {
        var obj = collection[i];
        // must throw an error if value is not an array
        var value = getValue(obj, field);
        if (_.isArray(value)) {
          _.each(value, function (item) {
            var tmp = _.clone(obj);
            tmp[field] = item;
            result.push(tmp);
          });
        } else {
          throw new Error("Target field '" + field + "' is not of type Array.");
        }
      }
      return result;
    },

    /**
     * Takes all input documents and returns them in a stream of sorted documents.
     *
     * @param collection
     * @param sortKeys
     * @returns {*}
     */
    $sort: function (collection, sortKeys) {
      if (!_.isEmpty(sortKeys) && _.isObject(sortKeys)) {
        var modifiers = _.keys(sortKeys);
        modifiers.reverse().forEach(function (key) {
          var indexes = [];
          var grouped = _.groupBy(collection, function (obj) {
            var value = resolve(obj, key);
            indexes.push(value);
            return value;
          });
          indexes = _.sortBy(_.uniq(indexes), function (item) {
            return item;
          });
          if (sortKeys[key] === -1) {
            indexes.reverse();
          }
          collection = [];
          _.each(indexes, function (item) {
            Array.prototype.push.apply(collection, grouped[item]);
          });
        });
      }
      return collection;
    }
  };

  var compoundOperators = {

    /**
     * Joins query clauses with a logical AND returns all documents that match the conditions of both clauses.
     *
     * @param selector
     * @param value
     * @returns {{test: Function}}
     */
    $and: function (selector, value) {
      if (!_.isArray(value)) {
        throw new Error("Invalid expression for $and criteria");
      }
      var queries = [];
      _.each(value, function (expr) {
        queries.push(new Mingo.Query(expr));
      });

      return {
        test: function (obj) {
          for (var i = 0; i < queries.length; i++) {
            if (!queries[i].test(obj)) {
              return false;
            }
          }
          return true;
        }
      };
    },

    /**
     * Joins query clauses with a logical OR returns all documents that match the conditions of either clause.
     *
     * @param selector
     * @param value
     * @returns {{test: Function}}
     */
    $or: function (selector, value) {
      if (!_.isArray(value)) {
        throw new Error("Invalid expression for $or criteria");
      }
      var queries = [];
      _.each(value, function (expr) {
        queries.push(new Mingo.Query(expr));
      });

      return {
        test: function (obj) {
          for (var i = 0; i < queries.length; i++) {
            if (queries[i].test(obj)) {
              return true;
            }
          }
          return false;
        }
      };
    },

    /**
     * Joins query clauses with a logical NOR returns all documents that fail to match both clauses.
     *
     * @param selector
     * @param value
     * @returns {{test: Function}}
     */
    $nor: function (selector, value) {
      if (!_.isArray(value)) {
        throw new Error("Invalid expression for $nor criteria");
      }
      var query = this.$or("$or", value);
      return {
        test: function (obj) {
          return !query.test(obj);
        }
      };
    },

    /**
     * Inverts the effect of a query expression and returns documents that do not match the query expression.
     *
     * @param selector
     * @param value
     * @returns {{test: Function}}
     */
    $not: function (selector, value) {
      var criteria = {};
      criteria[selector] = normalize(value);
      var query = new Mingo.Query(criteria);
      return {
        test: function (obj) {
          return !query.test(obj);
        }
      };
    },

    /**
     * Matches documents that satisfy a JavaScript expression.
     *
     * @param selector
     * @param value
     * @returns {{test: test}}
     */
    $where: function (selector, value) {
      if (!_.isFunction(value)) {
        value = new Function("return " + value + ";");
      }
      return {
        test: function (obj) {
          return value.call(obj) === true;
        }
      };
    }

  };

  var simpleOperators = {

    /**
     * Checks that two values are equal. Pseudo operator introduced for convenience and consistency
     *
     * @param a
     * @param b
     * @returns {*}
     */
    $eq: function (a, b) {
      a = _.isArray(a) ? a : [a];
      a = _.find(a, function (val) {
        return _.isEqual(val, b);
      });
      return a !== undefined;
    },

    /**
     * Matches all values that are not equal to the value specified in the query.
     *
     * @param a
     * @param b
     * @returns {boolean}
     */
    $ne: function (a, b) {
      return !this.$eq(a, b);
    },

    /**
     * Matches any of the values that exist in an array specified in the query.
     *
     * @param a
     * @param b
     * @returns {*}
     */
    $in: function (a, b) {
      a = _.isArray(a) ? a : [a];
      return _.intersection(a, b).length > 0;
    },

    /**
     * Matches values that do not exist in an array specified to the query.
     *
     * @param a
     * @param b
     * @returns {*|boolean}
     */
    $nin: function (a, b) {
      return _.isUndefined(a) || !this.$in(a, b);
    },

    /**
     * Matches values that are less than the value specified in the query.
     *
     * @param a
     * @param b
     * @returns {boolean}
     */
    $lt: function (a, b) {
      a = _.isArray(a) ? a : [a];
      a = _.find(a, function (val) {
        return val < b
      });
      return a !== undefined;
    },

    /**
     * Matches values that are less than or equal to the value specified in the query.
     *
     * @param a
     * @param b
     * @returns {boolean}
     */
    $lte: function (a, b) {
      a = _.isArray(a) ? a : [a];
      a = _.find(a, function (val) {
        return val <= b
      });
      return a !== undefined;
    },

    /**
     * Matches values that are greater than the value specified in the query.
     *
     * @param a
     * @param b
     * @returns {boolean}
     */
    $gt: function (a, b) {
      a = _.isArray(a) ? a : [a];
      a = _.find(a, function (val) {
        return val > b
      });
      return a !== undefined;
    },

    /**
     * Matches values that are greater than or equal to the value specified in the query.
     *
     * @param a
     * @param b
     * @returns {boolean}
     */
    $gte: function (a, b) {
      a = _.isArray(a) ? a : [a];
      a = _.find(a, function (val) {
        return val >= b
      });
      return a !== undefined;
    },

    /**
     * Performs a modulo operation on the value of a field and selects documents with a specified result.
     *
     * @param a
     * @param b
     * @returns {*|boolean|boolean}
     */
    $mod: function (a, b) {
      a = _.isArray(a) ? a : [a];
      a = _.find(a, function (val) {
        return _.isNumber(val) && _.isArray(b) && b.length === 2 && (val % b[0]) === b[1];
      });
      return a !== undefined;
    },

    /**
     * Selects documents where values match a specified regular expression.
     *
     * @param a
     * @param b
     * @returns {*|boolean}
     */
    $regex: function (a, b) {
      a = _.isArray(a) ? a : [a];
      a = _.find(a, function (val) {
        return _.isString(val) && _.isRegExp(b) && (!!val.match(b));
      });
      return a !== undefined;
    },

    /**
     * Matches documents that have the specified field.
     *
     * @param a
     * @param b
     * @returns {boolean|*|boolean}
     */
    $exists: function (a, b) {
      return (b === false && _.isUndefined(a)) || (b === true && !_.isUndefined(a));
    },

    /**
     * Matches arrays that contain all elements specified in the query.
     *
     * @param a
     * @param b
     * @returns boolean
     */
    $all: function (a, b) {
      var self = this;
      var matched = false;
      if (_.isArray(a) && _.isArray(b)) {
        for (var i = 0; i < b.length; i++) {
          if (_.isObject(b[i]) && _.contains(_.keys(b[i]), "$elemMatch")) {
            matched = matched || self.$elemMatch(a, b[i].$elemMatch);
          } else {
            // order of arguments matter. underscore maintains order after intersection
            return _.intersection(b, a).length === b.length;
          }
        }
      }
      return matched;
    },

    /**
     * Selects documents if the array field is a specified size.
     *
     * @param a
     * @param b
     * @returns {*|boolean}
     */
    $size: function (a, b) {
      return _.isArray(a) && _.isNumber(b) && (a.length === b);
    },

    /**
     * Selects documents if element in the array field matches all the specified $elemMatch condition.
     *
     * @param a
     * @param b
     */
    $elemMatch: function (a, b) {
      if (_.isArray(a) && !_.isEmpty(a)) {
        var query = new Mingo.Query(b);
        for (var i = 0; i < a.length; i++) {
          if (query.test(a[i])) {
            return true;
          }
        }
      }
      return false;
    },

    /**
     * Selects documents if a field is of the specified type.
     *
     * @param a
     * @param b
     * @returns {boolean}
     */
    $type: function (a, b) {
      switch (b) {
        case 1:
          return _.isNumeric(a) && (a + "").indexOf(".") !== -1;
        case 2:
        case 5:
          return _.isString(a);
        case 3:
          return _.isObject(a);
        case 4:
          return _.isArray(a);
        case 8:
          return _.isBoolean(a);
        case 9:
          return _.isDate(a);
        case 10:
          return _.isNull(a);
        case 11:
          return _.isRegExp(a);
        case 16:
          return _.isNumeric(a) && a <= 2147483647 && (a + "").indexOf(".") === -1;
        case 18:
          return _.isNumeric(a) && a > 2147483647 && a <= 9223372036854775807 && (a + "").indexOf(".") === -1;
        default:
          return false;
      }
    }

  };

  var projectionOperators = {

    /**
     * Projects the first element in an array that matches the query condition.
     *
     * @param obj
     * @param field
     * @param expr
     */
    $: function (obj, expr, field) {
      throw new Error("$ not implemented");
    },

    /**
     * Projects only the first element from an array that matches the specified $elemMatch condition.
     *
     * @param obj
     * @param field
     * @param expr
     * @returns {*}
     */
    $elemMatch: function (obj, expr, field) {
      var array = resolve(obj, field);
      var query = new Mingo.Query(expr);

      if (_.isUndefined(array) || !_.isArray(array)) {
        return undefined;
      }

      for (var i = 0; i < array.length; i++) {
        if (query.test(array[i])) {
          return [array[i]];
        }
      }

      return undefined;
    },

    /**
     * Limits the number of elements projected from an array. Supports skip and limit slices.
     *
     * @param obj
     * @param field
     * @param expr
     */
    $slice: function (obj, expr, field) {
      var array = resolve(obj, field);

      if (!_.isArray(array)) {
        return array;
      }
      if (!_.isArray(expr)) {
        if (!_.isNumber(expr)) {
          throw new Error("Invalid type for $slice operator");
        }
        expr = expr < 0 ? [expr] : [0, expr];
      } else {
        // MongoDB $slice works a bit differently from Array.slice
        // Uses single argument for 'limit' and array argument [skip, limit]
        var skip = (expr[0] < 0) ? array.length + expr[0] : expr;
        var limit = skip + expr[1];
        expr = [skip, limit];
      }

      return Array.prototype.slice.apply(array, expr);
    }
  };

  var groupOperators = {

    /**
     * Returns an array of all the unique values for the selected field among for each document in that group.
     *
     * @param collection
     * @param expr
     * @returns {*}
     */
    $addToSet: function (collection, expr) {
      var result = _.map(collection, function (obj) {
        return computeValue(obj, expr);
      });
      return _.uniq(result);
    },

    /**
     * Returns the sum of all the values in a group.
     *
     * @param collection
     * @param expr
     * @returns {*}
     */
    $sum: function (collection, expr) {
      if (_.isNumber(expr)) {
        // take a short cut if expr is number literal
        return collection.length * expr;
      }
      return _.reduce(collection, function (acc, obj) {
        // pass empty field to avoid naming conflicts with fields on documents
        return acc + computeValue(obj, expr);
      }, 0);
    },

    /**
     * Returns the highest value in a group.
     *
     * @param collection
     * @param expr
     * @returns {*}
     */
    $max: function (collection, expr) {
      var obj = _.max(collection, function (obj) {
        return computeValue(obj, expr);
      });
      return computeValue(obj, expr);
    },

    /**
     * Returns the lowest value in a group.
     *
     * @param collection
     * @param expr
     * @returns {*}
     */
    $min: function (collection, expr) {
      var obj = _.min(collection, function (obj) {
        return computeValue(obj, expr);
      });
      return computeValue(obj, expr);
    },

    /**
     * Returns an average of all the values in a group.
     *
     * @param collection
     * @param expr
     * @returns {number}
     */
    $avg: function (collection, expr) {
      return this.$sum(collection, expr) / (collection.length || 1);
    },

    /**
     * Returns an array of all values for the selected field among for each document in that group.
     *
     * @param collection
     * @param expr
     * @returns {Array|*}
     */
    $push: function (collection, expr) {
      return _.map(collection, function (obj) {
        return computeValue(obj, expr);
      });
    },

    /**
     * Returns the first value in a group.
     *
     * @param collection
     * @param expr
     * @returns {*}
     */
    $first: function (collection, expr) {
      return (collection.length > 0) ? computeValue(collection[0], expr) : undefined;
    },

    /**
     * Returns the last value in a group.
     *
     * @param collection
     * @param expr
     * @returns {*}
     */
    $last: function (collection, expr) {
      return (collection.length > 0) ? computeValue(collection[collection.length - 1], expr) : undefined;
    }
  };


  /////////// Common Aggregation Operators ///////////

  var arithmeticOperators = {

    /**
     * Computes the sum of an array of numbers.
     *
     * @param obj
     * @param expr
     * @returns {Object}
     */
    $add: function (obj, expr) {
      var args = computeValue(obj, expr);
      return _.reduce(args, function (memo, num) {
        return memo + num;
      }, 0);
    },

    /**
     * Takes an array that contains two numbers or two dates and subtracts the second value from the first.
     *
     * @param obj
     * @param expr
     * @returns {number}
     */
    $subtract: function (obj, expr) {
      var args = computeValue(obj, expr);
      return args[0] - args[1];
    },

    /**
     * Takes two numbers and divides the first number by the second.
     *
     * @param obj
     * @param expr
     * @returns {number}
     */
    $divide: function (obj, expr) {
      var args = computeValue(obj, expr);
      return args[0] / args[1];
    },

    /**
     * Computes the product of an array of numbers.
     *
     * @param obj
     * @param expr
     * @returns {Object}
     */
    $multiply: function (obj, expr) {
      var args = computeValue(obj, expr);
      return _.reduce(args, function (memo, num) {
        return memo * num;
      }, 1);
    },

    /**
     * Takes two numbers and calculates the modulo of the first number divided by the second.
     *
     * @param obj
     * @param expr
     * @returns {number}
     */
    $mod: function (obj, expr) {
      var args = computeValue(obj, expr);
      return args[0] % args[1];
    }
  };

  var stringOperators = {

    /**
     * Concatenates two strings.
     *
     * @param obj
     * @param expr
     * @returns {string|*}
     */
    $concat: function (obj, expr) {
      var args = computeValue(obj, expr);
      // does not allow concatenation with nulls
      if (_.contains(args, null) || _.contains(args, undefined)) {
        return null;
      }
      return args.join("");
    },

    /**
     * Compares two strings and returns an integer that reflects the comparison.
     *
     * @param obj
     * @param expr
     * @returns {number}
     */
    $strcasecmp: function (obj, expr) {
      var args = computeValue(obj, expr);
      args[0] = _.isEmpty(args[0]) ? "" : args[0].toUpperCase();
      args[1] = _.isEmpty(args[1]) ? "" : args[1].toUpperCase();
      if (args[0] > args[1]) {
        return 1;
      }
      return (args[0] < args[1]) ? -1 : 0;
    },

    /**
     * Returns a substring of a string, starting at a specified index position and including the specified number of characters.
     * The index is zero-based.
     *
     * @param obj
     * @param expr
     * @returns {string}
     */
    $substr: function (obj, expr) {
      var args = computeValue(obj, expr);
      if (_.isString(args[0])) {
        if (args[1] < 0) {
          return "";
        } else if (args[2] < 0) {
          return args[0].substr(args[1]);
        } else {
          return args[0].substr(args[1], args[2]);
        }
      }
      return "";
    },

    /**
     * Converts a string to lowercase.
     *
     * @param obj
     * @param expr
     * @returns {string}
     */
    $toLower: function (obj, expr) {
      var value = computeValue(obj, expr);
      return _.isEmpty(value) ? "" : value.toLowerCase();
    },

    /**
     * Converts a string to uppercase.
     *
     * @param obj
     * @param expr
     * @returns {string}
     */
    $toUpper: function (obj, expr) {
      var value = computeValue(obj, expr);
      return _.isEmpty(value) ? "" : value.toUpperCase();
    }
  };

  var dateOperators = {
    /**
     * Returns the day of the year for a date as a number between 1 and 366 (leap year).
     * @param obj
     * @param expr
     */
    $dayOfYear: function (obj, expr) {
      var d = computeValue(obj, expr);
      if (_.isDate(value)) {
        var start = new Date(d.getFullYear(), 0, 0);
        var diff = d - start;
        var oneDay = 1000 * 60 * 60 * 24;
        return Math.round(diff / oneDay);
      }
      return undefined;
    },

    /**
     * Returns the day of the month for a date as a number between 1 and 31.
     * @param obj
     * @param expr
     */
    $dayOfMonth: function (obj, expr) {
      var d = computeValue(obj, expr);
      return _.isDate(d) ? d.getDate() : undefined;
    },

    /**
     * Returns the day of the week for a date as a number between 1 (Sunday) and 7 (Saturday).
     * @param obj
     * @param expr
     */
    $dayOfWeek: function (obj, expr) {
      var d = computeValue(obj, expr);
      return _.isDate(d) ? d.getDay() + 1 : undefined;
    },

    /**
     * Returns the year for a date as a number (e.g. 2014).
     * @param obj
     * @param expr
     */
    $year: function (obj, expr) {
      var d = computeValue(obj, expr);
      return _.isDate(d) ? d.getFullYear() + 1 : undefined;
    },

    /**
     * Returns the month for a date as a number between 1 (January) and 12 (December).
     * @param obj
     * @param expr
     */
    $month: function (obj, expr) {
      var d = computeValue(obj, expr);
      return _.isDate(d) ? d.getMonth() + 1 : undefined;
    },

    /**
     * Returns the week number for a date as a number between 0
     * (the partial week that precedes the first Sunday of the year) and 53 (leap year).
     * @param obj
     * @param expr
     */
    $week: function (obj, expr) {
      var d = computeValue(obj, expr);
      // TODO
      throw new Error("Not Implemented");
    },

    /**
     * Returns the hour for a date as a number between 0 and 23.
     * @param obj
     * @param expr
     */
    $hour: function (obj, expr) {
      var d = computeValue(obj, expr);
      return _.isDate(d) ? d.getHours() : undefined;
    },

    /**
     * Returns the minute for a date as a number between 0 and 59.
     * @param obj
     * @param expr
     */
    $minute: function (obj, expr) {
      var d = computeValue(obj, expr);
      return _.isDate(d) ? d.getMinutes() : undefined;
    },

    /**
     * Returns the seconds for a date as a number between 0 and 60 (leap seconds).
     * @param obj
     * @param expr
     */
    $second: function (obj, expr) {
      var d = computeValue(obj, expr);
      return _.isDate(d) ? d.getSeconds() : undefined;
    },

    /**
     * Returns the milliseconds of a date as a number between 0 and 999.
     * @param obj
     * @param expr
     */
    $millisecond: function (obj, expr) {
      var d = computeValue(obj, expr);
      return _.isDate(d) ? d.getMilliseconds() : undefined;
    },

    /**
     * Returns the date as a formatted string.
     * @param obj
     * @param expr
     */
    $dateToString: function (obj, expr) {
      var fmt = expr['format'];
      var date = computeValue(obj, expr['date']);
      // TODO: use python-style date formatting
      /*
       %Y	Year (4 digits, zero padded)	0000-9999
       %m	Month (2 digits, zero padded)	01-12
       %d	Day of Month (2 digits, zero padded)	01-31
       %H	Hour (2 digits, zero padded, 24-hour clock)	00-23
       %M	Minute (2 digits, zero padded)	00-59
       %S	Second (2 digits, zero padded)	00-60
       %L	Millisecond (3 digits, zero padded)	000-999
       %j	Day of year (3 digits, zero padded)	001-366
       %w	Day of week (1-Sunday, 7-Saturday)	1-7
       %U	Week of year (2 digits, zero padded)	00-53
       %%	Percent Character as a Literal	%
       */
      throw new Error("Not Implemented");
    }
  };

  var setOperators = {
    /**
     * Returns true if two sets have the same elements.
     * @param obj
     * @param expr
     */
    $setEquals: function (obj, expr) {
      var args = computeValue(obj, expr);
      var first = _.uniq(args[0]);
      var second = _.uniq(args[1]);
      if (first.length !== second.length) {
        return false;
      }
      return _.difference(first, second).length == 0;
    },

    /**
     * Returns the common elements of the input sets.
     * @param obj
     * @param expr
     */
    $setIntersection: function (obj, expr) {
      var args = computeValue(obj, expr);
      return _.intersection(args[0], args[1]);
    },

    /**
     * Returns elements of a set that do not appear in a second set.
     * @param obj
     * @param expr
     */
    $setDifference: function (obj, expr) {
      var args = computeValue(obj, expr);
      return _.difference(args[0], args[1]);
    },

    /**
     * Returns a set that holds all elements of the input sets.
     * @param obj
     * @param expr
     */
    $setUnion: function (obj, expr) {
      var args = computeValue(obj, expr);
      return _.union(args[0], args[1]);
    },

    /**
     * Returns true if all elements of a set appear in a second set.
     * @param obj
     * @param expr
     */
    $setIsSubset: function (obj, expr) {
      var args = computeValue(obj, expr);
      return _.intersection(args[0], args[1]).length === args[0].length;
    },

    /**
     * Returns true if any elements of a set evaluate to true, and false otherwise.
     * @param obj
     * @param expr
     */
    $anyElementTrue: function (obj, expr) {
      // mongodb nests the array expression in another
      var args = computeValue(obj, expr)[0];
      for (var i = 0; i < args.length; i++) {
        if (!!args[i])
          return true;
      }
      return false;
    },

    /**
     * Returns true if all elements of a set evaluate to true, and false otherwise.
     * @param obj
     * @param expr
     */
    $allElementsTrue: function (obj, expr) {
      // mongodb nests the array expression in another
      var args = computeValue(obj, expr)[0];
      for (var i = 0; i < args.length; i++) {
        if (!args[i])
          return false;
      }
      return true;
    }
  };

  var conditionalOperators = {

    /**
     * A ternary operator that evaluates one expression,
     * and depending on the result returns the value of one following expressions.
     *
     * @param obj
     * @param expr
     */
    $cond: function (obj, expr) {
      var ifExpr, thenExpr, elseExpr;
      if (_.isArray(expr)) {
        if (expr.length != 3) {
          throw new Error("Invalid arguments for $cond operator");
        }
        ifExpr = expr[0];
        thenExpr = expr[1];
        elseExpr = expr[2];
      } else if (_.isObject(expr)) {
        ifExpr = expr['if'];
        thenExpr = expr['then'];
        elseExpr = expr['else'];
      }
      var condition = computeValue(obj, ifExpr);
      return condition ? computeValue(obj, thenExpr) : computeValue(obj, elseExpr);
    },

    /**
     * Evaluates an expression and returns the first expression if it evaluates to a non-null value.
     * Otherwise, $ifNull returns the second expression's value.
     *
     * @param obj
     * @param expr
     * @returns {*}
     */
    $ifNull: function (obj, expr) {
      if (!_.isArray(expr) || expr.length != 2) {
        throw new Error("Invalid arguments for $ifNull operator");
      }
      var args = computeValue(obj, expr);
      return (args[0] === null || args[0] === undefined) ? args[1] : args[0];
    }
  };

  var comparisonOperators = {
    /**
     * Compares two values and returns the result of the comparison as an integer.
     *
     * @param obj
     * @param expr
     * @returns {number}
     */
    $cmp: function (obj, expr) {
      var args = computeValue(obj, expr);
      if (args[0] > args[1]) {
        return 1;
      }
      return (args[0] < args[1]) ? -1 : 0;
    }
  };

  // combine aggregate operators
  var aggregateOperators = _.extend(
      {},
      arithmeticOperators,
      comparisonOperators,
      conditionalOperators,
      dateOperators,
      setOperators,
      stringOperators
  );

  // mixin comparison operators
  _.each(["$eq", "$ne", "$gt", "$gte", "$lt", "$lte"], function (op) {
    aggregateOperators[op] = function (obj, expr) {
      var args = computeValue(obj, expr);
      return simpleOperators[op](args[0], args[1]);
    };
  });

  var Ops = {
    simpleOperators: _.keys(simpleOperators),
    compoundOperators: _.keys(compoundOperators),
    aggregateOperators: _.keys(aggregateOperators),
    groupOperators: _.keys(groupOperators),
    pipelineOperators: _.keys(pipelineOperators),
    projectionOperators: _.keys(projectionOperators)
  };
  Ops.queryOperators = _.union(Ops.simpleOperators, Ops.compoundOperators);

  /**
   * Returns the result of evaluating a $group operation over a collection
   *
   * @param collection
   * @param field the name of the aggregate operator or field
   * @param expr the expression of the aggregate operator for the field
   * @returns {*}
   */
  function accumulate(collection, field, expr) {
    if (_.contains(Ops.groupOperators, field)) {
      return groupOperators[field](collection, expr);
    }

    if (_.isObject(expr)) {
      var result = {};
      for (var key in expr) {
        if (expr.hasOwnProperty(key)) {
          result[key] = accumulate(collection, key, expr[key]);
          // must run ONLY one group operator per expression
          // if so, return result of the computed value
          if (_.contains(Ops.groupOperators, key)) {
            result = result[key];
            // if there are more keys in expression this is bad
            if (_.keys(expr).length > 1) {
              throw new Error("Invalid $group expression '" + JSON.stringify(expr) + "'");
            }
            break;
          }
        }
      }
      return result;
    }

    return undefined;
  }

  /**
   * Computes the actual value of the expression using the given object as context
   *
   * @param obj the current object from the collection
   * @param expr the expression for the given field
   * @param field the field name (may also be an aggregate operator)
   * @returns {*}
   */
  function computeValue(obj, expr, field) {

    // if the field of the object is a valid operator
    if (_.contains(Ops.aggregateOperators, field)) {
      return aggregateOperators[field](obj, expr);
    }

    // if expr is a variable for an object field
    // field not used in this case
    if (_.isString(expr) && expr.length > 0 && expr[0] === "$") {
      return resolve(obj, expr.slice(1));
    }

    var result;

    if (_.isArray(expr)) {
      result = [];
      for (var i = 0; i < expr.length; i++) {
        result.push(computeValue(obj, expr[i], null));
      }
    } else if (_.isObject(expr)) {
      result = {};
      for (var key in expr) {
        if (expr.hasOwnProperty(key)) {
          result[key] = computeValue(obj, expr[key], key);

          // must run ONLY one aggregate operator per expression
          // if so, return result of the computed value
          if (_.contains(Ops.aggregateOperators, key)) {
            result = result[key];
            // if there are more keys in expression this is bad
            if (_.keys(expr).length > 1) {
              throw new Error("Invalid aggregation expression '" + JSON.stringify(expr) + "'");
            }
            break;
          }
        }
      }
    } else {
      // check and return value if already in a resolved state
      for (var i = 0; i < primitives.length; i++) {
        if (primitives[i](expr)) {
          return expr;
        }
      }
    }

    return result;
  }

}(this));
},{"stream":"stream","underscore":30,"util":5}],8:[function(require,module,exports){

/**
 * Module dependencies.
 */

var ops = require('./ops');
var eql = require('mongo-eql');
var dot = require('dot-component');
var type = require('component-type');
var object = require('object-component');
var debug = require('debug')('mongo-query');

/**
 * Module exports.
 */

module.exports = exports = filter;
exports.ops = ops;

/**
 * Filters an `obj` by the given `query` for subdocuments.
 *
 * @return {Object|Boolean} false if no match, or matched subdocs
 * @api public
 */

function filter(obj, query){
  obj = obj || {};
  var ret = {};

  for (var key in query) {
    if (!query.hasOwnProperty(key)) continue;

    // search value
    var val = query[key];

    // split the key into prefix and suffix
    var keys = key.split('.');
    var target = obj;
    var prefix, search;
    var matches = [];

    walk_keys:
    for (var i = 0; i < keys.length; i++) {
      target = target[keys[i]];

      switch (type(target)) {
        case 'array':
          // if it's an array subdocument search we stop here
          prefix = keys.slice(0, i + 1).join('.');
          search = keys.slice(i + 1).join('.');

          debug('searching array "%s"', prefix);

          // we special case operators that don't walk the array
          if (val.$size && !search.length) {
            return compare(val, target);
          }

          // walk subdocs
          var subset = ret[prefix] || target;

          for (var ii = 0; ii < subset.length; ii++) {
            if (search.length) {
              var q = {};
              q[search] = val;
              if ('object' == type(subset[ii])) {
                debug('attempting subdoc search with query %j', q);
                if (filter(subset[ii], q)) {
                  // we ignore the ret value of filter
                  if (!ret[prefix] || !~ret[prefix].indexOf(subset[ii])) {
                    matches.push(subset[ii]);
                  }
                }
              }
            } else {
              debug('performing simple array item search');
              if (compare(val, subset[ii])) {
                if (!ret[prefix] || !~ret[prefix].indexOf(subset[ii])) {
                  matches.push(subset[ii]);
                }
              }
            }
          }

          if (matches.length) {
            ret[prefix] = ret[prefix] || [];
            ret[prefix].push.apply(ret[prefix], matches);
          }

          // we don't continue the key search
          break walk_keys;

        case 'undefined':
          // if we can't find the key
          return false;

        case 'object':
          if (null != keys[i + 1]) {
            continue;
          } else if (!compare(val, target)) {
            return false;
          }
          break;

        default:
          if (!compare(val, target)) return false;
      }
    }
  }

  return ret;
}

/**
 * Compares the given matcher with the document value.
 *
 * @param {Mixed} matcher
 * @param {Mixed} value
 * @api private
 */

function compare(matcher, val){
  if ('object' != type(matcher)) {
    return eql(matcher, val);
  }

  var keys = object.keys(matcher);
  if ('$' == keys[0][0]) {
    for (var i = 0; i < keys.length; i++) {
      // special case for sub-object matching
      if ('$elemMatch' == keys[i]) {
        return false !== filter(val, matcher.$elemMatch);
      } else {
        if (!ops[keys[i]](matcher[keys[i]], val)) return false;
      }
    }
    return true;
  } else {
    return eql(matcher, val);
  }
}

},{"./ops":19,"component-type":11,"debug":12,"dot-component":15,"mongo-eql":17,"object-component":18}],9:[function(require,module,exports){

/**
 * Module dependencies.
 */

var mods = require('./mods');
var filter = require('./filter');
var dot = require('dot-component');
var type = require('component-type');
var object = require('object-component');
var debug = require('debug')('mongo-query');

/**
 * Module exports.
 */

module.exports = exports = query;

/**
 * Export filter helper.
 */

exports.filter = filter;

/**
 * Export modifiers.
 */

exports.mods = mods;

/**
 * Execute a query.
 *
 * Options:
 *  - `strict` only modify if query matches
 *
 * @param {Object} object to alter
 * @param {Object} query to filter modifications by
 * @param {Object} update object
 * @param {Object} options
 */

function query(obj, query, update, opts){
  obj = obj || {};
  opts = opts || {};
  query = query || {};
  update = update || {};

  // strict mode
  var strict = !!opts.strict;

  var match;
  var log = [];

  if (object.length(query)) {
    match = filter(obj, query);
  }

  if (!strict || false !== match) {
    var keys = object.keys(update);
    var transactions = [];

    for (var i = 0, l = keys.length; i < l; i++) {
      if (mods[keys[i]]) {
        debug('found modifier "%s"', keys[i]);
        for (var key in update[keys[i]]) {
          var pos = key.indexOf('.$.');

          if (~pos) {
            var prefix = key.substr(0, pos);
            var suffix = key.substr(pos + 3);

            if (match[prefix]) {
              debug('executing "%s" %s on first match within "%s"', key, keys[i], prefix);
              var fn = mods[keys[i]](match[prefix][0], suffix, update[keys[i]][key]);
              if (fn) {
                // produce a key name replacing $ with the actual index
                // TODO: this is unnecessarily expensive
                var index = dot.get(obj, prefix).indexOf(match[prefix][0]);
                fn.key = prefix + '.' + index + '.' + suffix;
                fn.op = keys[i];
                transactions.push(fn);
              }
            } else {
              debug('ignoring "%s" %s - no matches within "%s"', key, keys[i], prefix);
            }
          } else {
            var fn = mods[keys[i]](obj, key, update[keys[i]][key]);
            if (fn) {
              fn.key = key;
              fn.op = keys[i];
              transactions.push(fn);
            }
          }
        }
      } else {
        debug('skipping unknown modifier "%s"', keys[i]);
      }
    }

    if (transactions.length) {
      // if we got here error free we process all transactions
      for (var i = 0; i < transactions.length; i++) {
        var fn = transactions[i];
        var val = fn();
        log.push({ op: fn.op, key: fn.key, value: val });
      }
    }
  } else {
    debug('no matches for query %j', query);
  }

  return log;
}

},{"./filter":8,"./mods":10,"component-type":11,"debug":12,"dot-component":15,"object-component":18}],10:[function(require,module,exports){

/**
 * Module dependencies.
 */

var eql = require('mongo-eql');
var dot = require('dot-component');
var type = require('component-type');
var keys = require('object-component').keys;
var debug = require('debug')('mongo-query');

/**
 * Performs a `$set`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {String} value to set
 * @return {Function} transaction (unless noop)
 */

exports.$set = function $set(obj, path, val){
  var key = path.split('.').pop();
  obj = dot.parent(obj, path, true);

  switch (type(obj)) {
    case 'object':
      if (!eql(obj[key], val)) {
        return function(){
          obj[key] = val;
          return val;
        };
      }
      break;

    case 'array':
      if (numeric(key)) {
        if (!eql(obj[key], val)) {
          return function(){
            obj[key] = val;
            return val;
          };
        }
      } else {
        throw new Error('can\'t append to array using string field name [' + key + ']');
      }
      break;

    default:
      throw new Error('$set only supports object not ' + type(obj));
  }
};

/**
 * Performs an `$unset`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {String} value to set
 * @return {Function} transaction (unless noop)
 */

exports.$unset = function $unset(obj, path){
  var key = path.split('.').pop();
  obj = dot.parent(obj, path);

  switch (type(obj)) {
    case 'array':
    case 'object':
      if (obj.hasOwnProperty(key)) {
        return function(){
          // reminder: `delete arr[1]` === `delete arr['1']` [!]
          delete obj[key];
        };
      } else {
        // we fail silently
        debug('ignoring unset of inexisting key');
      }
  }
};

/**
 * Performs a `$rename`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {String} value to set
 * @return {Function} transaction (unless noop)
 */

exports.$rename = function $rename(obj, path, newKey){
  // target = source
  if (path == newKey) {
    throw new Error('$rename source must differ from target');
  }

  // target is parent of source
  if (0 === path.indexOf(newKey + '.')) {
    throw new Error('$rename target may not be a parent of source');
  }

  var p = dot.parent(obj, path);
  var t = type(p);

  if ('object' == t) {
    var key = path.split('.').pop();

    if (p.hasOwnProperty(key)) {
      return function(){
        var val = p[key];
        delete p[key];

        // target does initialize the path
        var newp = dot.parent(obj, newKey, true);

        // and also fails silently upon type mismatch
        if ('object' == type(newp)) {
          newp[newKey.split('.').pop()] = val;
        } else {
          debug('invalid $rename target path type');
        }

        // returns the name of the new key
        return newKey;
      };
    } else {
      debug('ignoring rename from inexisting source');
    }
  } else if ('undefined' != t) {
    throw new Error('$rename source field invalid');
  }
};

/**
 * Performs an `$inc`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {String} value to set
 * @return {Function} transaction (unless noop)
 */

exports.$inc = function $inc(obj, path, inc){
  if ('number' != type(inc)) {
    throw new Error('Modifier $inc allowed for numbers only');
  }

  obj = dot.parent(obj, path, true);
  var key = path.split('.').pop();

  switch (type(obj)) {
    case 'array':
    case 'object':
      if (obj.hasOwnProperty(key)) {
        if ('number' != type(obj[key])) {
          throw new Error('Cannot apply $inc modifier to non-number');
        }

        return function(){
          obj[key] += inc;
          return inc;
        };
      } else if('object' == type(obj) || numeric(key)){
        return function(){
          obj[key] = inc;
          return inc;
        };
      } else {
        throw new Error('can\'t append to array using string field name [' + key + ']');
      }
      break;

    default:
      throw new Error('Cannot apply $inc modifier to non-number');
  }
};

/**
 * Performs an `$pop`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {String} value to set
 * @return {Function} transaction (unless noop)
 */

exports.$pop = function $pop(obj, path, val){
  obj = dot.parent(obj, path);
  var key = path.split('.').pop();

  // we make sure the array is not just the parent of the main key
  switch (type(obj)) {
    case 'array':
    case 'object':
      if (obj.hasOwnProperty(key)) {
        switch (type(obj[key])) {
          case 'array':
            if (obj[key].length) {
              return function(){
                if (-1 == val) {
                  return obj[key].shift();
                } else {
                  // mongodb allows any value to pop
                  return obj[key].pop();
                }
              };
            }
            break;

          case 'undefined':
            debug('ignoring pop to inexisting key');
            break;

          default:
            throw new Error('Cannot apply $pop modifier to non-array');
        }
      } else {
        debug('ignoring pop to inexisting key');
      }
      break;

    case 'undefined':
      debug('ignoring pop to inexisting key');
      break;
  }
};

/**
 * Performs a `$push`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {Object} value to push
 * @return {Function} transaction (unless noop)
 */

exports.$push = function $push(obj, path, val){
  obj = dot.parent(obj, path, true);
  var key = path.split('.').pop();

  switch (type(obj)) {
    case 'object':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          return function(){
            obj[key].push(val);
            return val;
          };
        } else {
          throw new Error('Cannot apply $push/$pushAll modifier to non-array');
        }
      } else {
        return function(){
          obj[key] = [val];
          return val;
        };
      }
      break;

    case 'array':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          return function(){
            obj[key].push(val);
            return val;
          };
        } else {
          throw new Error('Cannot apply $push/$pushAll modifier to non-array');
        }
      } else if (numeric(key)) {
        return function(){
          obj[key] = [val];
          return val;
        };
      } else {
        throw new Error('can\'t append to array using string field name [' + key + ']');
      }
      break;
  }
};

/**
 * Performs a `$pushAll`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {Array} values to push
 * @return {Function} transaction (unless noop)
 */

exports.$pushAll = function $pushAll(obj, path, val){
  if ('array' != type(val)) {
    throw new Error('Modifier $pushAll/pullAll allowed for arrays only');
  }

  obj = dot.parent(obj, path, true);
  var key = path.split('.').pop();

  switch (type(obj)) {
    case 'object':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          return function(){
            obj[key].push.apply(obj[key], val);
            return val;
          };
        } else {
          throw new Error('Cannot apply $push/$pushAll modifier to non-array');
        }
      } else {
        return function(){
          obj[key] = val;
          return val;
        };
      }
      break;

    case 'array':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          return function(){
            obj[key].push.apply(obj[key], val);
            return val;
          };
        } else {
          throw new Error('Cannot apply $push/$pushAll modifier to non-array');
        }
      } else if (numeric(key)) {
        return function(){
          obj[key] = val;
          return val;
        };
      } else {
        throw new Error('can\'t append to array using string field name [' + key + ']');
      }
      break;
  }
};

/**
 * Performs a `$pull`.
 */

exports.$pull = function $pull(obj, path, val){
  obj = dot.parent(obj, path, true);
  var key = path.split('.').pop();
  var t = type(obj);

  switch (t) {
    case 'object':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          var pulled = [];
          var splice = pull(obj[key], [val], pulled);
          if (pulled.length) {
            return function(){
              splice();
              return pulled;
            };
          }
        } else {
          throw new Error('Cannot apply $pull/$pullAll modifier to non-array');
        }
      }
      break;

    case 'array':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          var pulled = [];
          var splice = pull(obj[key], [val], pulled);
          if (pulled.length) {
            return function(){
              splice();
              return pulled;
            };
          }
        } else {
          throw new Error('Cannot apply $pull/$pullAll modifier to non-array');
        }
      } else {
        debug('ignoring pull to non array');
      }
      break;

    default:
      if ('undefined' != t) {
        throw new Error('LEFT_SUBFIELD only supports Object: hello not: ' + t);
      }
  }
};

/**
 * Performs a `$pullAll`.
 */

exports.$pullAll = function $pullAll(obj, path, val){
  if ('array' != type(val)) {
    throw new Error('Modifier $pushAll/pullAll allowed for arrays only');
  }

  obj = dot.parent(obj, path, true);
  var key = path.split('.').pop();
  var t = type(obj);

  switch (t) {
    case 'object':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          var pulled = [];
          var splice = pull(obj[key], val, pulled);
          if (pulled.length) {
            return function(){
              splice();
              return pulled;
            };
          }
        } else {
          throw new Error('Cannot apply $pull/$pullAll modifier to non-array');
        }
      }
      break;

    case 'array':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          var pulled = [];
          var splice = pull(obj[key], val, pulled);
          if (pulled.length) {
            return function(){
              splice();
              return pulled;
            };
          }
        } else {
          throw new Error('Cannot apply $pull/$pullAll modifier to non-array');
        }
      } else {
        debug('ignoring pull to non array');
      }
      break;

    default:
      if ('undefined' != t) {
        throw new Error('LEFT_SUBFIELD only supports Object: hello not: ' + t);
      }
  }
};

/**
 * Performs a `$addToSet`.
 *
 * @param {Object} object to modify
 * @param {String} path to alter
 * @param {Object} value to push
 * @param {Boolean} internal, true if recursing
 * @return {Function} transaction (unless noop)
 */

exports.$addToSet = function $addToSet(obj, path, val, recursing){
  if (!recursing && 'array' == type(val.$each)) {
    var fns = [];
    for (var i = 0, l = val.$each.length; i < l; i++) {
      var fn = $addToSet(obj, path, val.$each[i], true);
      if (fn) fns.push(fn);
    }
    if (fns.length) {
      return function(){
        var values = [];
        for (var i = 0; i < fns.length; i++) values.push(fns[i]());
        return values;
      };
    } else {
      return;
    }
  }

  obj = dot.parent(obj, path, true);
  var key = path.split('.').pop();

  switch (type(obj)) {
    case 'object':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          if (!has(obj[key], val)) {
            return function(){
              obj[key].push(val);
              return val;
            };
          }
        } else {
          throw new Error('Cannot apply $addToSet modifier to non-array');
        }
      } else {
        return function(){
          obj[key] = [val];
          return val;
        };
      }
      break;

    case 'array':
      if (obj.hasOwnProperty(key)) {
        if ('array' == type(obj[key])) {
          if (!has(obj[key], val)) {
            return function(){
              obj[key].push(val);
              return val;
            };
          }
        } else {
          throw new Error('Cannot apply $addToSet modifier to non-array');
        }
      } else if (numeric(key)) {
        return function(){
          obj[key] = [val];
          return val;
        };
      } else {
        throw new Error('can\'t append to array using string field name [' + key + ']');
      }
      break;
  }
};

/**
 * Helper for determining if an array has the given value.
 *
 * @param {Array} array
 * @param {Object} value to check
 * @return {Boolean}
 */

function has(array, val){
  for (var i = 0, l = array.length; i < l; i++) {
    if (eql(val, array[i])) return true;
  }
  return false;
}

/**
 * Array#filter function generator for `$pull`/`$pullAll` operations.
 *
 * @param {Array} array of values to match
 * @param {Array} array to populate with results
 * @return {Function} that splices the array
 */

function pull(arr, vals, pulled){
  var indexes = [];

  for (var a = 0; a < arr.length; a++) {
    var val = arr[a];

    for (var i = 0; i < vals.length; i++) {
      var matcher = vals[i];
      if ('object' == type(matcher)) {
        // we only are only interested in obj <-> obj comparisons
        if ('object' == type(val)) {
          var match = false;

          if (keys(matcher).length) {
            for (var i in matcher) {
              if (matcher.hasOwnProperty(i)) {
                // we need at least one matching key to pull
                if (eql(matcher[i], val[i])) {
                  match = true;
                } else {
                  // if a single key doesn't match we move on
                  match = false;
                  break;
                }
              }
            }
          } else if (!keys(val).length) {
            // pull `{}` matches [{}]
            match = true;
          }

          if (match) {
            indexes.push(a);
            pulled.push(val);
            continue;
          }
        } else {
          debug('ignoring pull match against object');
        }
      } else {
        if (eql(matcher, val)) {
          indexes.push(a);
          pulled.push(val);
          continue;
        }
      }
    }
  }

  return function(){
    for (var i = 0; i < indexes.length; i++) {
      var index = indexes[i];
      arr.splice(index - i, 1);
    }
  };
}

/**
 * Helper to determine if a value is numeric.
 *
 * @param {String|Number} value
 * @return {Boolean} true if numeric
 * @api private
 */

function numeric(val){
  return 'number' == type(val) || Number(val) == val;
}

},{"component-type":11,"debug":12,"dot-component":15,"mongo-eql":17,"object-component":18}],11:[function(require,module,exports){
/**
 * toString ref.
 */

var toString = Object.prototype.toString;

/**
 * Return the type of `val`.
 *
 * @param {Mixed} val
 * @return {String}
 * @api public
 */

module.exports = function(val){
  switch (toString.call(val)) {
    case '[object Date]': return 'date';
    case '[object RegExp]': return 'regexp';
    case '[object Arguments]': return 'arguments';
    case '[object Array]': return 'array';
    case '[object Error]': return 'error';
  }

  if (val === null) return 'null';
  if (val === undefined) return 'undefined';
  if (val !== val) return 'nan';
  if (val && val.nodeType === 1) return 'element';

  val = val.valueOf
    ? val.valueOf()
    : Object.prototype.valueOf.apply(val)

  return typeof val;
};

},{}],12:[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Use chrome.storage.local if we are in an app
 */

var storage;

if (typeof chrome !== 'undefined' && typeof chrome.storage !== 'undefined')
  storage = chrome.storage.local;
else
  storage = localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      storage.removeItem('debug');
    } else {
      storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

},{"./debug":13}],13:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":14}],14:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],15:[function(require,module,exports){

/**
 * Module dependencies.
 */

var type = require('type-component');

/**
 * Gets a certain `path` from the `obj`.
 *
 * @param {Object} target
 * @param {String} key
 * @return {Object} found object, or `undefined
 * @api public
 */

exports.get = function(obj, path){
  if (~path.indexOf('.')) {
    var par = parent(obj, path);
    var mainKey = path.split('.').pop();
    var t = type(par);
    if ('object' == t || 'array' == t) return par[mainKey];
  } else {
    return obj[path];
  }
};

/**
 * Sets the given `path` to `val` in `obj`.
 *
 * @param {Object} target
 * @Param {String} key
 * @param {Object} value
 * @api public
 */

exports.set = function(obj, path, val){
  if (~path.indexOf('.')) {
    var par = parent(obj, path, true);
    var mainKey = path.split('.').pop();
    if (par && 'object' == type(par)) par[mainKey] = val;
  } else {
    obj[path] = val;
  }
};

/**
 * Gets the parent object for a given key (dot notation aware).
 *
 * - If a parent object doesn't exist, it's initialized.
 * - Array index lookup is supported
 *
 * @param {Object} target object
 * @param {String} key
 * @param {Boolean} true if it should initialize the path
 * @api public
 */

exports.parent = parent;

function parent(obj, key, init){
  if (~key.indexOf('.')) {
    var pieces = key.split('.');
    var ret = obj;

    for (var i = 0; i < pieces.length - 1; i++) {
      // if the key is a number string and parent is an array
      if (Number(pieces[i]) == pieces[i] && 'array' == type(ret)) {
        ret = ret[pieces[i]];
      } else if ('object' == type(ret)) {
        if (init && !ret.hasOwnProperty(pieces[i])) {
          ret[pieces[i]] = {};
        }
        if (ret) ret = ret[pieces[i]];
      }
    }

    return ret;
  } else {
    return obj;
  }
}

},{"type-component":16}],16:[function(require,module,exports){

/**
 * toString ref.
 */

var toString = Object.prototype.toString;

/**
 * Return the type of `val`.
 *
 * @param {Mixed} val
 * @return {String}
 * @api public
 */

module.exports = function(val){
  switch (toString.call(val)) {
    case '[object Function]': return 'function';
    case '[object Date]': return 'date';
    case '[object RegExp]': return 'regexp';
    case '[object Arguments]': return 'arguments';
    case '[object Array]': return 'array';
  }

  if (val === null) return 'null';
  if (val === undefined) return 'undefined';
  if (val === Object(val)) return 'object';

  return typeof val;
};

},{}],17:[function(require,module,exports){

/**
 * Module dependencies.
 */

var type = require('component-type');

/**
 * Module exports.
 */

module.exports = eql;

/**
 * MongoDB style value comparisons.
 *
 * @param {Object} matcher
 * @param {Object} value
 * @return {Boolean} true if they match
 */

function eql(matcher, val){
  switch (type(matcher)) {
    case 'null':
    case 'undefined':
      // we treat null as undefined
      return null == val;

    case 'regexp':
      return matcher.test(val);

    case 'array':
      if ('array' == type(val) && matcher.length == val.length) {
        for (var i = 0; i < matcher.length; i++) {
          if (!eql(val[i], matcher[i])) return false;
        }
        return true;
      } else {
        return false;
      }
      break;

    case 'object':
      // object can match keys in any order
      var keys = {};

      // we match all values of `matcher` in `val`
      for (var i in matcher) {
        if (matcher.hasOwnProperty(i)) {
          if (!val.hasOwnProperty(i) || !eql(matcher[i], val[i])) {
            return false;
          }
        }
        keys[i] = true;
      }

      // we make sure `val` doesn't have extra keys
      for (var i in val) {
        if (val.hasOwnProperty(i) && !keys.hasOwnProperty(i)) {
          return false;
        }
      }

      return true;

    default:
      return matcher === val;
  }
}

},{"component-type":11}],18:[function(require,module,exports){

/**
 * HOP ref.
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Return own keys in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.keys = Object.keys || function(obj){
  var keys = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      keys.push(key);
    }
  }
  return keys;
};

/**
 * Return own values in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.values = function(obj){
  var vals = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      vals.push(obj[key]);
    }
  }
  return vals;
};

/**
 * Merge `b` into `a`.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 * @api public
 */

exports.merge = function(a, b){
  for (var key in b) {
    if (has.call(b, key)) {
      a[key] = b[key];
    }
  }
  return a;
};

/**
 * Return length of `obj`.
 *
 * @param {Object} obj
 * @return {Number}
 * @api public
 */

exports.length = function(obj){
  return exports.keys(obj).length;
};

/**
 * Check if `obj` is empty.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api public
 */

exports.isEmpty = function(obj){
  return 0 == exports.length(obj);
};
},{}],19:[function(require,module,exports){

/**
 * Module dependencies.
 */

var eql = require('mongo-eql');
var type = require('component-type');

/**
 * $ne: not equal.
 */

exports.$ne = function $ne(matcher, val){
  return !eql(matcher, val);
};

/**
 * $gt: greater than.
 */

exports.$gt = function $gt(matcher, val){
  return type(matcher) === 'number' && val > matcher;
};

/**
 * $gte: greater than equal.
 */

exports.$gte = function $gte(matcher, val){
  return type(matcher) === 'number' && val >= matcher;
};

/**
 * $lt: less than.
 */

exports.$lt = function $lt(matcher, val){
  return type(matcher) === 'number' && val < matcher;
};

/**
 * $lte: less than equal.
 */

exports.$lte = function $lte(matcher, val){
  return type(matcher) === 'number' && val <= matcher;
};

/**
 * $regex: supply a regular expression as a string.
 */

exports.$regex = function $regex(matcher, val){
  // TODO: add $options support
  if ('regexp' != type('matcher')) matcher = new RegExp(matcher);
  return matcher.test(val);
};

/**
 * $exists: key exists.
 */

exports.$exists = function $exists(matcher, val){
  if (matcher) {
    return undefined !== val;
  } else {
    return undefined === val;
  }
};

/**
 * $in: value in array.
 */

exports.$in = function $in(matcher, val){
  if ('array' != type(matcher)) return false;
  for (var i = 0; i < matcher.length; i++) {
    if (eql(matcher[i], val)) return true;
  }
  return false;
};

/**
 * $nin: value not in array.
 */

exports.$nin = function $nin(matcher, val){
  return !exports.$in(matcher, val);
};

/**
 * @size: array length
 */

exports.$size = function(matcher, val){
  return Array.isArray(val) && matcher == val.length;
};

},{"component-type":11,"mongo-eql":17}],20:[function(require,module,exports){
var CryptoJS = require('./lib/core').CryptoJS;
require('./lib/enc-base64');
require('./lib/md5');
require('./lib/evpkdf');
require('./lib/cipher-core');
require('./lib/aes');
var JsonFormatter = require('./lib/jsonformatter').JsonFormatter;

exports.CryptoJS = CryptoJS;
exports.JsonFormatter = JsonFormatter;
},{"./lib/aes":21,"./lib/cipher-core":22,"./lib/core":23,"./lib/enc-base64":24,"./lib/evpkdf":25,"./lib/jsonformatter":26,"./lib/md5":27}],21:[function(require,module,exports){
var CryptoJS = require('./core').CryptoJS;

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var BlockCipher = C_lib.BlockCipher;
    var C_algo = C.algo;

    // Lookup tables
    var SBOX = [];
    var INV_SBOX = [];
    var SUB_MIX_0 = [];
    var SUB_MIX_1 = [];
    var SUB_MIX_2 = [];
    var SUB_MIX_3 = [];
    var INV_SUB_MIX_0 = [];
    var INV_SUB_MIX_1 = [];
    var INV_SUB_MIX_2 = [];
    var INV_SUB_MIX_3 = [];

    // Compute lookup tables
    (function () {
        // Compute double table
        var d = [];
        for (var i = 0; i < 256; i++) {
            if (i < 128) {
                d[i] = i << 1;
            } else {
                d[i] = (i << 1) ^ 0x11b;
            }
        }

        // Walk GF(2^8)
        var x = 0;
        var xi = 0;
        for (var i = 0; i < 256; i++) {
            // Compute sbox
            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
            SBOX[x] = sx;
            INV_SBOX[sx] = x;

            // Compute multiplication
            var x2 = d[x];
            var x4 = d[x2];
            var x8 = d[x4];

            // Compute sub bytes, mix columns tables
            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
            SUB_MIX_3[x] = t;

            // Compute inv sub bytes, inv mix columns tables
            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
            INV_SUB_MIX_3[sx] = t;

            // Compute next counter
            if (!x) {
                x = xi = 1;
            } else {
                x = x2 ^ d[d[d[x8 ^ x2]]];
                xi ^= d[d[xi]];
            }
        }
    }());

    // Precomputed Rcon lookup
    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

    /**
     * AES block cipher algorithm.
     */
    var AES = C_algo.AES = BlockCipher.extend({
        _doReset: function () {
            // Shortcuts
            var key = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;

            // Compute number of rounds
            var nRounds = this._nRounds = keySize + 6

            // Compute number of key schedule rows
            var ksRows = (nRounds + 1) * 4;

            // Compute key schedule
            var keySchedule = this._keySchedule = [];
            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
                if (ksRow < keySize) {
                    keySchedule[ksRow] = keyWords[ksRow];
                } else {
                    var t = keySchedule[ksRow - 1];

                    if (!(ksRow % keySize)) {
                        // Rot word
                        t = (t << 8) | (t >>> 24);

                        // Sub word
                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

                        // Mix Rcon
                        t ^= RCON[(ksRow / keySize) | 0] << 24;
                    } else if (keySize > 6 && ksRow % keySize == 4) {
                        // Sub word
                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
                    }

                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
                }
            }

            // Compute inv key schedule
            var invKeySchedule = this._invKeySchedule = [];
            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
                var ksRow = ksRows - invKsRow;

                if (invKsRow % 4) {
                    var t = keySchedule[ksRow];
                } else {
                    var t = keySchedule[ksRow - 4];
                }

                if (invKsRow < 4 || ksRow <= 4) {
                    invKeySchedule[invKsRow] = t;
                } else {
                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
                }
            }
        },

        encryptBlock: function (M, offset) {
            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
        },

        decryptBlock: function (M, offset) {
            // Swap 2nd and 4th rows
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;

            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

            // Inv swap 2nd and 4th rows
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;
        },

        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
            // Shortcut
            var nRounds = this._nRounds;

            // Get input, add round key
            var s0 = M[offset]     ^ keySchedule[0];
            var s1 = M[offset + 1] ^ keySchedule[1];
            var s2 = M[offset + 2] ^ keySchedule[2];
            var s3 = M[offset + 3] ^ keySchedule[3];

            // Key schedule row counter
            var ksRow = 4;

            // Rounds
            for (var round = 1; round < nRounds; round++) {
                // Shift rows, sub bytes, mix columns, add round key
                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

                // Update state
                s0 = t0;
                s1 = t1;
                s2 = t2;
                s3 = t3;
            }

            // Shift rows, sub bytes, add round key
            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

            // Set output
            M[offset]     = t0;
            M[offset + 1] = t1;
            M[offset + 2] = t2;
            M[offset + 3] = t3;
        },

        keySize: 256/32
    });

    /**
     * Shortcut functions to the cipher's object interface.
     *
     * @example
     *
     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
     */
    C.AES = BlockCipher._createHelper(AES);
}());

},{"./core":23}],22:[function(require,module,exports){
var CryptoJS = require('./core').CryptoJS;

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
/**
 * Cipher core components.
 */
CryptoJS.lib.Cipher || (function (undefined) {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var Base = C_lib.Base;
    var WordArray = C_lib.WordArray;
    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
    var C_enc = C.enc;
    var Utf8 = C_enc.Utf8;
    var Base64 = C_enc.Base64;
    var C_algo = C.algo;
    var EvpKDF = C_algo.EvpKDF;

    /**
     * Abstract base cipher template.
     *
     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
     */
    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
        /**
         * Configuration options.
         *
         * @property {WordArray} iv The IV to use for this operation.
         */
        cfg: Base.extend(),

        /**
         * Creates this cipher in encryption mode.
         *
         * @param {WordArray} key The key.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {Cipher} A cipher instance.
         *
         * @static
         *
         * @example
         *
         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
         */
        createEncryptor: function (key, cfg) {
            return this.create(this._ENC_XFORM_MODE, key, cfg);
        },

        /**
         * Creates this cipher in decryption mode.
         *
         * @param {WordArray} key The key.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {Cipher} A cipher instance.
         *
         * @static
         *
         * @example
         *
         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
         */
        createDecryptor: function (key, cfg) {
            return this.create(this._DEC_XFORM_MODE, key, cfg);
        },

        /**
         * Initializes a newly created cipher.
         *
         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
         * @param {WordArray} key The key.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @example
         *
         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
         */
        init: function (xformMode, key, cfg) {
            // Apply config defaults
            this.cfg = this.cfg.extend(cfg);

            // Store transform mode and key
            this._xformMode = xformMode;
            this._key = key;

            // Set initial values
            this.reset();
        },

        /**
         * Resets this cipher to its initial state.
         *
         * @example
         *
         *     cipher.reset();
         */
        reset: function () {
            // Reset data buffer
            BufferedBlockAlgorithm.reset.call(this);

            // Perform concrete-cipher logic
            this._doReset();
        },

        /**
         * Adds data to be encrypted or decrypted.
         *
         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
         *
         * @return {WordArray} The data after processing.
         *
         * @example
         *
         *     var encrypted = cipher.process('data');
         *     var encrypted = cipher.process(wordArray);
         */
        process: function (dataUpdate) {
            // Append
            this._append(dataUpdate);

            // Process available blocks
            return this._process();
        },

        /**
         * Finalizes the encryption or decryption process.
         * Note that the finalize operation is effectively a destructive, read-once operation.
         *
         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
         *
         * @return {WordArray} The data after final processing.
         *
         * @example
         *
         *     var encrypted = cipher.finalize();
         *     var encrypted = cipher.finalize('data');
         *     var encrypted = cipher.finalize(wordArray);
         */
        finalize: function (dataUpdate) {
            // Final data update
            if (dataUpdate) {
                this._append(dataUpdate);
            }

            // Perform concrete-cipher logic
            var finalProcessedData = this._doFinalize();

            return finalProcessedData;
        },

        keySize: 128/32,

        ivSize: 128/32,

        _ENC_XFORM_MODE: 1,

        _DEC_XFORM_MODE: 2,

        /**
         * Creates shortcut functions to a cipher's object interface.
         *
         * @param {Cipher} cipher The cipher to create a helper for.
         *
         * @return {Object} An object with encrypt and decrypt shortcut functions.
         *
         * @static
         *
         * @example
         *
         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
         */
        _createHelper: (function () {
            function selectCipherStrategy(key) {
                if (typeof key == 'string') {
                    return PasswordBasedCipher;
                } else {
                    return SerializableCipher;
                }
            }

            return function (cipher) {
                return {
                    encrypt: function (message, key, cfg) {
                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                    },

                    decrypt: function (ciphertext, key, cfg) {
                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                    }
                };
            };
        }())
    });

    /**
     * Abstract base stream cipher template.
     *
     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
     */
    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
        _doFinalize: function () {
            // Process partial blocks
            var finalProcessedBlocks = this._process(!!'flush');

            return finalProcessedBlocks;
        },

        blockSize: 1
    });

    /**
     * Mode namespace.
     */
    var C_mode = C.mode = {};

    /**
     * Abstract base block cipher mode template.
     */
    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
        /**
         * Creates this mode for encryption.
         *
         * @param {Cipher} cipher A block cipher instance.
         * @param {Array} iv The IV words.
         *
         * @static
         *
         * @example
         *
         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
         */
        createEncryptor: function (cipher, iv) {
            return this.Encryptor.create(cipher, iv);
        },

        /**
         * Creates this mode for decryption.
         *
         * @param {Cipher} cipher A block cipher instance.
         * @param {Array} iv The IV words.
         *
         * @static
         *
         * @example
         *
         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
         */
        createDecryptor: function (cipher, iv) {
            return this.Decryptor.create(cipher, iv);
        },

        /**
         * Initializes a newly created mode.
         *
         * @param {Cipher} cipher A block cipher instance.
         * @param {Array} iv The IV words.
         *
         * @example
         *
         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
         */
        init: function (cipher, iv) {
            this._cipher = cipher;
            this._iv = iv;
        }
    });

    /**
     * Cipher Block Chaining mode.
     */
    var CBC = C_mode.CBC = (function () {
        /**
         * Abstract base CBC mode.
         */
        var CBC = BlockCipherMode.extend();

        /**
         * CBC encryptor.
         */
        CBC.Encryptor = CBC.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function (words, offset) {
                // Shortcuts
                var cipher = this._cipher;
                var blockSize = cipher.blockSize;

                // XOR and encrypt
                xorBlock.call(this, words, offset, blockSize);
                cipher.encryptBlock(words, offset);

                // Remember this block to use with next block
                this._prevBlock = words.slice(offset, offset + blockSize);
            }
        });

        /**
         * CBC decryptor.
         */
        CBC.Decryptor = CBC.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function (words, offset) {
                // Shortcuts
                var cipher = this._cipher;
                var blockSize = cipher.blockSize;

                // Remember this block to use with next block
                var thisBlock = words.slice(offset, offset + blockSize);

                // Decrypt and XOR
                cipher.decryptBlock(words, offset);
                xorBlock.call(this, words, offset, blockSize);

                // This block becomes the previous block
                this._prevBlock = thisBlock;
            }
        });

        function xorBlock(words, offset, blockSize) {
            // Shortcut
            var iv = this._iv;

            // Choose mixing block
            if (iv) {
                var block = iv;

                // Remove IV for subsequent blocks
                this._iv = undefined;
            } else {
                var block = this._prevBlock;
            }

            // XOR blocks
            for (var i = 0; i < blockSize; i++) {
                words[offset + i] ^= block[i];
            }
        }

        return CBC;
    }());

    /**
     * Padding namespace.
     */
    var C_pad = C.pad = {};

    /**
     * PKCS #5/7 padding strategy.
     */
    var Pkcs7 = C_pad.Pkcs7 = {
        /**
         * Pads data using the algorithm defined in PKCS #5/7.
         *
         * @param {WordArray} data The data to pad.
         * @param {number} blockSize The multiple that the data should be padded to.
         *
         * @static
         *
         * @example
         *
         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
         */
        pad: function (data, blockSize) {
            // Shortcut
            var blockSizeBytes = blockSize * 4;

            // Count padding bytes
            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

            // Create padding word
            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

            // Create padding
            var paddingWords = [];
            for (var i = 0; i < nPaddingBytes; i += 4) {
                paddingWords.push(paddingWord);
            }
            var padding = WordArray.create(paddingWords, nPaddingBytes);

            // Add padding
            data.concat(padding);
        },

        /**
         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
         *
         * @param {WordArray} data The data to unpad.
         *
         * @static
         *
         * @example
         *
         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
         */
        unpad: function (data) {
            // Get number of padding bytes from last byte
            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

            // Remove padding
            data.sigBytes -= nPaddingBytes;
        }
    };

    /**
     * Abstract base block cipher template.
     *
     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
     */
    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
        /**
         * Configuration options.
         *
         * @property {Mode} mode The block mode to use. Default: CBC
         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
         */
        cfg: Cipher.cfg.extend({
            mode: CBC,
            padding: Pkcs7
        }),

        reset: function () {
            // Reset cipher
            Cipher.reset.call(this);

            // Shortcuts
            var cfg = this.cfg;
            var iv = cfg.iv;
            var mode = cfg.mode;

            // Reset block mode
            if (this._xformMode == this._ENC_XFORM_MODE) {
                var modeCreator = mode.createEncryptor;
            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
                var modeCreator = mode.createDecryptor;

                // Keep at least one block in the buffer for unpadding
                this._minBufferSize = 1;
            }
            this._mode = modeCreator.call(mode, this, iv && iv.words);
        },

        _doProcessBlock: function (words, offset) {
            this._mode.processBlock(words, offset);
        },

        _doFinalize: function () {
            // Shortcut
            var padding = this.cfg.padding;

            // Finalize
            if (this._xformMode == this._ENC_XFORM_MODE) {
                // Pad data
                padding.pad(this._data, this.blockSize);

                // Process final blocks
                var finalProcessedBlocks = this._process(!!'flush');
            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
                // Process final blocks
                var finalProcessedBlocks = this._process(!!'flush');

                // Unpad data
                padding.unpad(finalProcessedBlocks);
            }

            return finalProcessedBlocks;
        },

        blockSize: 128/32
    });

    /**
     * A collection of cipher parameters.
     *
     * @property {WordArray} ciphertext The raw ciphertext.
     * @property {WordArray} key The key to this ciphertext.
     * @property {WordArray} iv The IV used in the ciphering operation.
     * @property {WordArray} salt The salt used with a key derivation function.
     * @property {Cipher} algorithm The cipher algorithm.
     * @property {Mode} mode The block mode used in the ciphering operation.
     * @property {Padding} padding The padding scheme used in the ciphering operation.
     * @property {number} blockSize The block size of the cipher.
     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
     */
    var CipherParams = C_lib.CipherParams = Base.extend({
        /**
         * Initializes a newly created cipher params object.
         *
         * @param {Object} cipherParams An object with any of the possible cipher parameters.
         *
         * @example
         *
         *     var cipherParams = CryptoJS.lib.CipherParams.create({
         *         ciphertext: ciphertextWordArray,
         *         key: keyWordArray,
         *         iv: ivWordArray,
         *         salt: saltWordArray,
         *         algorithm: CryptoJS.algo.AES,
         *         mode: CryptoJS.mode.CBC,
         *         padding: CryptoJS.pad.PKCS7,
         *         blockSize: 4,
         *         formatter: CryptoJS.format.OpenSSL
         *     });
         */
        init: function (cipherParams) {
            this.mixIn(cipherParams);
        },

        /**
         * Converts this cipher params object to a string.
         *
         * @param {Format} formatter (Optional) The formatting strategy to use.
         *
         * @return {string} The stringified cipher params.
         *
         * @throws Error If neither the formatter nor the default formatter is set.
         *
         * @example
         *
         *     var string = cipherParams + '';
         *     var string = cipherParams.toString();
         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
         */
        toString: function (formatter) {
            return (formatter || this.formatter).stringify(this);
        }
    });

    /**
     * Format namespace.
     */
    var C_format = C.format = {};

    /**
     * OpenSSL formatting strategy.
     */
    var OpenSSLFormatter = C_format.OpenSSL = {
        /**
         * Converts a cipher params object to an OpenSSL-compatible string.
         *
         * @param {CipherParams} cipherParams The cipher params object.
         *
         * @return {string} The OpenSSL-compatible string.
         *
         * @static
         *
         * @example
         *
         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
         */
        stringify: function (cipherParams) {
            // Shortcuts
            var ciphertext = cipherParams.ciphertext;
            var salt = cipherParams.salt;

            // Format
            if (salt) {
                var wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
            } else {
                var wordArray = ciphertext;
            }

            return wordArray.toString(Base64);
        },

        /**
         * Converts an OpenSSL-compatible string to a cipher params object.
         *
         * @param {string} openSSLStr The OpenSSL-compatible string.
         *
         * @return {CipherParams} The cipher params object.
         *
         * @static
         *
         * @example
         *
         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
         */
        parse: function (openSSLStr) {
            // Parse base64
            var ciphertext = Base64.parse(openSSLStr);

            // Shortcut
            var ciphertextWords = ciphertext.words;

            // Test for salt
            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
                // Extract salt
                var salt = WordArray.create(ciphertextWords.slice(2, 4));

                // Remove salt from ciphertext
                ciphertextWords.splice(0, 4);
                ciphertext.sigBytes -= 16;
            }

            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
        }
    };

    /**
     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
     */
    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
        /**
         * Configuration options.
         *
         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
         */
        cfg: Base.extend({
            format: OpenSSLFormatter
        }),

        /**
         * Encrypts a message.
         *
         * @param {Cipher} cipher The cipher algorithm to use.
         * @param {WordArray|string} message The message to encrypt.
         * @param {WordArray} key The key.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {CipherParams} A cipher params object.
         *
         * @static
         *
         * @example
         *
         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
         */
        encrypt: function (cipher, message, key, cfg) {
            // Apply config defaults
            cfg = this.cfg.extend(cfg);

            // Encrypt
            var encryptor = cipher.createEncryptor(key, cfg);
            var ciphertext = encryptor.finalize(message);

            // Shortcut
            var cipherCfg = encryptor.cfg;

            // Create and return serializable cipher params
            return CipherParams.create({
                ciphertext: ciphertext,
                key: key,
                iv: cipherCfg.iv,
                algorithm: cipher,
                mode: cipherCfg.mode,
                padding: cipherCfg.padding,
                blockSize: cipher.blockSize,
                formatter: cfg.format
            });
        },

        /**
         * Decrypts serialized ciphertext.
         *
         * @param {Cipher} cipher The cipher algorithm to use.
         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
         * @param {WordArray} key The key.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {WordArray} The plaintext.
         *
         * @static
         *
         * @example
         *
         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
         */
        decrypt: function (cipher, ciphertext, key, cfg) {
            // Apply config defaults
            cfg = this.cfg.extend(cfg);

            // Convert string to CipherParams
            ciphertext = this._parse(ciphertext, cfg.format);

            // Decrypt
            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

            return plaintext;
        },

        /**
         * Converts serialized ciphertext to CipherParams,
         * else assumed CipherParams already and returns ciphertext unchanged.
         *
         * @param {CipherParams|string} ciphertext The ciphertext.
         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
         *
         * @return {CipherParams} The unserialized ciphertext.
         *
         * @static
         *
         * @example
         *
         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
         */
        _parse: function (ciphertext, format) {
            if (typeof ciphertext == 'string') {
                return format.parse(ciphertext, this);
            } else {
                return ciphertext;
            }
        }
    });

    /**
     * Key derivation function namespace.
     */
    var C_kdf = C.kdf = {};

    /**
     * OpenSSL key derivation function.
     */
    var OpenSSLKdf = C_kdf.OpenSSL = {
        /**
         * Derives a key and IV from a password.
         *
         * @param {string} password The password to derive from.
         * @param {number} keySize The size in words of the key to generate.
         * @param {number} ivSize The size in words of the IV to generate.
         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
         *
         * @return {CipherParams} A cipher params object with the key, IV, and salt.
         *
         * @static
         *
         * @example
         *
         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
         */
        execute: function (password, keySize, ivSize, salt) {
            // Generate random salt
            if (!salt) {
                salt = WordArray.random(64/8);
            }

            // Derive key and IV
            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);

            // Separate key and IV
            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
            key.sigBytes = keySize * 4;

            // Return params
            return CipherParams.create({ key: key, iv: iv, salt: salt });
        }
    };

    /**
     * A serializable cipher wrapper that derives the key from a password,
     * and returns ciphertext as a serializable cipher params object.
     */
    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
        /**
         * Configuration options.
         *
         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
         */
        cfg: SerializableCipher.cfg.extend({
            kdf: OpenSSLKdf
        }),

        /**
         * Encrypts a message using a password.
         *
         * @param {Cipher} cipher The cipher algorithm to use.
         * @param {WordArray|string} message The message to encrypt.
         * @param {string} password The password.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {CipherParams} A cipher params object.
         *
         * @static
         *
         * @example
         *
         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
         */
        encrypt: function (cipher, message, password, cfg) {
            // Apply config defaults
            cfg = this.cfg.extend(cfg);

            // Derive key and other params
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);

            // Add IV to config
            cfg.iv = derivedParams.iv;

            // Encrypt
            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

            // Mix in derived params
            ciphertext.mixIn(derivedParams);

            return ciphertext;
        },

        /**
         * Decrypts serialized ciphertext using a password.
         *
         * @param {Cipher} cipher The cipher algorithm to use.
         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
         * @param {string} password The password.
         * @param {Object} cfg (Optional) The configuration options to use for this operation.
         *
         * @return {WordArray} The plaintext.
         *
         * @static
         *
         * @example
         *
         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
         */
        decrypt: function (cipher, ciphertext, password, cfg) {
            // Apply config defaults
            cfg = this.cfg.extend(cfg);

            // Convert string to CipherParams
            ciphertext = this._parse(ciphertext, cfg.format);

            // Derive key and other params
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);

            // Add IV to config
            cfg.iv = derivedParams.iv;

            // Decrypt
            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

            return plaintext;
        }
    });
}());

},{"./core":23}],23:[function(require,module,exports){
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
/**
 * CryptoJS core components.
 */
var CryptoJS = CryptoJS || (function (Math, undefined) {
    /**
     * CryptoJS namespace.
     */
    var C = {};

    /**
     * Library namespace.
     */
    var C_lib = C.lib = {};

    /**
     * Base object for prototypal inheritance.
     */
    var Base = C_lib.Base = (function () {
        function F() {}

        return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function (overrides) {
                // Spawn
                F.prototype = this;
                var subtype = new F();

                // Augment
                if (overrides) {
                    subtype.mixIn(overrides);
                }

                // Create default initializer
                if (!subtype.hasOwnProperty('init')) {
                    subtype.init = function () {
                        subtype.$super.init.apply(this, arguments);
                    };
                }

                // Initializer's prototype is the subtype object
                subtype.init.prototype = subtype;

                // Reference supertype
                subtype.$super = this;

                return subtype;
            },

            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function () {
                var instance = this.extend();
                instance.init.apply(instance, arguments);

                return instance;
            },

            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function () {
            },

            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function (properties) {
                for (var propertyName in properties) {
                    if (properties.hasOwnProperty(propertyName)) {
                        this[propertyName] = properties[propertyName];
                    }
                }

                // IE won't copy toString using the loop above
                if (properties.hasOwnProperty('toString')) {
                    this.toString = properties.toString;
                }
            },

            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function () {
                return this.init.prototype.extend(this);
            }
        };
    }());

    /**
     * An array of 32-bit words.
     *
     * @property {Array} words The array of 32-bit words.
     * @property {number} sigBytes The number of significant bytes in this word array.
     */
    var WordArray = C_lib.WordArray = Base.extend({
        /**
         * Initializes a newly created word array.
         *
         * @param {Array} words (Optional) An array of 32-bit words.
         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
         *
         * @example
         *
         *     var wordArray = CryptoJS.lib.WordArray.create();
         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
         */
        init: function (words, sigBytes) {
            words = this.words = words || [];

            if (sigBytes != undefined) {
                this.sigBytes = sigBytes;
            } else {
                this.sigBytes = words.length * 4;
            }
        },

        /**
         * Converts this word array to a string.
         *
         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
         *
         * @return {string} The stringified word array.
         *
         * @example
         *
         *     var string = wordArray + '';
         *     var string = wordArray.toString();
         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
         */
        toString: function (encoder) {
            return (encoder || Hex).stringify(this);
        },

        /**
         * Concatenates a word array to this word array.
         *
         * @param {WordArray} wordArray The word array to append.
         *
         * @return {WordArray} This word array.
         *
         * @example
         *
         *     wordArray1.concat(wordArray2);
         */
        concat: function (wordArray) {
            // Shortcuts
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;

            // Clamp excess bits
            this.clamp();

            // Concat
            if (thisSigBytes % 4) {
                // Copy one byte at a time
                for (var i = 0; i < thatSigBytes; i++) {
                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
                }
            } else if (thatWords.length > 0xffff) {
                // Copy one word at a time
                for (var i = 0; i < thatSigBytes; i += 4) {
                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
                }
            } else {
                // Copy all words at once
                thisWords.push.apply(thisWords, thatWords);
            }
            this.sigBytes += thatSigBytes;

            // Chainable
            return this;
        },

        /**
         * Removes insignificant bits.
         *
         * @example
         *
         *     wordArray.clamp();
         */
        clamp: function () {
            // Shortcuts
            var words = this.words;
            var sigBytes = this.sigBytes;

            // Clamp
            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
            words.length = Math.ceil(sigBytes / 4);
        },

        /**
         * Creates a copy of this word array.
         *
         * @return {WordArray} The clone.
         *
         * @example
         *
         *     var clone = wordArray.clone();
         */
        clone: function () {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);

            return clone;
        },

        /**
         * Creates a word array filled with random bytes.
         *
         * @param {number} nBytes The number of random bytes to generate.
         *
         * @return {WordArray} The random word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.lib.WordArray.random(16);
         */
        random: function (nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
                words.push((Math.random() * 0x100000000) | 0);
            }

            return new WordArray.init(words, nBytes);
        }
    });

    /**
     * Encoder namespace.
     */
    var C_enc = C.enc = {};

    /**
     * Hex encoding strategy.
     */
    var Hex = C_enc.Hex = {
        /**
         * Converts a word array to a hex string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The hex string.
         *
         * @static
         *
         * @example
         *
         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;

            // Convert
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                hexChars.push((bite >>> 4).toString(16));
                hexChars.push((bite & 0x0f).toString(16));
            }

            return hexChars.join('');
        },

        /**
         * Converts a hex string to a word array.
         *
         * @param {string} hexStr The hex string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
         */
        parse: function (hexStr) {
            // Shortcut
            var hexStrLength = hexStr.length;

            // Convert
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
            }

            return new WordArray.init(words, hexStrLength / 2);
        }
    };

    /**
     * Latin1 encoding strategy.
     */
    var Latin1 = C_enc.Latin1 = {
        /**
         * Converts a word array to a Latin1 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The Latin1 string.
         *
         * @static
         *
         * @example
         *
         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;

            // Convert
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                latin1Chars.push(String.fromCharCode(bite));
            }

            return latin1Chars.join('');
        },

        /**
         * Converts a Latin1 string to a word array.
         *
         * @param {string} latin1Str The Latin1 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
         */
        parse: function (latin1Str) {
            // Shortcut
            var latin1StrLength = latin1Str.length;

            // Convert
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
            }

            return new WordArray.init(words, latin1StrLength);
        }
    };

    /**
     * UTF-8 encoding strategy.
     */
    var Utf8 = C_enc.Utf8 = {
        /**
         * Converts a word array to a UTF-8 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The UTF-8 string.
         *
         * @static
         *
         * @example
         *
         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
         */
        stringify: function (wordArray) {
            try {
                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
                throw new Error('Malformed UTF-8 data');
            }
        },

        /**
         * Converts a UTF-8 string to a word array.
         *
         * @param {string} utf8Str The UTF-8 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
         */
        parse: function (utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
        }
    };

    /**
     * Abstract buffered block algorithm template.
     *
     * The property blockSize must be implemented in a concrete subtype.
     *
     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
     */
    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
        /**
         * Resets this block algorithm's data buffer to its initial state.
         *
         * @example
         *
         *     bufferedBlockAlgorithm.reset();
         */
        reset: function () {
            // Initial values
            this._data = new WordArray.init();
            this._nDataBytes = 0;
        },

        /**
         * Adds new data to this block algorithm's buffer.
         *
         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
         *
         * @example
         *
         *     bufferedBlockAlgorithm._append('data');
         *     bufferedBlockAlgorithm._append(wordArray);
         */
        _append: function (data) {
            // Convert string to WordArray, else assume WordArray already
            if (typeof data == 'string') {
                data = Utf8.parse(data);
            }

            // Append
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
        },

        /**
         * Processes available data blocks.
         *
         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
         *
         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
         *
         * @return {WordArray} The processed data.
         *
         * @example
         *
         *     var processedData = bufferedBlockAlgorithm._process();
         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
         */
        _process: function (doFlush) {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;

            // Count blocks ready
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
                // Round up to include partial blocks
                nBlocksReady = Math.ceil(nBlocksReady);
            } else {
                // Round down to include only full blocks,
                // less the number of blocks that must remain in the buffer
                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }

            // Count words ready
            var nWordsReady = nBlocksReady * blockSize;

            // Count bytes ready
            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

            // Process blocks
            if (nWordsReady) {
                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                    // Perform concrete-algorithm logic
                    this._doProcessBlock(dataWords, offset);
                }

                // Remove processed words
                var processedWords = dataWords.splice(0, nWordsReady);
                data.sigBytes -= nBytesReady;
            }

            // Return processed words
            return new WordArray.init(processedWords, nBytesReady);
        },

        /**
         * Creates a copy of this object.
         *
         * @return {Object} The clone.
         *
         * @example
         *
         *     var clone = bufferedBlockAlgorithm.clone();
         */
        clone: function () {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();

            return clone;
        },

        _minBufferSize: 0
    });

    /**
     * Abstract hasher template.
     *
     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
     */
    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
        /**
         * Configuration options.
         */
        cfg: Base.extend(),

        /**
         * Initializes a newly created hasher.
         *
         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
         *
         * @example
         *
         *     var hasher = CryptoJS.algo.SHA256.create();
         */
        init: function (cfg) {
            // Apply config defaults
            this.cfg = this.cfg.extend(cfg);

            // Set initial values
            this.reset();
        },

        /**
         * Resets this hasher to its initial state.
         *
         * @example
         *
         *     hasher.reset();
         */
        reset: function () {
            // Reset data buffer
            BufferedBlockAlgorithm.reset.call(this);

            // Perform concrete-hasher logic
            this._doReset();
        },

        /**
         * Updates this hasher with a message.
         *
         * @param {WordArray|string} messageUpdate The message to append.
         *
         * @return {Hasher} This hasher.
         *
         * @example
         *
         *     hasher.update('message');
         *     hasher.update(wordArray);
         */
        update: function (messageUpdate) {
            // Append
            this._append(messageUpdate);

            // Update the hash
            this._process();

            // Chainable
            return this;
        },

        /**
         * Finalizes the hash computation.
         * Note that the finalize operation is effectively a destructive, read-once operation.
         *
         * @param {WordArray|string} messageUpdate (Optional) A final message update.
         *
         * @return {WordArray} The hash.
         *
         * @example
         *
         *     var hash = hasher.finalize();
         *     var hash = hasher.finalize('message');
         *     var hash = hasher.finalize(wordArray);
         */
        finalize: function (messageUpdate) {
            // Final message update
            if (messageUpdate) {
                this._append(messageUpdate);
            }

            // Perform concrete-hasher logic
            var hash = this._doFinalize();

            return hash;
        },

        blockSize: 512/32,

        /**
         * Creates a shortcut function to a hasher's object interface.
         *
         * @param {Hasher} hasher The hasher to create a helper for.
         *
         * @return {Function} The shortcut function.
         *
         * @static
         *
         * @example
         *
         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
         */
        _createHelper: function (hasher) {
            return function (message, cfg) {
                return new hasher.init(cfg).finalize(message);
            };
        },

        /**
         * Creates a shortcut function to the HMAC's object interface.
         *
         * @param {Hasher} hasher The hasher to use in this HMAC helper.
         *
         * @return {Function} The shortcut function.
         *
         * @static
         *
         * @example
         *
         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
         */
        _createHmacHelper: function (hasher) {
            return function (message, key) {
                return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
        }
    });

    /**
     * Algorithm namespace.
     */
    var C_algo = C.algo = {};

    return C;
}(Math));

exports.CryptoJS = CryptoJS;

},{}],24:[function(require,module,exports){
var CryptoJS = require('./core').CryptoJS;

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var C_enc = C.enc;

    /**
     * Base64 encoding strategy.
     */
    var Base64 = C_enc.Base64 = {
        /**
         * Converts a word array to a Base64 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The Base64 string.
         *
         * @static
         *
         * @example
         *
         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;

            // Clamp excess bits
            wordArray.clamp();

            // Convert
            var base64Chars = [];
            for (var i = 0; i < sigBytes; i += 3) {
                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
                }
            }

            // Add padding
            var paddingChar = map.charAt(64);
            if (paddingChar) {
                while (base64Chars.length % 4) {
                    base64Chars.push(paddingChar);
                }
            }

            return base64Chars.join('');
        },

        /**
         * Converts a Base64 string to a word array.
         *
         * @param {string} base64Str The Base64 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
         */
        parse: function (base64Str) {
            // Shortcuts
            var base64StrLength = base64Str.length;
            var map = this._map;

            // Ignore padding
            var paddingChar = map.charAt(64);
            if (paddingChar) {
                var paddingIndex = base64Str.indexOf(paddingChar);
                if (paddingIndex != -1) {
                    base64StrLength = paddingIndex;
                }
            }

            // Convert
            var words = [];
            var nBytes = 0;
            for (var i = 0; i < base64StrLength; i++) {
                if (i % 4) {
                    var bits1 = map.indexOf(base64Str.charAt(i - 1)) << ((i % 4) * 2);
                    var bits2 = map.indexOf(base64Str.charAt(i)) >>> (6 - (i % 4) * 2);
                    words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);
                    nBytes++;
                }
            }

            return WordArray.create(words, nBytes);
        },

        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
    };
}());

},{"./core":23}],25:[function(require,module,exports){
var CryptoJS = require('./core').CryptoJS;

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var Base = C_lib.Base;
    var WordArray = C_lib.WordArray;
    var C_algo = C.algo;
    var MD5 = C_algo.MD5;

    /**
     * This key derivation function is meant to conform with EVP_BytesToKey.
     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
     */
    var EvpKDF = C_algo.EvpKDF = Base.extend({
        /**
         * Configuration options.
         *
         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
         * @property {number} iterations The number of iterations to perform. Default: 1
         */
        cfg: Base.extend({
            keySize: 128/32,
            hasher: MD5,
            iterations: 1
        }),

        /**
         * Initializes a newly created key derivation function.
         *
         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
         *
         * @example
         *
         *     var kdf = CryptoJS.algo.EvpKDF.create();
         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
         */
        init: function (cfg) {
            this.cfg = this.cfg.extend(cfg);
        },

        /**
         * Derives a key from a password.
         *
         * @param {WordArray|string} password The password.
         * @param {WordArray|string} salt A salt.
         *
         * @return {WordArray} The derived key.
         *
         * @example
         *
         *     var key = kdf.compute(password, salt);
         */
        compute: function (password, salt) {
            // Shortcut
            var cfg = this.cfg;

            // Init hasher
            var hasher = cfg.hasher.create();

            // Initial values
            var derivedKey = WordArray.create();

            // Shortcuts
            var derivedKeyWords = derivedKey.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;

            // Generate key
            while (derivedKeyWords.length < keySize) {
                if (block) {
                    hasher.update(block);
                }
                var block = hasher.update(password).finalize(salt);
                hasher.reset();

                // Iterations
                for (var i = 1; i < iterations; i++) {
                    block = hasher.finalize(block);
                    hasher.reset();
                }

                derivedKey.concat(block);
            }
            derivedKey.sigBytes = keySize * 4;

            return derivedKey;
        }
    });

    /**
     * Derives a key from a password.
     *
     * @param {WordArray|string} password The password.
     * @param {WordArray|string} salt A salt.
     * @param {Object} cfg (Optional) The configuration options to use for this computation.
     *
     * @return {WordArray} The derived key.
     *
     * @static
     *
     * @example
     *
     *     var key = CryptoJS.EvpKDF(password, salt);
     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
     */
    C.EvpKDF = function (password, salt, cfg) {
        return EvpKDF.create(cfg).compute(password, salt);
    };
}());

},{"./core":23}],26:[function(require,module,exports){
var CryptoJS = require('./core').CryptoJS;

// create custom json serialization format
var JsonFormatter = {
	stringify: function (cipherParams) {
		// create json object with ciphertext
		var jsonObj = {
			ct: cipherParams.ciphertext.toString(CryptoJS.enc.Base64)
		};
		
		// optionally add iv and salt
		if (cipherParams.iv) {
			jsonObj.iv = cipherParams.iv.toString();
		}
		
		if (cipherParams.salt) {
			jsonObj.s = cipherParams.salt.toString();
		}

		// stringify json object
		return JSON.stringify(jsonObj)
	},

	parse: function (jsonStr) {
		// parse json string
		var jsonObj = JSON.parse(jsonStr);
		
		// extract ciphertext from json object, and create cipher params object
		var cipherParams = CryptoJS.lib.CipherParams.create({
			ciphertext: CryptoJS.enc.Base64.parse(jsonObj.ct)
		});
		
		// optionally extract iv and salt
		if (jsonObj.iv) {
			cipherParams.iv = CryptoJS.enc.Hex.parse(jsonObj.iv);
		}
            
		if (jsonObj.s) {
			cipherParams.salt = CryptoJS.enc.Hex.parse(jsonObj.s);
		}
		
		return cipherParams;
	}
};

exports.JsonFormatter = JsonFormatter;
},{"./core":23}],27:[function(require,module,exports){
var CryptoJS = require('./core').CryptoJS;

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function (Math) {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var Hasher = C_lib.Hasher;
    var C_algo = C.algo;

    // Constants table
    var T = [];

    // Compute constants
    (function () {
        for (var i = 0; i < 64; i++) {
            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
        }
    }());

    /**
     * MD5 hash algorithm.
     */
    var MD5 = C_algo.MD5 = Hasher.extend({
        _doReset: function () {
            this._hash = new WordArray.init([
                0x67452301, 0xefcdab89,
                0x98badcfe, 0x10325476
            ]);
        },

        _doProcessBlock: function (M, offset) {
            // Swap endian
            for (var i = 0; i < 16; i++) {
                // Shortcuts
                var offset_i = offset + i;
                var M_offset_i = M[offset_i];

                M[offset_i] = (
                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
                );
            }

            // Shortcuts
            var H = this._hash.words;

            var M_offset_0  = M[offset + 0];
            var M_offset_1  = M[offset + 1];
            var M_offset_2  = M[offset + 2];
            var M_offset_3  = M[offset + 3];
            var M_offset_4  = M[offset + 4];
            var M_offset_5  = M[offset + 5];
            var M_offset_6  = M[offset + 6];
            var M_offset_7  = M[offset + 7];
            var M_offset_8  = M[offset + 8];
            var M_offset_9  = M[offset + 9];
            var M_offset_10 = M[offset + 10];
            var M_offset_11 = M[offset + 11];
            var M_offset_12 = M[offset + 12];
            var M_offset_13 = M[offset + 13];
            var M_offset_14 = M[offset + 14];
            var M_offset_15 = M[offset + 15];

            // Working varialbes
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];

            // Computation
            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
            d = II(d, a, b, c, M_offset_7,  10, T[49]);
            c = II(c, d, a, b, M_offset_14, 15, T[50]);
            b = II(b, c, d, a, M_offset_5,  21, T[51]);
            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
            d = II(d, a, b, c, M_offset_3,  10, T[53]);
            c = II(c, d, a, b, M_offset_10, 15, T[54]);
            b = II(b, c, d, a, M_offset_1,  21, T[55]);
            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
            d = II(d, a, b, c, M_offset_15, 10, T[57]);
            c = II(c, d, a, b, M_offset_6,  15, T[58]);
            b = II(b, c, d, a, M_offset_13, 21, T[59]);
            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
            d = II(d, a, b, c, M_offset_11, 10, T[61]);
            c = II(c, d, a, b, M_offset_2,  15, T[62]);
            b = II(b, c, d, a, M_offset_9,  21, T[63]);

            // Intermediate hash value
            H[0] = (H[0] + a) | 0;
            H[1] = (H[1] + b) | 0;
            H[2] = (H[2] + c) | 0;
            H[3] = (H[3] + d) | 0;
        },

        _doFinalize: function () {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;

            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;

            // Add padding
            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
            var nBitsTotalL = nBitsTotal;
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
            );
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
            );

            data.sigBytes = (dataWords.length + 1) * 4;

            // Hash final blocks
            this._process();

            // Shortcuts
            var hash = this._hash;
            var H = hash.words;

            // Swap endian
            for (var i = 0; i < 4; i++) {
                // Shortcut
                var H_i = H[i];

                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
            }

            // Return final computed hash
            return hash;
        },

        clone: function () {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();

            return clone;
        }
    });

    function FF(a, b, c, d, x, s, t) {
        var n = a + ((b & c) | (~b & d)) + x + t;
        return ((n << s) | (n >>> (32 - s))) + b;
    }

    function GG(a, b, c, d, x, s, t) {
        var n = a + ((b & d) | (c & ~d)) + x + t;
        return ((n << s) | (n >>> (32 - s))) + b;
    }

    function HH(a, b, c, d, x, s, t) {
        var n = a + (b ^ c ^ d) + x + t;
        return ((n << s) | (n >>> (32 - s))) + b;
    }

    function II(a, b, c, d, x, s, t) {
        var n = a + (c ^ (b | ~d)) + x + t;
        return ((n << s) | (n >>> (32 - s))) + b;
    }

    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.MD5('message');
     *     var hash = CryptoJS.MD5(wordArray);
     */
    C.MD5 = Hasher._createHelper(MD5);

    /**
     * Shortcut function to the HMAC's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     * @param {WordArray|string} key The secret key.
     *
     * @return {WordArray} The HMAC.
     *
     * @static
     *
     * @example
     *
     *     var hmac = CryptoJS.HmacMD5(message, key);
     */
    C.HmacMD5 = Hasher._createHmacHelper(MD5);
}(Math));

},{"./core":23}],28:[function(require,module,exports){
/*!
  * Reqwest! A general purpose XHR connection manager
  * license MIT (c) Dustin Diaz 2014
  * https://github.com/ded/reqwest
  */

!function (name, context, definition) {
  if (typeof module != 'undefined' && module.exports) module.exports = definition()
  else if (typeof define == 'function' && define.amd) define(definition)
  else context[name] = definition()
}('reqwest', this, function () {

  var win = window
    , doc = document
    , httpsRe = /^http/
    , protocolRe = /(^\w+):\/\//
    , twoHundo = /^(20\d|1223)$/ //http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
    , byTag = 'getElementsByTagName'
    , readyState = 'readyState'
    , contentType = 'Content-Type'
    , requestedWith = 'X-Requested-With'
    , head = doc[byTag]('head')[0]
    , uniqid = 0
    , callbackPrefix = 'reqwest_' + (+new Date())
    , lastValue // data stored by the most recent JSONP callback
    , xmlHttpRequest = 'XMLHttpRequest'
    , xDomainRequest = 'XDomainRequest'
    , noop = function () {}

    , isArray = typeof Array.isArray == 'function'
        ? Array.isArray
        : function (a) {
            return a instanceof Array
          }

    , defaultHeaders = {
          'contentType': 'application/x-www-form-urlencoded'
        , 'requestedWith': xmlHttpRequest
        , 'accept': {
              '*':  'text/javascript, text/html, application/xml, text/xml, */*'
            , 'xml':  'application/xml, text/xml'
            , 'html': 'text/html'
            , 'text': 'text/plain'
            , 'json': 'application/json, text/javascript'
            , 'js':   'application/javascript, text/javascript'
          }
      }

    , xhr = function(o) {
        // is it x-domain
        if (o['crossOrigin'] === true) {
          var xhr = win[xmlHttpRequest] ? new XMLHttpRequest() : null
          if (xhr && 'withCredentials' in xhr) {
            return xhr
          } else if (win[xDomainRequest]) {
            return new XDomainRequest()
          } else {
            throw new Error('Browser does not support cross-origin requests')
          }
        } else if (win[xmlHttpRequest]) {
          return new XMLHttpRequest()
        } else {
          return new ActiveXObject('Microsoft.XMLHTTP')
        }
      }
    , globalSetupOptions = {
        dataFilter: function (data) {
          return data
        }
      }

  function succeed(r) {
    var protocol = protocolRe.exec(r.url);
    protocol = (protocol && protocol[1]) || window.location.protocol;
    return httpsRe.test(protocol) ? twoHundo.test(r.request.status) : !!r.request.response;
  }

  function handleReadyState(r, success, error) {
    return function () {
      // use _aborted to mitigate against IE err c00c023f
      // (can't read props on aborted request objects)
      if (r._aborted) return error(r.request)
      if (r._timedOut) return error(r.request, 'Request is aborted: timeout')
      if (r.request && r.request[readyState] == 4) {
        r.request.onreadystatechange = noop
        if (succeed(r)) success(r.request)
        else
          error(r.request)
      }
    }
  }

  function setHeaders(http, o) {
    var headers = o['headers'] || {}
      , h

    headers['Accept'] = headers['Accept']
      || defaultHeaders['accept'][o['type']]
      || defaultHeaders['accept']['*']

    var isAFormData = typeof FormData === 'function' && (o['data'] instanceof FormData);
    // breaks cross-origin requests with legacy browsers
    if (!o['crossOrigin'] && !headers[requestedWith]) headers[requestedWith] = defaultHeaders['requestedWith']
    if (!headers[contentType] && !isAFormData) headers[contentType] = o['contentType'] || defaultHeaders['contentType']
    for (h in headers)
      headers.hasOwnProperty(h) && 'setRequestHeader' in http && http.setRequestHeader(h, headers[h])
  }

  function setCredentials(http, o) {
    if (typeof o['withCredentials'] !== 'undefined' && typeof http.withCredentials !== 'undefined') {
      http.withCredentials = !!o['withCredentials']
    }
  }

  function generalCallback(data) {
    lastValue = data
  }

  function urlappend (url, s) {
    return url + (/\?/.test(url) ? '&' : '?') + s
  }

  function handleJsonp(o, fn, err, url) {
    var reqId = uniqid++
      , cbkey = o['jsonpCallback'] || 'callback' // the 'callback' key
      , cbval = o['jsonpCallbackName'] || reqwest.getcallbackPrefix(reqId)
      , cbreg = new RegExp('((^|\\?|&)' + cbkey + ')=([^&]+)')
      , match = url.match(cbreg)
      , script = doc.createElement('script')
      , loaded = 0
      , isIE10 = navigator.userAgent.indexOf('MSIE 10.0') !== -1

    if (match) {
      if (match[3] === '?') {
        url = url.replace(cbreg, '$1=' + cbval) // wildcard callback func name
      } else {
        cbval = match[3] // provided callback func name
      }
    } else {
      url = urlappend(url, cbkey + '=' + cbval) // no callback details, add 'em
    }

    win[cbval] = generalCallback

    script.type = 'text/javascript'
    script.src = url
    script.async = true
    if (typeof script.onreadystatechange !== 'undefined' && !isIE10) {
      // need this for IE due to out-of-order onreadystatechange(), binding script
      // execution to an event listener gives us control over when the script
      // is executed. See http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
      script.htmlFor = script.id = '_reqwest_' + reqId
    }

    script.onload = script.onreadystatechange = function () {
      if ((script[readyState] && script[readyState] !== 'complete' && script[readyState] !== 'loaded') || loaded) {
        return false
      }
      script.onload = script.onreadystatechange = null
      script.onclick && script.onclick()
      // Call the user callback with the last value stored and clean up values and scripts.
      fn(lastValue)
      lastValue = undefined
      head.removeChild(script)
      loaded = 1
    }

    // Add the script to the DOM head
    head.appendChild(script)

    // Enable JSONP timeout
    return {
      abort: function () {
        script.onload = script.onreadystatechange = null
        err({}, 'Request is aborted: timeout', {})
        lastValue = undefined
        head.removeChild(script)
        loaded = 1
      }
    }
  }

  function getRequest(fn, err) {
    var o = this.o
      , method = (o['method'] || 'GET').toUpperCase()
      , url = typeof o === 'string' ? o : o['url']
      // convert non-string objects to query-string form unless o['processData'] is false
      , data = (o['processData'] !== false && o['data'] && typeof o['data'] !== 'string')
        ? reqwest.toQueryString(o['data'])
        : (o['data'] || null)
      , http
      , sendWait = false

    // if we're working on a GET request and we have data then we should append
    // query string to end of URL and not post data
    if ((o['type'] == 'jsonp' || method == 'GET') && data) {
      url = urlappend(url, data)
      data = null
    }

    if (o['type'] == 'jsonp') return handleJsonp(o, fn, err, url)

    // get the xhr from the factory if passed
    // if the factory returns null, fall-back to ours
    http = (o.xhr && o.xhr(o)) || xhr(o)

    http.open(method, url, o['async'] === false ? false : true)
    setHeaders(http, o)
    setCredentials(http, o)
    if (win[xDomainRequest] && http instanceof win[xDomainRequest]) {
        http.onload = fn
        http.onerror = err
        // NOTE: see
        // http://social.msdn.microsoft.com/Forums/en-US/iewebdevelopment/thread/30ef3add-767c-4436-b8a9-f1ca19b4812e
        http.onprogress = function() {}
        sendWait = true
    } else {
      http.onreadystatechange = handleReadyState(this, fn, err)
    }
    o['before'] && o['before'](http)
    if (sendWait) {
      setTimeout(function () {
        http.send(data)
      }, 200)
    } else {
      http.send(data)
    }
    return http
  }

  function Reqwest(o, fn) {
    this.o = o
    this.fn = fn

    init.apply(this, arguments)
  }

  function setType(header) {
    // json, javascript, text/plain, text/html, xml
    if (header.match('json')) return 'json'
    if (header.match('javascript')) return 'js'
    if (header.match('text')) return 'html'
    if (header.match('xml')) return 'xml'
  }

  function init(o, fn) {

    this.url = typeof o == 'string' ? o : o['url']
    this.timeout = null

    // whether request has been fulfilled for purpose
    // of tracking the Promises
    this._fulfilled = false
    // success handlers
    this._successHandler = function(){}
    this._fulfillmentHandlers = []
    // error handlers
    this._errorHandlers = []
    // complete (both success and fail) handlers
    this._completeHandlers = []
    this._erred = false
    this._responseArgs = {}

    var self = this

    fn = fn || function () {}

    if (o['timeout']) {
      this.timeout = setTimeout(function () {
        timedOut()
      }, o['timeout'])
    }

    if (o['success']) {
      this._successHandler = function () {
        o['success'].apply(o, arguments)
      }
    }

    if (o['error']) {
      this._errorHandlers.push(function () {
        o['error'].apply(o, arguments)
      })
    }

    if (o['complete']) {
      this._completeHandlers.push(function () {
        o['complete'].apply(o, arguments)
      })
    }

    function complete (resp) {
      o['timeout'] && clearTimeout(self.timeout)
      self.timeout = null
      while (self._completeHandlers.length > 0) {
        self._completeHandlers.shift()(resp)
      }
    }

    function success (resp) {
      var type = o['type'] || resp && setType(resp.getResponseHeader('Content-Type')) // resp can be undefined in IE
      resp = (type !== 'jsonp') ? self.request : resp
      // use global data filter on response text
      var filteredResponse = globalSetupOptions.dataFilter(resp.responseText, type)
        , r = filteredResponse
      try {
        resp.responseText = r
      } catch (e) {
        // can't assign this in IE<=8, just ignore
      }
      if (r) {
        switch (type) {
        case 'json':
          try {
            resp = win.JSON ? win.JSON.parse(r) : eval('(' + r + ')')
          } catch (err) {
            return error(resp, 'Could not parse JSON in response', err)
          }
          break
        case 'js':
          resp = eval(r)
          break
        case 'html':
          resp = r
          break
        case 'xml':
          resp = resp.responseXML
              && resp.responseXML.parseError // IE trololo
              && resp.responseXML.parseError.errorCode
              && resp.responseXML.parseError.reason
            ? null
            : resp.responseXML
          break
        }
      }

      self._responseArgs.resp = resp
      self._fulfilled = true
      fn(resp)
      self._successHandler(resp)
      while (self._fulfillmentHandlers.length > 0) {
        resp = self._fulfillmentHandlers.shift()(resp)
      }

      complete(resp)
    }

    function timedOut() {
      self._timedOut = true
      self.request.abort()      
    }

    function error(resp, msg, t) {
      resp = self.request
      self._responseArgs.resp = resp
      self._responseArgs.msg = msg
      self._responseArgs.t = t
      self._erred = true
      while (self._errorHandlers.length > 0) {
        self._errorHandlers.shift()(resp, msg, t)
      }
      complete(resp)
    }

    this.request = getRequest.call(this, success, error)
  }

  Reqwest.prototype = {
    abort: function () {
      this._aborted = true
      this.request.abort()
    }

  , retry: function () {
      init.call(this, this.o, this.fn)
    }

    /**
     * Small deviation from the Promises A CommonJs specification
     * http://wiki.commonjs.org/wiki/Promises/A
     */

    /**
     * `then` will execute upon successful requests
     */
  , then: function (success, fail) {
      success = success || function () {}
      fail = fail || function () {}
      if (this._fulfilled) {
        this._responseArgs.resp = success(this._responseArgs.resp)
      } else if (this._erred) {
        fail(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t)
      } else {
        this._fulfillmentHandlers.push(success)
        this._errorHandlers.push(fail)
      }
      return this
    }

    /**
     * `always` will execute whether the request succeeds or fails
     */
  , always: function (fn) {
      if (this._fulfilled || this._erred) {
        fn(this._responseArgs.resp)
      } else {
        this._completeHandlers.push(fn)
      }
      return this
    }

    /**
     * `fail` will execute when the request fails
     */
  , fail: function (fn) {
      if (this._erred) {
        fn(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t)
      } else {
        this._errorHandlers.push(fn)
      }
      return this
    }
  , 'catch': function (fn) {
      return this.fail(fn)
    }
  }

  function reqwest(o, fn) {
    return new Reqwest(o, fn)
  }

  // normalize newline variants according to spec -> CRLF
  function normalize(s) {
    return s ? s.replace(/\r?\n/g, '\r\n') : ''
  }

  function serial(el, cb) {
    var n = el.name
      , t = el.tagName.toLowerCase()
      , optCb = function (o) {
          // IE gives value="" even where there is no value attribute
          // 'specified' ref: http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-862529273
          if (o && !o['disabled'])
            cb(n, normalize(o['attributes']['value'] && o['attributes']['value']['specified'] ? o['value'] : o['text']))
        }
      , ch, ra, val, i

    // don't serialize elements that are disabled or without a name
    if (el.disabled || !n) return

    switch (t) {
    case 'input':
      if (!/reset|button|image|file/i.test(el.type)) {
        ch = /checkbox/i.test(el.type)
        ra = /radio/i.test(el.type)
        val = el.value
        // WebKit gives us "" instead of "on" if a checkbox has no value, so correct it here
        ;(!(ch || ra) || el.checked) && cb(n, normalize(ch && val === '' ? 'on' : val))
      }
      break
    case 'textarea':
      cb(n, normalize(el.value))
      break
    case 'select':
      if (el.type.toLowerCase() === 'select-one') {
        optCb(el.selectedIndex >= 0 ? el.options[el.selectedIndex] : null)
      } else {
        for (i = 0; el.length && i < el.length; i++) {
          el.options[i].selected && optCb(el.options[i])
        }
      }
      break
    }
  }

  // collect up all form elements found from the passed argument elements all
  // the way down to child elements; pass a '<form>' or form fields.
  // called with 'this'=callback to use for serial() on each element
  function eachFormElement() {
    var cb = this
      , e, i
      , serializeSubtags = function (e, tags) {
          var i, j, fa
          for (i = 0; i < tags.length; i++) {
            fa = e[byTag](tags[i])
            for (j = 0; j < fa.length; j++) serial(fa[j], cb)
          }
        }

    for (i = 0; i < arguments.length; i++) {
      e = arguments[i]
      if (/input|select|textarea/i.test(e.tagName)) serial(e, cb)
      serializeSubtags(e, [ 'input', 'select', 'textarea' ])
    }
  }

  // standard query string style serialization
  function serializeQueryString() {
    return reqwest.toQueryString(reqwest.serializeArray.apply(null, arguments))
  }

  // { 'name': 'value', ... } style serialization
  function serializeHash() {
    var hash = {}
    eachFormElement.apply(function (name, value) {
      if (name in hash) {
        hash[name] && !isArray(hash[name]) && (hash[name] = [hash[name]])
        hash[name].push(value)
      } else hash[name] = value
    }, arguments)
    return hash
  }

  // [ { name: 'name', value: 'value' }, ... ] style serialization
  reqwest.serializeArray = function () {
    var arr = []
    eachFormElement.apply(function (name, value) {
      arr.push({name: name, value: value})
    }, arguments)
    return arr
  }

  reqwest.serialize = function () {
    if (arguments.length === 0) return ''
    var opt, fn
      , args = Array.prototype.slice.call(arguments, 0)

    opt = args.pop()
    opt && opt.nodeType && args.push(opt) && (opt = null)
    opt && (opt = opt.type)

    if (opt == 'map') fn = serializeHash
    else if (opt == 'array') fn = reqwest.serializeArray
    else fn = serializeQueryString

    return fn.apply(null, args)
  }

  reqwest.toQueryString = function (o, trad) {
    var prefix, i
      , traditional = trad || false
      , s = []
      , enc = encodeURIComponent
      , add = function (key, value) {
          // If value is a function, invoke it and return its value
          value = ('function' === typeof value) ? value() : (value == null ? '' : value)
          s[s.length] = enc(key) + '=' + enc(value)
        }
    // If an array was passed in, assume that it is an array of form elements.
    if (isArray(o)) {
      for (i = 0; o && i < o.length; i++) add(o[i]['name'], o[i]['value'])
    } else {
      // If traditional, encode the "old" way (the way 1.3.2 or older
      // did it), otherwise encode params recursively.
      for (prefix in o) {
        if (o.hasOwnProperty(prefix)) buildParams(prefix, o[prefix], traditional, add)
      }
    }

    // spaces should be + according to spec
    return s.join('&').replace(/%20/g, '+')
  }

  function buildParams(prefix, obj, traditional, add) {
    var name, i, v
      , rbracket = /\[\]$/

    if (isArray(obj)) {
      // Serialize array item.
      for (i = 0; obj && i < obj.length; i++) {
        v = obj[i]
        if (traditional || rbracket.test(prefix)) {
          // Treat each array item as a scalar.
          add(prefix, v)
        } else {
          buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add)
        }
      }
    } else if (obj && obj.toString() === '[object Object]') {
      // Serialize object item.
      for (name in obj) {
        buildParams(prefix + '[' + name + ']', obj[name], traditional, add)
      }

    } else {
      // Serialize scalar item.
      add(prefix, obj)
    }
  }

  reqwest.getcallbackPrefix = function () {
    return callbackPrefix
  }

  // jQuery and Zepto compatibility, differences can be remapped here so you can call
  // .ajax.compat(options, callback)
  reqwest.compat = function (o, fn) {
    if (o) {
      o['type'] && (o['method'] = o['type']) && delete o['type']
      o['dataType'] && (o['type'] = o['dataType'])
      o['jsonpCallback'] && (o['jsonpCallbackName'] = o['jsonpCallback']) && delete o['jsonpCallback']
      o['jsonp'] && (o['jsonpCallback'] = o['jsonp'])
    }
    return new Reqwest(o, fn)
  }

  reqwest.ajaxSetup = function (options) {
    options = options || {}
    for (var k in options) {
      globalSetupOptions[k] = options[k]
    }
  }

  return reqwest
});

},{}],29:[function(require,module,exports){
(function (process){
/*!
 * @overview RSVP - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/tildeio/rsvp.js/master/LICENSE
 * @version   3.0.18
 */

(function() {
    "use strict";
    function lib$rsvp$utils$$objectOrFunction(x) {
      return typeof x === 'function' || (typeof x === 'object' && x !== null);
    }

    function lib$rsvp$utils$$isFunction(x) {
      return typeof x === 'function';
    }

    function lib$rsvp$utils$$isMaybeThenable(x) {
      return typeof x === 'object' && x !== null;
    }

    var lib$rsvp$utils$$_isArray;
    if (!Array.isArray) {
      lib$rsvp$utils$$_isArray = function (x) {
        return Object.prototype.toString.call(x) === '[object Array]';
      };
    } else {
      lib$rsvp$utils$$_isArray = Array.isArray;
    }

    var lib$rsvp$utils$$isArray = lib$rsvp$utils$$_isArray;

    var lib$rsvp$utils$$now = Date.now || function() { return new Date().getTime(); };

    function lib$rsvp$utils$$F() { }

    var lib$rsvp$utils$$o_create = (Object.create || function (o) {
      if (arguments.length > 1) {
        throw new Error('Second argument not supported');
      }
      if (typeof o !== 'object') {
        throw new TypeError('Argument must be an object');
      }
      lib$rsvp$utils$$F.prototype = o;
      return new lib$rsvp$utils$$F();
    });
    function lib$rsvp$events$$indexOf(callbacks, callback) {
      for (var i=0, l=callbacks.length; i<l; i++) {
        if (callbacks[i] === callback) { return i; }
      }

      return -1;
    }

    function lib$rsvp$events$$callbacksFor(object) {
      var callbacks = object._promiseCallbacks;

      if (!callbacks) {
        callbacks = object._promiseCallbacks = {};
      }

      return callbacks;
    }

    var lib$rsvp$events$$default = {

      /**
        `RSVP.EventTarget.mixin` extends an object with EventTarget methods. For
        Example:

        ```javascript
        var object = {};

        RSVP.EventTarget.mixin(object);

        object.on('finished', function(event) {
          // handle event
        });

        object.trigger('finished', { detail: value });
        ```

        `EventTarget.mixin` also works with prototypes:

        ```javascript
        var Person = function() {};
        RSVP.EventTarget.mixin(Person.prototype);

        var yehuda = new Person();
        var tom = new Person();

        yehuda.on('poke', function(event) {
          console.log('Yehuda says OW');
        });

        tom.on('poke', function(event) {
          console.log('Tom says OW');
        });

        yehuda.trigger('poke');
        tom.trigger('poke');
        ```

        @method mixin
        @for RSVP.EventTarget
        @private
        @param {Object} object object to extend with EventTarget methods
      */
      'mixin': function(object) {
        object['on']      = this['on'];
        object['off']     = this['off'];
        object['trigger'] = this['trigger'];
        object._promiseCallbacks = undefined;
        return object;
      },

      /**
        Registers a callback to be executed when `eventName` is triggered

        ```javascript
        object.on('event', function(eventInfo){
          // handle the event
        });

        object.trigger('event');
        ```

        @method on
        @for RSVP.EventTarget
        @private
        @param {String} eventName name of the event to listen for
        @param {Function} callback function to be called when the event is triggered.
      */
      'on': function(eventName, callback) {
        var allCallbacks = lib$rsvp$events$$callbacksFor(this), callbacks;

        callbacks = allCallbacks[eventName];

        if (!callbacks) {
          callbacks = allCallbacks[eventName] = [];
        }

        if (lib$rsvp$events$$indexOf(callbacks, callback) === -1) {
          callbacks.push(callback);
        }
      },

      /**
        You can use `off` to stop firing a particular callback for an event:

        ```javascript
        function doStuff() { // do stuff! }
        object.on('stuff', doStuff);

        object.trigger('stuff'); // doStuff will be called

        // Unregister ONLY the doStuff callback
        object.off('stuff', doStuff);
        object.trigger('stuff'); // doStuff will NOT be called
        ```

        If you don't pass a `callback` argument to `off`, ALL callbacks for the
        event will not be executed when the event fires. For example:

        ```javascript
        var callback1 = function(){};
        var callback2 = function(){};

        object.on('stuff', callback1);
        object.on('stuff', callback2);

        object.trigger('stuff'); // callback1 and callback2 will be executed.

        object.off('stuff');
        object.trigger('stuff'); // callback1 and callback2 will not be executed!
        ```

        @method off
        @for RSVP.EventTarget
        @private
        @param {String} eventName event to stop listening to
        @param {Function} callback optional argument. If given, only the function
        given will be removed from the event's callback queue. If no `callback`
        argument is given, all callbacks will be removed from the event's callback
        queue.
      */
      'off': function(eventName, callback) {
        var allCallbacks = lib$rsvp$events$$callbacksFor(this), callbacks, index;

        if (!callback) {
          allCallbacks[eventName] = [];
          return;
        }

        callbacks = allCallbacks[eventName];

        index = lib$rsvp$events$$indexOf(callbacks, callback);

        if (index !== -1) { callbacks.splice(index, 1); }
      },

      /**
        Use `trigger` to fire custom events. For example:

        ```javascript
        object.on('foo', function(){
          console.log('foo event happened!');
        });
        object.trigger('foo');
        // 'foo event happened!' logged to the console
        ```

        You can also pass a value as a second argument to `trigger` that will be
        passed as an argument to all event listeners for the event:

        ```javascript
        object.on('foo', function(value){
          console.log(value.name);
        });

        object.trigger('foo', { name: 'bar' });
        // 'bar' logged to the console
        ```

        @method trigger
        @for RSVP.EventTarget
        @private
        @param {String} eventName name of the event to be triggered
        @param {Any} options optional value to be passed to any event handlers for
        the given `eventName`
      */
      'trigger': function(eventName, options) {
        var allCallbacks = lib$rsvp$events$$callbacksFor(this), callbacks, callback;

        if (callbacks = allCallbacks[eventName]) {
          // Don't cache the callbacks.length since it may grow
          for (var i=0; i<callbacks.length; i++) {
            callback = callbacks[i];

            callback(options);
          }
        }
      }
    };

    var lib$rsvp$config$$config = {
      instrument: false
    };

    lib$rsvp$events$$default['mixin'](lib$rsvp$config$$config);

    function lib$rsvp$config$$configure(name, value) {
      if (name === 'onerror') {
        // handle for legacy users that expect the actual
        // error to be passed to their function added via
        // `RSVP.configure('onerror', someFunctionHere);`
        lib$rsvp$config$$config['on']('error', value);
        return;
      }

      if (arguments.length === 2) {
        lib$rsvp$config$$config[name] = value;
      } else {
        return lib$rsvp$config$$config[name];
      }
    }

    var lib$rsvp$instrument$$queue = [];

    function lib$rsvp$instrument$$scheduleFlush() {
      setTimeout(function() {
        var entry;
        for (var i = 0; i < lib$rsvp$instrument$$queue.length; i++) {
          entry = lib$rsvp$instrument$$queue[i];

          var payload = entry.payload;

          payload.guid = payload.key + payload.id;
          payload.childGuid = payload.key + payload.childId;
          if (payload.error) {
            payload.stack = payload.error.stack;
          }

          lib$rsvp$config$$config['trigger'](entry.name, entry.payload);
        }
        lib$rsvp$instrument$$queue.length = 0;
      }, 50);
    }

    function lib$rsvp$instrument$$instrument(eventName, promise, child) {
      if (1 === lib$rsvp$instrument$$queue.push({
          name: eventName,
          payload: {
            key: promise._guidKey,
            id:  promise._id,
            eventName: eventName,
            detail: promise._result,
            childId: child && child._id,
            label: promise._label,
            timeStamp: lib$rsvp$utils$$now(),
            error: lib$rsvp$config$$config["instrument-with-stack"] ? new Error(promise._label) : null
          }})) {
            lib$rsvp$instrument$$scheduleFlush();
          }
      }
    var lib$rsvp$instrument$$default = lib$rsvp$instrument$$instrument;

    function  lib$rsvp$$internal$$withOwnPromise() {
      return new TypeError('A promises callback cannot return that same promise.');
    }

    function lib$rsvp$$internal$$noop() {}

    var lib$rsvp$$internal$$PENDING   = void 0;
    var lib$rsvp$$internal$$FULFILLED = 1;
    var lib$rsvp$$internal$$REJECTED  = 2;

    var lib$rsvp$$internal$$GET_THEN_ERROR = new lib$rsvp$$internal$$ErrorObject();

    function lib$rsvp$$internal$$getThen(promise) {
      try {
        return promise.then;
      } catch(error) {
        lib$rsvp$$internal$$GET_THEN_ERROR.error = error;
        return lib$rsvp$$internal$$GET_THEN_ERROR;
      }
    }

    function lib$rsvp$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
      try {
        then.call(value, fulfillmentHandler, rejectionHandler);
      } catch(e) {
        return e;
      }
    }

    function lib$rsvp$$internal$$handleForeignThenable(promise, thenable, then) {
      lib$rsvp$config$$config.async(function(promise) {
        var sealed = false;
        var error = lib$rsvp$$internal$$tryThen(then, thenable, function(value) {
          if (sealed) { return; }
          sealed = true;
          if (thenable !== value) {
            lib$rsvp$$internal$$resolve(promise, value);
          } else {
            lib$rsvp$$internal$$fulfill(promise, value);
          }
        }, function(reason) {
          if (sealed) { return; }
          sealed = true;

          lib$rsvp$$internal$$reject(promise, reason);
        }, 'Settle: ' + (promise._label || ' unknown promise'));

        if (!sealed && error) {
          sealed = true;
          lib$rsvp$$internal$$reject(promise, error);
        }
      }, promise);
    }

    function lib$rsvp$$internal$$handleOwnThenable(promise, thenable) {
      if (thenable._state === lib$rsvp$$internal$$FULFILLED) {
        lib$rsvp$$internal$$fulfill(promise, thenable._result);
      } else if (thenable._state === lib$rsvp$$internal$$REJECTED) {
        thenable._onError = null;
        lib$rsvp$$internal$$reject(promise, thenable._result);
      } else {
        lib$rsvp$$internal$$subscribe(thenable, undefined, function(value) {
          if (thenable !== value) {
            lib$rsvp$$internal$$resolve(promise, value);
          } else {
            lib$rsvp$$internal$$fulfill(promise, value);
          }
        }, function(reason) {
          lib$rsvp$$internal$$reject(promise, reason);
        });
      }
    }

    function lib$rsvp$$internal$$handleMaybeThenable(promise, maybeThenable) {
      if (maybeThenable.constructor === promise.constructor) {
        lib$rsvp$$internal$$handleOwnThenable(promise, maybeThenable);
      } else {
        var then = lib$rsvp$$internal$$getThen(maybeThenable);

        if (then === lib$rsvp$$internal$$GET_THEN_ERROR) {
          lib$rsvp$$internal$$reject(promise, lib$rsvp$$internal$$GET_THEN_ERROR.error);
        } else if (then === undefined) {
          lib$rsvp$$internal$$fulfill(promise, maybeThenable);
        } else if (lib$rsvp$utils$$isFunction(then)) {
          lib$rsvp$$internal$$handleForeignThenable(promise, maybeThenable, then);
        } else {
          lib$rsvp$$internal$$fulfill(promise, maybeThenable);
        }
      }
    }

    function lib$rsvp$$internal$$resolve(promise, value) {
      if (promise === value) {
        lib$rsvp$$internal$$fulfill(promise, value);
      } else if (lib$rsvp$utils$$objectOrFunction(value)) {
        lib$rsvp$$internal$$handleMaybeThenable(promise, value);
      } else {
        lib$rsvp$$internal$$fulfill(promise, value);
      }
    }

    function lib$rsvp$$internal$$publishRejection(promise) {
      if (promise._onError) {
        promise._onError(promise._result);
      }

      lib$rsvp$$internal$$publish(promise);
    }

    function lib$rsvp$$internal$$fulfill(promise, value) {
      if (promise._state !== lib$rsvp$$internal$$PENDING) { return; }

      promise._result = value;
      promise._state = lib$rsvp$$internal$$FULFILLED;

      if (promise._subscribers.length === 0) {
        if (lib$rsvp$config$$config.instrument) {
          lib$rsvp$instrument$$default('fulfilled', promise);
        }
      } else {
        lib$rsvp$config$$config.async(lib$rsvp$$internal$$publish, promise);
      }
    }

    function lib$rsvp$$internal$$reject(promise, reason) {
      if (promise._state !== lib$rsvp$$internal$$PENDING) { return; }
      promise._state = lib$rsvp$$internal$$REJECTED;
      promise._result = reason;
      lib$rsvp$config$$config.async(lib$rsvp$$internal$$publishRejection, promise);
    }

    function lib$rsvp$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
      var subscribers = parent._subscribers;
      var length = subscribers.length;

      parent._onError = null;

      subscribers[length] = child;
      subscribers[length + lib$rsvp$$internal$$FULFILLED] = onFulfillment;
      subscribers[length + lib$rsvp$$internal$$REJECTED]  = onRejection;

      if (length === 0 && parent._state) {
        lib$rsvp$config$$config.async(lib$rsvp$$internal$$publish, parent);
      }
    }

    function lib$rsvp$$internal$$publish(promise) {
      var subscribers = promise._subscribers;
      var settled = promise._state;

      if (lib$rsvp$config$$config.instrument) {
        lib$rsvp$instrument$$default(settled === lib$rsvp$$internal$$FULFILLED ? 'fulfilled' : 'rejected', promise);
      }

      if (subscribers.length === 0) { return; }

      var child, callback, detail = promise._result;

      for (var i = 0; i < subscribers.length; i += 3) {
        child = subscribers[i];
        callback = subscribers[i + settled];

        if (child) {
          lib$rsvp$$internal$$invokeCallback(settled, child, callback, detail);
        } else {
          callback(detail);
        }
      }

      promise._subscribers.length = 0;
    }

    function lib$rsvp$$internal$$ErrorObject() {
      this.error = null;
    }

    var lib$rsvp$$internal$$TRY_CATCH_ERROR = new lib$rsvp$$internal$$ErrorObject();

    function lib$rsvp$$internal$$tryCatch(callback, detail) {
      try {
        return callback(detail);
      } catch(e) {
        lib$rsvp$$internal$$TRY_CATCH_ERROR.error = e;
        return lib$rsvp$$internal$$TRY_CATCH_ERROR;
      }
    }

    function lib$rsvp$$internal$$invokeCallback(settled, promise, callback, detail) {
      var hasCallback = lib$rsvp$utils$$isFunction(callback),
          value, error, succeeded, failed;

      if (hasCallback) {
        value = lib$rsvp$$internal$$tryCatch(callback, detail);

        if (value === lib$rsvp$$internal$$TRY_CATCH_ERROR) {
          failed = true;
          error = value.error;
          value = null;
        } else {
          succeeded = true;
        }

        if (promise === value) {
          lib$rsvp$$internal$$reject(promise, lib$rsvp$$internal$$withOwnPromise());
          return;
        }

      } else {
        value = detail;
        succeeded = true;
      }

      if (promise._state !== lib$rsvp$$internal$$PENDING) {
        // noop
      } else if (hasCallback && succeeded) {
        lib$rsvp$$internal$$resolve(promise, value);
      } else if (failed) {
        lib$rsvp$$internal$$reject(promise, error);
      } else if (settled === lib$rsvp$$internal$$FULFILLED) {
        lib$rsvp$$internal$$fulfill(promise, value);
      } else if (settled === lib$rsvp$$internal$$REJECTED) {
        lib$rsvp$$internal$$reject(promise, value);
      }
    }

    function lib$rsvp$$internal$$initializePromise(promise, resolver) {
      var resolved = false;
      try {
        resolver(function resolvePromise(value){
          if (resolved) { return; }
          resolved = true;
          lib$rsvp$$internal$$resolve(promise, value);
        }, function rejectPromise(reason) {
          if (resolved) { return; }
          resolved = true;
          lib$rsvp$$internal$$reject(promise, reason);
        });
      } catch(e) {
        lib$rsvp$$internal$$reject(promise, e);
      }
    }

    function lib$rsvp$enumerator$$makeSettledResult(state, position, value) {
      if (state === lib$rsvp$$internal$$FULFILLED) {
        return {
          state: 'fulfilled',
          value: value
        };
      } else {
        return {
          state: 'rejected',
          reason: value
        };
      }
    }

    function lib$rsvp$enumerator$$Enumerator(Constructor, input, abortOnReject, label) {
      this._instanceConstructor = Constructor;
      this.promise = new Constructor(lib$rsvp$$internal$$noop, label);
      this._abortOnReject = abortOnReject;

      if (this._validateInput(input)) {
        this._input     = input;
        this.length     = input.length;
        this._remaining = input.length;

        this._init();

        if (this.length === 0) {
          lib$rsvp$$internal$$fulfill(this.promise, this._result);
        } else {
          this.length = this.length || 0;
          this._enumerate();
          if (this._remaining === 0) {
            lib$rsvp$$internal$$fulfill(this.promise, this._result);
          }
        }
      } else {
        lib$rsvp$$internal$$reject(this.promise, this._validationError());
      }
    }

    var lib$rsvp$enumerator$$default = lib$rsvp$enumerator$$Enumerator;

    lib$rsvp$enumerator$$Enumerator.prototype._validateInput = function(input) {
      return lib$rsvp$utils$$isArray(input);
    };

    lib$rsvp$enumerator$$Enumerator.prototype._validationError = function() {
      return new Error('Array Methods must be provided an Array');
    };

    lib$rsvp$enumerator$$Enumerator.prototype._init = function() {
      this._result = new Array(this.length);
    };

    lib$rsvp$enumerator$$Enumerator.prototype._enumerate = function() {
      var length  = this.length;
      var promise = this.promise;
      var input   = this._input;

      for (var i = 0; promise._state === lib$rsvp$$internal$$PENDING && i < length; i++) {
        this._eachEntry(input[i], i);
      }
    };

    lib$rsvp$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
      var c = this._instanceConstructor;
      if (lib$rsvp$utils$$isMaybeThenable(entry)) {
        if (entry.constructor === c && entry._state !== lib$rsvp$$internal$$PENDING) {
          entry._onError = null;
          this._settledAt(entry._state, i, entry._result);
        } else {
          this._willSettleAt(c.resolve(entry), i);
        }
      } else {
        this._remaining--;
        this._result[i] = this._makeResult(lib$rsvp$$internal$$FULFILLED, i, entry);
      }
    };

    lib$rsvp$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
      var promise = this.promise;

      if (promise._state === lib$rsvp$$internal$$PENDING) {
        this._remaining--;

        if (this._abortOnReject && state === lib$rsvp$$internal$$REJECTED) {
          lib$rsvp$$internal$$reject(promise, value);
        } else {
          this._result[i] = this._makeResult(state, i, value);
        }
      }

      if (this._remaining === 0) {
        lib$rsvp$$internal$$fulfill(promise, this._result);
      }
    };

    lib$rsvp$enumerator$$Enumerator.prototype._makeResult = function(state, i, value) {
      return value;
    };

    lib$rsvp$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
      var enumerator = this;

      lib$rsvp$$internal$$subscribe(promise, undefined, function(value) {
        enumerator._settledAt(lib$rsvp$$internal$$FULFILLED, i, value);
      }, function(reason) {
        enumerator._settledAt(lib$rsvp$$internal$$REJECTED, i, reason);
      });
    };
    function lib$rsvp$promise$all$$all(entries, label) {
      return new lib$rsvp$enumerator$$default(this, entries, true /* abort on reject */, label).promise;
    }
    var lib$rsvp$promise$all$$default = lib$rsvp$promise$all$$all;
    function lib$rsvp$promise$race$$race(entries, label) {
      /*jshint validthis:true */
      var Constructor = this;

      var promise = new Constructor(lib$rsvp$$internal$$noop, label);

      if (!lib$rsvp$utils$$isArray(entries)) {
        lib$rsvp$$internal$$reject(promise, new TypeError('You must pass an array to race.'));
        return promise;
      }

      var length = entries.length;

      function onFulfillment(value) {
        lib$rsvp$$internal$$resolve(promise, value);
      }

      function onRejection(reason) {
        lib$rsvp$$internal$$reject(promise, reason);
      }

      for (var i = 0; promise._state === lib$rsvp$$internal$$PENDING && i < length; i++) {
        lib$rsvp$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);
      }

      return promise;
    }
    var lib$rsvp$promise$race$$default = lib$rsvp$promise$race$$race;
    function lib$rsvp$promise$resolve$$resolve(object, label) {
      /*jshint validthis:true */
      var Constructor = this;

      if (object && typeof object === 'object' && object.constructor === Constructor) {
        return object;
      }

      var promise = new Constructor(lib$rsvp$$internal$$noop, label);
      lib$rsvp$$internal$$resolve(promise, object);
      return promise;
    }
    var lib$rsvp$promise$resolve$$default = lib$rsvp$promise$resolve$$resolve;
    function lib$rsvp$promise$reject$$reject(reason, label) {
      /*jshint validthis:true */
      var Constructor = this;
      var promise = new Constructor(lib$rsvp$$internal$$noop, label);
      lib$rsvp$$internal$$reject(promise, reason);
      return promise;
    }
    var lib$rsvp$promise$reject$$default = lib$rsvp$promise$reject$$reject;

    var lib$rsvp$promise$$guidKey = 'rsvp_' + lib$rsvp$utils$$now() + '-';
    var lib$rsvp$promise$$counter = 0;

    function lib$rsvp$promise$$needsResolver() {
      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
    }

    function lib$rsvp$promise$$needsNew() {
      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
    }

    /**
      Promise objects represent the eventual result of an asynchronous operation. The
      primary way of interacting with a promise is through its `then` method, which
      registers callbacks to receive either a promises eventual value or the reason
      why the promise cannot be fulfilled.

      Terminology
      -----------

      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
      - `thenable` is an object or function that defines a `then` method.
      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
      - `exception` is a value that is thrown using the throw statement.
      - `reason` is a value that indicates why a promise was rejected.
      - `settled` the final resting state of a promise, fulfilled or rejected.

      A promise can be in one of three states: pending, fulfilled, or rejected.

      Promises that are fulfilled have a fulfillment value and are in the fulfilled
      state.  Promises that are rejected have a rejection reason and are in the
      rejected state.  A fulfillment value is never a thenable.

      Promises can also be said to *resolve* a value.  If this value is also a
      promise, then the original promise's settled state will match the value's
      settled state.  So a promise that *resolves* a promise that rejects will
      itself reject, and a promise that *resolves* a promise that fulfills will
      itself fulfill.


      Basic Usage:
      ------------

      ```js
      var promise = new Promise(function(resolve, reject) {
        // on success
        resolve(value);

        // on failure
        reject(reason);
      });

      promise.then(function(value) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Advanced Usage:
      ---------------

      Promises shine when abstracting away asynchronous interactions such as
      `XMLHttpRequest`s.

      ```js
      function getJSON(url) {
        return new Promise(function(resolve, reject){
          var xhr = new XMLHttpRequest();

          xhr.open('GET', url);
          xhr.onreadystatechange = handler;
          xhr.responseType = 'json';
          xhr.setRequestHeader('Accept', 'application/json');
          xhr.send();

          function handler() {
            if (this.readyState === this.DONE) {
              if (this.status === 200) {
                resolve(this.response);
              } else {
                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
              }
            }
          };
        });
      }

      getJSON('/posts.json').then(function(json) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Unlike callbacks, promises are great composable primitives.

      ```js
      Promise.all([
        getJSON('/posts'),
        getJSON('/comments')
      ]).then(function(values){
        values[0] // => postsJSON
        values[1] // => commentsJSON

        return values;
      });
      ```

      @class RSVP.Promise
      @param {function} resolver
      @param {String} label optional string for labeling the promise.
      Useful for tooling.
      @constructor
    */
    function lib$rsvp$promise$$Promise(resolver, label) {
      this._id = lib$rsvp$promise$$counter++;
      this._label = label;
      this._state = undefined;
      this._result = undefined;
      this._subscribers = [];

      if (lib$rsvp$config$$config.instrument) {
        lib$rsvp$instrument$$default('created', this);
      }

      if (lib$rsvp$$internal$$noop !== resolver) {
        if (!lib$rsvp$utils$$isFunction(resolver)) {
          lib$rsvp$promise$$needsResolver();
        }

        if (!(this instanceof lib$rsvp$promise$$Promise)) {
          lib$rsvp$promise$$needsNew();
        }

        lib$rsvp$$internal$$initializePromise(this, resolver);
      }
    }

    var lib$rsvp$promise$$default = lib$rsvp$promise$$Promise;

    // deprecated
    lib$rsvp$promise$$Promise.cast = lib$rsvp$promise$resolve$$default;
    lib$rsvp$promise$$Promise.all = lib$rsvp$promise$all$$default;
    lib$rsvp$promise$$Promise.race = lib$rsvp$promise$race$$default;
    lib$rsvp$promise$$Promise.resolve = lib$rsvp$promise$resolve$$default;
    lib$rsvp$promise$$Promise.reject = lib$rsvp$promise$reject$$default;

    lib$rsvp$promise$$Promise.prototype = {
      constructor: lib$rsvp$promise$$Promise,

      _guidKey: lib$rsvp$promise$$guidKey,

      _onError: function (reason) {
        lib$rsvp$config$$config.async(function(promise) {
          setTimeout(function() {
            if (promise._onError) {
              lib$rsvp$config$$config['trigger']('error', reason);
            }
          }, 0);
        }, this);
      },

    /**
      The primary way of interacting with a promise is through its `then` method,
      which registers callbacks to receive either a promise's eventual value or the
      reason why the promise cannot be fulfilled.

      ```js
      findUser().then(function(user){
        // user is available
      }, function(reason){
        // user is unavailable, and you are given the reason why
      });
      ```

      Chaining
      --------

      The return value of `then` is itself a promise.  This second, 'downstream'
      promise is resolved with the return value of the first promise's fulfillment
      or rejection handler, or rejected if the handler throws an exception.

      ```js
      findUser().then(function (user) {
        return user.name;
      }, function (reason) {
        return 'default name';
      }).then(function (userName) {
        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
        // will be `'default name'`
      });

      findUser().then(function (user) {
        throw new Error('Found user, but still unhappy');
      }, function (reason) {
        throw new Error('`findUser` rejected and we're unhappy');
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
      });
      ```
      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.

      ```js
      findUser().then(function (user) {
        throw new PedagogicalException('Upstream error');
      }).then(function (value) {
        // never reached
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // The `PedgagocialException` is propagated all the way down to here
      });
      ```

      Assimilation
      ------------

      Sometimes the value you want to propagate to a downstream promise can only be
      retrieved asynchronously. This can be achieved by returning a promise in the
      fulfillment or rejection handler. The downstream promise will then be pending
      until the returned promise is settled. This is called *assimilation*.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // The user's comments are now available
      });
      ```

      If the assimliated promise rejects, then the downstream promise will also reject.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // If `findCommentsByAuthor` fulfills, we'll have the value here
      }, function (reason) {
        // If `findCommentsByAuthor` rejects, we'll have the reason here
      });
      ```

      Simple Example
      --------------

      Synchronous Example

      ```javascript
      var result;

      try {
        result = findResult();
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js
      findResult(function(result, err){
        if (err) {
          // failure
        } else {
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findResult().then(function(result){
        // success
      }, function(reason){
        // failure
      });
      ```

      Advanced Example
      --------------

      Synchronous Example

      ```javascript
      var author, books;

      try {
        author = findAuthor();
        books  = findBooksByAuthor(author);
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js

      function foundBooks(books) {

      }

      function failure(reason) {

      }

      findAuthor(function(author, err){
        if (err) {
          failure(err);
          // failure
        } else {
          try {
            findBoooksByAuthor(author, function(books, err) {
              if (err) {
                failure(err);
              } else {
                try {
                  foundBooks(books);
                } catch(reason) {
                  failure(reason);
                }
              }
            });
          } catch(error) {
            failure(err);
          }
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findAuthor().
        then(findBooksByAuthor).
        then(function(books){
          // found books
      }).catch(function(reason){
        // something went wrong
      });
      ```

      @method then
      @param {Function} onFulfilled
      @param {Function} onRejected
      @param {String} label optional string for labeling the promise.
      Useful for tooling.
      @return {Promise}
    */
      then: function(onFulfillment, onRejection, label) {
        var parent = this;
        var state = parent._state;

        if (state === lib$rsvp$$internal$$FULFILLED && !onFulfillment || state === lib$rsvp$$internal$$REJECTED && !onRejection) {
          if (lib$rsvp$config$$config.instrument) {
            lib$rsvp$instrument$$default('chained', this, this);
          }
          return this;
        }

        parent._onError = null;

        var child = new this.constructor(lib$rsvp$$internal$$noop, label);
        var result = parent._result;

        if (lib$rsvp$config$$config.instrument) {
          lib$rsvp$instrument$$default('chained', parent, child);
        }

        if (state) {
          var callback = arguments[state - 1];
          lib$rsvp$config$$config.async(function(){
            lib$rsvp$$internal$$invokeCallback(state, child, callback, result);
          });
        } else {
          lib$rsvp$$internal$$subscribe(parent, child, onFulfillment, onRejection);
        }

        return child;
      },

    /**
      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
      as the catch block of a try/catch statement.

      ```js
      function findAuthor(){
        throw new Error('couldn't find that author');
      }

      // synchronous
      try {
        findAuthor();
      } catch(reason) {
        // something went wrong
      }

      // async with promises
      findAuthor().catch(function(reason){
        // something went wrong
      });
      ```

      @method catch
      @param {Function} onRejection
      @param {String} label optional string for labeling the promise.
      Useful for tooling.
      @return {Promise}
    */
      'catch': function(onRejection, label) {
        return this.then(null, onRejection, label);
      },

    /**
      `finally` will be invoked regardless of the promise's fate just as native
      try/catch/finally behaves

      Synchronous example:

      ```js
      findAuthor() {
        if (Math.random() > 0.5) {
          throw new Error();
        }
        return new Author();
      }

      try {
        return findAuthor(); // succeed or fail
      } catch(error) {
        return findOtherAuther();
      } finally {
        // always runs
        // doesn't affect the return value
      }
      ```

      Asynchronous example:

      ```js
      findAuthor().catch(function(reason){
        return findOtherAuther();
      }).finally(function(){
        // author was either found, or not
      });
      ```

      @method finally
      @param {Function} callback
      @param {String} label optional string for labeling the promise.
      Useful for tooling.
      @return {Promise}
    */
      'finally': function(callback, label) {
        var constructor = this.constructor;

        return this.then(function(value) {
          return constructor.resolve(callback()).then(function(){
            return value;
          });
        }, function(reason) {
          return constructor.resolve(callback()).then(function(){
            throw reason;
          });
        }, label);
      }
    };

    function lib$rsvp$all$settled$$AllSettled(Constructor, entries, label) {
      this._superConstructor(Constructor, entries, false /* don't abort on reject */, label);
    }

    lib$rsvp$all$settled$$AllSettled.prototype = lib$rsvp$utils$$o_create(lib$rsvp$enumerator$$default.prototype);
    lib$rsvp$all$settled$$AllSettled.prototype._superConstructor = lib$rsvp$enumerator$$default;
    lib$rsvp$all$settled$$AllSettled.prototype._makeResult = lib$rsvp$enumerator$$makeSettledResult;
    lib$rsvp$all$settled$$AllSettled.prototype._validationError = function() {
      return new Error('allSettled must be called with an array');
    };

    function lib$rsvp$all$settled$$allSettled(entries, label) {
      return new lib$rsvp$all$settled$$AllSettled(lib$rsvp$promise$$default, entries, label).promise;
    }
    var lib$rsvp$all$settled$$default = lib$rsvp$all$settled$$allSettled;
    function lib$rsvp$all$$all(array, label) {
      return lib$rsvp$promise$$default.all(array, label);
    }
    var lib$rsvp$all$$default = lib$rsvp$all$$all;
    var lib$rsvp$asap$$len = 0;
    var lib$rsvp$asap$$toString = {}.toString;
    var lib$rsvp$asap$$vertxNext;
    function lib$rsvp$asap$$asap(callback, arg) {
      lib$rsvp$asap$$queue[lib$rsvp$asap$$len] = callback;
      lib$rsvp$asap$$queue[lib$rsvp$asap$$len + 1] = arg;
      lib$rsvp$asap$$len += 2;
      if (lib$rsvp$asap$$len === 2) {
        // If len is 1, that means that we need to schedule an async flush.
        // If additional callbacks are queued before the queue is flushed, they
        // will be processed by this flush that we are scheduling.
        lib$rsvp$asap$$scheduleFlush();
      }
    }

    var lib$rsvp$asap$$default = lib$rsvp$asap$$asap;

    var lib$rsvp$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;
    var lib$rsvp$asap$$browserGlobal = lib$rsvp$asap$$browserWindow || {};
    var lib$rsvp$asap$$BrowserMutationObserver = lib$rsvp$asap$$browserGlobal.MutationObserver || lib$rsvp$asap$$browserGlobal.WebKitMutationObserver;
    var lib$rsvp$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

    // test for web worker but not in IE10
    var lib$rsvp$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
      typeof importScripts !== 'undefined' &&
      typeof MessageChannel !== 'undefined';

    // node
    function lib$rsvp$asap$$useNextTick() {
      var nextTick = process.nextTick;
      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
      // setImmediate should be used instead instead
      var version = process.versions.node.match(/^(?:(\d+)\.)?(?:(\d+)\.)?(\*|\d+)$/);
      if (Array.isArray(version) && version[1] === '0' && version[2] === '10') {
        nextTick = setImmediate;
      }
      return function() {
        nextTick(lib$rsvp$asap$$flush);
      };
    }

    // vertx
    function lib$rsvp$asap$$useVertxTimer() {
      return function() {
        lib$rsvp$asap$$vertxNext(lib$rsvp$asap$$flush);
      };
    }

    function lib$rsvp$asap$$useMutationObserver() {
      var iterations = 0;
      var observer = new lib$rsvp$asap$$BrowserMutationObserver(lib$rsvp$asap$$flush);
      var node = document.createTextNode('');
      observer.observe(node, { characterData: true });

      return function() {
        node.data = (iterations = ++iterations % 2);
      };
    }

    // web worker
    function lib$rsvp$asap$$useMessageChannel() {
      var channel = new MessageChannel();
      channel.port1.onmessage = lib$rsvp$asap$$flush;
      return function () {
        channel.port2.postMessage(0);
      };
    }

    function lib$rsvp$asap$$useSetTimeout() {
      return function() {
        setTimeout(lib$rsvp$asap$$flush, 1);
      };
    }

    var lib$rsvp$asap$$queue = new Array(1000);
    function lib$rsvp$asap$$flush() {
      for (var i = 0; i < lib$rsvp$asap$$len; i+=2) {
        var callback = lib$rsvp$asap$$queue[i];
        var arg = lib$rsvp$asap$$queue[i+1];

        callback(arg);

        lib$rsvp$asap$$queue[i] = undefined;
        lib$rsvp$asap$$queue[i+1] = undefined;
      }

      lib$rsvp$asap$$len = 0;
    }

    function lib$rsvp$asap$$attemptVertex() {
      try {
        var r = require;
        var vertx = r('vertx');
        lib$rsvp$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
        return lib$rsvp$asap$$useVertxTimer();
      } catch(e) {
        return lib$rsvp$asap$$useSetTimeout();
      }
    }

    var lib$rsvp$asap$$scheduleFlush;
    // Decide what async method to use to triggering processing of queued callbacks:
    if (lib$rsvp$asap$$isNode) {
      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useNextTick();
    } else if (lib$rsvp$asap$$BrowserMutationObserver) {
      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useMutationObserver();
    } else if (lib$rsvp$asap$$isWorker) {
      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useMessageChannel();
    } else if (lib$rsvp$asap$$browserWindow === undefined && typeof require === 'function') {
      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$attemptVertex();
    } else {
      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useSetTimeout();
    }
    function lib$rsvp$defer$$defer(label) {
      var deferred = { };

      deferred['promise'] = new lib$rsvp$promise$$default(function(resolve, reject) {
        deferred['resolve'] = resolve;
        deferred['reject'] = reject;
      }, label);

      return deferred;
    }
    var lib$rsvp$defer$$default = lib$rsvp$defer$$defer;
    function lib$rsvp$filter$$filter(promises, filterFn, label) {
      return lib$rsvp$promise$$default.all(promises, label).then(function(values) {
        if (!lib$rsvp$utils$$isFunction(filterFn)) {
          throw new TypeError("You must pass a function as filter's second argument.");
        }

        var length = values.length;
        var filtered = new Array(length);

        for (var i = 0; i < length; i++) {
          filtered[i] = filterFn(values[i]);
        }

        return lib$rsvp$promise$$default.all(filtered, label).then(function(filtered) {
          var results = new Array(length);
          var newLength = 0;

          for (var i = 0; i < length; i++) {
            if (filtered[i]) {
              results[newLength] = values[i];
              newLength++;
            }
          }

          results.length = newLength;

          return results;
        });
      });
    }
    var lib$rsvp$filter$$default = lib$rsvp$filter$$filter;

    function lib$rsvp$promise$hash$$PromiseHash(Constructor, object, label) {
      this._superConstructor(Constructor, object, true, label);
    }

    var lib$rsvp$promise$hash$$default = lib$rsvp$promise$hash$$PromiseHash;

    lib$rsvp$promise$hash$$PromiseHash.prototype = lib$rsvp$utils$$o_create(lib$rsvp$enumerator$$default.prototype);
    lib$rsvp$promise$hash$$PromiseHash.prototype._superConstructor = lib$rsvp$enumerator$$default;
    lib$rsvp$promise$hash$$PromiseHash.prototype._init = function() {
      this._result = {};
    };

    lib$rsvp$promise$hash$$PromiseHash.prototype._validateInput = function(input) {
      return input && typeof input === 'object';
    };

    lib$rsvp$promise$hash$$PromiseHash.prototype._validationError = function() {
      return new Error('Promise.hash must be called with an object');
    };

    lib$rsvp$promise$hash$$PromiseHash.prototype._enumerate = function() {
      var promise = this.promise;
      var input   = this._input;
      var results = [];

      for (var key in input) {
        if (promise._state === lib$rsvp$$internal$$PENDING && Object.prototype.hasOwnProperty.call(input, key)) {
          results.push({
            position: key,
            entry: input[key]
          });
        }
      }

      var length = results.length;
      this._remaining = length;
      var result;

      for (var i = 0; promise._state === lib$rsvp$$internal$$PENDING && i < length; i++) {
        result = results[i];
        this._eachEntry(result.entry, result.position);
      }
    };

    function lib$rsvp$hash$settled$$HashSettled(Constructor, object, label) {
      this._superConstructor(Constructor, object, false, label);
    }

    lib$rsvp$hash$settled$$HashSettled.prototype = lib$rsvp$utils$$o_create(lib$rsvp$promise$hash$$default.prototype);
    lib$rsvp$hash$settled$$HashSettled.prototype._superConstructor = lib$rsvp$enumerator$$default;
    lib$rsvp$hash$settled$$HashSettled.prototype._makeResult = lib$rsvp$enumerator$$makeSettledResult;

    lib$rsvp$hash$settled$$HashSettled.prototype._validationError = function() {
      return new Error('hashSettled must be called with an object');
    };

    function lib$rsvp$hash$settled$$hashSettled(object, label) {
      return new lib$rsvp$hash$settled$$HashSettled(lib$rsvp$promise$$default, object, label).promise;
    }
    var lib$rsvp$hash$settled$$default = lib$rsvp$hash$settled$$hashSettled;
    function lib$rsvp$hash$$hash(object, label) {
      return new lib$rsvp$promise$hash$$default(lib$rsvp$promise$$default, object, label).promise;
    }
    var lib$rsvp$hash$$default = lib$rsvp$hash$$hash;
    function lib$rsvp$map$$map(promises, mapFn, label) {
      return lib$rsvp$promise$$default.all(promises, label).then(function(values) {
        if (!lib$rsvp$utils$$isFunction(mapFn)) {
          throw new TypeError("You must pass a function as map's second argument.");
        }

        var length = values.length;
        var results = new Array(length);

        for (var i = 0; i < length; i++) {
          results[i] = mapFn(values[i]);
        }

        return lib$rsvp$promise$$default.all(results, label);
      });
    }
    var lib$rsvp$map$$default = lib$rsvp$map$$map;

    function lib$rsvp$node$$Result() {
      this.value = undefined;
    }

    var lib$rsvp$node$$ERROR = new lib$rsvp$node$$Result();
    var lib$rsvp$node$$GET_THEN_ERROR = new lib$rsvp$node$$Result();

    function lib$rsvp$node$$getThen(obj) {
      try {
       return obj.then;
      } catch(error) {
        lib$rsvp$node$$ERROR.value= error;
        return lib$rsvp$node$$ERROR;
      }
    }


    function lib$rsvp$node$$tryApply(f, s, a) {
      try {
        f.apply(s, a);
      } catch(error) {
        lib$rsvp$node$$ERROR.value = error;
        return lib$rsvp$node$$ERROR;
      }
    }

    function lib$rsvp$node$$makeObject(_, argumentNames) {
      var obj = {};
      var name;
      var i;
      var length = _.length;
      var args = new Array(length);

      for (var x = 0; x < length; x++) {
        args[x] = _[x];
      }

      for (i = 0; i < argumentNames.length; i++) {
        name = argumentNames[i];
        obj[name] = args[i + 1];
      }

      return obj;
    }

    function lib$rsvp$node$$arrayResult(_) {
      var length = _.length;
      var args = new Array(length - 1);

      for (var i = 1; i < length; i++) {
        args[i - 1] = _[i];
      }

      return args;
    }

    function lib$rsvp$node$$wrapThenable(then, promise) {
      return {
        then: function(onFulFillment, onRejection) {
          return then.call(promise, onFulFillment, onRejection);
        }
      };
    }

    function lib$rsvp$node$$denodeify(nodeFunc, options) {
      var fn = function() {
        var self = this;
        var l = arguments.length;
        var args = new Array(l + 1);
        var arg;
        var promiseInput = false;

        for (var i = 0; i < l; ++i) {
          arg = arguments[i];

          if (!promiseInput) {
            // TODO: clean this up
            promiseInput = lib$rsvp$node$$needsPromiseInput(arg);
            if (promiseInput === lib$rsvp$node$$GET_THEN_ERROR) {
              var p = new lib$rsvp$promise$$default(lib$rsvp$$internal$$noop);
              lib$rsvp$$internal$$reject(p, lib$rsvp$node$$GET_THEN_ERROR.value);
              return p;
            } else if (promiseInput && promiseInput !== true) {
              arg = lib$rsvp$node$$wrapThenable(promiseInput, arg);
            }
          }
          args[i] = arg;
        }

        var promise = new lib$rsvp$promise$$default(lib$rsvp$$internal$$noop);

        args[l] = function(err, val) {
          if (err)
            lib$rsvp$$internal$$reject(promise, err);
          else if (options === undefined)
            lib$rsvp$$internal$$resolve(promise, val);
          else if (options === true)
            lib$rsvp$$internal$$resolve(promise, lib$rsvp$node$$arrayResult(arguments));
          else if (lib$rsvp$utils$$isArray(options))
            lib$rsvp$$internal$$resolve(promise, lib$rsvp$node$$makeObject(arguments, options));
          else
            lib$rsvp$$internal$$resolve(promise, val);
        };

        if (promiseInput) {
          return lib$rsvp$node$$handlePromiseInput(promise, args, nodeFunc, self);
        } else {
          return lib$rsvp$node$$handleValueInput(promise, args, nodeFunc, self);
        }
      };

      fn.__proto__ = nodeFunc;

      return fn;
    }

    var lib$rsvp$node$$default = lib$rsvp$node$$denodeify;

    function lib$rsvp$node$$handleValueInput(promise, args, nodeFunc, self) {
      var result = lib$rsvp$node$$tryApply(nodeFunc, self, args);
      if (result === lib$rsvp$node$$ERROR) {
        lib$rsvp$$internal$$reject(promise, result.value);
      }
      return promise;
    }

    function lib$rsvp$node$$handlePromiseInput(promise, args, nodeFunc, self){
      return lib$rsvp$promise$$default.all(args).then(function(args){
        var result = lib$rsvp$node$$tryApply(nodeFunc, self, args);
        if (result === lib$rsvp$node$$ERROR) {
          lib$rsvp$$internal$$reject(promise, result.value);
        }
        return promise;
      });
    }

    function lib$rsvp$node$$needsPromiseInput(arg) {
      if (arg && typeof arg === 'object') {
        if (arg.constructor === lib$rsvp$promise$$default) {
          return true;
        } else {
          return lib$rsvp$node$$getThen(arg);
        }
      } else {
        return false;
      }
    }
    function lib$rsvp$race$$race(array, label) {
      return lib$rsvp$promise$$default.race(array, label);
    }
    var lib$rsvp$race$$default = lib$rsvp$race$$race;
    function lib$rsvp$reject$$reject(reason, label) {
      return lib$rsvp$promise$$default.reject(reason, label);
    }
    var lib$rsvp$reject$$default = lib$rsvp$reject$$reject;
    function lib$rsvp$resolve$$resolve(value, label) {
      return lib$rsvp$promise$$default.resolve(value, label);
    }
    var lib$rsvp$resolve$$default = lib$rsvp$resolve$$resolve;
    function lib$rsvp$rethrow$$rethrow(reason) {
      setTimeout(function() {
        throw reason;
      });
      throw reason;
    }
    var lib$rsvp$rethrow$$default = lib$rsvp$rethrow$$rethrow;

    // default async is asap;
    lib$rsvp$config$$config.async = lib$rsvp$asap$$default;
    var lib$rsvp$$cast = lib$rsvp$resolve$$default;
    function lib$rsvp$$async(callback, arg) {
      lib$rsvp$config$$config.async(callback, arg);
    }

    function lib$rsvp$$on() {
      lib$rsvp$config$$config['on'].apply(lib$rsvp$config$$config, arguments);
    }

    function lib$rsvp$$off() {
      lib$rsvp$config$$config['off'].apply(lib$rsvp$config$$config, arguments);
    }

    // Set up instrumentation through `window.__PROMISE_INTRUMENTATION__`
    if (typeof window !== 'undefined' && typeof window['__PROMISE_INSTRUMENTATION__'] === 'object') {
      var lib$rsvp$$callbacks = window['__PROMISE_INSTRUMENTATION__'];
      lib$rsvp$config$$configure('instrument', true);
      for (var lib$rsvp$$eventName in lib$rsvp$$callbacks) {
        if (lib$rsvp$$callbacks.hasOwnProperty(lib$rsvp$$eventName)) {
          lib$rsvp$$on(lib$rsvp$$eventName, lib$rsvp$$callbacks[lib$rsvp$$eventName]);
        }
      }
    }

    var lib$rsvp$umd$$RSVP = {
      'race': lib$rsvp$race$$default,
      'Promise': lib$rsvp$promise$$default,
      'allSettled': lib$rsvp$all$settled$$default,
      'hash': lib$rsvp$hash$$default,
      'hashSettled': lib$rsvp$hash$settled$$default,
      'denodeify': lib$rsvp$node$$default,
      'on': lib$rsvp$$on,
      'off': lib$rsvp$$off,
      'map': lib$rsvp$map$$default,
      'filter': lib$rsvp$filter$$default,
      'resolve': lib$rsvp$resolve$$default,
      'reject': lib$rsvp$reject$$default,
      'all': lib$rsvp$all$$default,
      'rethrow': lib$rsvp$rethrow$$default,
      'defer': lib$rsvp$defer$$default,
      'EventTarget': lib$rsvp$events$$default,
      'configure': lib$rsvp$config$$configure,
      'async': lib$rsvp$$async
    };

    /* global define:true module:true window: true */
    if (typeof define === 'function' && define['amd']) {
      define(function() { return lib$rsvp$umd$$RSVP; });
    } else if (typeof module !== 'undefined' && module['exports']) {
      module['exports'] = lib$rsvp$umd$$RSVP;
    } else if (typeof this !== 'undefined') {
      this['RSVP'] = lib$rsvp$umd$$RSVP;
    }
}).call(this);


}).call(this,require('_process'))

},{"_process":3}],30:[function(require,module,exports){
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result  either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],31:[function(require,module,exports){
(function (global){

var rng;

if (global.crypto && crypto.getRandomValues) {
  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
  // Moderately fast, high quality
  var _rnds8 = new Uint8Array(16);
  rng = function whatwgRNG() {
    crypto.getRandomValues(_rnds8);
    return _rnds8;
  };
}

if (!rng) {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var  _rnds = new Array(16);
  rng = function() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return _rnds;
  };
}

module.exports = rng;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],32:[function(require,module,exports){
//     uuid.js
//
//     Copyright (c) 2010-2012 Robert Kieffer
//     MIT License - http://opensource.org/licenses/mit-license.php

// Unique ID creation requires a high quality random # generator.  We feature
// detect to determine the best RNG source, normalizing to a function that
// returns 128-bits of randomness, since that's what's usually required
var _rng = require('./rng');

// Maps for number <-> hex string conversion
var _byteToHex = [];
var _hexToByte = {};
for (var i = 0; i < 256; i++) {
  _byteToHex[i] = (i + 0x100).toString(16).substr(1);
  _hexToByte[_byteToHex[i]] = i;
}

// **`parse()` - Parse a UUID into it's component bytes**
function parse(s, buf, offset) {
  var i = (buf && offset) || 0, ii = 0;

  buf = buf || [];
  s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
    if (ii < 16) { // Don't overflow!
      buf[i + ii++] = _hexToByte[oct];
    }
  });

  // Zero out remaining bytes if string was short
  while (ii < 16) {
    buf[i + ii++] = 0;
  }

  return buf;
}

// **`unparse()` - Convert UUID byte array (ala parse()) into a string**
function unparse(buf, offset) {
  var i = offset || 0, bth = _byteToHex;
  return  bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]];
}

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

// random #'s we need to init node and clockseq
var _seedBytes = _rng();

// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
var _nodeId = [
  _seedBytes[0] | 0x01,
  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
];

// Per 4.2.2, randomize (14 bit) clockseq
var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

// Previous uuid creation time
var _lastMSecs = 0, _lastNSecs = 0;

// See https://github.com/broofa/node-uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};

  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  var node = options.node || _nodeId;
  for (var n = 0; n < 6; n++) {
    b[i + n] = node[n];
  }

  return buf ? buf : unparse(b);
}

// **`v4()` - Generate random UUID**

// See https://github.com/broofa/node-uuid for API details
function v4(options, buf, offset) {
  // Deprecated - 'format' argument, as supported in v1.2
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options == 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || _rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ii++) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || unparse(rnds);
}

// Export public API
var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;
uuid.parse = parse;
uuid.unparse = unparse;

module.exports = uuid;

},{"./rng":31}],33:[function(require,module,exports){
'use strict';
var Constants = {};
Constants.DefaultTakeItemsCount = 50;
Constants.ExpandExpressionName = 'Expand';
Constants.ReturnAsFieldName = 'ReturnAs';
Constants.FieldsExpressionName = 'Fields';
Constants.SingleFieldExpressionName = 'SingleField';
Constants.SortExpressionName = 'Sort';
Constants.FilterExpressionName = 'Filter';
Constants.SkipExpressionName = 'Skip';
Constants.TakeExpressionName = 'Take';
Constants.ParentRelationFieldName = 'ParentRelationField';
Constants.IdFieldNameClient = 'Id';
Constants.TargetTypeNameFieldName = 'TargetTypeName';

module.exports = Constants;
},{}],34:[function(require,module,exports){
'use strict';
var Constants = require('./Constants');

/**
 * A class that is used to get all required information in order to process a set of relations.
 * @param parent - An ExecutionNode instance used to supply the tree like data structure.
 * @param relationNode - The relation node used to created the ExecutionNode instance (ExecutionNode instance should contain one or many relations
 * if they can be combined for batch execution).
 * @constructor
 */
var ExecutionNode = function (parent, relationNode) {
    var parentPath = '';
    if (parent) {
        parentPath = parent.path;
    }
    this.parent = parentPath;
    this.relations = [relationNode.path];
    this.name = relationNode.path;
    this.targetTypeName = relationNode.targetTypeName;
    this.canAddOtherRelations = !relationNode.filterExpression && !relationNode.sortExpression && !relationNode.take && !relationNode.skip;
    this.children = [];
    var path = '';
    if (parentPath) {
        path += parentPath + '.';
    }
    path += relationNode.targetTypeName;
    this.path = path;
};

/**
 * Inserts a RelationNode to an ExecutionNode.
 * @param relation - A Relation instance.
 */
ExecutionNode.prototype.insertRelationNode = function (relation) {
    this.relations.push(relation.path);
};

/**
 * Inserts a child node (which relations) depends from parent node result.
 * @param child - ExecutionNode instance representing child node.
 */
ExecutionNode.prototype.insertChildrenNode = function (child) {
    this.children.push(child.name);
};

/**
 * Helper method that checks if some relations could be combined (for example have same TargetType).
 * @param relation
 * @returns {boolean}
 */
ExecutionNode.prototype.canCombineWithRelation = function (relation) {
    if (!this.canAddOtherRelations) {
        return false;
    }

    return this.targetTypeName === relation.targetTypeName && !relation.filterExpression && !relation.sortExpression && !relation.take && !relation.skip;
};

/** ExecutionTree
 * Class that allows the creation of an execution tree from a relationTree. Used to process all queries (master and child) in a correct order.
 * @param relationTree - An instance of relation tree.
 * @constructor
 */
var ExecutionTree = function (relationTree) {
    this._relationTree = relationTree;
    this._map = {};
};

/**
 * Adds execution node to the ExecutionTree.
 * @param executionNode
 */
ExecutionTree.prototype.addExecutionNode = function (executionNode) {
    this._map[executionNode.name] = executionNode;
};

/**
 * Finds the ExecutionNode which contains the requested relation.
 * @param relation - A Relation instance.
 * @returns {*}
 */
ExecutionTree.prototype.getExecutionNodeOfRelation = function (relation) {
    for (var execNode in this._map) {
        if (this._map.hasOwnProperty(execNode)) {
            if (this._map[execNode].relations.indexOf(relation) > -1) {
                return this._map[execNode];
            }
        }
    }
    return null;
};

/**
 * Finds a RelationNode within the RelationTree.
 * @param relation - String that represents the relation within the RelationTree (for example: Activities.Likes.Role).
 * @returns {*}
 */
ExecutionTree.prototype.getRelationNode = function (relation) {
    if (relation) {
        return this._relationTree[relation] || null;
    } else {
        return null;
    }
};

ExecutionTree.prototype.getRootRelationNode = function () {
    return this._relationTree[this._relationTree.$root] || null;
};
/**
 * Builds the ExecutionTree from a RelationTree.
 */
ExecutionTree.prototype.build = function () {
    //build beginning from the root
    var relationRoot = this.getRelationNode(this._relationTree.$root);
    //Setup the root of the execution tree.
    var rootExecutionNode = new ExecutionNode(null, relationRoot);//no parent node
    this.addExecutionNode(rootExecutionNode);
    this.buildInternal(relationRoot);
};

/**
 * Traverse the relation tree and build the execution tree.
 * @param relationRoot - The root node of the RelationTree.
 */
ExecutionTree.prototype.buildInternal = function (relationRoot) {
    relationRoot.children.forEach(function (child) {
        var childRelationNode = this.getRelationNode(child);
        this.insertRelationNodeInExecutionTree(childRelationNode);
        this.buildInternal(childRelationNode);
    }, this);
};

/**
 * Inserts a relation node within the execution tree (based on its dependencies).
 * @param relation - The relation that will be inserted.
 */
ExecutionTree.prototype.insertRelationNodeInExecutionTree = function (relation) {
    var rootExecutionNode = this.getExecutionNodeOfRelation(relation.parent);
    var childToCombine = this.tryGetChildNodeToCombine(rootExecutionNode, relation);
    if (childToCombine) {//if there is a child that we combine the relation
        childToCombine.insertRelationNode(relation);
    } else {
        var newExecutionNode = new ExecutionNode(rootExecutionNode, relation);//create a separate execution node that will host the relation
        rootExecutionNode.insertChildrenNode(newExecutionNode);
        this.addExecutionNode(newExecutionNode);
    }
};

/**
 * Tries to find an ExecutionNode which could be combined with a relation.
 * @param rootExecutionNode - The root node of the ExecutionTree.
 * @param relation - Relation that will be added to the ExecutionTree.
 * @returns {*}
 */
ExecutionTree.prototype.tryGetChildNodeToCombine = function (rootExecutionNode, relation) {
    if (rootExecutionNode.canCombineWithRelation(relation)) {
        return rootExecutionNode;
    }
    var children = rootExecutionNode.children;
    for (var i = 0; i < children.length; i++) {
        var child = this._map[children[i]];
        var childToCombine = this.tryGetChildNodeToCombine(child, relation);
        if (childToCombine) {
            return childToCombine;
        }
    }
    return null;
};

/**
 * Gets the filter expression from all relations inside an ExecutionNode.
 * @param executionNode - The ExecutionNode instance.
 * @returns {{}}
 */
ExecutionTree.prototype.getFilterFromExecutionNode = function (executionNode, includeArrays) {
    var filter = {};
    var subRelationsFilter = [];
    for (var i = 0; i < executionNode.relations.length; i++) {
        var innerFilter = this.getFilterFromSingleRelation(this._relationTree[executionNode.relations[i]], includeArrays);
        if (innerFilter) {
            subRelationsFilter.push(innerFilter);
        }
    }

    if (subRelationsFilter.length > 1) {
        filter.$or = subRelationsFilter;
    } else if (subRelationsFilter.length > 0) {
        filter = subRelationsFilter[0];
    } else {
        filter = null;
    }
    return filter;
};

/**
 * Gets filter expression from a single relation. Traverse the relation tree in order to get the "Id"s from the result of parent relation
 * along with user defined filters.
 * @param relation - A Relation instance.
 * @returns {*}
 */
ExecutionTree.prototype.getFilterFromSingleRelation = function (relation, includeArrays) {
    var userDefinedFilter = relation.filterExpression;
    var parentRelationFilter = {};
    var parentRelationIds = this.getRelationFieldValues(relation, includeArrays);
    var parentRelationFieldName = (relation.isInvertedRelation ? relation.relationField : Constants.IdFieldNameClient);

    if (parentRelationIds.length > 0) {
        parentRelationFilter[parentRelationFieldName] = {'$in': parentRelationIds};
    } else {
        return null;
    }

    if (userDefinedFilter !== undefined) {
        var filters = [];
        filters.push(parentRelationFilter);
        filters.push(userDefinedFilter);
        return {'$and': filters};
    } else {
        return parentRelationFilter;
    }
};

/**
 * Get relation field values of parent relation in order to construct a proper filter (to create a relation).
 * @param relation - A relation instance which will get the filter.
 * @param includeArrays - Whether to include array valus of the parent items when calculating the items that will be expanded on the current level.
 * @returns {Array} - An array of relation field values.
 */
ExecutionTree.prototype.getRelationFieldValues = function (relation, includeArrays) {
    var parentRelationIds = [];
    var parentRelation = this._relationTree[relation.parent];
    // parentRelationResult actually is an Activity or Array of Activities
    var parentRelationResult = Array.isArray(parentRelation.result) ? parentRelation.result : [parentRelation.result];
    if (relation.isInvertedRelation) {
        for (var p = 0; p < parentRelationResult.length; p++) {
            parentRelationIds.push(parentRelationResult[p][relation.parentRelationField]);
        }
    } else {
        // all comments are related to expand of type content type Activities expand: {"Likes": true}
        if (parentRelation && parentRelation.result) {
            relation.parentRelationIds = relation.parentRelationIds || {};
            for (var i = 0; i < parentRelationResult.length; i++) {
                // itemFromParentRelation is single Activity
                var itemFromParentRelation = parentRelationResult[i];

                // parentRelationFieldValue is Activity.Likes
                var parentRelationFieldValue = itemFromParentRelation[relation.relationField];
                if (Array.isArray(parentRelationFieldValue)) {
                    relation.hasArrayValues = true;
                    if (includeArrays) {
                        for (var j = 0; j < parentRelationFieldValue.length; j++) {
                            // itemToExpandId is current value in Activity.Likes array or just a single "Id"
                            var itemToExpandId = parentRelationFieldValue[j];
                            if(itemToExpandId !== undefined && itemToExpandId !== null) {
                                parentRelationIds.push(itemToExpandId);
                                // we set any value just to create a map of Ids
                                relation.parentRelationIds[itemToExpandId] = 1;
                            }
                        }
                    }
                } else {
                    if(parentRelationFieldValue !== undefined && parentRelationFieldValue !== null) {
                        parentRelationIds.push(parentRelationFieldValue);
                        relation.parentRelationIds[parentRelationFieldValue] = 1;
                    }
                }
            }
        }
    }

    return parentRelationIds;
};

module.exports = ExecutionTree;

},{"./Constants":33}],35:[function(require,module,exports){
'use strict';
function ExpandError(message) {
    this.name = 'ExpandError';
    this.message = message;
    this.stack = (new Error()).stack;
}
ExpandError.prototype = new Error;
module.exports = ExpandError;
},{}],36:[function(require,module,exports){
'use strict';
var async = require('async');
var RelationTreeBuilder = require('./RelationTreeBuilder');
var ExecutionTree = require('./ExecutionTree');
var Constants = require('./Constants');
var ExpandError = require('./ExpandError');

function Processor(options) {
    this._executionNodeFunction = options.executionNodeFunction;
    this._metadataProviderFunction = options.metadataProviderFunction;
}

Processor.prototype._getExecutionTreeRoot = function (executionTree) {
    var executionTreeRoot = null;
    for (var exNode in executionTree) {
        if (executionTree.hasOwnProperty(exNode)) {
            if (executionTree[exNode].parent === '') {
                executionTreeRoot = executionTree[exNode];
                break;
            }
        }
    }
    return executionTreeRoot;
};

Processor.prototype._createExecuteNodeExecutor = function (relationsTree, executionTree, executionNode, expandContext) {
    var self = this;
    var relationsTreeMap = relationsTree.map;
    return function (done) {
        var relationNode = executionTree.getRelationNode(executionNode.relations[0]);//get the relation node for the only relation of the execution node.
        var parentRelationNode = executionTree.getRelationNode(relationNode.parent);
        var includeArrays = !(parentRelationNode.parent && parentRelationNode.hasArrayValues); //only expand array fields if the parent relation is not an array. This means that if we have expanded a Likes (multiple to Users), we won't expand any array relations that are nested in it such as the UserComments (multiple relation to Comments).
        var filter = executionTree.getFilterFromExecutionNode(executionNode, includeArrays);

        var errorMessage = relationsTree.validateSingleRelation(relationNode);
        if (errorMessage) {
            return done(new ExpandError(errorMessage));
        }

        // if we have such options executionNode should have only one relation.
        var node = {};
        node.select = relationNode.fieldsExpression;
        node.sort = relationNode.sortExpression;
        node.skip = relationNode.skip;
        node.take = relationNode.take;
        node.filter = filter;
        node.targetTypeName = relationNode.targetTypeName;

        self._executionNodeFunction.call(null, node, expandContext, function onProcessExecutionNode(err, result) {
            if (err) {
                return done(err);
            }

            for (var i = 0; i < executionNode.relations.length; i++) {
                var childRelation = relationsTreeMap[executionNode.relations[i]];
                childRelation.result = self._extractResultForRelation(relationsTreeMap[executionNode.relations[i]], result);
            }
            executionNode.result = childRelation.result;
            var arr = [];
            for (var j = 0; j < executionNode.children.length; j++) {
                var executionTreeMap = executionTree._map;
                arr.push(self._createExecuteNodeExecutor(relationsTree, executionTree, executionTreeMap[executionNode.children[j]], expandContext));
            }
            async.parallel(arr, done);
        });
    };
};

Processor.prototype._getSingleResult = function (relationsTree, relation, singleObject) {
    if (!singleObject) {
        return null;
    }

    var childRelation;
    var childItem;

    // if relation has singleFieldName option we just replace the parent id with a single value
    if (relation.singleFieldName) {
        if (relation.children && relation.children.length > 0) {
            childRelation = relationsTree[relation.children[0]];
            childItem = this._getObjectByIdFromArray(childRelation.result, singleObject[relation.singleFieldName]);
            return this._getSingleResult(relationsTree, childRelation, childItem);
        }
        return singleObject[relation.singleFieldName];
    }

    var result = {};
    var passedProperties = {};

    if (relation.children && relation.children.length > 0) {
        for (var j = 0; j < relation.children.length; j++) {
            childRelation = relationsTree[relation.children[j]];
            var childRelationField = childRelation.relationField;
            var userDefinedRelName = childRelation.userDefinedName;
            if (!childRelation.isInvertedRelation) {
                passedProperties[childRelationField] = 1;
            }

            var innerRelationResult = childRelation.result;

            if (childRelation.isInvertedRelation) {
                for (var k = 0; k < innerRelationResult.length; k++) {
                    this._addSingleResultToParentArray(relationsTree, childRelation, innerRelationResult[k], result, userDefinedRelName);
                }
            } else {
                result[userDefinedRelName] = childRelation.isArray() ? [] : null;

                if (singleObject[childRelationField]) {
                    if (Array.isArray(singleObject[childRelationField])) {
                        if (childRelation.sortExpression) {
                            // if there is a sorting we replace items using order of the query result
                            for (var p = 0; p < innerRelationResult.length; p++) {
                                if (singleObject[childRelationField].indexOf(innerRelationResult[p].Id) > -1) {
                                    childItem = innerRelationResult[p];
                                    this._addSingleResultToParentArray(relationsTree, childRelation, childItem, result, userDefinedRelName);
                                }
                            }
                        } else {
                            // we just replace items getting them by id which we have
                            for (var i = 0; i < singleObject[childRelationField].length; i++) {
                                childItem = this._getObjectByIdFromArray(innerRelationResult, singleObject[childRelationField][i]);
                                this._addSingleResultToParentArray(relationsTree, childRelation, childItem, result, userDefinedRelName);
                            }
                        }
                    } else {
                        childItem = this._getObjectByIdFromArray(innerRelationResult, singleObject[childRelationField]);
                        result[userDefinedRelName] = this._getSingleResult(relationsTree, childRelation, childItem);
                    }
                }
            }
        }
    }

    // add all other fields to the result (except the relation fields which we have already replaced).
    for (var prop in singleObject) {
        var propertyShouldBeAddedToResult = singleObject.hasOwnProperty(prop) && !passedProperties[prop] &&
            this._fieldExistInFieldsExpression(prop, relation.originalFieldsExpression);
        if (propertyShouldBeAddedToResult) {
            result[prop] = singleObject[prop];
        }
    }

    return result;
};

Processor.prototype._addSingleResultToParentArray = function (relationsTree, childRelation, childItem, result, userDefinedRelName) {
    var singleResult = this._getSingleResult(relationsTree, childRelation, childItem);
    result[userDefinedRelName] = result[userDefinedRelName] || [];
    if (singleResult) {
        result[userDefinedRelName].push(singleResult);
    }
};

/**
 * Checks if a field will be returned via given fields expression.
 * @param field - The name of the field.
 * @param fieldsExpression - The Fields expression which is checked.
 * @returns {*}
 */
Processor.prototype._fieldExistInFieldsExpression = function (field, fieldsExpression) {
    if (fieldsExpression === undefined || Object.keys(fieldsExpression).length === 0) {
        return true;
    }

    if (field === Constants.IdFieldNameClient) {
        if (fieldsExpression[field] === undefined) {
            return true;
        }
        return fieldsExpression[field];
    }

    var isExclusive = RelationTreeBuilder.getIsFieldsExpressionExclusive(fieldsExpression);

    if (isExclusive === undefined) {
        return true;
    }

    if (isExclusive) {
        return !fieldsExpression.hasOwnProperty(field);
    } else {
        return fieldsExpression.hasOwnProperty(field);
    }
};

/**
 * Extracts the result for a single relation (in cases when ExecutionNode contains more than one relations).
 * @param relation - The relation object.
 * @param queryResult - Result of the combined query.
 * @returns {Array}
 */
Processor.prototype._extractResultForRelation = function (relation, queryResult) {
    var result = [];
    for (var i = 0; i < queryResult.length; i++) {
        if (relation.parentRelationIds) {
            if (relation.parentRelationIds.hasOwnProperty(queryResult[i].Id)) {
                result.push(queryResult[i]);
            }
        }
        if (relation.isInvertedRelation) {
            result.push(queryResult[i]);
        }
    }
    return result;
};

/**
 * Gets an object with a given Id from Array.
 * @param array
 * @param id
 * @returns {*}
 */
Processor.prototype._getObjectByIdFromArray = function (array, id) {
    if (array) {
        for (var i = 0; i < array.length; i++) {
            if (array[i].Id === id) {
                return array[i];
            }
        }
    }
    return null;
};

/**
 * @public
 * @param expandExpression
 * @param mainTypeName
 * @param isArray
 * @param fieldsExpression
 * @param maxTakeValue
 * @param prepareContext
 * @param done
 */
Processor.prototype.prepare = function (expandExpression, mainTypeName, isArray, fieldsExpression, maxTakeValue, prepareContext, done) {
    var rtb = new RelationTreeBuilder(expandExpression, mainTypeName, isArray, fieldsExpression, maxTakeValue, this._metadataProviderFunction, prepareContext);
    rtb.build(function (err, map) {
        var mainQueryFieldsExpression;
        if (map) {
            mainQueryFieldsExpression = map[map.$root].fieldsExpression;
            var prepareResult = {
                relationsTree: rtb,
                mainQueryFieldsExpression: mainQueryFieldsExpression
            }
        }
        done(err, prepareResult);
    });
};

/**
 * @public
 * @param relationsTree
 * @param mainQueryResult
 * @param expandContext
 * @param done
 */
Processor.prototype.expand = function (relationsTree, mainQueryResult, expandContext, done) {
    var relationsTreeMap = relationsTree.map;
    var self = this;
    var executionTree = new ExecutionTree(relationsTreeMap);
    executionTree.build();
    relationsTreeMap[relationsTreeMap.$root].result = mainQueryResult;
    var executionTreeMap = executionTree._map;

    var executionTreeRoot = this._getExecutionTreeRoot(executionTreeMap);

    var maxQueriesCount = 20;
    if (Object.keys(executionTreeMap).length > maxQueriesCount) {
        done(new ExpandError('Expand expression results in more than ' + maxQueriesCount + ' inner queries!'));
    }

    if (executionTreeRoot) {
        var execFuncs = [];
        for (var i = 0; i < executionTreeRoot.children.length; i++) {
            execFuncs.push(this._createExecuteNodeExecutor(relationsTree, executionTree, executionTreeMap[executionTreeRoot.children[i]], expandContext));
        }
        // execFuncs are functions created for every single execution note
        // we execute them in async, since the result of the parent relation is used to get correct filter.
        async.series(execFuncs, function onProcessExecutionTree(err) {
            if (err) {
                done(err);
            } else {
                var output;
                var rootRelation = relationsTreeMap[relationsTreeMap.$root];
                if (Array.isArray(mainQueryResult)) {
                    output = [];
                    for (var i = 0; i < mainQueryResult.length; i++) {
                        var singleResult = self._getSingleResult(relationsTreeMap, rootRelation, mainQueryResult[i]);
                        if (singleResult) {
                            output.push(singleResult);
                        }
                    }
                } else {
                    output = self._getSingleResult(relationsTreeMap, rootRelation, mainQueryResult);
                }
                done(null, output);
            }
        });
    }
};

Processor.Constants = Constants;

module.exports = Processor;

},{"./Constants":33,"./ExecutionTree":34,"./ExpandError":35,"./RelationTreeBuilder":38,"async":39}],37:[function(require,module,exports){
'use strict';
var Constants = require('./Constants');
var _ = require('underscore');
var ExpandError = require('./ExpandError');

function RelationNode(options) {
    this.parent = options.parent;
    this.relationField = options.relationField;
    this.path = options.path || options.parent + '.' + options.relationField;
    this.fieldsExpression = options.fieldsExpression || {};
    this.targetTypeName = options.targetTypeName;
    this.children = [];
    this.isInvertedRelation = options.isInvertedRelation;
    this.isArrayRoot = options.isArrayRoot; //used for validation of cases where various expand features are disabled for a GetAll scenario.
    this.hasArrayValues = false;//set when we have executed the query. Used in validation scenarios where we do not have metadata about whether the relation is an array or not.

    var expandExpression = options.expandExpression || {};

    this.parentRelationField = expandExpression[Constants.ParentRelationFieldName] || Constants.IdFieldNameClient;
    var relationField = this.isInvertedRelation ? this.path : this.relationField; //inverted relations appear with the full path - ContentType.Field - in the result when expanding.
    this.userDefinedName = expandExpression[Constants.ReturnAsFieldName] || relationField;
    _.extend(this.fieldsExpression, expandExpression[Constants.FieldsExpressionName]);
    this.originalFieldsExpression = {};
    _.extend(this.originalFieldsExpression, this.fieldsExpression);
    this.singleFieldName = expandExpression[Constants.SingleFieldExpressionName];
    this.filterExpression = expandExpression[Constants.FilterExpressionName];
    this.sortExpression = expandExpression[Constants.SortExpressionName];
    this.skip = expandExpression[Constants.SkipExpressionName];
    this.take = this._getTakeLimit(expandExpression[Constants.TakeExpressionName], options.maxTakeValue);
}


/**
 * Gets the take limit depending on the application and the take value that the user has provided.
 * @param clientTakeValue
 * @param maxTakeValue
 * @returns {number}
 */
RelationNode.prototype._getTakeLimit = function (clientTakeValue, maxTakeValue) {
    maxTakeValue = maxTakeValue || Constants.DefaultTakeItemsCount;
    if (clientTakeValue) {
        if (clientTakeValue > maxTakeValue) {
            throw new ExpandError('The maximum allowed take value when expanding relations is ' + maxTakeValue + '!');
        }
        return clientTakeValue;
    } else {
        return maxTakeValue;
    }
};

/**
 * Anyone using the bs-expand-processor module can set whether the relation is a multiple relation in the prepare phase.
 * This will allow for certain restrictions to be enforced directly on the prepare phase instead of the execution phase.
 */
RelationNode.prototype.setIsArrayFromMetadata = function () {
    this.isArrayFromMetadata = true;
};

RelationNode.prototype.isArray = function () {
    // We can find out if a relation is an array in the following cases:
    // From metadata in the API Server.
    // All inverted relations are array.
    // Once values have been received we can find out. This is used for scenarios where we do not have metadata about the relation (offline storage in SDK).
    return this.isArrayFromMetadata || this.isInvertedRelation || this.hasArrayValues;
};

module.exports = RelationNode;

},{"./Constants":33,"./ExpandError":35,"underscore":40}],38:[function(require,module,exports){
'use strict';
var RelationNode = require('./RelationNode');
var _ = require('underscore');
var Constants = require('./Constants');
var ExpandError = require('./ExpandError');

//var relationFieldPropertyName = Constants.RelationExpressionName;

var possibleExpandOptions = [
    Constants.ExpandExpressionName,
    Constants.ReturnAsFieldName,
    Constants.FieldsExpressionName,
    Constants.SingleFieldExpressionName,
    Constants.SortExpressionName,
    Constants.FilterExpressionName,
    Constants.SkipExpressionName,
    Constants.TakeExpressionName,
    Constants.ParentRelationFieldName,
    Constants.TargetTypeNameFieldName
];


/**
 * A class used to parse Expand expression and build a corresponding relation tree.
 * In a process of creating the relation tree are performed several checks in order to force some limitations -
 * 50 items both for master and child queries and entire amount of all queries limited to 20.
 * Checks if the relation field given by the customer is valid (for example: user gives "Like" while the relation field is "Likes").
 * Checks for possible expand options.
 * @constructor
 */
var RelationTreeBuilder = function (expandExpression, mainTypeName, isArray, fieldsExpression, maxTakeValue, metadataProviderFunction, context) {
    this.maxTakeValue = maxTakeValue;
    this._metadataProviderFunction = metadataProviderFunction;
    this.context = context;
    this.expandExpression = this.processExpandExpression(expandExpression);
    // mark the main query in order to avoid some duplication issues.
    this.map = {};
    this.map[mainTypeName] = new RelationNode({
        targetTypeName: mainTypeName,
        isArrayRoot: isArray,
        fieldsExpression: fieldsExpression,
        validated: true,
        path: mainTypeName,
        maxTakeValue: maxTakeValue
    });
    this.map[mainTypeName].originalFieldsExpression = {};
    _.extend(this.map[mainTypeName].originalFieldsExpression, fieldsExpression);
    this.map.$root = mainTypeName;
};

/**
 * Creates fully qualified expand expression from shorthand usages:
 * {"Likes": true} -> {"Likes": {"ReturnAs": "Likes"}}
 * {"Likes": "LikesExpanded"} -> {"Likes": {"ReturnAs": "LikesExpanded"}}
 * @param expandExpression
 * @returns {*}
 */
RelationTreeBuilder.prototype.processExpandExpression = function (expandExpression) {
    for (var property in expandExpression) {
        if (expandExpression.hasOwnProperty(property)) {
            if (typeof expandExpression[property] === 'boolean') {
                expandExpression[property] = {};
                expandExpression[property][Constants.ReturnAsFieldName] = property;
            }
            if (typeof expandExpression[property] === 'string') {
                var relationField = expandExpression[property];
                expandExpression[property] = {};
                expandExpression[property][Constants.ReturnAsFieldName] = relationField;
            }
        }
    }
    return expandExpression;
};

/**
 * Builds the relation tree.
 * @param done
 */
RelationTreeBuilder.prototype.build = function (done) {
    try {
        this.buildMapInternal(this.expandExpression, this.map.$root);
    } catch (e) {
        return done(e);
    }
    var self = this;
    require('async').series([
        this.configureRelationTree.bind(this),
        this.validateRelationTree.bind(this)
    ], function (err) {
        done(err, self.map);
    });
};

/**
 *
 * @param relationName - A path to the external relation collection (Comments.ActivityId)
 * @param expandExpression - The expand expression that contains all information about the relation
 * @param rootName - Name of the parent relation.
 * @returns {RelationNode}
 */
RelationTreeBuilder.prototype.createInvertedRelation = function (relationName, expandExpression, rootName) {
    var options = {};
    var relationNameParts = relationName.split('.');
    options.parent = rootName;
    options.relationField = relationNameParts[1];
    options.isInvertedRelation = true;
    options.targetTypeName = relationNameParts[0];
    options.expandExpression = expandExpression;
    options.path = relationName;
    options.maxTakeValue = this.maxTakeValue;
    options.validated = false;

    return new RelationNode(options);
};

/**
 * An internal method which parses the expand expression and produces a basic relation tree (only names and parent relations).
 * @param expandExpression - The expand expression which will be processed.
 * @param rootName - The name of the root relation (master query) usually the name of the requested content type (Activities).
 */
RelationTreeBuilder.prototype.buildMapInternal = function (expandExpression, rootName) {
    for (var relationName in expandExpression) {
        if (expandExpression.hasOwnProperty(relationName)) {
            var currentExpression = expandExpression[relationName];

            for (var option in currentExpression) {
                if (currentExpression.hasOwnProperty(option) && possibleExpandOptions.indexOf(option) === -1) {
                    throw new ExpandError('\"' + option + '\"' + ' is not a valid option for Expand expression');
                }
            }

            if (relationName.indexOf('.') > -1) {
                var invertedRelation = this.createInvertedRelation(relationName, currentExpression, rootName);
                this.map[invertedRelation.path] = invertedRelation;
                this.map[invertedRelation.parent].children.push(invertedRelation.path);
                // adds a field expression in the original fields expression in order to get the result for that field
                RelationTreeBuilder.addFieldToFieldsExpression(this.map[invertedRelation.parent].originalFieldsExpression, invertedRelation.userDefinedName);

                if (expandExpression[relationName][Constants.ExpandExpressionName]) {
                    var processedExpandExpression = this.processExpandExpression(expandExpression[relationName][Constants.ExpandExpressionName]);
                    this.buildMapInternal(processedExpandExpression, invertedRelation.path);
                }
            } else {
                var options = {};
                options.relationField = relationName;
                options.parent = rootName;
                options.expandExpression = currentExpression;
                options.maxTakeValue = this.maxTakeValue;
                options.targetTypeName = currentExpression[Constants.TargetTypeNameFieldName];
                var relationNode = new RelationNode(options);
                var parentNode = this.map[options.parent];
                parentNode.children.push(relationNode.path);
                this.map[relationNode.path] = relationNode;

                if (currentExpression.hasOwnProperty(Constants.ExpandExpressionName)) {
                    if (typeof(currentExpression[Constants.ExpandExpressionName]) === 'object') {
                        this.buildMapInternal(this.processExpandExpression(currentExpression.Expand), relationNode.path);
                    } else {
                        throw new ExpandError(relationNode.path + '.Expand must be a valid expand expression!');
                    }
                }
            }
        }
    }
};

/**
 * Adds additional metadata which is necessary to execute a query.
 * Name of the content type of the child relation get via relation field.
 * @param done
 */
RelationTreeBuilder.prototype.configureRelationTree = function (done) {
    if (this._metadataProviderFunction) {
        var relationNames = [];
        var self = this;

        for (var rel in this.map) {
            if (this.map.hasOwnProperty(rel)) {
                if (this.map[rel].parent !== null) {
                    relationNames.push(this.map[rel].relationField);
                }
            }
        }

        this._metadataProviderFunction(relationNames, this.map, this.context, function (err, result) {
            done(err);
        });
    } else {
        return done();
    }
};

/**
 * Performs several checks like:
 * Validity of the relation field.
 * To not use filter or sorting expression within a "GetByFilter" scenario.
 * Does not allow to nest (expand multiple relation field) after a multiple relation.
 * Does not allow to use both "Fields" and "SingleField" options.
 * @param done
 * @returns {*}
 */
RelationTreeBuilder.prototype.validateRelationTree = function (done) {
    var errorMessage = '';
    var EOL = '\r\n';
    for (var relationPath in this.map) {
        if (relationPath !== '$root' && this.map.hasOwnProperty(relationPath)) {
            var relation = this.map[relationPath];
            errorMessage += this.validateSingleRelation(relation);
            this.configureFieldsExpressionsForRelation(relation);
        }
    }
    if (errorMessage !== '') {
        var finalErrorMessage = errorMessage.substr(0, errorMessage.lastIndexOf(EOL));
        var error = new ExpandError(finalErrorMessage);
        return done(error);
    } else {
        done();
    }
};

/**
 * Add relation fields to parent relation fields expression if needed (otherwise relation cannot be established).
 * @param relation - A relation which will be configured.
 */
RelationTreeBuilder.prototype.configureFieldsExpressionsForRelation = function (relation) {
    if (relation.parent) {
        var parentRelationFieldsExpression = this.map[relation.parent].fieldsExpression;
        if (relation.isInvertedRelation) {
            RelationTreeBuilder.addFieldToFieldsExpression(parentRelationFieldsExpression, relation.parentRelationField);
        } else {
            RelationTreeBuilder.addFieldToFieldsExpression(parentRelationFieldsExpression, relation.relationField);
        }
    }
    if (relation.isInvertedRelation) {
        RelationTreeBuilder.addFieldToFieldsExpression(relation.fieldsExpression, relation.relationField);
    } else {
        RelationTreeBuilder.addFieldToFieldsExpression(relation.fieldsExpression, Constants.IdFieldNameClient);
    }
    RelationTreeBuilder.adjustParentRelationFieldsExpression(this.map[relation.parent], relation);
};

/**
 * Validates a single relation for all build-in limitations.
 * @param relation - A relation which will be validated.
 * @returns {string} - Returns an error message with all errors or empty string if there is no errors.
 */
RelationTreeBuilder.prototype.validateSingleRelation = function (relation) {
    var errorMessage = '';
    var EOL = '\r\n';
    var isGetByFilterQuery = this.map[this.map.$root].isArrayRoot;

    if (relation.path === relation.parent) {
        errorMessage += relation.path + ' has same parent which will cause an infinite loop.' + EOL;
        return errorMessage;
    }

    if (relation.isArray()) {
        var multipleQueriesCount = this.getParentMultipleRelationsCount(relation);
        if (multipleQueriesCount > 0) {
            errorMessage += 'Expand expression has multiple relation \"' + relation.path + '\" inside a multiple relation.';
            errorMessage += EOL;
        }

        if (this.map[relation.parent] === this.map[this.map.$root] &&
            isGetByFilterQuery &&
            (relation.filterExpression || relation.sortExpression)) {
            errorMessage += 'Filter and Sort expressions are not allowed with GetByFilter scenario.';
            errorMessage += EOL;
        }

        if (isGetByFilterQuery && relation.isInvertedRelation) {
            errorMessage += 'Expanding an external content type is not allowed with GetByFilter scenario.';
            errorMessage += EOL;
        }
    }
    if (!relation.targetTypeName) {
        errorMessage += 'Expanding relation \"' + relation.relationField + '\" has no target type name specified. You should use \"TargetTypeName\" to specify it.';
        errorMessage += EOL;
    }
    if (relation.fieldsExpression && Object.keys(relation.fieldsExpression).length && relation.singleFieldName) {
        errorMessage += relation.path + ' ';
        errorMessage += 'expand expression contains both \"Fields\" and \"SingleField\" expressions.';
        errorMessage += EOL;
    }
    if (relation.singleFieldName) {
        if (relation.children) {
            if (relation.children.length > 1) {
                errorMessage += relation.path + ' has multiple expand expressions with a single field option.' + EOL;
            }
            if (relation.children.length === 1 && this.map[relation.children[0]].relationField !== relation.singleFieldName) {
                errorMessage += 'Expand expression ' + relation.path;
                errorMessage += ' single field \"' + relation.singleFieldName + '\"';
                errorMessage += ' does not match child relation field \"' + this.map[relation.children[0]].relationField + '\".';
                errorMessage += EOL;
            }
        }
    }

    return errorMessage;
};

/**
 * Gets the count of parent multiple relations.
 * @param relation - Starting relation.
 * @returns {number} - count of all parent multiple relations
 */
RelationTreeBuilder.prototype.getParentMultipleRelationsCount = function (relation) {
    var result = 0;
    var relationForLoop = relation;
    while (relationForLoop.parent) {
        var parentRelation = this.map[relationForLoop.parent];
        if (parentRelation.isArray() && parentRelation.parent) {
            result += 1;
        }
        relationForLoop = parentRelation;
    }
    return result;
};


/**
 * Adjusts fields expression of the parent relation based on paging setting of a relation (skip, take).
 * In that case we put a "$slice" option within the parent relation fields expression.
 * @param parentRelation
 * @param relation
 */
RelationTreeBuilder.adjustParentRelationFieldsExpression = function (parentRelation, relation) {
    if (!relation.isInvertedRelation && relation.take && typeof relation.take === 'number') {
        // when relation has filter or sorting skip and take should not be transferred to the parent relation as $slice.
        var shouldTransferPagingToParentRelation = relation.isArray() && !relation.filterExpression && !relation.sortExpression && parentRelation;
        if (shouldTransferPagingToParentRelation) {
            if (parentRelation.fieldsExpression === undefined) {
                parentRelation.fieldsExpression = {};
            }

            if (relation.skip && typeof relation.skip === 'number') {
                parentRelation.fieldsExpression[relation.relationField] = {
                    '$slice': [relation.skip, relation.take]
                };
            } else {
                parentRelation.fieldsExpression[relation.relationField] = {
                    '$slice': relation.take
                };
            }
            relation.take = null;
            relation.skip = null;
            relation.movedSkipTakeAsSlice = true;
        }
    }
};

/**
 * Adds field to parent relation fields expression. For example if the relation field is excluded from the master request.
 * @param fieldsExpression - Fields expression of the parent relation.
 * @param relationField - Name of the field which should be returned.
 */
RelationTreeBuilder.addFieldToFieldsExpression = function (fieldsExpression, relationField) {
    if (fieldsExpression === undefined || Object.keys(fieldsExpression).length === 0) {
        return;
    }
    var isExclusive = RelationTreeBuilder.getIsFieldsExpressionExclusive(fieldsExpression);

    if (isExclusive === undefined) {
        return;
    }

    if (isExclusive) {
        delete fieldsExpression[relationField];
    } else {
        fieldsExpression[relationField] = 1;
    }
};

/**
 * Gets if the fields expression is exclusive ("FieldName" : 0)
 * @param fieldsExpression - Fields expression to check.
 * @returns {*}
 */
RelationTreeBuilder.getIsFieldsExpressionExclusive = function (fieldsExpression) {
    var isExclusive;
    for (var fieldName in fieldsExpression) {
        if (fieldName !== Constants.IdFieldNameClient && fieldsExpression.hasOwnProperty(fieldName)) {
            if (isExclusive === undefined) {
                if (fieldsExpression[fieldName] === 0) {
                    isExclusive = true;
                    break;
                } else {
                    if (typeof fieldsExpression[fieldName] === 'object') {
                        continue;
                    } else {
                        // fieldsExpression[fieldName] === 1
                        isExclusive = false;
                        break;
                    }
                }
            }
        }
    }
    return isExclusive;
};

module.exports = RelationTreeBuilder;

},{"./Constants":33,"./ExpandError":35,"./RelationNode":37,"async":39,"underscore":40}],39:[function(require,module,exports){
(function (process){
/*!
 * async
 * https://github.com/caolan/async
 *
 * Copyright 2010-2014 Caolan McMahon
 * Released under the MIT license
 */
/*jshint onevar: false, indent:4 */
/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _toString = Object.prototype.toString;

    var _isArray = Array.isArray || function (obj) {
        return _toString.call(obj) === '[object Array]';
    };

    var _each = function (arr, iterator) {
        if (arr.forEach) {
            return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = function (fn) {
              // not a direct alias for IE10 compatibility
              setImmediate(fn);
            };
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(done) );
        });
        function done(err) {
          if (err) {
              callback(err);
              callback = function () {};
          }
          else {
              completed += 1;
              if (completed >= arr.length) {
                  callback();
              }
          }
        }
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback();
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        if (!callback) {
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err) {
                    callback(err);
                });
            });
        } else {
            var results = [];
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err, v) {
                    results[x.index] = v;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        var remainingTasks = keys.length
        if (!remainingTasks) {
            return callback();
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            remainingTasks--
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (!remainingTasks) {
                var theCallback = callback;
                // prevent final callback from calling itself if it errors
                callback = function () {};

                theCallback(null, results);
            }
        });

        _each(keys, function (k) {
            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.retry = function(times, task, callback) {
        var DEFAULT_TIMES = 5;
        var attempts = [];
        // Use defaults if times not passed
        if (typeof times === 'function') {
            callback = task;
            task = times;
            times = DEFAULT_TIMES;
        }
        // Make sure times is a number
        times = parseInt(times, 10) || DEFAULT_TIMES;
        var wrappedTask = function(wrappedCallback, wrappedResults) {
            var retryAttempt = function(task, finalAttempt) {
                return function(seriesCallback) {
                    task(function(err, result){
                        seriesCallback(!err || finalAttempt, {err: err, result: result});
                    }, wrappedResults);
                };
            };
            while (times) {
                attempts.push(retryAttempt(task, !(times-=1)));
            }
            async.series(attempts, function(done, data){
                data = data[data.length - 1];
                (wrappedCallback || callback)(data.err, data.result);
            });
        }
        // If a callback is passed, run this as a controll flow
        return callback ? wrappedTask() : wrappedTask
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (!_isArray(tasks)) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (test.apply(null, args)) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (!test.apply(null, args)) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            started: false,
            paused: false,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            kill: function () {
              q.drain = null;
              q.tasks = [];
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (!q.paused && workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            },
            idle: function() {
                return q.tasks.length + workers === 0;
            },
            pause: function () {
                if (q.paused === true) { return; }
                q.paused = true;
                q.process();
            },
            resume: function () {
                if (q.paused === false) { return; }
                q.paused = false;
                q.process();
            }
        };
        return q;
    };
    
    async.priorityQueue = function (worker, concurrency) {
        
        function _compareTasks(a, b){
          return a.priority - b.priority;
        };
        
        function _binarySearch(sequence, item, compare) {
          var beg = -1,
              end = sequence.length - 1;
          while (beg < end) {
            var mid = beg + ((end - beg + 1) >>> 1);
            if (compare(item, sequence[mid]) >= 0) {
              beg = mid;
            } else {
              end = mid - 1;
            }
          }
          return beg;
        }
        
        function _insert(q, data, priority, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  priority: priority,
                  callback: typeof callback === 'function' ? callback : null
              };
              
              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }
        
        // Start with a normal queue
        var q = async.queue(worker, concurrency);
        
        // Override push to accept second parameter representing priority
        q.push = function (data, priority, callback) {
          _insert(q, data, priority, callback);
        };
        
        // Remove unshift function
        delete q.unshift;

        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            drained: true,
            push: function (data, callback) {
                if (!_isArray(data)) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    cargo.drained = false;
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain && !cargo.drained) cargo.drain();
                    cargo.drained = true;
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0, tasks.length);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                async.nextTick(function () {
                    callback.apply(null, memo[key]);
                });
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.seq = function (/* functions... */) {
        var fns = arguments;
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    async.compose = function (/* functions... */) {
      return async.seq.apply(null, Array.prototype.reverse.call(arguments));
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // Node.js
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // AMD / RequireJS
    else if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

}).call(this,require('_process'))

},{"_process":3}],40:[function(require,module,exports){
//     Underscore.js 1.8.2
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.2';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result  either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var isArrayLike = function(collection) {
    var length = collection && collection.length;
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, target, fromIndex) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    return _.indexOf(obj, target, typeof fromIndex == 'number' && fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = input && input.length; i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (array == null) return [];
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = array.length; i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    if (array == null) return [];
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = array.length; i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, 'length').length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = list && list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    var i = 0, length = array && array.length;
    if (typeof isSorted == 'number') {
      i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;
    } else if (isSorted && length) {
      i = _.sortedIndex(array, item);
      return array[i] === item ? i : -1;
    }
    if (item !== item) {
      return _.findIndex(slice.call(array, i), _.isNaN);
    }
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  _.lastIndexOf = function(array, item, from) {
    var idx = array ? array.length : 0;
    if (typeof from == 'number') {
      idx = from < 0 ? idx + from + 1 : Math.min(idx, from + 1);
    }
    if (item !== item) {
      return _.findLastIndex(slice.call(array, 0, idx), _.isNaN);
    }
    while (--idx >= 0) if (array[idx] === item) return idx;
    return -1;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = array != null && array.length;
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createIndexFinder(1);

  _.findLastIndex = createIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    
    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of 
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
  
  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],41:[function(require,module,exports){
var buildPromise = require('./utils').buildPromise;
var EverliveError = require('./EverliveError').EverliveError;
var Platform = require('./constants').Platform;
var common = require('./common');
var jstz = common.jstz;
var _ = common._;

module.exports = (function () {
    /**
     * @class CurrentDevice
     * @deprecated
     * @protected
     * @param pushHandler
     * @constructor
     */
    var CurrentDevice = function (pushHandler) {
        this._pushHandler = pushHandler;
        this._initSuccessCallback = null;
        this._initErrorCallback = null;

        //Suffix for the global callback functions
        this._globalFunctionSuffix = null;

        this.pushSettings = null;
        this.pushToken = null;
        this.isInitialized = false;
        this.isInitializing = false;

        this.emulatorMode = false;
    };

    CurrentDevice.prototype = {

        /**
         * Initializes the current device for push notifications. This method requests a push token from the device vendor and enables the push notification functionality on the device. Once this is done, you can register the device in {{site.TelerikBackendServices}} using the register() method.
         * @method enableNotifications
         * @name enableNotifications
         * @memberOf CurrentDevice.prototype
         * @param {PushSettings} pushSettings An object specifying various settings for the initialization.
         * @returns {Object} The promise for the request.
         */
        /**
         * Initializes the current device for push notifications. This method requests a push token from the device vendor and enables the push notification functionality on the device. Once this is done, you can register the device in Everlive using the register() method.
         * @method enableNotifications
         * @name enableNotifications
         * @memberOf CurrentDevice.prototype
         * @param {PushSettings} pushSettings An object specifying various settings for the initialization.
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        enableNotifications: function (pushSettings, success, error) {
            this.pushSettings = this._cleanPlatformsPushSettings(pushSettings);

            return buildPromise(_.bind(this._initialize, this), success, error);
        },

        /**
         * Disables push notifications for the current device. This method invalidates any push tokens that were obtained for the device from the current application.
         * @method disableNotifications
         * @name disableNotifications
         * @memberOf CurrentDevice.prototype
         * @returns {Object} The promise for the request.
         */
        /**
         * Disables push notifications for the current device. This method invalidates any push tokens that were obtained for the device from the current application.
         * @method disableNotifications
         * @name disableNotifications
         * @memberOf CurrentDevice.prototype
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        disableNotifications: function (success, error) {
            var self = this;

            return this.unregister().then(
                function () {
                    return buildPromise(
                        function (success, error) {
                            if (self.emulatorMode) {
                                success();
                            } else {
                                var pushNotification = window.plugins.pushNotification;
                                var unregisterOptions;
                                var platformType = self._getPlatformType(device.platform);
                                if (platformType === Platform.WindowsPhone) {
                                    unregisterOptions = {'channelName': self.pushSettings.wp8.channelName};
                                }
                                pushNotification.unregister(
                                    function () {
                                        self.isInitialized = false;
                                        success();
                                    },
                                    error,
                                    unregisterOptions
                                );
                            }
                        },
                        success,
                        error
                    );
                },
                error
            );
        },

        /**
         * Returns the push registration for the current device.
         * @memberOf CurrentDevice.prototype
         * @method getRegistration
         * @name getRegistration
         * @returns {Object} The promise for the request.
         */
        /**
         * Returns the push registration for the current device.
         * @memberOf CurrentDevice.prototype
         * @method getRegistration
         * @name getRegistration
         * @param {Function} success Callback to invoke on success.
         * @param {Function} error Callback to invoke on error.
         */
        getRegistration: function (success, error) {
            var deviceId = encodeURIComponent(this._getDeviceId());
            return this._pushHandler.devices.getById('HardwareId/' + deviceId, success, error);
        },

        /**
         * Registers the current device for push notifications in {{site.TelerikBackendServices}}. This method can be called only after [enableNotifications()](#CurrentDevice.enableNotifications) has completed successfully.
         * @memberOf CurrentDevice.prototype
         * @method register
         * @name register
         * @param {Object} customParameters Custom parameters for the registration.
         * @returns {Object} The promise for the request.
         */
        /**
         * Registers the current device for push notifications in {{site.TelerikBackendServices}}. This method can be called only after [enableNotifications()](#CurrentDevice.enableNotifications) has completed successfully.
         * @memberOf CurrentDevice.prototype
         * @method register
         * @name register
         * @param {Object} customParameters Custom parameters for the registration.
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        register: function (customParameters, success, error) {
            var self = this;

            var deviceRegistration = {};
            if (customParameters !== undefined) {
                deviceRegistration.Parameters = customParameters;
            }

            return this._populateRegistrationObject(deviceRegistration).then(
                function () {
                    return self._pushHandler.devices.create(deviceRegistration, success, error);
                },
                error
            );
        },

        /**
         * Unregisters the current device from push notifications in {{site.TelerikBackendServices}}. After this call completes successfully, {{site.bs}} will no longer send notifications to this device. Note that this does not prevent the device from receiving notifications and does not invalidate push tokens.
         * @memberOf CurrentDevice.prototype
         * @method unregister
         * @name unregister
         * @returns {Object} The promise for the request.
         */
        /**
         * Unregisters the current device from push notifications in {{site.TelerikBackendServices}}. After this call completes successfully, {{site.bs}} will no longer send notifications to this device. Note that this does not prevent the device from receiving notifications and does not invalidate push tokens.
         * @memberOf CurrentDevice.prototype
         * @method unregister
         * @name unregister
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        unregister: function (success, error) {
            var deviceId = encodeURIComponent(device.uuid);
            return this._pushHandler.devices.destroySingle({Id: 'HardwareId/' + deviceId}, success, error);
        },

        /**
         * Updates the registration of the current device.
         * @memberOf CurrentDevice.prototype
         * @method updateRegistration
         * @name updateRegistration
         * @param {Object} customParameters Custom parameters for the registration. If undefined, customParameters are not updated.
         * @returns {Object} The promise for the request.
         */
        /**
         * Updates the registration for the current device.
         * @memberOf CurrentDevice.prototype
         * @method updateRegistration
         * @name updateRegistration
         * @param {Object} customParameters Custom parameters for the registration. If undefined, customParameters are not updated.
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        updateRegistration: function (customParameters, success, error) {
            var self = this;

            var deviceRegistration = {};
            if (customParameters !== undefined) {
                deviceRegistration.Parameters = customParameters;
            }

            return this._populateRegistrationObject(deviceRegistration).then(
                function () {
                    deviceRegistration.Id = 'HardwareId/' + encodeURIComponent(deviceRegistration.HardwareId);
                    return self._pushHandler.devices.updateSingle(deviceRegistration, success, error);
                },
                error
            );
        },

        _initializeInteractivePush: function (iOSSettings, success, error) {
            var pushPlugin = window.plugins.pushNotification;

            var interactiveSettings = iOSSettings.interactiveSettings;
            var notificationTypes = [];
            if (iOSSettings.alert) {
                notificationTypes.push(pushPlugin.UserNotificationTypes.Alert);
            }
            if (iOSSettings.badge) {
                notificationTypes.push(pushPlugin.UserNotificationTypes.Badge);
            }
            if (iOSSettings.sound) {
                notificationTypes.push(pushPlugin.UserNotificationTypes.Sound);
            }

            var getAction = function (actionIdentifier) {
                var action = _.find(interactiveSettings.actions, function (action) {
                    return action.identifier === actionIdentifier;
                });

                return action;
            };
            var categories = _.map(interactiveSettings.categories, function (category) {
                return {
                    identifier: category.identifier,
                    actionsForDefaultContext: _.map(category.actionsForDefaultContext, getAction),
                    actionsForMinimalContext: _.map(category.actionsForMinimalContext, getAction)
                }
            });

            pushPlugin.registerUserNotificationSettings(
                // the success callback which will immediately return (APNs is not contacted for this)
                success,
                // called in case the configuration is incorrect
                error, {
                    // asking permission for these features
                    types: notificationTypes,
                    // register these categories
                    categories: categories
                }
            );
        },

        //Initializes the push functionality on the device.
        _initialize: function (success, error) {
            var self = this;

            if (this.isInitializing) {
                error(new EverliveError('Push notifications are currently initializing.'));
                return;
            }

            if (!this.emulatorMode && (!window.navigator || !window.navigator.globalization)) {
                error(new EverliveError('The globalization plugin is not initialized.'));
                return;
            }

            if (!this.emulatorMode && (!window.plugins || !window.plugins.pushNotification)) {
                error(new EverliveError('The push notifications plugin is not initialized.'));
                return;
            }

            this._initSuccessCallback = success;
            this._initErrorCallback = error;

            if (this.isInitialized) {
                this._deviceRegistrationSuccess(this.pushToken);
                return;
            }

            if (this.emulatorMode) {
                setTimeout(
                    function () {
                        self._deviceRegistrationSuccess('fake_push_token');
                    },
                    1000
                );
                return;
            }

            this.isInitializing = true;

            var suffix = this._globalFunctionSuffix;
            if (!suffix) {
                suffix = Date.now().toString();
                this._globalFunctionSuffix = suffix;
            }

            var pushNotification = window.plugins.pushNotification;

            var platformType = this._getPlatformType(device.platform);
            if (platformType === Platform.iOS) {
                //Initialize global APN callback
                var apnCallbackName = 'apnCallback_' + suffix;
                Everlive.PushCallbacks[apnCallbackName] = _.bind(this._onNotificationAPN, this);

                //Construct registration options object and validate iOS settings
                var apnRegistrationOptions = this.pushSettings.iOS;
                this._validateIOSSettings(apnRegistrationOptions);
                apnRegistrationOptions.ecb = 'Everlive.PushCallbacks.' + apnCallbackName;

                //Register for APN
                pushNotification.register(
                    _.bind(this._successfulRegistrationAPN, this),
                    _.bind(this._failedRegistrationAPN, this),
                    apnRegistrationOptions
                );
            } else if (platformType === Platform.Android) {
                //Initialize global GCM callback
                var gcmCallbackName = 'gcmCallback_' + suffix;
                Everlive.PushCallbacks[gcmCallbackName] = _.bind(this._onNotificationGCM, this);

                //Construct registration options object and validate the Android settings
                var gcmRegistrationOptions = this.pushSettings.android;
                this._validateAndroidSettings(gcmRegistrationOptions);
                gcmRegistrationOptions.ecb = 'Everlive.PushCallbacks.' + gcmCallbackName;

                //Register for GCM
                pushNotification.register(
                    _.bind(this._successSentRegistrationGCM, this),
                    _.bind(this._errorSentRegistrationGCM, this),
                    gcmRegistrationOptions
                );
            } else if (platformType === Platform.WindowsPhone) {
                //Initialize global WP8 callbacks.
                var wp8CallbackName = 'wp8Callback_' + suffix;
                var wp8RegistrationSuccessCallbackName = 'wp8RegistrationSuccessCallback_' + suffix;
                var wp8RegistrationErrorCallbackName = 'wp8RegistrationErrorCallback_' + suffix;

                Everlive.PushCallbacks[wp8CallbackName] = _.bind(this._onNotificationWP8, this);
                Everlive.PushCallbacks[wp8RegistrationSuccessCallbackName] = _.bind(this._deviceRegistrationSuccessWP, this);
                Everlive.PushCallbacks[wp8RegistrationErrorCallbackName] = _.bind(this._deviceRegistrationFailed, this);

                //Construct registration options object and validate the WP8  settings
                var wp8RegistrationOptions = this.pushSettings.wp8;
                this._validateWP8Settings(wp8RegistrationOptions);
                wp8RegistrationOptions.ecb = 'Everlive.PushCallbacks.' + wp8CallbackName;
                wp8RegistrationOptions.uccb = 'Everlive.PushCallbacks.' + wp8RegistrationSuccessCallbackName;
                wp8RegistrationOptions.errcb = 'Everlive.PushCallbacks.' + wp8RegistrationErrorCallbackName;


                pushNotification.register(
                    _.bind(this._successSentRegistrationWP8, this),
                    _.bind(this._errorSentRegistrationWP8, this),
                    wp8RegistrationOptions
                );

            } else {
                throw new EverliveError('The current platform is not supported: ' + device.platform);
            }
        },

        _deviceRegistrationSuccessWP: function (result) {
            this._deviceRegistrationSuccess(result.uri);
        },

        _validateAndroidSettings: function (androidSettings) {
            if (!androidSettings.senderID) {
                throw new EverliveError('Sender ID (project number) is not set in the android settings.');
            }
        },
        _validateWP8Settings: function (settings) {
            if (!settings.channelName) {
                throw new EverliveError('channelName is not set in the WP8 settings.');
            }
        },

        _validateIOSSettings: function (iOSSettings) {

        },

        _cleanPlatformsPushSettings: function (pushSettings) {
            var cleanSettings = {};
            pushSettings = pushSettings || {};

            var addSettingsForPlatform = function addSettingsForPlatform(newSettingsObject, platform, allowedFields) {
                if (!pushSettings[platform]) {
                    return;
                }

                newSettingsObject[platform] = newSettingsObject[platform] || {};
                var newPlatformSettings = pushSettings[platform];
                var settings = newSettingsObject[platform];
                _.each(allowedFields, function (allowedField) {
                    if (newPlatformSettings.hasOwnProperty(allowedField)) {
                        settings[allowedField] = newPlatformSettings[allowedField];
                    }
                });
            };

            addSettingsForPlatform(cleanSettings, 'iOS', ['badge', 'sound', 'alert', 'interactiveSettings']);
            addSettingsForPlatform(cleanSettings, 'android', ['senderID', 'projectNumber']);
            addSettingsForPlatform(cleanSettings, 'wp8', ['channelName']);

            var callbackFields = ['notificationCallbackAndroid', 'notificationCallbackIOS', 'notificationCallbackWP8'];
            _.each(callbackFields, function (callbackField) {
                var callback = pushSettings[callbackField];
                if (callback) {
                    if (typeof callback !== 'function') {
                        throw new EverliveError('The "' + callbackField + '" of the push settings should be a function');
                    }

                    cleanSettings[callbackField] = pushSettings[callbackField];
                }
            });

            if (pushSettings.customParameters) {
                cleanSettings.customParameters = pushSettings.customParameters;
            }

            return cleanSettings;
        },

        _populateRegistrationObject: function (deviceRegistration, success, error) {
            var self = this;

            return buildPromise(
                function (success, error) {
                    if (!self.pushToken) {
                        throw new EverliveError('Push token is not available.');
                    }

                    self._getLocaleName(
                        function (locale) {
                            var deviceId = self._getDeviceId();
                            var hardwareModel = device.model;
                            var platformType = self._getPlatformType(device.platform);
                            var timeZone = jstz.determine().name();
                            var pushToken = self.pushToken;
                            var language = locale.value;
                            var platformVersion = device.version;

                            deviceRegistration.HardwareId = deviceId;
                            deviceRegistration.HardwareModel = hardwareModel;
                            deviceRegistration.PlatformType = platformType;
                            deviceRegistration.PlatformVersion = platformVersion;
                            deviceRegistration.TimeZone = timeZone;
                            deviceRegistration.PushToken = pushToken;
                            deviceRegistration.Locale = language;

                            success();
                        },
                        error
                    );
                },
                success,
                error
            );
        },

        _getLocaleName: function (success, error) {
            if (this.emulatorMode) {
                success({value: 'en_US'});
            } else {
                navigator.globalization.getLocaleName(
                    function (locale) {
                        success(locale);
                    },
                    error
                );
                navigator.globalization.getLocaleName(
                    function (locale) {
                    },
                    error
                );
            }
        },

        _getDeviceId: function () {
            return device.uuid;
        },

        //Returns the Everlive device platform constant given a value aquired from cordova's device.platform.
        _getPlatformType: function (platformString) {
            var psLower = platformString.toLowerCase();
            switch (psLower) {
                case 'ios':
                case 'iphone':
                case 'ipad':
                    return Platform.iOS;
                case 'android':
                    return Platform.Android;
                case 'wince':
                    return Platform.WindowsPhone;
                case 'win32nt': // real wp8 devices return this string as platform identifier.
                    return Platform.WindowsPhone;
                default:
                    return Platform.Unknown;
            }
        },

        _deviceRegistrationFailed: function (error) {
            this.pushToken = null;
            this.isInitializing = false;
            this.isInitialized = false;

            if (this._initErrorCallback) {
                this._initErrorCallback({error: error});
            }
        },

        _deviceRegistrationSuccess: function (token) {
            this.pushToken = token;
            this.isInitializing = false;
            this.isInitialized = true;

            if (this._initSuccessCallback) {
                this._initSuccessCallback({token: token});
            }
        },

        //Occurs when the device registration in APN succeeds
        _successfulRegistrationAPN: function (token) {
            var self = this;
            if (this.pushSettings.iOS && this.pushSettings.iOS.interactiveSettings) {
                this._initializeInteractivePush(
                    this.pushSettings.iOS,
                    function () {
                        self._deviceRegistrationSuccess(token);
                    },
                    function (err) {
                        throw new EverliveError('The interactive push configuration is incorrect: ' + err);
                    }
                );
            } else {
                this._deviceRegistrationSuccess(token);
            }
        },

        //Occurs if the device registration in APN fails
        _failedRegistrationAPN: function (error) {
            this._deviceRegistrationFailed(error);
        },

        //Occurs when device registration has been successfully sent to GCM
        _successSentRegistrationGCM: function (id) {
            //console.log("Successfully sent request for registering with GCM.");
        },
        //Occurs when device registration has been successfully sent for WP8
        _successSentRegistrationWP8: function (id) {
            //console.log("Successfully sent request for registering WP8 .");
        },
        //Occurs when an error occured when sending registration request for WP8
        _errorSentRegistrationWP8: function (error) {
            this._deviceRegistrationFailed(error);
        },

        //Occurs when an error occured when sending registration request to GCM
        _errorSentRegistrationGCM: function (error) {
            this._deviceRegistrationFailed(error);
        },

        //This function receives all notification events from APN
        _onNotificationAPN: function (e) {
            this._raiseNotificationEventIOS(e);
        },
        //This function receives all notification events for WP8
        _onNotificationWP8: function (e) {
            this._raiseNotificationEventWP8(e);
        },

        //This function receives all notification events from GCM
        _onNotificationGCM: function onNotificationGCM(e) {
            switch (e.event) {
                case 'registered':
                    if (e.regid.length > 0) {
                        this._deviceRegistrationSuccess(e.regid);
                    }
                    break;
                case 'message':
                    this._raiseNotificationEventAndroid(e);
                    break;
                case 'error':
                    if (!this.pushToken) {
                        this._deviceRegistrationFailed(e);
                    } else {
                        this._raiseNotificationEventAndroid(e);
                    }
                    break;
                default:
                    this._raiseNotificationEventAndroid(e);
                    break;
            }
        },

        _raiseNotificationEventAndroid: function (e) {
            if (this.pushSettings.notificationCallbackAndroid) {
                this.pushSettings.notificationCallbackAndroid(e);
            }
        },
        _raiseNotificationEventIOS: function (e) {
            if (this.pushSettings.notificationCallbackIOS) {
                this.pushSettings.notificationCallbackIOS(e);
            }
        },
        _raiseNotificationEventWP8: function (e) {
            if (this.pushSettings.notificationCallbackWP8) {
                this.pushSettings.notificationCallbackWP8(e);
            }
        }
    };

    return CurrentDevice;
}());
},{"./EverliveError":43,"./common":53,"./constants":54,"./utils":73}],42:[function(require,module,exports){
var Setup = require('./Setup');
var Data = require('./types/Data');
var usersModule = require('./types/Users');
var filesModule = require('./types/Files');
var constants = require('./constants');
var utils = require('./utils');
var buildAuthHeader = utils.buildAuthHeader;
var Push = require('./Push');
var Authentication = require('./auth/Authentication');
var offlineModule = require('./offline/offline');
var Request = require('./Request');
var common = require('./common');
var rsvp = common.rsvp;
var _ = common._;
var EverliveError = require('./EverliveError').EverliveError;
var EverliveErrors = require('./EverliveError').EverliveErrors;
var EventEmitter = require('events').EventEmitter;

module.exports = (function () {

    // The constructor of Everlive instances.
    // The entry point for the SDK.

    /**
     * @class Everlive
     * @classdesc The constructor of the {{site.bs}} (Everlive) JavaScript SDK. This is the entry point for the SDK.
     * @param {object|string} options - An object containing configuration options for the Setup object. Alternatively, you can pass a string representing your API key.
     * @param {string} options.apiKey - Your API key.
     * @param {string} [options.url=//api.everlive.com/v1/] - The {{site.TelerikBackendServices}} URL.
     * @param {string} [options.token] - An authentication token. The instance will be associated with the provided previously obtained token.
     * @param {string} [options.tokenType=bearer] - The type of the token that is used for authentication.
     * @param {string} [options.scheme=http] - The URI scheme used to make requests. Supported values: http, https
     * @param {boolean} [options.parseOnlyCompleteDateTimeObjects=false] - If set to true, the SDK will parse only complete date strings (according to the ISO 8601 standard).
     * @param {boolean} [options.emulatorMode=false] - Set this option to true to set the SDK in emulator mode.
     * @param {object|boolean} [options.offlineStorage] - Set this option to true to use the default offline settings.
     * @param {boolean} [options.offlineStorage.autoSync=true] - Whether to sync data automatically when offing online.
     * @param {boolean} [options.offlineStorage.isOnline=true] - Whether the storage is in online mode initially.
     * @param {ConflictResolutionStrategy|function} [options.offlineStorage.conflictResolutionStrategy=ConflictResolutionStrategy.ClientWins] - A constant specifying the conflict resolution strategy or a function used to resolve the conflicts.
     * @param {StorageProvider|object} [options.offlineStorage.storageProviderSettings=StorageProvider.LocalStorage] - An object specifying settings for the offline storage provider.
     * @param {function} [options.offlineStorage.syncStart=null] - A function that is called whenever a synchronisation starts.
     * @param {function} [options.offlineStorage.syncEnd=null] - A function that is called when the synchronization completes. The function receives a list of sync errors.
     */
    function Everlive(options) {
        var self = this;
        this.setup = new Setup(options);
        _.each(initializations, function (init) {
            init.func.call(self, options);
        });

        if (Everlive.$ === null) {
            Everlive.$ = self;
        }

        this._emitter = new EventEmitter();
    }

    Everlive.prototype._emitterProxy = function (event, args) {
        this._emitter[event].apply(this._emitter, args);
    };

    Everlive.prototype.addListener = function () {
        this._emitterProxy('addListener', arguments);
    };
    Everlive.prototype.on = Everlive.prototype.addListener;

    Everlive.prototype.removeListener = function () {
        this._emitterProxy('removeListener', arguments);
    };
    Everlive.prototype.off = Everlive.prototype.removeListener;

    Everlive.prototype.once = function () {
        this._emitterProxy('once', arguments);
    };

    Everlive.prototype.removeAllListeners = function () {
        this._emitterProxy('removeAllListeners', arguments);
    };

    /** Reference to the current {{site.TelerikBackendServices}} (Everlive) JavaScript SDK
     * @memberOf Everlive
     * @type {Everlive}
     * @static
     */
    Everlive.$ = null;
    Everlive.idField = constants.idField;


    // An array keeping initialization functions called by the Everlive constructor.
    // These functions will be used to extend the functionality of an Everlive instance.
    var initializations = [];

    /** An array of functions that are invoked during instantiation of the {{site.TelerikBackendServices}} (Everlive) JavaScript SDK.
     * @memberOf Everlive
     * @type {Function[]}
     * @static
     * @private
     */
    Everlive.initializations = initializations;

    /** Creates a new {{site.TelerikBackendServices}} (Everlive) Java Script SDK instance.
     * @memberOf Everlive
     * @param {object} options - An object containing options used to initialize the {{site.bs}} JavaScript SDK instance.
     * @returns {Everlive} The instance of the {{site.bs}} (Everlive) JavaScript SDK that was created using the provided options.
     * @static
     * @method
     */
    Everlive.init = function (options) {
        Everlive.$ = null;
        return new Everlive(options);
    };

    Everlive.prototype.data = function (collectionName) {
        return new Data(this.setup, collectionName, this.offlineStorage, this);
    };

    /**
     * Returns the URL to the {{site.bs}} application endpoint that the SDK uses.
     * @memberOf Everlive.prototype
     * @method buildUrl
     * @returns {string} The generated URL.
     */
    Everlive.prototype.buildUrl = function () {
        return utils.buildUrl(this.setup);
    };

    /**
     * Generates the Authorization headers that are used by the {{site.TelerikBackendServices}} (Everlive) JavaScript SDK to make requests to the {{site.bs}} servers.
     * @memberOf Everlive
     * @returns {Object} AuthorizationHeaders The generated Authorization headers object.
     */
    Everlive.prototype.buildAuthHeader = function () {
        return buildAuthHeader(this.setup);
    };

    Everlive.disableRequestCache = function (url, method) {
        if (method === 'GET') {
            var timestamp = (new Date()).getTime();
            var separator = url.indexOf('?') > -1 ? '&' : '?';
            url += separator + '_el=' + timestamp;
        }

        return url;
    };

    Everlive.AuthStatus = constants.AuthStatus;

    /**
     * Gets the current authentication status of the {{site.TelerikBackendServices}} JavaScript SDK instance.
     * @memberOf Everlive.prototype
     * @method authInfo
     * @name authInfo
     * @returns {Promise} A promise to the authentication status.
     */
    /**
     * Gets the current authentication status of the {{site.TelerikBackendServices}} JavaScript SDK instance.
     * @memberOf Everlive.prototype
     * @method authInfo
     * @name authInfo
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    Everlive.prototype.authInfo = function (success, error) {
        var self = this;
        return utils.buildPromise(function (success, error) {
            var setup = self.setup;
            if (setup.masterKey) {
                return success({status: Everlive.AuthStatus.masterKey});
            }

            if (!setup.token) {
                return success({status: Everlive.AuthStatus.unauthenticated});
            }

            if (self.authentication && self.authentication.isAuthenticationInProgress()) {
                return success({status: Everlive.AuthStatus.authenticating});
            }

            self.Users
                .skipAuth(true)
                .currentUser()
                .then(function (res) {
                    return success({status: Everlive.AuthStatus.authenticated, user: res.result});
                }, function (err) {
                    if (self.authentication && self.authentication.isAuthenticationInProgress()) {
                        return success({status: Everlive.AuthStatus.authenticating});
                    } else if (err.code === EverliveErrors.invalidRequest.code || err.code === EverliveErrors.expiredToken.code) { // invalid request, i.e. the access token is invalid or missing
                        return success({status: Everlive.AuthStatus.invalidAuthentication});
                    } else {
                        return error(err);
                    }
                });
        }, success, error);
    };

    /**
     * Make a request to the current {{site.bs}} JavaScript SDK instance.
     * @method request
     * @memberOf Everlive.prototype
     * @param {object} options Object used to configure the request.
     * @param {object} [options.endpoint] The endpoint of the {{site.bs}} JavaScript API relative to the API key section. (For example, options.endpoint = MyType will make a request to the MyType type.)
     * @param {HttpMethod} [options.method] HTTP request method.
     * @param {object} [options.data] Data to be sent with the request.
     * @param {Function} [options.success] Success callback that will be called when the request finishes successfully.
     * @param {Function} [options.error] Error callback to be called in case of an error.
     * @param {object} [options.headers] Additional headers to be included in the request.
     * @param {Query|object} [options.filter] This is either a {@link Query} or a [filter]({% slug rest-api-querying-filtering %}) expression.
     * @param {boolean} [options.authHeaders=true] When set to false, no Authorization headers will be sent with the request.
     * @returns {function} The request configuration object containing the `send` function that sends the request.
     */
    Everlive.prototype.request = function (options) {
        return new Request(this.setup, options);
    };

    function protectOfflineEnabled() {
        if (!this._isOfflineStorageEnabled()) {
            throw new EverliveError('You have instantiated the SDK without support for offline storage');
        }
    }

    Everlive.prototype._isOfflineStorageEnabled = function () {
        return !!this.setup.offlineStorage;
    };

    /**
     * Sets the SDK to work in offline mode
     * @memberOf Everlive.prototype
     * @param {boolean} [offline] Boolean parameter for setting the SDK to online or offline mode
     */
    Everlive.prototype.offline = function () {
        protectOfflineEnabled.call(this);

        var isOffline;
        if (arguments.length === 0) {
            isOffline = true;
        } else {
            isOffline = arguments[0] == true;
        }
        this.offlineStorage._setOffline(isOffline);
    };

    /**
     * Sets the SDK to work in online mode
     * @memberOf Everlive.prototype
     * @param {boolean} [online] Boolean parameter for setting the SDK to online or offline mode
     */
    Everlive.prototype.online = function () {
        protectOfflineEnabled.call(this);

        var isOnline;
        if (arguments.length === 0) {
            isOnline = true;
        } else {
            isOnline = arguments[0] == true;
        }
        this.offlineStorage._setOffline(!isOnline);
    };

    /**
     * Check if the SDK is in offline mode
     * @memberOf Everlive.prototype
     * @returns {boolean} isOffline Returns true if the SDK is in offline mode
     */
    Everlive.prototype.isOffline = function () {
        protectOfflineEnabled.call(this);
        return !this.isOnline();
    };

    /**
     * Check if the SDK is in online mode
     * @memberOf Everlive.prototype
     * @returns {boolean} isOnline Returns true if the SDK is in online mode
     */
    Everlive.prototype.isOnline = function () {
        protectOfflineEnabled.call(this);
        return this.offlineStorage.isOnline();
    };

    /**
     * Starts the synchronization procedure. Emits the 'syncStart' event once started and the 'syncEnd' event once the procedure finishes
     * @memberOf Everlive.prototype
     */
    Everlive.prototype.sync = function () {
        protectOfflineEnabled.call(this);
        return this.offlineStorage.sync.apply(this.offlineStorage, arguments);
    };

    var initDefault = function initDefault() {
        /**
         * @memberOf Everlive
         * @instance
         * @description An instance of the [Users]{@link Users} class for working with users.
         * @member {Users} Users
         */
        this.Users = this.data('Users');
        usersModule.addUsersFunctions(this.Users, this);

        /**
         * @memberOf Everlive
         * @instance
         * @description An instance of the [Files]{@link Files} class for working with files.
         * @member {Files} Files
         */
        this.Files = this.data('Files');
        filesModule.addFilesFunctions(this.Files);

        /**
         * @memberOf Everlive
         * @instance
         * @description An instance of the [Push]{@link Push} class for working with push notifications.
         * @member {Push} push
         */
        this.push = new Push(this);
    };

    var initAuthentication = function initAuthentication() {
        /**
         * @memberOf Everlive
         * @instance
         * @description An instance of the [Authentication]{@link Authentication} class for working with the authentication of the SDK.
         * @member {Authentication} authentication
         */
        this.authentication = new Authentication(this, this.setup.authentication);
    };

    initializations.push({name: 'offlineStorage', func: offlineModule.initOfflineStorage});
    initializations.push({name: 'default', func: initDefault});
    initializations.push({name: 'authentication', func: initAuthentication});

    return Everlive;
}());

},{"./EverliveError":43,"./Push":48,"./Request":49,"./Setup":50,"./auth/Authentication":51,"./common":53,"./constants":54,"./offline/offline":60,"./types/Data":70,"./types/Files":71,"./types/Users":72,"./utils":73,"events":1}],43:[function(require,module,exports){
var EverliveErrors = {
    itemNotFound: {
        code: 801,
        message: 'Item not found.'
    },
    syncConflict: {
        code: 4242,
        message: 'A conflict occurred while syncing data.'
    },
    syncError: {
        code: 4243,
        message: 'Synchronization failed for item.'
    },
    syncInProgress: {
        code: 4244,
        message: 'Cannot perform operation while synchronization is in progress'
    },
    generalDatabaseError: {
        code: 107,
        message: 'General database error'
    },
    invalidToken: {
        code: 301,
        message: 'Invalid access token'
    },
    expiredToken: {
        code: 302,
        message: 'Expired access token'
    },
    invalidExpandExpression: {
        code: 618,
        message: 'Invalid expand expression.'
    },
    invalidRequest: {
        code: 601,
        message: 'Invalid request.'
    }
};

var EverliveError = (function () {
    function EverliveError(message, code) {
        var tmp = Error.apply(this, arguments);

        tmp.name = this.name = 'EverliveError';

        this.message = tmp.message;
        this.code = code;

        Object.defineProperty(this, 'stack', {
            get: function () {
                return tmp.stack
            }
        });

        return this;
    }

    EverliveError.prototype = Object.create(Error.prototype);
    EverliveError.prototype.toJSON = function () {
        return {
            name: this.name,
            message: this.message,
            code: this.code,
            stack: this.stack
        };
    };

    return EverliveError;
}());

var DeviceRegistrationError = (function () {
    var DeviceRegistrationError = function (errorType, message, additionalInformation) {
        EverliveError.call(this, message);
        this.errorType = errorType;
        this.message = message;
        if (additionalInformation !== undefined) {
            this.additionalInformation = additionalInformation;
        }
    };

    DeviceRegistrationError.prototype = Object.create(EverliveError.prototype);

    DeviceRegistrationError.fromEverliveError = function (everliveError) {
        var deviceRegistrationError = new DeviceRegistrationError(DeviceRegistrationErrorTypes.EverliveError, everliveError.message, everliveError);
        return deviceRegistrationError;
    };

    DeviceRegistrationError.fromPluginError = function (errorObj) {
        var message = 'A plugin error occurred';
        if (errorObj) {
            if (typeof errorObj.error === 'string') {
                message = errorObj.error;
            } else if (typeof errorObj.message === 'string') {
                message = errorObj.message;
            }
        }

        var deviceRegistrationError = new DeviceRegistrationError(DeviceRegistrationErrorTypes.PluginError, message, errorObj);
        return deviceRegistrationError;
    };

    var DeviceRegistrationErrorTypes = {
        EverliveError: 1,
        PluginError: 2
    };

    return DeviceRegistrationError;
}());

module.exports = {
    EverliveError: EverliveError,
    EverliveErrors: EverliveErrors,
    DeviceRegistrationError: DeviceRegistrationError
};
},{}],44:[function(require,module,exports){
var Processor = require('./common').Processor;
var DataQuery = require('./query/DataQuery');
var Query = require('./query/Query');
var EverliveError = require('./EverliveError').EverliveError;

module.exports = (function () {
    return new Processor({
        executionNodeFunction: function (node, expandContext, done) {
            var query = new DataQuery({
                operation: DataQuery.operations.read,
                collectionName: node.targetTypeName,
                filter: new Query(node.filter, node.select, node.sort, node.skip, node.take)
            });

            expandContext.offlineModule.processQuery(query).then(function (data) {
                done(null, data.result);
            }, done);
        }
    });
}());

},{"./EverliveError":43,"./common":53,"./query/DataQuery":63,"./query/Query":64}],45:[function(require,module,exports){
module.exports = (function () {
    function Expression(operator, operands) {
        this.operator = operator;
        this.operands = operands || [];
    }

    Expression.prototype = {
        addOperand: function (operand) {
            this.operands.push(operand);
        }
    };

    return Expression;
}());
},{}],46:[function(require,module,exports){
module.exports = (function () {
    //TODO add a function for calculating the distances in geospatial queries

    /**
     * @classdesc A class representing a value for the {{site.TelerikBackendServices}} GeoPoint field.
     * @class GeoPoint
     * @param longitude Longitude of the GeoPoint in decimal degrees (range: -180 to 180). Example: `123.3239467`
     * @param latitude Latitude of the GeoPoint in decimal degrees (range: -90 to 90). Example: `42.6954322`
     */
    function GeoPoint(longitude, latitude) {
        this.longitude = longitude || 0;
        this.latitude = latitude || 0;
    }

    return GeoPoint;
}());
},{}],47:[function(require,module,exports){
var platform = require('./everlive.platform');
var isNativeScript = platform.isNativeScript;
var isNodejs = platform.isNodejs;
var constants = require('./constants');

module.exports = (function () {
    'use strict';

    function getLocalStorage(sdk) {
        if (isNativeScript) {
            var localSettings = require('application-settings');

            return {
                getItem: function (key) {
                    return localSettings.getString(key);
                },

                removeItem: function (key) {
                    return localSettings.remove(key);
                },

                setItem: function (key, value) {
                    return localSettings.setString(key, value);
                }
            };
        } else {
            var localStorage;
            if (isNodejs) {
                var LocalStorage = require('node-localstorage').LocalStorage;
                localStorage = new LocalStorage(sdk.offlineStorage.setup.storage.storagePath);
            } else {
                localStorage = window.localStorage;
            }

            return {
                getItem: function (key) {
                    return localStorage.getItem(key);
                },

                removeItem: function (key) {
                    return localStorage.removeItem(key);
                },

                setItem: function (key, value) {
                    return localStorage.setItem(key, value);
                }
            };
        }
    }

    function LocalStore(sdk) {
        this.sdk = sdk;
        this._localStorage = getLocalStorage(this.sdk);
    }

    LocalStore.prototype = {
        getItem: function (key) {
            return this._localStorage.getItem(key);
        },

        removeItem: function (key) {
            return this._localStorage.removeItem(key);
        },

        setItem: function (key, value) {
            return this._localStorage.setItem(key, value);
        }
    };

    return LocalStore;
}());
},{"./constants":54,"./everlive.platform":56,"application-settings":"application-settings","node-localstorage":"node-localstorage"}],48:[function(require,module,exports){
var utils = require('./utils');
var buildPromise = utils.buildPromise;
var DeviceRegistrationResult = utils.DeviceRegistrationResult;
var everliveErrorModule = require('./EverliveError');
var DeviceRegistrationError = everliveErrorModule.DeviceRegistrationError;
var EverliveError = everliveErrorModule.EverliveError;
var CurrentDevice = require('./CurrentDevice');
var Platform = require('./constants').Platform;

module.exports = (function () {
    /**
     * @class Push
     * @classdesc A class for managing push notifications in your application. Supported are push notifications for hybrid apps on Android and iOS.
     * @protected
     * @param el {Everlive} Everlive Object
     */
    function Push(el) {
        this._el = el;
        this.notifications = el.data('Push/Notifications');
        this.devices = el.data('Push/Devices');
    }

    Push.prototype = {

        /**
         * Ensures that the Telerik Push Notifications plug-in has been loaded and is ready to use. An {EverliveError} is returned if the plug-in is not available.
         * @method ensurePushIsAvailable
         * @memberOf Push.prototype
         */
        ensurePushIsAvailable: function () {
            var isPushNotificationPluginAvailable = (typeof window !== 'undefined' && window.plugins && window.plugins.pushNotification);

            if (!isPushNotificationPluginAvailable) {
                throw new EverliveError("The push notification plugin is not available. Ensure that the pushNotification plugin is included " +
                "and use after `deviceready` event has been fired.");
            }
        },
        /**
         * Returns the current device for sending push notifications
         * @deprecated since version 1.2.7
         * @see [Push.register]{@link push.register}
         * @memberOf Push.prototype
         * @method currentDevice
         * @name currentDevice
         * @param [emulatorMode] {Boolean} If set to true, emulator mode is enabled meaning you cannot send push notifications.
         * @returns {CurrentDevice} Returns an instance of CurrentDevice.
         */
        currentDevice: function (emulatorMode) {
            this.ensurePushIsAvailable();

            if (arguments.length === 0) {
                emulatorMode = this._el.setup._emulatorMode;
            }

            if (!window.cordova) {
                throw new EverliveError('Error: currentDevice() can only be called from within a hybrid mobile app, after \'deviceready\' event has been fired.');
            }

            if (!this._currentDevice) {
                this._currentDevice = new CurrentDevice(this);
            }

            this._currentDevice.emulatorMode = emulatorMode;

            return this._currentDevice;
        },

        /**
         * Enables push notifications on the device and registers it for the feature with {{site.TelerikBackendServices}} if it hasn't already been registered. If it has been registered, the registration details are updated.
         * @method register
         * @name register
         * @memberOf Push.prototype
         * @param {Object} settings An object containing settings for the registration. It can include custom parameters to be stored by {{site.bs}}.
         * @param {Object} settings.iOS=null iOS-specific settings.
         * @param {Boolean} settings.iOS.alert=true If set to true, the push notification will display as a standard iOS alert.
         * @param {String|Number} settings.iOS.badge='+1' Specifies the badge counter to be displayed on the device.
         * @param {Boolean} settings.iOS.sound=true If set to true, the device will play a notification sound.
         * @param {Object} settings.android=null Android-specific settings.
         * @param {String} settings.android.senderID=null Your Google API project number. It is required when obtaining a push token for an Android device.
         * @param {String} settings.android.projectNumber=null Synonym for android.senderID. Available in JavaScript SDK versions 1.2.7 and later.
         * @param {Object} settings.wp8=null Windows Phone specific settings.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Enables push notifications on the device and registers it for the feature with {{site.TelerikBackendServices}} if it hasn't already been registered. If it has been registered, the registration details are updated.
         * Telerik Backend Services if it hasn't already been registered.
         * If it was registered the registration details are updated.
         * @method register
         * @name register
         * @memberOf Push.prototype
         * @param {Object} settings Settings for the registration. Can include custom parameters to be saved in backend services.
         * @param {Object} settings.iOS=null iOS specific settings
         * @param {Boolean} settings.iOS.alert=true Specifies whether the device will display an alert message.
         * @param {String|Number} settings.iOS.badge='+1' Specifies the badge counter to be displayed on the device.
         * @param {Boolean} settings.iOS.sound=true Specifies whether the device will play a sound.
         * @param {Object} settings.android=null Android specific settings
         * @param {String} settings.android.senderID=null This is your Google API project number. It is required when obtaining a push token for an Android device.
         * @param {String} settings.android.projectNumber=null Synonym for android.senderID. Available in JavaScript SDK versions 1.2.7 and later.
         * @param {Object} settings.wp8=null Windows Phone specific settings
         * @param {Function} [success] Callback to invoke on success.
         * @param {Function} [error] Callback to invoke on error.
         */
        register: function (settings, success, error) {
            this.ensurePushIsAvailable();

            var currentDevice = this.currentDevice();
            var self = this;
            settings = settings || {};

            if (settings.android) {
                settings.android.senderID = settings.android.projectNumber || settings.android.senderID;
            }

            var successCallback = function (token, callback) {
                var result = new DeviceRegistrationResult(token);
                callback(result);
            };

            var errorCallback = function (err, callback) {
                var registrationError = DeviceRegistrationError.fromEverliveError(err);
                callback(registrationError);
            };

            var clearBadgeIfNeeded = function (token, successCb, errorCb) {
                var platformType = currentDevice._getPlatformType(device.platform);
                var clearBadge = platformType === Platform.iOS;

                if (clearBadge && settings.iOS) {
                    clearBadge = settings.iOS.clearBadge !== false;
                }

                if (clearBadge) {
                    self.clearBadgeNumber().then(function () {
                        successCallback(token, successCb);
                    }, function (err) {
                        errorCallback(err, errorCb);
                    });
                } else {
                    successCallback(token, successCb);
                }
            };

            return buildPromise(function (successCb, errorCb) {
                currentDevice.enableNotifications(settings, function (response) {
                    var token = response.token;
                    var customParameters = settings.customParameters;
                    currentDevice.getRegistration()
                        .then(function () {
                            currentDevice.updateRegistration(customParameters, function () {
                                clearBadgeIfNeeded(token, successCb, errorCb);
                            }, function (err) {
                                errorCallback(err, errorCb);
                            });
                        }, function (err) {
                            if (err.code === 801) { //Not registered
                                currentDevice.register(customParameters, function () {
                                    clearBadgeIfNeeded(token, successCb, errorCb);
                                }, errorCb);
                            } else {
                                errorCallback(err, errorCb);
                            }
                        });
                }, function (err) {
                    var deviceRegistrationError = DeviceRegistrationError.fromPluginError(err);
                    errorCb(deviceRegistrationError);
                });
            }, success, error);
        },

        /**
         * Disables push notifications for the current device. This method invalidates any push tokens that were obtained for the device from the current application. The device will also be unregistered from {{site.TelerikBackendServices}}.
         * @method unregister
         * @name unregister
         * @memberOf Push.prototype
         * @returns {Promise} The promise for the request.
         */
        /**
         * Disables push notifications for the current device. This method invalidates any push tokens that were obtained for the device from the current application. The device will also be unregistered from {{site.TelerikBackendServices}}.
         * This method invalidates any push tokens that were obtained for the device from the current application.
         * The device will also be unregistered from Telerik Backend Services.
         * @method unregister
         * @name unregister
         * @memberOf Push.prototype
         * @param {Function} [onSuccess] Callback to invoke on success.
         * @param {Function} [onError] Callback to invoke on error.
         */
        unregister: function (onSuccess, onError) {
            this.ensurePushIsAvailable();

            var currentDevice = this.currentDevice();
            return currentDevice.disableNotifications.apply(currentDevice, arguments);
        },

        /**
         * Updates the registration of the current device.
         * @method updateRegistration
         * @name updateRegistration
         * @memberOf Push.prototype
         * @param {Object} customParameters Custom parameters for the registration. If {undefined}, customParameters are not updated.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Updates the registration for the current device.
         * @method updateRegistration
         * @name updateRegistration
         * @memberOf Push.prototype
         * @param {Object} customParameters Custom parameters for the registration. If {undefined}, customParameters are not updated.
         * @param {Function} [onSuccess] Callback to invoke on success.
         * @param {Function} [onError] Callback to invoke on error.
         */
        updateRegistration: function (customParameters, onSuccess, onError) {
            this.ensurePushIsAvailable();

            var currentDevice = this.currentDevice();
            return currentDevice.updateRegistration.apply(currentDevice, arguments);
        },

        /**
         * Sets the badge number on the {{site.TelerikBackendServices}} server.
         * @method setBadgeNumber
         * @name setBadgeNumber
         * @memberOf Push.prototype
         * @param {Number|String} badge The number to be set as a badge.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Sets the badge number on the server
         * @method setBadgeNumber
         * @name setBadgeNumber
         * @memberOf Push.prototype
         * @param {Number|String} badge The number to be set as a badge.
         * @param {Function} [onSuccess] Callback to invoke on success.
         * @param {Function} [onError] Callback to invoke on error.
         */
        setBadgeNumber: function (badge, onSuccess, onError) {
            this.ensurePushIsAvailable();

            badge = parseInt(badge);
            if (isNaN(badge)) {
                return buildPromise(function (success, error) {
                    error(new EverliveError('The badge must have a numeric value'));
                }, onSuccess, onError);
            }

            var deviceRegistration = {};
            var currentDevice = this.currentDevice();
            var deviceId = currentDevice._getDeviceId();
            deviceRegistration.Id = 'HardwareId/' + encodeURIComponent(deviceId);
            deviceRegistration.BadgeCounter = badge;
            return buildPromise(function (successCb, errorCb) {
                currentDevice._pushHandler.devices.updateSingle(deviceRegistration).then(
                    function () {
                        if (window.plugins && window.plugins.pushNotification) {
                            return window.plugins.pushNotification.setApplicationIconBadgeNumber(successCb, errorCb, badge);
                        } else {
                            return successCb();
                        }
                    }, errorCb)
            }, onSuccess, onError);
        },

        /**
         * Resets the badge number on the {{site.TelerikBackendServices}} server to 0.
         * @method clearBadgeNumber
         * @name clearBadgeNumber
         * @memberOf Push.prototype
         * @returns {Promise} The promise for the request.
         */
        /**
         * Clears the badge number on the server by setting it to 0
         * @method clearBadgeNumber
         * @name clearBadgeNumber
         * @memberOf Push.prototype
         * @param {Function} [onSuccess] Callback to invoke on success.
         * @param {Function} [onError] Callback to invoke on error.
         */
        clearBadgeNumber: function (onSuccess, onError) {
            this.ensurePushIsAvailable();

            return this.setBadgeNumber(0, onSuccess, onError);
        },

        /**
         * Returns the push notifications registration for the current device.
         * @method getRegistration
         * @name getRegistration
         * @memberOf Push.prototype
         * @returns {Promise} The promise for the request.
         */
        /**
         * Returns the push registration for the current device.
         * @method getRegistration
         * @name getRegistration
         * @memberOf Push.prototype
         * @param {Function} [onSuccess] Callback to invoke on success.
         * @param {Function} [onError] Callback to invoke on error.
         */
        getRegistration: function (onSuccess, onError) {
            this.ensurePushIsAvailable();

            var currentDevice = this.currentDevice();
            return currentDevice.getRegistration.apply(currentDevice, arguments);
        },

        /**
         * Sends a push notification.
         * @method send
         * @name send
         * @memberOf Push.prototype
         * @param {Object} notification The push notification object
         * @returns {Promise} The promise for request.
         */
        /**
         * Sends a push message
         * @method send
         * @name send
         * @memberOf Push.prototype
         * @param {Object} notification The push notification object
         * @param {Function} [onSuccess] Callback to invoke on success.
         * @param {Function} [onError] Callback to invoke on error.
         */
        send: function (notification, onSuccess, onError) {
            this.ensurePushIsAvailable();

            return this.notifications.create.apply(this.notifications, arguments);
        },

        /**
         * This method provides a different operation on each supported platform:
         *
         * - On iOS: Checks if Notifications is enabled for this application in the device's Notification Center.
         * - On Windows Phone: Checks if the application has an active open channel for communication with the Microsoft Push Notification Service. The outcome does not depend on the device's notification settings.
         * - On Android: Checks if the application has established a connection with Google Cloud Messaging. The outcome does not depend on the device's notification settings.
         * @method areNotificationsEnabled
         * @name areNotificationsEnabled
         * @memberOf Push.prototype
         * @param {Object} options An object passed to the Push Notification plugin's areNotificationsEnabled method
         * @returns {Promise} The promise for the request.
         */
        /**
         * iOS: Checks if the Notifications are enabled for this Application in the Device's Notification Center.
         * Windows Phone: Checks if the Application has an active opened Channel for communication with the Notification Service. Not relying on the device notification settings.
         * Android: Checks if the Application has established connection with the Notification Service. Not relying on the device notification settings.
         * @method areNotificationsEnabled
         * @name areNotificationsEnabled
         * @memberOf Push.prototype
         * @param {Object} options an object passed to the Push Notification plugin's areNotificationsEnabled method.
         * @param {Function} [onSuccess] Callback to invoke on successful check. Passes a single boolean value: true or false.
         * @param {Function} [onError] Callback to invoke when an error in the push plugin has occurred.
         */
        areNotificationsEnabled: function (options, onSuccess, onError) {
            this.ensurePushIsAvailable();

            options = options || {};
            var pushNotification = window.plugins.pushNotification;

            return buildPromise(function (successCb, errorCb) {
                pushNotification.areNotificationsEnabled(successCb, errorCb, options);
            }, onSuccess, onError);
        }
    };

    return Push;
}());
},{"./CurrentDevice":41,"./EverliveError":43,"./constants":54,"./utils":73}],49:[function(require,module,exports){
var utils = require('./utils');
var rsvp = require('./common').rsvp;
var buildAuthHeader = utils.buildAuthHeader;
var parseUtilities = utils.parseUtilities;
var guardUnset = utils.guardUnset;
var common = require('./common');
var reqwest = common.reqwest;
var _ = common._;
var Headers = require('./constants').Headers;
var isNodejs = require('./everlive.platform').isNodejs;

module.exports = (function () {
    var _self;

    // The Request type is an abstraction over Ajax libraries
    // A Request object needs information about the Everlive connection and initialization options

    function Request(setup, options) {
        guardUnset(setup, 'setup');
        guardUnset(options, 'options');
        this.setup = setup;
        this.method = null;
        this.endpoint = null;
        this.data = null;
        this.headers = {};
        // TODO success and error callbacks should be uniformed for all ajax libs
        this.success = null;
        this.error = null;
        this.parse = Request.parsers.simple;

        _.extend(this, options);
        _self = this;
        this._init(options);
    }

    Request.prototype = {
        // Calls the underlying Ajax library
        send: function () {
            Request.sendRequest(this);
        },
        // Returns an authorization header used by the request.
        // If there is a logged in user for the Everlive instance then her/his authentication will be used.
        buildAuthHeader: buildAuthHeader,
        // Builds the URL of the target Everlive service
        buildUrl: function buildUrl(setup) {
            return utils.buildUrl(setup);
        },
        // Processes the given query to return appropriate headers to be used by the request
        buildQueryHeaders: function buildQueryHeaders(query) {
            if (query) {
                if (query instanceof Everlive.Query) {
                    return Request.prototype._buildQueryHeaders(query);
                }
                else {
                    return Request.prototype._buildFilterHeader(query);
                }
            }
            else {
                return {};
            }
        },
        // Initialize the Request object by using the passed options
        _init: function (options) {
            _.extend(this.headers, this.buildAuthHeader(this.setup, options), this.buildQueryHeaders(options.filter), options.headers);
        },
        // Translates an Everlive.Query to request headers
        _buildQueryHeaders: function (query) {
            query = query.build();
            var headers = {};
            if (query.$where !== null) {
                headers[Headers.filter] = JSON.stringify(query.$where);
            }
            if (query.$select !== null) {
                headers[Headers.select] = JSON.stringify(query.$select);
            }
            if (query.$sort !== null) {
                headers[Headers.sort] = JSON.stringify(query.$sort);
            }
            if (query.$skip !== null) {
                headers[Headers.skip] = query.$skip;
            }
            if (query.$take !== null) {
                headers[Headers.take] = query.$take;
            }
            if (query.$expand !== null) {
                headers[Headers.expand] = JSON.stringify(query.$expand);
            }
            return headers;
        },
        // Creates a header from a simple filter
        _buildFilterHeader: function (filter) {
            var headers = {};
            headers[Headers.filter] = JSON.stringify(filter);
            return headers;
        }
    };

    var parseOnlyCompleteDateTimeString = _self && _self.setup && _self.setup.parseOnlyCompleteDateTimeObjects;

    var reviver = parseUtilities.getReviver(parseOnlyCompleteDateTimeString);

    Request.parsers = {
        simple: {
            result: parseUtilities.parseResult.bind(null, reviver),
            error: parseUtilities.parseError.bind(null, reviver)
        },
        single: {
            result: parseUtilities.parseSingleResult.bind(null, reviver),
            error: parseUtilities.parseError.bind(null, reviver)
        },
        update: {
            result: parseUtilities.parseUpdateResult.bind(null, reviver),
            error: parseUtilities.parseError.bind(null, reviver)
        }
    };

    // TODO built for request
    if (typeof Request.sendRequest === 'undefined') {
        Request.sendRequest = function (request) {
            var url = request.buildUrl(request.setup) + request.endpoint;
            url = Everlive.disableRequestCache(url, request.method);
            var data = request.method === 'GET' ? request.data : JSON.stringify(request.data);

            var requestParams = {
                url: url,
                method: request.method,
                data: data,
                headers: request.headers,
                contentType: 'application/json'
            };

            if (isNodejs) {
                requestParams.success = function (data, response) {
                    request.success.call(request, request.parse.result(data), response);
                };

                requestParams.error = function (jqXHR) {
                    request.error.call(request, request.parse.error(jqXHR.responseText || jqXHR.statusText));
                };
            } else {
                requestParams.type = 'json';
                requestParams.crossOrigin = true;
                requestParams.success = function (data, textStatus, jqXHR) {
                    var result = request.parse.result(data);
                    request.success.call(request, result);
                };

                requestParams.error = function (jqXHR, textStatus, errorThrown) {
                    var error = request.parse.error(jqXHR.responseText || jqXHR.statusText);
                    request.error.call(request, error);
                };
            }

            reqwest(requestParams);
        };
    }

    return Request;
}());
},{"./common":53,"./constants":54,"./everlive.platform":56,"./utils":73}],50:[function(require,module,exports){
var _ = require('./common')._;
var constants = require('./constants');
var AuthenticationSetup = require('./auth/AuthenticationSetup');

module.exports = (function () {
    var everliveUrl = constants.everliveUrl;

    // An object that keeps information about an Everlive connection
    function Setup(options) {
        this.url = everliveUrl;
        this.apiKey = null;
        this.masterKey = null;
        this.token = null;
        this.tokenType = null;
        this.principalId = null;
        this.scheme = 'http'; // http or https
        this.parseOnlyCompleteDateTimeObjects = false;
        if (typeof options === 'string') {
            this.apiKey = options;
        } else {
            this._emulatorMode = options.emulatorMode;
            _.extend(this, options);
        }

        this.authentication = new AuthenticationSetup(this, options.authentication);
    }

    Setup.prototype.setAuthorizationProperties = function (token, tokenType, principalId) {
        this.token = token;
        this.tokenType = tokenType;
        this.principalId = principalId;
    };

    Setup.prototype.getAuthorizationProperties = function () {
        return {
            token: this.token,
            tokenType: this.tokenType,
            principalId: this.principalId
        };
    };

    return Setup;

}());
},{"./auth/AuthenticationSetup":52,"./common":53,"./constants":54}],51:[function(require,module,exports){
'use strict';
var utils = require('../utils');
var DataQuery = require('../query/DataQuery');
var Request = require('../Request');
var Everlive = require('../Everlive');
var constants = require('../constants');
var usersCollectionName = 'Users';
var buildPromise = utils.buildPromise;
var LocalStore = require('../LocalStore');
var EverliveErrors = require('../EverliveError').EverliveErrors;

module.exports = (function () {
    /**
     * @class Authentication
     * @classdesc A class for managing authentication of a user in your application.
     * @protected
     * @param el {Everlive} Everlive Object
     * @param setup {AuthSetup} the authentication setup object
     */
    var Authentication = function (el, setup) {
        this.authSetup = setup || {};
        this._el = el;
        this._authenticationCallbacks = null;
        this._localStore = new LocalStore(el);
        if (this.authSetup.persist) {
            var self = this;
            var localStoreKey = this._getLocalStoreKey();
            var authOptions = this._localStore.getItem(localStoreKey);
            var authInfo;
            if (authOptions) {
                authInfo = JSON.parse(this._localStore.getItem(localStoreKey));
            }
            if (authInfo) {
                self._el.setup.setAuthorizationProperties(authInfo.token, authInfo.tokenType, authInfo.principalId);
            }
        }
    };

    /**
     *
     * Logs in a user using a username and a password to the current {{site.bs}} JavaScript SDK instance. All requests initiated by the current {{site.bs}} JavaScript SDK instance will be authenticated with that user's credentials.
     * @memberOf Authentication.prototype
     * @method login
     * @name login
     * @param {string} username The user's username.
     * @param {string} password The user's password.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Logs in a user using a username and a password to the current {{site.bs}} JavaScript SDK instance. All requests initiated by the current {{site.bs}} JavaScript SDK instance will be authenticated with that user's credentials.
     * @memberOf Authentication.prototype
     * @method login
     * @name login
     * @param {string} username The user's username.
     * @param {string} password The user's password.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    Authentication.prototype.login = function (username, password, success, error) {
        var self = this;
        return buildPromise(function (success, error) {
            var successFunc = function () {
                self._loginSuccess.apply(self, arguments);
                success.apply(null, arguments);
            };

            var query = new DataQuery({
                operation: DataQuery.operations.userLogin,
                collectionName: usersCollectionName,
                data: {
                    username: username,
                    password: password,
                    grant_type: 'password'
                },
                skipAuth: true,
                onSuccess: successFunc,
                onError: error
            });

            return self._el.Users.processDataQuery(query);
        }, success, error);
    };

    /**
     * Log out the user who is currently logged in.
     * @memberOf Authentication.prototype
     * @method logout
     * @name logout
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log out the user who is currently logged in.
     * @memberOf Authentication.prototype
     * @method logout
     * @name logout
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    Authentication.prototype.logout = function (success, error) {
        var self = this;
        return buildPromise(function (success, error) {
            var successFunc = function () {
                self._logoutSuccess.apply(self, arguments);
                success.apply(null, arguments);
            };

            var errorFunc = function (err) {
                if (err.code === 301) { //invalid token
                    self.clearAuthorization();
                }

                error.apply(null, arguments);
            };

            var query = new DataQuery({
                operation: DataQuery.operations.userLogout,
                collectionName: usersCollectionName,
                skipAuth: true,
                onSuccess: successFunc,
                onError: errorFunc
            });

            return self._el.Users.processDataQuery(query);
        }, success, error);
    };

    Authentication.prototype._getLocalStoreKey = function () {
        return constants.AuthStoreKey + this._el.setup.apiKey + '$authentication';
    };

    /**
     * Log in a user using an Facebook access token.
     * @memberOf Authentication.prototype
     * @method loginWithFacebook
     * @name loginWithFacebook
     * @param {string} accessToken Facebook access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using an Facebook access token.
     * @memberOf Authentication.prototype
     * @method loginWithFacebook
     * @name loginWithFacebook
     * @param {string} accessToken Facebook access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    Authentication.prototype.loginWithFacebook = function (accessToken, success, error) {
        var identity = {
            Provider: 'Facebook',
            Token: accessToken
        };
        return this._loginWithProvider(identity, success, error);
    };

    /**
     * Log in a user using an ADFS access token.
     * @memberOf Authentication.prototype
     * @method loginWithADFS
     * @name loginWithADFS
     * @param {string} accessToken ADFS access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using an ADFS access token.
     * @memberOf Authentication.prototype
     * @method loginWithADFS
     * @name loginWithADFS
     * @param {string} accessToken ADFS access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    Authentication.prototype.loginWithADFS = function (accessToken, success, error) {
        var identity = {
            Provider: 'ADFS',
            Token: accessToken
        };
        return this._loginWithProvider(identity, success, error);
    };

    /**
     * Log in a user using a LiveID access token.
     * @memberOf Authentication.prototype
     * @method loginWithLiveID
     * @name loginWithLiveID
     * @param {string} accessToken LiveID access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using a LiveID access token.
     * @memberOf Authentication.prototype
     * @method loginWithLiveID
     * @name loginWithLiveID
     * @param {string} accessToken LiveID access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    Authentication.prototype.loginWithLiveID = function (accessToken, success, error) {
        var identity = {
            Provider: 'LiveID',
            Token: accessToken
        };
        return this._loginWithProvider(identity, success, error);
    };

    /**
     * Log in a user using a Google access token.
     * @memberOf Authentication.prototype
     * @method loginWithGoogle
     * @name loginWithGoogle
     * @param {string} accessToken Google access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using a Google access token.
     * @memberOf Authentication.prototype
     * @method loginWithGoogle
     * @name loginWithGoogle
     * @param {string} accessToken Google access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    Authentication.prototype.loginWithGoogle = function (accessToken, success, error) {
        var identity = {
            Provider: 'Google',
            Token: accessToken
        };

        return this._loginWithProvider(identity, success, error);
    };

    /**
     * Log in a user with a Twitter token. A secret token needs to be provided.
     * @memberOf Authentication.prototype
     * @method loginWithTwitter
     * @name loginWithTwitter
     * @param {string} token Twitter token.
     * @param {string} tokenSecret Twitter secret token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user with a Twitter token. A secret token needs to be provided.
     * @memberOf Authentication.prototype
     * @method loginWithTwitter
     * @name loginWithTwitter
     * @param {string} token Twitter token.
     * @param {string} tokenSecret Twitter secret token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    Authentication.prototype.loginWithTwitter = function (token, tokenSecret, success, error) {
        var identity = {
            Provider: 'Twitter',
            Token: token,
            TokenSecret: tokenSecret
        };

        return this._loginWithProvider(identity, success, error);
    };

    /**
     * Sets the token and token type that the {{site.TelerikBackendServices}} JavaScript SDK will use for authorization.
     * @memberOf Authentication.prototype
     * @method setAuthorization
     * @param {string} token Token that will be used for authorization.
     * @param {Everlive.TokenType} tokenType Token type. Currently only 'bearer' token is supported.
     * @param {string} principalId The id of the user that is logged in.
     */
    Authentication.prototype.setAuthorization = function setAuthorization(token, tokenType, principalId) {
        this._el.setup.setAuthorizationProperties(token, tokenType, principalId);

        if (this.authSetup.persist) {
            var localStoreKey = this._getLocalStoreKey();
            var authorizationProperties = this._el.setup.getAuthorizationProperties();
            this._localStore.setItem(localStoreKey, JSON.stringify(authorizationProperties));
        }

        if (this._authenticationCallbacks) {
            this._authenticationCallbacks.success();
            this._authenticationCallbacks = null;
        }
    };

    /**
     * Clears the authentication token that the {{site.bs}} JavaScript SDK currently uses. Note that this is different than logging out, because the authorization token that was used, will not be invalidated.
     * @method clearAuthorization
     * @memberOf Authentication.prototype
     */
    Authentication.prototype.clearAuthorization = function clearAuthorization() {
        this.setAuthorization(null, null, null);
        this.clearPersistedAuthentication();
    };

    /**
     * Clears the current persisted authentication from the local store for the current {{site.bs}} JavaScript SDK instance. Will not logout or modify the current authentication of the Javascript SDK.
     * @method clearPersistedAuthentication
     * @memberOf Authentication.prototype
     */
    Authentication.prototype.clearPersistedAuthentication = function () {
        if (this._localStore) {
            var localStoreKey = this._getLocalStoreKey();
            this._localStore.removeItem(localStoreKey);
        }
    };

    /**
     * @memberOf Authentication.prototype
     * Returns whether authentication requirement is enabled for the current instance of the {{site.bs}} JavaScript SDK.
     * @returns {boolean} whether an onAuthenticationRequired function is provided
     */
    Authentication.prototype.isAuthenticationInProgress = function () {
        return typeof this.authSetup.onAuthenticationRequired === 'function';
    };

    /** Ensures that authentication is completed before continuing.
     * @memberOf Authentication.prototype
     * @private
     * @returns {Promise} A promise that will be resolved when the authentication is complete. See {{@link Everlive.prototype.completeAuthentication}}.
     * @throws throws an error if no onAuthenticationRequired handler is provided to the setup.
     */
    Authentication.prototype._ensureAuthentication = function () {
        if (!this.isAuthenticationInProgress()) {
            throw new Error('onAuthenticationRequired option of Everlive.Setup.Authentication is required.');
        }
        if (this.isAuthenticating()) {
            return this._authenticationCallbacks.promise;
        }
        this.clearAuthorization();
        this.authSetup.onAuthenticationRequired.call(this);
        this._authenticationCallbacks = utils.getCallbacks();
        return this._authenticationCallbacks.promise;
    };

    /**
     * A method that should be called with the authentication result.
     * @memberOf Authentication.prototype
     * @param authentication authentication object containing information about the
     * @param authentication.access_token
     * @param authentication.token_type
     * @param authentication.principal_id
     */
    Authentication.prototype.completeAuthentication = function (authentication) {
        this._el.setAuthorization(authentication.access_token, authentication.token_type, authentication.principal_id);
    };
    /**
     * Gets the current authentication status of the {{site.TelerikBackendServices}} JavaScript SDK instance.
     * @memberOf Authentication.prototype
     * @method getAuthenticationStatus
     * @name getAuthenticationStatus
     * @returns {Promise} A promise to the authentication status.
     */
    /**
     * Gets the current authentication status of the {{site.TelerikBackendServices}} JavaScript SDK instance.
     * @memberOf Authentication.prototype
     * @method getAuthenticationStatus
     * @name getAuthenticationStatus
     * @param {Everlive.Callbacks.authenticationStatusSuccess} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    Authentication.prototype.getAuthenticationStatus = function (success, error) {
        var self = this;
        return utils.buildPromise(function (success, error) {
            var setup = self._el.setup;
            if (setup.masterKey) {
                return success({status: constants.AuthStatus.masterKey});
            }

            if (!setup.token) {
                return success({status: constants.AuthStatus.unauthenticated});
            }

            if (self.isAuthenticationInProgress()) {
                return success({status: constants.AuthStatus.authenticating});
            }

            self._el.Users
                .skipAuth(true)
                .currentUser()
                .then(function (res) {
                    return success({status: constants.AuthStatus.authenticated, user: res.result});
                }, function (err) {
                    if (self.isAuthenticationInProgress()) {
                        return success({status: constants.AuthStatus.authenticating});
                    } else if (err.code === EverliveErrors.invalidRequest.code || err.code === EverliveErrors.invalidToken.code) { // invalid request, i.e. the access token is invalid or missing
                        return success({status: constants.AuthStatus.invalidAuthentication});
                    } else if (err.code === EverliveErrors.expiredToken.code) {
                        return success({status: constants.AuthStatus.expiredAuthentication});
                    } else {
                        return error(err);
                    }
                });
        }, success, error);
    };

    /** Returns whether the {{site.TelerikBackendServices}} is currently waiting for authentication to be completed. See {{@link Everlive.prototype.completeAuthentication}}.
     * @memberOf Everlive.prototype
     * @returns {boolean}
     */
    Authentication.prototype.isAuthenticating = function () {
        return !!this._authenticationCallbacks;
    };

    Authentication.prototype._loginSuccess = function (data) {
        var result = data.result;
        this.setAuthorization(result.access_token, result.token_type, result.principal_id);
    };

    Authentication.prototype._logoutSuccess = function () {
        this.clearAuthorization();
    };

    Authentication.prototype._loginWithProvider = function (identity, success, error) {
        var user = {
            Identity: identity
        };
        var self = this;
        return buildPromise(function (success, error) {
            var successFunc = function () {
                self._loginSuccess.apply(self, arguments);
                success.apply(null, arguments);
            };

            var query = new DataQuery({
                operation: DataQuery.operations.userLoginWithProvider,
                collectionName: usersCollectionName,
                data: user,
                authHeaders: false,
                skipAuth: true,
                parse: Request.parsers.single,
                onSuccess: successFunc,
                onError: error
            });

            self._el.Users.processDataQuery(query);
        }, success, error);
    };

    return Authentication;
}());

},{"../Everlive":42,"../EverliveError":43,"../LocalStore":47,"../Request":49,"../constants":54,"../query/DataQuery":63,"../utils":73}],52:[function(require,module,exports){
'use strict';
var AuthenticationSetup = function (everlive, options) {
    options = options || {};
    this.onAuthenticationRequired = options.onAuthenticationRequired;
    this.persist = options.persist;
};

module.exports = AuthenticationSetup;
},{}],53:[function(require,module,exports){
(function (global){
module.exports = (function () {
    var common = {};

    var platform = require('./everlive.platform');
    var isNativeScript = platform.isNativeScript;
    var isNodejs = platform.isNodejs;

    if (!isNodejs && !isNativeScript) {
        common.reqwest = require('reqwest');
    } else if (isNativeScript) {
        common.root = global;
        common.reqwest = require('./reqwest.nativescript');
    } else if (isNodejs) {
        common.root = global;
        common.reqwest = require('./reqwest.nodejs');
    }

    if (!common.root) {
        //browser/requirejs/cordova
        common.root = window;
    }

    var ensureDependency = function ensureDependency(globalName, localName) {
        if (!localName) {
            localName = globalName;
        }

        if (!Object.keys(common[localName]).length) {
            common[localName] = common.root[globalName];
        }
    };

    //for the everlive bundle without dependencies included browserify replaces them with empty objects
    common._ = require('underscore');
    ensureDependency('_');

    common.jstz = require('jstimezonedetect').jstz;
    ensureDependency('jstz');

    common.mongoQuery = require('mongo-query');
    ensureDependency('mongoQuery');

    common.Mingo = require('mingo');
    ensureDependency('Mingo');

    common.uuid = require('uuid');
    ensureDependency('uuid');

    common.Processor = require('../scripts/bs-expand-processor');
    ensureDependency('Processor');

    common.rsvp = require('rsvp');
    ensureDependency('RSVP', 'rsvp');

    if (!isNodejs && !isNativeScript) {
        ensureDependency('reqwest');
    }

    return common;
}());
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../scripts/bs-expand-processor":36,"./everlive.platform":56,"./reqwest.nativescript":68,"./reqwest.nodejs":69,"jstimezonedetect":6,"mingo":7,"mongo-query":9,"reqwest":28,"rsvp":29,"underscore":30,"uuid":32}],54:[function(require,module,exports){
var constants = {
    idField: 'Id',
    guidEmpty: '00000000-0000-0000-0000-000000000000',
    everliveUrl: '//api.everlive.com/v1/',
    /**
     * A class used to represent the conflict resolution strategies.
     * @property {string} ClientWins
     * @property {string} ServerWins
     * @property {string} Custom
     * @typedef {string} Everlive.ConflictResolutionStrategy
     */
    ConflictResolutionStrategy: {
        ClientWins: 'clientWins',
        ServerWins: 'serverWins',
        Custom: 'custom'
    },
    ConflictResolution: {
        KeepServer: 'keepServer',
        KeepClient: 'keepClient',
        Custom: 'custom'
    },
    /**
     * A class used to represent the available storage providers.
     * @property {string} LocalStorage
     * @property {string} FileSystem
     * @property {string} Custom
     * @typedef {string} Everlive.StorageProvider
     */
    StorageProvider: {
        LocalStorage: 'localStorage',
        FileSystem: 'fileSystem',
        Custom: 'custom'
    },

    DefaultStoragePath: 'el_store/',

    EncryptionProvider: {
        Default: 'default',
        Custom: 'custom'
    },
    // The headers used by the Everlive services
    Headers: {
        filter: 'X-Everlive-Filter',
        select: 'X-Everlive-Fields',
        sort: 'X-Everlive-Sort',
        skip: 'X-Everlive-Skip',
        take: 'X-Everlive-Take',
        expand: 'X-Everlive-Expand',
        singleField: 'X-Everlive-Single-Field',
        includeCount: 'X-Everlive-Include-Count',
        powerFields: 'X-Everlive-Power-Fields',
        debug: 'X-Everlive-Debug',
        overrideSystemFields: 'X-Everlive-Override-System-Fields'
    },
    //Constants for different platforms in Everlive
    Platform: {
        WindowsPhone: 1,
        Windows: 2,
        Android: 3,
        iOS: 4,
        OSX: 5,
        Blackberry: 6,
        Nokia: 7,
        Unknown: 100
    },
    OperatorType: {
        query: 1,

        where: 100,
        filter: 101,

        and: 110,
        or: 111,
        not: 112,

        equal: 120,
        not_equal: 121,
        lt: 122,
        lte: 123,
        gt: 124,
        gte: 125,
        isin: 126,
        notin: 127,
        all: 128,
        size: 129,
        regex: 130,
        contains: 131,
        startsWith: 132,
        endsWith: 133,

        nearShpere: 140,
        withinBox: 141,
        withinPolygon: 142,
        withinShpere: 143,

        select: 200,
        exclude: 201,

        order: 300,
        order_desc: 301,

        skip: 400,
        take: 401,
        expand: 402
    },

    /**
     * A class used to represent the current authentication status of the {{site.TelerikBackendServices}} JavaScript SDK instance.
     * @property {string} unauthenticated Indicates that no user is authenticated.
     * @property {string} masterKey Indicates that a master key authentication is used.
     * @property {string} invalidAuthentication Indicates an authentication has been attempted, but it was invalid.
     * @property {string} authenticated Indicates that a user is authenticated.
     * @property {string} authenticating Indicates that a user is currently authenticating. Some requests might be pending and waiting for the user to authenticate.
     * @property {string} expiredAuthentication Indicates that a user is currently authenticating. Some requests might be pending and waiting for the user to authenticate.
     * @typedef {string} Everlive.AuthStatus
     */
    AuthStatus: {
        unauthenticated: 'unauthenticated',
        masterKey: 'masterKey',
        invalidAuthentication: 'invalidAuthentication',
        authenticated: 'authenticated',
        expiredAuthentication: 'expiredAuthentication',
        authenticating: 'authenticating'
    },
    offlineItemStates: {
        created: 'created',
        modified: 'modified',
        deleted: 'deleted'
    },

    /**
     * HTTP Methods
     * @enum {string}
     */
    HttpMethod: {
        GET: 'GET',
        POST: 'POST',
        PUT: 'PUT',
        DELETE: 'DELETE'
    },
    maxDistanceConsts: {
        radians: '$maxDistance',
        km: '$maxDistanceInKilometers',
        miles: '$maxDistanceInMiles'
    },
    radiusConsts: {
        radians: 'radius',
        km: 'radiusInKilometers',
        miles: 'radiusInMiles'
    }
};

// using an invalid field name in the context of Everlive
// to ensure no naming collisions can occur
constants.offlineItemsStateMarker = '__everlive_offline_state';

constants.SyncErrors = {
    generalError: 'generalError',
    itemSyncError: 'itemSyncError'
};

constants.syncBatchSize = 10;

constants.AuthStoreKey = '__everlive_auth_key';

// the minimum interval between sync requests
constants.defaultSyncInterval = 1000 * 60 * 10; // 10 minutes

module.exports = constants;
},{}],55:[function(require,module,exports){
var CryptoJS = require('node-cryptojs-aes').CryptoJS;
var AES = CryptoJS.AES;

module.exports = (function () {

    function CryptographicProvider (sdk) {
        this.sdk = sdk;
    }

    CryptographicProvider.prototype = {
        _getKey: function () {
            return this.sdk.offlineStorage.setup.encryption.key;
        },

        _canEncryptDecrypt: function (content) {
            return this._getKey() && content !== null && content !== undefined;
        },

        encrypt: function (content) {
            if (!this._canEncryptDecrypt(content)) {
                return content;
            }

            return AES.encrypt(content, this._getKey()).toString();
        },

        decrypt: function (content) {
            if (!this._canEncryptDecrypt(content)) {
                return content;
            }

            return AES.decrypt(content, this._getKey()).toString(CryptoJS.enc.Utf8);
        }
    };

    return CryptographicProvider;
}());
},{"node-cryptojs-aes":20}],56:[function(require,module,exports){
(function (global){
var isNativeScriptApplication = Boolean(((typeof android !== 'undefined' && android && android.widget && android.widget.Button)
    || (typeof UIButton !== 'undefined' && UIButton)));

if (isNativeScriptApplication) {
    global.isNativeScriptApplication = isNativeScriptApplication;
    global.isCordovaApplication = false;

    global.window = {
            localStorage: {
                removeItem: function () { } //shim for mongo-query under nativescript
            }
        };
} else if (typeof window !== 'undefined') {
    var isCordovaApplication = /^file:\/{3}[^\/]/i.test(window.location.href) && /ios|iphone|ipod|ipad|android/i.test(navigator.userAgent);
}

var isNodejs = typeof exports === 'object' && typeof window === 'undefined';
var isRequirejs = typeof define === 'function' && define.amd;

module.exports = {
    isCordova: isCordovaApplication,
    isNativeScript: isNativeScriptApplication,
    isNodejs: isNodejs,
    isRequirejs: isRequirejs
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],57:[function(require,module,exports){
/*!
 The MIT License (MIT)
 Copyright (c) 2013 Telerik AD
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.y distributed under the MIT license.
 */
/*!
 Everlive SDK
 Version 1.3.0
 */
(function () {
    var Everlive = require('./Everlive');
    var platform = require('./everlive.platform');
    var common = require('./common');
    common.root.Everlive = Everlive;

    if (!platform.isNativeScript && !platform.isNodejs) {
        var kendo = require('./kendo/kendo.everlive');
        Everlive.createDataSource = kendo.createDataSource;
        Everlive.createHierarchicalDataSource = kendo.createHierarchicalDataSource;
    }

    //Global event handlers for push notification events. Required by the cordova PushNotifications plugin that we use.
    Everlive.PushCallbacks = {};
    Everlive.Offline = {};

    Everlive.Query = require('./query/Query');
    Everlive.QueryBuilder = require('./query/QueryBuilder');
    Everlive.GeoPoint = require('./GeoPoint');
    Everlive.Constants = require('./constants');
    Everlive.Request = require('./Request');
    Everlive.Data = require('./types/Data');
    Everlive._utils = require('./utils');
    Everlive._traverseAndRevive = Everlive._utils.parseUtilities.traverseAndRevive;
    Everlive._common = require('./common');

    var persistersModule = require('./offline/offlinePersisters');
    Everlive.persister = {
        LocalStorage: persistersModule.LocalStoragePersister,
        FileSystem: persistersModule.FileSystemPersister
    };

    if (typeof exports === 'object') {
        module.exports = common.root.Everlive;
    }
}());
},{"./Everlive":42,"./GeoPoint":46,"./Request":49,"./common":53,"./constants":54,"./everlive.platform":56,"./kendo/kendo.everlive":58,"./offline/offlinePersisters":61,"./query/Query":64,"./query/QueryBuilder":65,"./types/Data":70,"./utils":73}],58:[function(require,module,exports){
var QueryBuilder = require('../query/QueryBuilder');
var Query = require('../query/Query');
var Request = require('../Request');
var constants = require('../constants');
var _ = require('../common')._;
var Everlive = require('../Everlive');
var EverliveError = require('../EverliveError').EverliveError;

(function () {
    if (typeof window !== 'undefined' && typeof window.jQuery === 'undefined' || typeof window.kendo === 'undefined') {
        return;
    }

    var $ = window.jQuery;
    var kendo = window.kendo;

    var extend = $.extend;

    var everliveTransport = kendo.data.RemoteTransport.extend({
        init: function (options) {
            this.everlive$ = options.dataProvider || Everlive.$;
            if (!this.everlive$) {
                throw new Error('An instance of the Backend services sdk must be provided.');
            }

            if (!options.typeName) {
                throw new Error('A type name must be provided.');
            }

            this.headers = options.headers;

            this.dataCollection = this.everlive$.data(options.typeName);
            kendo.data.RemoteTransport.fn.init.call(this, options);
        },

        read: function (options) {
            var methodOption = this.options['read'];
            if (methodOption && methodOption.url) {
                return kendo.data.RemoteTransport.fn.read.call(this, options);
            }
            var methodHeaders;
            if (methodOption && methodOption.headers) {
                methodHeaders = methodOption.headers;
            }
            var query = translateKendoQuery(options.data);
            var everliveQuery = new Query(query.$where, null, query.$sort, query.$skip, query.$take);
            var id = options.data.Id;

            if (id) {
                this.dataCollection.withHeaders(this.headers).withHeaders(methodHeaders).getById(id).then(options.success, options.error);
            } else {
                this.dataCollection.withHeaders(this.headers).withHeaders(methodHeaders).get(everliveQuery).then(options.success, options.error);
            }
        },

        update: function (options) {
            var methodOption = this.options['update'];
            if (methodOption && methodOption.url) {
                return kendo.data.RemoteTransport.fn.read.call(this, options);
            }
            var methodHeaders;
            if (methodOption && methodOption.headers) {
                methodHeaders = methodOption.headers;
            }
            var isMultiple = _.isArray(options.data.models);
            if (isMultiple) {
                throw new Error('Batch update is not supported.');
            } else {
                var itemForUpdate = options.data;
                return this.dataCollection.withHeaders(this.headers).withHeaders(methodHeaders).updateSingle(itemForUpdate)
                    .then(options.success.bind(this, itemForUpdate), options.error);
            }
        },

        create: function (options) {
            var methodOption = this.options['create'];
            if (methodOption && methodOption.url) {
                return kendo.data.RemoteTransport.fn.read.call(this, options);
            }
            var methodHeaders;
            if (methodOption && methodOption.headers) {
                methodHeaders = methodOption.headers;
            }
            var isMultiple = _.isArray(options.data.models);
            var createData = isMultiple ? options.data.models : options.data;

            return this.dataCollection.withHeaders(this.headers).withHeaders(methodHeaders).create(createData)
                .then(options.success.bind(this, createData), options.error);
        },

        destroy: function (options) {
            var methodOption = this.options['destroy'];
            if (methodOption && methodOption.url) {
                return kendo.data.RemoteTransport.fn.read.call(this, options);
            }
            var methodHeaders;
            if (methodOption && methodOption.headers) {
                methodHeaders = methodOption.headers;
            }
            var isMultiple = _.isArray(options.data.models);
            if (isMultiple) {
                throw new Error('Batch destroy is not supported.');
            }
            return this.dataCollection.withHeaders(this.headers).withHeaders(methodHeaders).destroy(options.data)
                .then(options.success, options.error);
        }
    });

    $.extend(true, kendo.data, {
        transports: {
            everlive: everliveTransport
        },
        schemas: {
            everlive: {
                type: 'json',
                total: function (data) {
                    return data.hasOwnProperty('count') ? data.count : data.Count;
                },
                data: function (data) {
                    return data.result || Everlive._traverseAndRevive(data.Result) || data;
                },
                model: {
                    id: constants.idField
                }
            }
        }
    });

    function translateKendoQuery(data) {
        var result = {};
        if (data) {
            if (data.skip) {
                result.$skip = data.skip;
                delete data.skip;
            }
            if (data.take) {
                result.$take = data.take;
                delete data.take;
            }
            if (data.sort) {
                var sortExpressions = data.sort;
                var sort = {};
                if (!$.isArray(sortExpressions)) {
                    sortExpressions = [sortExpressions];
                }
                $.each(sortExpressions, function (idx, value) {
                    sort[value.field] = value.dir === 'asc' ? 1 : -1;
                });
                result.$sort = sort;
                delete data.sort;
            }
            if (data.filter) {
                var filter = filterBuilder.build(data.filter);
                result.$where = filter;
                delete data.filter;
            }
        }
        return result;
    }

    var regexOperations = ['startswith', 'startsWith', 'endswith', 'endsWith', 'contains'];

    var filterBuilder = {
        build: function (filter) {
            return filterBuilder._build(filter);
        },
        _build: function (filter) {
            if (filterBuilder._isRaw(filter)) {
                return filterBuilder._raw(filter);
            }
            else if (filterBuilder._isSimple(filter)) {
                return filterBuilder._simple(filter);
            }
            else if (filterBuilder._isRegex(filter)) {
                return filterBuilder._regex(filter);
            }
            else if (filterBuilder._isAnd(filter)) {
                return filterBuilder._and(filter);
            }
            else if (filterBuilder._isOr(filter)) {
                return filterBuilder._or(filter);
            }
        },
        _isRaw: function (filter) {
            return filter.operator === '_raw';
        },
        _raw: function (filter) {
            var fieldTerm = {};
            fieldTerm[filter.field] = filter.value;
            return fieldTerm;
        },
        _isSimple: function (filter) {
            return typeof filter.logic === 'undefined' && !filterBuilder._isRegex(filter);
        },
        _simple: function (filter) {
            var term = {}, fieldTerm = {};
            var operator = filterBuilder._translateoperator(filter.operator);
            if (operator) {
                term[operator] = filter.value;
            }
            else {
                term = filter.value;
            }
            fieldTerm[filter.field] = term;
            return fieldTerm;
        },
        _isRegex: function (filter) {
            return $.inArray(filter.operator, regexOperations) !== -1;
        },
        _regex: function (filter) {
            var fieldTerm = {};
            var regex = filterBuilder._getRegex(filter);
            fieldTerm[filter.field] = filterBuilder._getRegexValue(regex);
            return fieldTerm;
        },
        _getRegex: function (filter) {
            var pattern = filter.value;
            var filterOperator = filter.operator;
            switch (filterOperator) {
                case 'contains':
                    return new RegExp(".*" + pattern + ".*", "i");
                case 'startsWith': // removing the camel case operators will be a breaking change
                case 'startswith': // the Kendo UI operators are in lower case
                    return new RegExp("^" + pattern, "i");
                case 'endsWith':
                case 'endswith':
                    return new RegExp(pattern + "$", "i");
            }
            throw new Error("Unknown operator type.");
        },
        _getRegexValue: function (regex) {
            return QueryBuilder.prototype._getRegexValue.call(this, regex);
        },
        _isAnd: function (filter) {
            return filter.logic === 'and';
        },
        _and: function (filter) {
            var i, l, term, result = {};
            var operands = filter.filters;
            for (i = 0, l = operands.length; i < l; i++) {
                term = filterBuilder._build(operands[i]);
                result = filterBuilder._andAppend(result, term);
            }
            return result;
        },
        _andAppend: function (andObj, newObj) {
            return QueryBuilder.prototype._andAppend.call(this, andObj, newObj);
        },
        _isOr: function (filter) {
            return filter.logic === 'or';
        },
        _or: function (filter) {
            var i, l, term, result = [];
            var operands = filter.filters;
            for (i = 0, l = operands.length; i < l; i++) {
                term = filterBuilder._build(operands[i]);
                result.push(term);
            }
            return {$or: result};
        },
        _translateoperator: function (operator) {
            switch (operator) {
                case 'eq':
                    return null;
                case 'neq':
                    return "$ne";
                case 'gt':
                    return "$gt";
                case 'lt':
                    return "$lt";
                case 'gte':
                    return "$gte";
                case 'lte':
                    return "$lte";
            }
            throw new Error("Unknown operator type.");
        }
    };

    /**
     * Creates a new Kendo UI [DataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/datasource) that manages a certain Backend Services content type.
     * Kendo UI [DataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/datasource) is used in conjunction with other Kendo UI widgets (such as [ListView](http://docs.telerik.com/kendo-ui/web/listview/overview) and [Grid](http://docs.telerik.com/kendo-ui/web/grid/overview)) to provide an easy way to render data from Backend Services.
     * *including Kendo scripts is required*.
     * @param options data source options. See Kendo UI documentation of [DataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/datasource) for more info.
     * @param options.transport.typeName the content type name in Backend Services that will be managed.
     * @returns {DataSource} A new instance of Kendo UI DataSource. See Kendo UI documentation of [DataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/datasource) for more info.
     * @example ```js
     * var booksDataSource = Everlive.createDataSource({
     *   transport: {
     *     typeName: 'Books'
     *   }
     * });
     * ```
     */
    var createDataSource = function (options) {
        options = options || {};
        var typeName = options.typeName;
        var everlive$ = options.dataProvider || Everlive.$;
        if (!everlive$) {
            throw new Error("You need to instantiate an Everlive instance in order to create a kendo DataSource.");
        }

        if (!typeName) {
            throw new Error("You need to specify a 'typeName' in order to create a kendo DataSource.");
        }

        return everlive$.getKendoDataSource(typeName, options);
    };

    /**
     * Creates a new [HierarchicalDataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/hierarchicaldatasource) that manages a certain Backend Services content type and can expand a chain of relations.
     * Kendo UI [HierarchicalDataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/hierarchicaldatasource) is used in conjunction with other Kendo widgets (such as [TreeView](http://docs.telerik.com/kendo-ui/web/treeview/overview)) to render data from Backend Services in a structured way.
     * The chain of relations is defined by specifying the field names that contain the relation on each level. For example a generic hierarchy chain is a content type 'Continents' with relation to 'Countries', which in turn contains a relation to 'Towns'.
     * *including Kendo scripts is required*.
     * @param options data source options for [HierarchicalDataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/hierarchicaldatasource).
     * @param options.typeName name of the main content type for the data source.
     * @param {ExpandDefinition[]} options.expand an array of expand definitions. It defines the levels of hierarchy by specifying the relation fields. An expand definition can either be the field name as a **string**, or an **object** that allows additional options.
     * @param {string} ExpandDefinition - The field name of the relation that will be expanded. Only supported in online mode.
     * @param {string} ExpandDefinition.relation - *Required*. The field name of the relation that will be expanded.
     * @param {string} ExpandDefinition.typeName - *Required in offline mode*. The type name of the relation that will be expanded.
     * @param {object} ExpandDefinition.filter - an object specifying the filter expression.
     * @param {object} ExpandDefinition.sort - an object specifying the sort expression.
     * @param {object} ExpandDefinition.skip - a number specifying the skip value.
     * @param {object} ExpandDefinition.take - a number specifying the take value.
     * @param {object} ExpandDefinition.fields - an object specifying the fields expression.
     * @returns {HierarchicalDataSource} A new instance of Kendo UI HierarchicalDataSource. See Kendo UI documentation for [HierarchicalDataSource](http://docs.telerik.com/kendo-ui/api/javascript/data/hierarchicaldatasource)
     * @example ```js
     * var el = new Everlive('your-api-key-here');
     * var continents = Everlive.createHierarchicalDataSource({
     *   "typeName": "Continents",
     *   "expand": ["Countries", "Towns"]
     * });
     *
     * ...
     * ("#treeview").kendoTreeView({
     *   dataSource: continents,
     *   dataTextField: ["ContinentName", "CountryName", "TownName"]
     * });
     * ```
     */
    var createHierarchicalDataSource = function (options) {
        var typeName = options.typeName;
        var everlive$ = options.dataProvider || Everlive.$;
        if (!everlive$) {
            throw new Error("You need to instantiate an Everlive instance in order to create a kendo DataSource.");
        }
        if (!typeName) {
            throw new Error("You need to specify a 'typeName' in order to create a kendo DataSource.");
        }
        return everlive$.getHierarchicalDataSource(typeName, options);

    };

    Everlive.prototype.getKendoDataSource = function (typeName, datasourceOptions) {
        datasourceOptions = _.extend({}, datasourceOptions);
        if (datasourceOptions.hasOwnProperty('serverGrouping') && datasourceOptions.serverGrouping === true) {
            throw new EverliveError('Server Grouping is not supported.');
        }

        var defaultEverliveOptions = {
            type: 'everlive',
            transport: {
                typeName: typeName,
                dataProvider: this
            }
        };

        var options = _.defaults(defaultEverliveOptions, datasourceOptions);
        return new kendo.data.DataSource(options);
    };


    var getUrlGeneratorForNode = function (baseUrl, expandArray) {
        var expandField = getRelationFieldForExpandNode(expandArray[expandArray.length - 1]);
        var pathArray = expandArray.slice(0, expandArray.length - 1);
        var pathUrl = '/_expand';
        for (var i = 0; i < pathArray.length; i++) {
            pathUrl += '/' + getRelationFieldForExpandNode(pathArray[i]);
        }
        return (function (pathUrl, expandField) {
            return function (options) {
                var url = baseUrl + '';
                if (options.Id && expandField) {//if we are expanding
                    url += pathUrl + '/' + options.Id + '/' + expandField;
                }
                return url;
            }
        }(pathUrl, expandField));
    }

    var getHeadersForExpandNode = function (expandNode) {
        if (typeof expandNode === "string") {
            return {};
        } else {
            return {
                'X-Everlive-Filter': JSON.stringify(expandNode.filter),
                'X-Everlive-Sort': JSON.stringify(expandNode.sort),
                'X-Everlive-Single-Field': expandNode.singleField,
                'X-Everlive-Skip': expandNode.skip,
                'X-Everlive-Take': expandNode.take,
                'X-Everlive-Fields': JSON.stringify(expandNode.fields)
            }
        }
    };

    var getRelationFieldForExpandNode = function (expandNode) {
        if (typeof expandNode === "string") {
            return expandNode;
        } else {
            if (expandNode.relation) {
                return expandNode.relation;
            } else {
                throw new Error("You need to specify a 'relation' for an expand node when using the object notation");
            }
        }
    };

    Everlive.prototype.getHierarchicalDataSource = function (typeName, dataSourceOptions) {
        dataSourceOptions = dataSourceOptions || {};
        if (dataSourceOptions.hasOwnProperty('serverGrouping') && dataSourceOptions.serverGrouping === true) {
            throw new EverliveError('Server Grouping is not supported.');
        }
        var expand = dataSourceOptions.expand || dataSourceOptions;
        delete dataSourceOptions.expand;
        if (!typeName) {
            throw new Error("You need to specify a 'typeName' in order to create a kendo HierarchicalDataSource.");
        }
        if (!$.isArray(expand)) {
            throw new Error("You need to set 'expand' array option in order to create a kendo HierarchicalDataSource");
        }
        var baseUrl = this.buildUrl() + typeName;

        var expandSchema;
        var isOfflineStorageEnabled = this._isOfflineStorageEnabled();
        for (var i = expand.length - 1; i >= 0; i--) { //recursively build the hierarchical data source
            var expandNode = expand[i];
            if (isOfflineStorageEnabled) {
                if (!$.isPlainObject(expandNode)) {
                    throw new Error("When offline is enabled, each member of the expand array option must be an object. (Expand node index: " + i + ")");
                }
                if (!expandNode.relation) {
                    throw new Error("When offline is enabled, each member of the expand array option must have a `relation` option set.  (Expand node index: " + i + ")");
                }
                if (!expandNode.typeName) {
                    throw new Error("When offline is enabled, each member of the expand array option must have a `typeName` option set.  (Expand node index: " + i + ")");
                }

                var headers;
                var expandExpression = {};
                expandExpression[expandNode.relation] = {
                    TargetTypeName: expandNode.typeName,
                    Filter: expandNode.filter,
                    Sort: expandNode.sort,
                    Take: expandNode.take,
                    Skip: expandNode.skip,
                    Fields: expandNode.fields,
                    SingleField: expandNode.singleField
                };
                headers = {
                    'X-Everlive-Expand': JSON.stringify(expandExpression),
                    'X-Everlive-Single-Field': expandNode.relation
                };
                var parentType;
                if (i === 0) {
                    parentType = typeName;
                } else {
                    parentType = expand[i - 1].typeName;
                }
                expandSchema = {
                    model: {
                        hasChildren: expandNode.relation,
                        children: {
                            type: "everlive",
                            transport: {
                                typeName: parentType,
                                read: {
                                    headers: headers
                                }
                            },
                            schema: expandSchema
                        }
                    }
                };
            } else {
                expandSchema = {
                    model: {
                        hasChildren: getRelationFieldForExpandNode(expandNode),
                        children: {
                            type: "everlive",
                            transport: {
                                read: {
                                    url: getUrlGeneratorForNode(baseUrl, expand.slice(0, i + 1)),
                                    headers: getHeadersForExpandNode(expandNode)
                                }
                            },
                            schema: expandSchema
                        }
                    }
                }
            }
        }
        var options = {};
        options.type = 'everlive';
        options.transport = {
            typeName: typeName,
            dataProvider: this
        };
        options.schema = expandSchema;
        if ($.isPlainObject(dataSourceOptions)) {
            extend(true, options, dataSourceOptions);
        }
        return new kendo.data.HierarchicalDataSource(options);
    };


    module.exports = {
        createDataSource: createDataSource,
        createHierarchicalDataSource: createHierarchicalDataSource
    };
}());
},{"../Everlive":42,"../EverliveError":43,"../Request":49,"../common":53,"../constants":54,"../query/Query":64,"../query/QueryBuilder":65}],59:[function(require,module,exports){
var DataQuery = require('../query/DataQuery');
var everliveErrorModule = require('../EverliveError');
var EverliveError = everliveErrorModule.EverliveError;
var EverliveErrors = everliveErrorModule.EverliveErrors;
var constants = require('../constants');
var offlineItemStates = constants.offlineItemStates;
var Headers = constants.Headers;
var RequestOptionsBuilder = require('../query/RequestOptionsBuilder');
var common = require('../common');
var _ = common._;
var rsvp = common.rsvp;
var mingo = common.Mingo;
var mongoQuery = common.mongoQuery;
var uuid = common.uuid;
var utils = require('../utils');
var Request = require('../Request');
var expandProcessor = require('../ExpandProcessor');
var offlineTransformations = require('./offlineTransformations');
var buildPromise = require('../utils').buildPromise;

/**
 * @class OfflineModule
 * @classDesc A class providing access to some offline storage functionalities.
 */

/**
 * Represents the {@link OfflineModule} class.
 * @memberOf Everlive.prototype
 * @member {OfflineModule} storage
 */

module.exports = (function () {
    function OfflineModule(everlive, options, persister, encryptionProvider) {
        this.everlive = everlive;
        this.setup = options;
        this._persister = persister;
        this._encryptionProvider = encryptionProvider;
        this._isSynchronizing = false;
        this._collectionCache = {};
    }


    var getSyncFilterForItem = function (item) {
        var filter = getSyncFilterNoModifiedAt(item);
        filter.ModifiedAt = item.ModifiedAt;
        return filter;
    };

    var getSyncFilterNoModifiedAt = function (item) {
        return {
            Id: item.Id
        }
    };

    function buildUsersErrorMessage(dataQuery) {
        var operation = dataQuery.operation;
        if (operation === DataQuery.operations.userLoginWithProvider ||
            operation === DataQuery.operations.userLinkWithProvider ||
            operation === DataQuery.operations.userUnlinkFromProvider) {
            operation += dataQuery.data.Provider || dataQuery.data.Identity.Provider;
        }

        return 'The Users operation ' + operation + ' is not supported in offline mode';
    }

    var unsupportedUsersOperations = {};
    unsupportedUsersOperations[DataQuery.operations.create] = true;
    unsupportedUsersOperations[DataQuery.operations.update] = true;
    unsupportedUsersOperations[DataQuery.operations.remove] = true;
    unsupportedUsersOperations[DataQuery.operations.removeSingle] = true;
    unsupportedUsersOperations[DataQuery.operations.rawUpdate] = true;
    unsupportedUsersOperations[DataQuery.operations.setAcl] = true;
    unsupportedUsersOperations[DataQuery.operations.setOwner] = true;
    unsupportedUsersOperations[DataQuery.operations.userLoginWithProvider] = true;
    unsupportedUsersOperations[DataQuery.operations.userLinkWithProvider] = true;
    unsupportedUsersOperations[DataQuery.operations.userUnlinkFromProvider] = true;
    unsupportedUsersOperations[DataQuery.operations.userLogin] = true;
    unsupportedUsersOperations[DataQuery.operations.userLogout] = true;
    unsupportedUsersOperations[DataQuery.operations.userChangePassword] = true;

    var unsupportedOfflineHeaders = [Headers.powerFields];

    OfflineModule.prototype = {
        /**
         * Removes all data from the offline storage
         * @memberOf OfflineModule.prototype
         * @param {function} success
         * @param {function} error
         */
        /**
         * Removes all data from the offline storage
         * @memberOf OfflineModule.prototype
         * @returns Promise
         */
        purgeAll: function (success, error) {
            var self = this;
            this._collectionCache = {};
            return buildPromise(function (success, error) {
                self._persister.purgeAll(success, error);
            }, success, error);
        },

        /**
         * Removes all data for a specific content type from the offline storage
         * @memberOf OfflineStorageModule.prototype
         * @param {string} contentType The content type to purge
         * @param success
         * @param error
         */
        /**
         * Removes all data for a specific content type from the offline storage
         * @memberOf OfflineStorageModule.prototype
         * @param {string} contentType The content type to purge
         * @returns Promise
         */
        purge: function (contentType, success, error) {
            var self = this;
            return buildPromise(function (success, error) {
                self._persister.purge(contentType, success, error);
            }, success, error);
        },

        processQuery: function (dataQuery) {
            var unsupportedClientOpMessage = this.getUnsupportedClientOpMessage(dataQuery);
            if (unsupportedClientOpMessage && !dataQuery.isSync) {
                return new rsvp.Promise(function (resolve, reject) {
                    reject(new EverliveError(unsupportedClientOpMessage));
                });
            }

            var sort = dataQuery.getHeaderAsJSON(Headers.sort);
            var limit = dataQuery.getHeaderAsJSON(Headers.take);
            var skip = dataQuery.getHeaderAsJSON(Headers.skip);
            var select = dataQuery.getHeaderAsJSON(Headers.select);
            var filter = dataQuery.getHeaderAsJSON(Headers.filter);
            var expand = dataQuery.getHeaderAsJSON(Headers.expand);

            if (dataQuery.filter instanceof Everlive.Query) {
                var filterObj = dataQuery.filter.build();
                filter = filterObj.$where || filter;
                sort = filterObj.$sort || sort;
                limit = filterObj.$take || limit;
                skip = filterObj.$skip || skip;
                select = filterObj.$select || select;
                expand = filterObj.$expand || expand;
            } else {
                filter = dataQuery.filter || filter;
            }

            if (!filter) {
                filter = {};
            }

            var unsupportedOperators = utils.getUnsupportedOperators(filter);
            var unsupportedOperatorCount = unsupportedOperators.length;
            if (unsupportedOperatorCount) {
                return new rsvp.Promise(function (resolve, reject) {
                    var errorMessage;
                    if (unsupportedOperatorCount === 1) {
                        errorMessage = 'The operator ' + unsupportedOperators[0] + ' is not supported in offline mode.';
                    } else {
                        errorMessage = 'The operators ' + unsupportedOperators.join(',') + 'are not supported in offline mode.';
                    }

                    reject(new EverliveError(errorMessage));
                });
            }

            offlineTransformations.traverseAndTransformFilterId(filter);

            switch (dataQuery.operation) {
                case DataQuery.operations.read:
                    return this.read(dataQuery, filter, sort, skip, limit, select, expand);
                case DataQuery.operations.readById:
                    return this.readById(dataQuery, expand);
                case DataQuery.operations.count:
                    return this.count(dataQuery, filter);
                case DataQuery.operations.create:
                    return this.create(dataQuery);
                case DataQuery.operations.rawUpdate:
                case DataQuery.operations.update:
                    return this.update(dataQuery, filter);
                case DataQuery.operations.remove:
                    return this.remove(dataQuery, filter);
                case DataQuery.operations.removeSingle:
                    filter._id = dataQuery.additionalOptions.id;
                    return this.remove(dataQuery, filter);
                default:
                    return new rsvp.Promise(function (resolve, reject) {
                        if (dataQuery.isSync) {
                            resolve();
                        } else {
                            reject(new EverliveError(dataQuery.operation + ' is not supported in offline mode'));
                        }
                    });
            }
        },

        getUnsupportedClientOpMessage: function (dataQuery) {
            for (var i = 0; i < unsupportedOfflineHeaders.length; i++) {
                var header = unsupportedOfflineHeaders[i];
                if (dataQuery.getHeader(header)) {
                    return 'The header ' + header + ' is not supported in offline mode';
                }
            }

            if (dataQuery.collectionName.toLowerCase() === 'files') {
                return 'Operations on files are not supported in offline mode';
            }

            if (dataQuery.collectionName.toLowerCase() === 'users' && unsupportedUsersOperations[dataQuery.operation]) {
                return buildUsersErrorMessage(dataQuery);
            }
        },

        _getEncryptionProvider: function () {
            return this._encryptionProvider;
        },

        _getCreateResult: function (createdItems) {
            if (createdItems.length === 1) {
                return {
                    result: {
                        CreatedAt: utils.cloneDate(createdItems[0].CreatedAt),
                        Id: createdItems[0]._id
                    }
                }
            } else {
                var multipleCreateResult = [];
                _.each(createdItems, function (createdItem) {
                    multipleCreateResult.push({
                        CreatedAt: utils.cloneDate(createdItem.CreatedAt),
                        Id: createdItem._id
                    });
                });

                return {
                    result: multipleCreateResult
                }
            }
        },

        create: function (dataQuery) {
            var self = this;

            return new rsvp.Promise(function (resolve, reject) {
                self._createItems(dataQuery.collectionName, dataQuery.data, dataQuery.isSync, dataQuery.preserveState, function (createdItems) {
                    var createResult = self._getCreateResult(createdItems);
                    resolve(createResult);
                }, reject);
            });
        },

        read: function (dataQuery, filter, sort, skip, limit, select, expand) {
            var self = this;

            return new rsvp.Promise(function (resolve, reject) {
                var collectionLength;

                self._prepareExpand(expand, dataQuery, true)
                    .then(function (prepareExpandResult) {
                        if (prepareExpandResult) {
                            select = prepareExpandResult.mainQueryFieldsExpression;
                        }

                        return self._getCollection(dataQuery.collectionName)
                            .then(function (collection) {
                                var result = self._readInternal(collection, filter, sort, skip, limit, select);

                                if (skip || limit) {
                                    var all = self._readInternal(collection);
                                    collectionLength = all.length;
                                }

                                if (!self._shouldAutogenerateIdForContentType(dataQuery.collectionName)) {
                                    result = offlineTransformations.removeIdTransform(result, true);
                                } else {
                                    result = offlineTransformations.idTransform(result);
                                }

                                return self._expandResult(prepareExpandResult, result);
                            });
                    })
                    .then(function (result) {
                        var response = self._transformOfflineResult(result, collectionLength, dataQuery);
                        resolve(response);
                    })
                    .catch(reject);
            });
        },

        _readInternal: function (collection, filter, sort, skip, limit, select) {
            var filterCopy = _.extend({}, filter);
            var actualFilter = this._getWithoutDeletedFilter(filterCopy);
            offlineTransformations.traverseAndTransformFilterId(actualFilter);
            var query = mingo.Query(actualFilter);
            var cursor = mingo.Cursor(collection, query, select);
            if (sort) {
                cursor = cursor.sort(sort);
            }

            if (skip) {
                cursor.skip(skip);
            }

            if (limit) {
                cursor.limit(limit);
            }

            return _.map(cursor.all(), function (item) {
                return _.extend({}, item);
            });
        },

        readById: function (dataQuery, expand) {
            var self = this;

            return self._prepareExpand(expand, dataQuery, false)
                .then(function (prepareExpandResult) {
                    return self._getCollection(dataQuery.collectionName)
                        .then(function (collection) {
                            return new rsvp.Promise(function (resolve, reject) {
                                var item = self._getById(collection, dataQuery.additionalOptions.id);

                                if (!item) {
                                    return reject(EverliveErrors.itemNotFound);
                                }

                                item = offlineTransformations.idTransform(item);
                                return self._expandResult(prepareExpandResult, item).then(resolve).catch(reject);
                            });
                        });
                })
                .then(function (result) {
                    var response = self._transformOfflineResult(result, null, dataQuery);
                    return response;
                });
        },

        _prepareExpand: function (expand, dataQuery, isArray) {
            return new rsvp.Promise(function (resolve, reject) {
                if (expand) {
                    expandProcessor.prepare(expand, dataQuery.collectionName, isArray, dataQuery.fields, null, null, function (err, prepareResult) {
                        if (err) {
                            if (err.name === 'ExpandError') {
                                err.code = EverliveErrors.invalidExpandExpression.code;
                            }
                            return reject(err);
                        }
                        resolve(prepareResult);
                    });
                } else {
                    resolve();
                }
            });
        },

        _expandResult: function (prepareExpandResult, result) {
            var self = this;
            return new rsvp.Promise(function (resolve, reject) {
                if (prepareExpandResult) {
                    expandProcessor.expand(prepareExpandResult.relationsTree, result, {
                        offlineModule: self
                    }, function (err, result) {
                        if (err) {
                            if (err.name === 'ExpandError') {
                                err.code = EverliveErrors.invalidExpandExpression.code;
                            }
                            return reject(err);
                        }
                        resolve(result);
                    });
                } else {
                    resolve(result);
                }
            })
        },

        _getWithoutDeletedFilter: function (filter) {
            var withoutDeletedFilter = {
                $and: []
            };
            withoutDeletedFilter.$and.push(filter);
            var deleteOfflineFilter = {};
            deleteOfflineFilter[constants.offlineItemsStateMarker] = {$ne: offlineItemStates.deleted};
            withoutDeletedFilter.$and.push(deleteOfflineFilter);
            return withoutDeletedFilter;
        },

        update: function (dataQuery, filter) {
            var self = this;

            return new rsvp.Promise(function (resolve, reject) {
                self._updateItems(dataQuery, dataQuery.data, filter, dataQuery.isSync, resolve, reject);
            });
        },

        remove: function (dataQuery, filter) {
            var self = this;
            return new rsvp.Promise(function (resolve, reject) {
                self._removeItems(dataQuery, filter, dataQuery.isSync, resolve, reject);
            });
        },

        count: function (dataQuery, filter) {
            var self = this;

            return new rsvp.Promise(function (resolve, reject) {
                self._getCollection(dataQuery.collectionName)
                    .then(function (collection) {
                        var filterResult = self._readInternal(collection, filter);
                        resolve({result: filterResult.length});
                    }).catch(reject);
            });
        },

        _setOffline: function (offline) {
            this.setup.offline = offline;
        },

        isOnline: function () {
            return !this.setup.offline;
        },

        _prepareSyncData: function (contentTypesForSync) {
            var self = this;

            var contentTypesSyncData = {};
            var conflicts = [];
            _.each(contentTypesForSync, function (contentType, typeName) {
                var syncItems = offlineTransformations.idTransform(contentType.offlineItemsToSync);
                var syncData = self._getSyncItemStates(typeName, syncItems, contentType.serverItems);
                conflicts.push(syncData.conflicts);
                contentTypesSyncData[typeName] = syncData.itemsForSync;
            });

            return {
                conflicts: conflicts,
                contentTypesSyncData: contentTypesSyncData
            };
        },

        _resolveConflicts: function (syncData) {
            var self = this;
            return this._applyResolutionStrategy(syncData.conflicts)
                .then(self._mergeResolvedConflicts.bind(self, syncData.conflicts, syncData.contentTypesSyncData))
                .then(function () {
                    return syncData.contentTypesSyncData;
                });
        },

        isSynchronizing: function () {
            return this._isSynchronizing;
        },

        _fireSyncStart: function () {
            var self = this;

            return new rsvp.Promise(function (resolve) {
                if (!self._isSynchronizing) {
                    self._isSynchronizing = true;
                    self.everlive._emitter.emit('syncStart');
                    resolve();
                } else {
                    resolve();
                }
            });
        },

        _fireSyncEnd: function () {
            var self = this;

            this._isSynchronizing = false;
            _.each(this._syncResultInfo.syncedItems, function (syncedItems, contentTypeName) {
                self._syncResultInfo.syncedToServer += _.where(syncedItems, {storage: 'server'}).length;
                self._syncResultInfo.syncedToClient += _.where(syncedItems, {storage: 'client'}).length;
            });

            this.everlive._emitter.emit('syncEnd', this._syncResultInfo);
            delete this._syncResultInfo;
        },

        _eachSyncItem: function (items, getFilterFunction, contentTypeName, operation) {
            var self = this;

            _.each(items, function (item) {
                var itemFilter = getFilterFunction(item.remoteItem);
                // if we already have an error for this item we do not want to try and sync it again
                var resultItem = item.resultingItem;
                if (_.some(self._syncResultInfo.failedItems[contentTypeName], {itemId: resultItem.Id})) {
                    return;
                }

                operation(resultItem, itemFilter);
            });
        },

        _addCreatedItemsForSync: function (contentTypeData, syncPromises, dataCollection) {
            var self = this;

            var resultingItemsForCreate = _.pluck(contentTypeData.createdItems, 'resultingItem');
            var ids;
            if (!this._shouldAutogenerateIdForContentType(dataCollection.collectionName)) {
                ids = _.pluck(resultingItemsForCreate, 'Id');
                resultingItemsForCreate = offlineTransformations.removeIdTransform(resultingItemsForCreate);
            }

            syncPromises['create'] =
                new rsvp.Promise(function (resolve, reject) {
                    dataCollection
                        .isSync(true)
                        .applyOffline(false)
                        .create(resultingItemsForCreate)
                        .then(function (res) {
                            resultingItemsForCreate = _.map(resultingItemsForCreate, function (item, index) {
                                item.Id = res.result[index].Id;
                                item.CreatedAt = item.ModifiedAt = res.result[index].CreatedAt;
                                return item;
                            });

                            return dataCollection
                                .isSync(true)
                                .useOffline(true)
                                .create(resultingItemsForCreate)
                                .then(function () {
                                    var collectionName = dataCollection.collectionName;
                                    _.each(resultingItemsForCreate, function (createdItem) {
                                        self._addItemSynced(createdItem, collectionName, 'server', 'create');
                                    });

                                    if (ids && ids.length) {
                                        var filter = {Id: {$in: ids}};
                                        return dataCollection
                                            .isSync(true)
                                            .useOffline(true)
                                            .destroy(filter).catch(function (err) {
                                                reject({
                                                    type: 'create',
                                                    items: resultingItemsForCreate,
                                                    contentType: dataCollection.collectionName,
                                                    error: err,
                                                    storage: 'client'
                                                })
                                            });
                                    }
                                }, function (err) {
                                    reject({
                                        type: 'create',
                                        items: resultingItemsForCreate,
                                        contentType: dataCollection.collectionName,
                                        error: err,
                                        storage: 'client'
                                    })
                                });
                        }, function (err) {
                            reject({
                                type: 'create',
                                items: resultingItemsForCreate,
                                contentType: dataCollection.collectionName,
                                error: err,
                                storage: 'server'
                            })
                        })
                        .then(resolve)
                        .catch(function (err) {
                            reject({
                                type: 'create',
                                items: resultingItemsForCreate,
                                contentType: dataCollection.collectionName,
                                error: err
                            });
                        });
                });
        },

        _addUpdatedItemsForSync: function (contentTypeData, getFilterOperation, syncPromises, dataCollection, itemUpdateOperation) {
            var self = this;
            var collectionName = dataCollection.collectionName;
            self._eachSyncItem(contentTypeData.modifiedItems, getFilterOperation, collectionName, itemUpdateOperation);
        },

        _addDeletedItemsForSync: function (contentTypeData, getFilterOperation, syncPromises, dataCollection, itemDeleteOperation) {
            var self = this;

            var collectionName = dataCollection.collectionName;
            self._eachSyncItem(contentTypeData.deletedItems, getFilterOperation, collectionName, itemDeleteOperation);
        },

        _onSyncResponse: function (res, item, collectionName, operation) {
            var self = this;

            if (res.result !== 1) {
                return new rsvp.Promise(function (resolve, reject) {
                    self._removeItemSynced(item, collectionName);
                    reject(_.extend({}, EverliveErrors.syncConflict, {
                        contentType: collectionName
                    }));
                });
            } else {
                if (operation === DataQuery.operations.update) {
                    self._addItemSynced(item, collectionName, 'server', 'update');
                    var updatedItem = _.extend({}, item, {
                        ModifiedAt: res.ModifiedAt
                    });

                    var updateQuery = new DataQuery({
                        operation: operation,
                        data: updatedItem,
                        additionalOptions: {
                            id: item.Id
                        },
                        collectionName: collectionName,
                        isSync: true
                    });

                    return this.processQuery(updateQuery);
                } else if (operation === DataQuery.operations.remove) {
                    self._addItemSynced(item, collectionName, 'server', 'delete');
                    return this._purgeById(collectionName, item.Id);
                }
            }
        },

        _purgeById: function (contentType, itemId) {
            var self = this;

            return self._getCollection(contentType)
                .then(function (collection) {
                    delete collection[itemId];
                    return self._persistData(contentType);
                });
        },

        sync: function () {
            var self = this;
            self._syncResultInfo = self._syncResultInfo || {
                syncedItems: {},
                syncedToServer: 0,
                syncedToClient: 0,
                failedItems: {},
                error: undefined // added for visibility
            };

            if (!this.isOnline()) {
                throw new EverliveError('Cannot synchronize while offline');
            }

            self._fireSyncStart()
                .then(self._applySync.bind(self))
                .then(function (syncResults) {
                    var conflictsWhileSync = [];
                    _.each(syncResults, function (syncResult, itemId) {
                        if (syncResult && syncResult.state === 'rejected') {
                            var targetType = syncResult.reason.contentType;
                            if (syncResult.reason && syncResult.reason.code === EverliveErrors.syncConflict.code) {
                                conflictsWhileSync.push(syncResult);
                            } else {
                                // to save time and traffic we are using a single create request for all items
                                // this is why if there is an error we need to split the items we tried to create
                                // and set the same error for all items.
                                var type = syncResult.reason.type;
                                self._syncResultInfo.failedItems[targetType] = self._syncResultInfo.failedItems[targetType] || [];
                                if (type === 'create') {
                                    _.each(syncResult.reason.items, function (item) {
                                        self._removeItemSynced(item, targetType, 'server', 'create');
                                        self._syncResultInfo.failedItems[targetType]
                                            .push(_.extend({itemId: item.Id}, _.pick(syncResult.reason, 'storage', 'type', 'error')));
                                    });
                                } else {
                                    self._removeItemSynced(itemId, targetType, 'server');
                                    self._syncResultInfo.failedItems[targetType]
                                        .push(_.extend({itemId: itemId}, _.pick(syncResult.reason, 'storage', 'type', 'error')));
                                }
                            }
                        }
                    });

                    if (conflictsWhileSync.length) {
                        return self.sync();
                    } else {
                        self._fireSyncEnd();
                    }
                })
                .catch(function (err) {
                    self._syncResultInfo.error = err;
                    self._fireSyncEnd();
                });
        },

        _handleKeepServer: function (typeName, conflictingItem, offlineSyncOperations) {
            var self = this;

            var serverItem = conflictingItem.serverItem;
            var clientItem = conflictingItem.clientItem;
            var syncQuery;
            if (serverItem && clientItem) {
                // update the item offline
                syncQuery = new DataQuery({
                    collectionName: typeName,
                    operation: DataQuery.operations.update,
                    additionalOptions: {
                        id: serverItem.Id
                    },
                    data: serverItem
                });
            } else if (serverItem && !clientItem) {
                // create item offline
                syncQuery = new DataQuery({
                    collectionName: typeName,
                    operation: DataQuery.operations.create,
                    data: serverItem
                });
            } else if (!serverItem && clientItem) {
                // delete item offline
                syncQuery = new DataQuery({
                    collectionName: typeName,
                    operation: DataQuery.operations.removeSingle,
                    additionalOptions: {
                        id: clientItem.Id
                    }
                });
            } else {
                throw new EverliveError('Both serverItem and clientItem are not set when syncing data with "KeepServer" resolution strategy.');
            }

            syncQuery.isSync = true;
            offlineSyncOperations.push(new rsvp.Promise(function (resolve, reject) {
                self.processQuery(syncQuery)
                    .then(function () {
                        switch (syncQuery.operation) {
                            case DataQuery.operations.update:
                                self._addItemSynced(serverItem, typeName, 'client', 'update');
                                break;
                            case DataQuery.operations.create:
                                self._addItemSynced(serverItem, typeName, 'client', 'create');
                                break;
                            case DataQuery.operations.removeSingle:
                                self._addItemSynced(clientItem, typeName, 'client', 'delete');
                                break;
                        }
                        resolve();
                    }, function (err) {
                        var itemId;
                        var operation;
                        switch (syncQuery.operation) {
                            case DataQuery.operations.update:
                                itemId = serverItem.Id;
                                operation = 'update';
                                break;
                            case DataQuery.operations.create:
                                itemId = serverItem.Id;
                                operation = 'create';
                                break;
                            case DataQuery.operations.removeSingle:
                                itemId = clientItem.Id;
                                operation = 'delete';
                                break;
                        }

                        reject({
                            itemId: itemId,
                            type: operation,
                            contentType: syncQuery.collectionName,
                            error: err,
                            storage: 'client'
                        })
                    })
            }));
        },

        _handleKeepClient: function (conflictingItem, contentTypeSyncData) {
            var serverItem = conflictingItem.serverItem;
            var clientItem = conflictingItem.clientItem;
            if (serverItem && clientItem) {
                var modifiedObject = _.extend(clientItem, {ModifiedAt: new Date(serverItem.ModifiedAt)});

                contentTypeSyncData.modifiedItems.push({
                    remoteItem: conflictingItem.serverItem,
                    resultingItem: modifiedObject
                });
            } else if (serverItem && !clientItem) {
                contentTypeSyncData.deletedItems.push({
                    remoteItem: conflictingItem.serverItem,
                    resultingItem: serverItem
                });
            } else if (!serverItem && clientItem) {
                contentTypeSyncData.createdItems.push({
                    remoteItem: conflictingItem.serverItem,
                    resultingItem: clientItem
                });
            } else {
                throw new EverliveError('Both serverItem and clientItem are not set when syncing data with "KeepClient" resolution strategy.');
            }
        },

        _handleCustom: function (conflictingItem, typeName, offlineSyncOperations, contentTypeSyncData) {
            var serverItem = conflictingItem.serverItem;
            var clientItem = conflictingItem.clientItem;
            var customItem = _.omit(conflictingItem.result.item, 'CreatedAt', 'ModifiedAt');
            if (serverItem && customItem) {
                var createItemOfflineQuery = new DataQuery({
                    collectionName: typeName,
                    operation: DataQuery.operations.create,
                    data: serverItem // create the server item offline and it will be updated when sync finishes
                });

                createItemOfflineQuery.preserveState = true;
                createItemOfflineQuery.isSync = true;

                offlineSyncOperations.push(this.processQuery(createItemOfflineQuery));
            }

            if (serverItem && customItem && !clientItem) {
                customItem.Id = serverItem.Id;
                contentTypeSyncData.modifiedItems.push({
                    remoteItem: serverItem,
                    resultingItem: customItem
                });
            } else if (serverItem && !customItem) {
                contentTypeSyncData.deletedItems.push({
                    remoteItem: conflictingItem.serverItem,
                    resultingItem: serverItem
                });
            } else if (!serverItem && customItem && clientItem) {
                var updateItemOfflineQuery = new DataQuery({
                    collectionName: typeName,
                    operation: DataQuery.operations.update,
                    data: customItem,
                    additionalOptions: {
                        id: clientItem.Id
                    }
                });

                offlineSyncOperations.push(this.processQuery(updateItemOfflineQuery));
                customItem.Id = clientItem.Id;

                contentTypeSyncData.createdItems.push({
                    remoteItem: serverItem,
                    resultingItem: customItem
                });
            } else {
                customItem.Id = serverItem.Id;
                contentTypeSyncData.modifiedItems.push({
                    remoteItem: serverItem,
                    resultingItem: customItem
                });
            }
        },

        _mergeResolvedConflicts: function (conflicts, syncData) {
            var self = this;

            var offlineSyncOperations = [];
            _.each(conflicts, function (conflict) {
                var typeName = conflict.contentTypeName;
                _.each(conflict.conflictingItems, function (conflictingItem) {
                    var contentTypeSyncData = syncData[typeName];
                    switch (conflictingItem.result.resolutionType) {
                        case constants.ConflictResolution.KeepServer:
                            self._handleKeepServer(typeName, conflictingItem, offlineSyncOperations);
                            break;
                        case constants.ConflictResolution.KeepClient:
                            self._handleKeepClient(conflictingItem, contentTypeSyncData);
                            break;
                        case constants.ConflictResolution.Custom:
                            self._handleCustom(conflictingItem, typeName, offlineSyncOperations, contentTypeSyncData);
                            break;
                    }
                });
            });

            return rsvp.all(offlineSyncOperations);
        },

        _getSyncItemStates: function (contentType, offlineItems, serverItems) {
            var self = this;

            var contentTypeSyncData = {
                itemsForSync: {
                    createdItems: [],
                    modifiedItems: [],
                    deletedItems: []
                },
                conflicts: {
                    contentTypeName: contentType,
                    conflictingItems: []
                }
            };

            _.each(offlineItems, function (offlineItem) {
                var serverItem = _.findWhere(serverItems, {Id: offlineItem.Id});
                if (serverItem) {
                    if (serverItem.Id === offlineItem.Id && offlineItem[constants.offlineItemsStateMarker] === offlineItemStates.created) {
                        self._syncResultInfo.failedItems[contentType] = self._syncResultInfo.failedItems[contentType] || [];
                        self._syncResultInfo.failedItems[contentType].push({
                            itemId: serverItem.Id,
                            type: 'create',
                            storage: 'client',
                            error: EverliveErrors.syncError
                        });

                        return;
                    }

                    var clientItemChanged = !!offlineItem[constants.offlineItemsStateMarker];
                    var hasUpdateConflict = false;

                    if (clientItemChanged) {
                        hasUpdateConflict = serverItem.ModifiedAt.getTime() !== offlineItem.ModifiedAt.getTime();
                    }

                    if (hasUpdateConflict) {
                        contentTypeSyncData.conflicts.conflictingItems.push({
                            // if the item was modified on the server and deleted locally we have a conflict and set the client item to null
                            // otherwise it is a simple modification conflict
                            clientItem: offlineItem[constants.offlineItemsStateMarker] === offlineItemStates.deleted ? null : offlineItem,
                            serverItem: serverItem,
                            result: {}
                        });
                    } else {
                        if (offlineItem[constants.offlineItemsStateMarker] === offlineItemStates.deleted) {
                            contentTypeSyncData.itemsForSync.deletedItems.push({
                                remoteItem: serverItem,
                                resultingItem: offlineItem
                            });
                        } else {
                            contentTypeSyncData.itemsForSync.modifiedItems.push({
                                remoteItem: serverItem,
                                resultingItem: offlineItem
                            });
                        }
                    }
                } else {
                    // if the item in memory has been modified, but the item on the server has been deleted
                    if (offlineItem[constants.offlineItemsStateMarker] === offlineItemStates.modified) {
                        contentTypeSyncData.conflicts.conflictingItems.push({
                            clientItem: offlineItem,
                            serverItem: null,
                            result: {}
                        });
                    } else {
                        contentTypeSyncData.itemsForSync.createdItems.push({
                            remoteItem: serverItem,
                            resultingItem: offlineItem
                        });
                    }
                }

                delete offlineItem[constants.offlineItemsStateMarker];
            });

            return contentTypeSyncData;
        },

        _setResolutionTypeForItem: function (resolutionType, conflictingItem) {
            conflictingItem.result = {
                resolutionType: resolutionType
            };
        },

        _applyResolutionStrategy: function (conflicts) {
            var self = this;
            var conflictResolutionStrategy = self.setup.conflicts.strategy;
            return new rsvp.Promise(function (resolve, reject) {
                for (var i = 0; i < conflicts.length; i++) {
                    var conflict = conflicts[i];
                    if (conflict.conflictingItems.length) {
                        switch (conflictResolutionStrategy) {
                            case constants.ConflictResolutionStrategy.ServerWins:
                                _.each(conflict.conflictingItems,
                                    self._setResolutionTypeForItem.bind(self, constants.ConflictResolution.KeepServer));
                                break;
                            case constants.ConflictResolutionStrategy.ClientWins:
                                break;
                            case constants.ConflictResolutionStrategy.Custom:
                                var customStrategy = self.setup.conflicts.implementation;
                                if (!customStrategy) {
                                    return reject(new EverliveError('Implementation of the conflict resolution strategy ' +
                                    'must be provided when set to Custom'));
                                }

                                customStrategy(conflicts, resolve);
                                break;
                            default:
                                return reject(new EverliveError('Invalid resolution strategy provided'));
                        }
                    }
                }

                resolve();
            });
        },

        _getSyncPromiseBatch: function (contentType, batchIds) {
            var self = this;

            return new rsvp.Promise(function (resolve, reject) {
                var dataQuery = new DataQuery({
                    collectionName: contentType,
                    filter: {
                        'Id': {
                            '$in': batchIds
                        }
                    },
                    operation: DataQuery.operations.read,
                    onSuccess: function (res) {
                        resolve(res.result);
                    },
                    applyOffline: false,
                    onError: reject
                });

                var getRequestOptionsFromQuery = RequestOptionsBuilder[dataQuery.operation];
                var requestOptions = getRequestOptionsFromQuery(dataQuery);
                var request = new Request(self.everlive.setup, requestOptions);
                request.send();
            });
        },

        _getSyncPromiseForCollection: function (collection, contentType) {
            var self = this;

            var batches = [];
            var batchSize = constants.syncBatchSize;

            var offlineItemsToSync = self._getDirtyItems(collection);

            var allIdsForSync;
            if (this._shouldAutogenerateIdForContentType(contentType)) {
                allIdsForSync = _.pluck(offlineItemsToSync, '_id');
            } else {
                allIdsForSync = _.pluck(_.reject(offlineItemsToSync, function (offlineItem) {
                    return offlineItem[constants.offlineItemsStateMarker] === offlineItemStates.created;
                }), '_id');
            }

            var batchCount = Math.ceil(allIdsForSync.length / batchSize);

            for (var i = 0; i < batchCount; i++) {
                var batchSkipSize = i * batchSize;
                var batchIds = allIdsForSync.slice(batchSkipSize, batchSkipSize + batchSize);
                var syncGetServerItemsPromise = this._getSyncPromiseBatch(contentType, batchIds);
                batches.push(syncGetServerItemsPromise);
            }

            return rsvp.all(batches)
                .then(function (serverItemsSyncResponses) {
                    var result = {
                        serverItems: []
                    };

                    _.each(serverItemsSyncResponses, function (serverItems) {
                        result.serverItems = _.union(result.serverItems, serverItems);
                    });

                    result.offlineItemsToSync = offlineItemsToSync;
                    return result;
                });
        },

        _addItemSynced: function (item, contentType, syncStorage, syncType) {
            if (!this._syncResultInfo.syncedItems[contentType]) {
                this._syncResultInfo.syncedItems[contentType] = [];
            }

            this._syncResultInfo.syncedItems[contentType].push({
                itemId: item.Id,
                type: syncType,
                storage: syncStorage
            })
        },

        _removeItemSynced: function (item, contentType) {
            var itemId;
            if (typeof item === 'string' || typeof item === 'number') {
                itemId = item;
            } else {
                itemId = item.Id;
            }

            if (!this._syncResultInfo.syncedItems[contentType]) {
                this._syncResultInfo.syncedItems[contentType] = [];
            }

            var syncedItems = this._syncResultInfo.syncedItems[contentType];
            this._syncResultInfo.syncedItems[contentType] = _.without(syncedItems, _.findWhere(syncedItems, {itemId: itemId}));
        },

        _getClientWinsSyncData: function (collections) {
            var self = this;

            var syncData = {};
            _.each(collections, function (collection, key) {
                if (!syncData[key]) {
                    syncData[key] = {
                        createdItems: [],
                        modifiedItems: [],
                        deletedItems: []
                    };
                }

                var dirtyItems = self._getDirtyItems(collection);
                var itemsForSync = offlineTransformations.idTransform(dirtyItems);
                _.each(itemsForSync, function (itemForSync) {
                    switch (itemForSync[constants.offlineItemsStateMarker]) {
                        case offlineItemStates.created:
                            syncData[key].createdItems.push({
                                remoteItem: itemForSync,
                                resultingItem: itemForSync
                            });
                            break;
                        case offlineItemStates.modified:
                            syncData[key].modifiedItems.push({
                                remoteItem: itemForSync,
                                resultingItem: itemForSync
                            });
                            break;
                        case offlineItemStates.deleted:
                            syncData[key].deletedItems.push({
                                remoteItem: itemForSync,
                                resultingItem: itemForSync
                            });
                            break;
                    }

                    delete itemForSync[constants.offlineItemsStateMarker];
                });

                syncData[key].offlineItemsToSync = itemsForSync;
            });
            return syncData;
        },

        _addModifiedItemsForSyncClientWins: function (contentTypeData, syncPromises, dataCollection) {
            var self = this;

            this._addUpdatedItemsForSync(contentTypeData, getSyncFilterNoModifiedAt, syncPromises, dataCollection, function (item) {
                var itemId = item.Id;
                if (!itemId) {
                    throw new EverliveError('When updating an item it must have an Id field.');
                }
                var collectionName = dataCollection.collectionName;
                syncPromises[itemId] = new rsvp.Promise(function (resolve, reject) {
                    return dataCollection
                        .isSync(true)
                        .applyOffline(false)
                        .updateSingle(item)
                        .then(function (res) {
                            self._addItemSynced(item, collectionName, 'server', 'update');
                            var updatedItem = _.extend({}, item, {
                                ModifiedAt: res.ModifiedAt
                            });

                            var updateQuery = new DataQuery({
                                operation: DataQuery.operations.update,
                                data: updatedItem,
                                additionalOptions: {
                                    id: item.Id
                                },
                                collectionName: collectionName,
                                isSync: true
                            });

                            return self.processQuery(updateQuery).then(resolve, function () {
                                reject(_.extend({}, {
                                    storage: 'client',
                                    type: 'update',
                                    itemId: item.Id,
                                    contentType: collectionName,
                                    error: res
                                }));
                            });
                        }, function (res) {
                            reject(_.extend({}, {
                                storage: 'server',
                                type: 'update',
                                itemId: item.Id,
                                contentType: collectionName,
                                error: res
                            }));
                        })
                });
            });
        },

        _addDeletedItemsForSyncClientWins: function (contentTypeData, syncPromises, dataCollection) {
            var self = this;

            this._addDeletedItemsForSync(contentTypeData, getSyncFilterNoModifiedAt, syncPromises, dataCollection,
                function (item, itemFilter) {
                    var collectionName = dataCollection.collectionName;
                    syncPromises[item.Id] = new rsvp.Promise(function (resolve, reject) {
                        var itemId = item.Id;
                        if (!itemId) {
                            throw new EverliveError('When deleting an item it must have an Id field.');
                        }

                        return dataCollection
                            .isSync(true)
                            .applyOffline(false)
                            .destroySingle(itemFilter)
                            .then(function () {
                                self._addItemSynced(item, collectionName, 'server', 'delete');
                                return self._purgeById(collectionName, item.Id).then(function () {
                                    resolve();
                                }, function (err) {
                                    reject(_.extend({}, {
                                        storage: 'client',
                                        type: 'delete',
                                        contentType: collectionName,
                                        itemId: itemId,
                                        error: err
                                    }));
                                });
                            }, function (err) {
                                reject(_.extend({}, {
                                    storage: 'server',
                                    type: 'delete',
                                    contentType: collectionName,
                                    error: err,
                                    itemId: itemId
                                }));
                            });
                    });
                });
        },

        _applyClientWins: function (collections) {
            var self = this;
            var syncData = this._getClientWinsSyncData(collections);
            var syncPromises = {};

            _.each(syncData, function (contentTypeData, typeName) {
                var dataCollection = self.everlive.data(typeName);
                if (contentTypeData.createdItems.length) {
                    self._addCreatedItemsForSync(contentTypeData, syncPromises, dataCollection);
                }

                if (contentTypeData.modifiedItems.length) {
                    self._addModifiedItemsForSyncClientWins(contentTypeData, syncPromises, dataCollection);
                }

                if (contentTypeData.deletedItems.length) {
                    self._addDeletedItemsForSyncClientWins(contentTypeData, syncPromises, dataCollection);
                }
            });

            return rsvp.hashSettled(syncPromises);
        },

        _applyStandardSync: function (collections) {
            var self = this;

            var promises = {};
            _.each(collections, function (collection, contentType) {
                promises[contentType] = self._getSyncPromiseForCollection(collection, contentType);
            });

            return rsvp.hash(promises)
                .then(self._prepareSyncData.bind(self))
                .then(self._resolveConflicts.bind(self))
                .then(function (contentTypeSyncData) {
                    var syncPromises = {};
                    _.each(contentTypeSyncData, function (contentTypeData, typeName) {
                        var dataCollection = self.everlive.data(typeName);
                        if (contentTypeData.createdItems.length) {
                            self._addCreatedItemsForSync(contentTypeData, syncPromises, dataCollection);
                        }

                        if (contentTypeData.modifiedItems.length) {
                            self._addUpdatedItemsForSync(contentTypeData, getSyncFilterForItem, syncPromises, dataCollection, function (item, itemFilter) {
                                syncPromises[item.Id] = dataCollection
                                    .isSync(true)
                                    .applyOffline(false)
                                    .update(item, itemFilter)
                                    .then(function (res) {
                                        return self._onSyncResponse(res, item, typeName, DataQuery.operations.update);
                                    });
                            });
                        }

                        if (contentTypeData.deletedItems.length) {
                            self._addDeletedItemsForSync(contentTypeData, getSyncFilterForItem, syncPromises, dataCollection, function (item, itemFilter) {
                                syncPromises[item.Id] = dataCollection
                                    .isSync(true)
                                    .applyOffline(false)
                                    .destroy(itemFilter)
                                    .then(function (res) {
                                        return self._onSyncResponse(res, item, typeName, DataQuery.operations.remove);
                                    });
                            });
                        }
                    });

                    return rsvp.hashSettled(syncPromises);
                });
        },

        _applySync: function () {
            var self = this;

            return this._getAllCollections()
                .then(function (collections) {
                    if (self.setup.conflicts.strategy === constants.ConflictResolutionStrategy.ClientWins) {
                        return self._applyClientWins(collections);
                    } else {
                        return self._applyStandardSync(collections);
                    }
                });
        },

        _getDirtyItems: function (collection) {
            var filter = {};
            filter[constants.offlineItemsStateMarker] = {$exists: true};
            var query = mingo.Query(filter);
            var cursor = mingo.Cursor(collection, query);
            return cursor.all();
        },

        _getAllCollections: function () {
            return new rsvp.Promise(this._persister.getAllData.bind(this._persister));
        },

        _getCollection: function (contentType) {
            var self = this;

            return new rsvp.Promise(function (resolve, reject) {
                // check the persister if there is no data in the collection cache for this content type
                if (!self._collectionCache[contentType]) {
                    self._persister.getData(contentType, function (data) {
                        self._collectionCache[contentType] = data || {};
                        resolve(self._collectionCache[contentType]);
                    }, reject);
                } else {
                    resolve(self._collectionCache[contentType]);
                }
            });
        },

        _persistData: function (contentType) {
            var self = this;

            return new rsvp.Promise(function (resolve, reject) {
                var contentTypeData = self._collectionCache[contentType];
                self._transformPersistedData(contentType, contentTypeData);
                self._persister.saveData(contentType, contentTypeData, resolve, reject);
            });
        },

        _getById: function (collection, id) {
            if (!id) {
                throw new EverliveError('Id field is mandatory when using offline storage');
            }

            if (collection[id]) {
                var item = _.extend({}, collection[id]);
                var isDeleted = item && item[constants.offlineItemsStateMarker] === offlineItemStates.deleted;

                return isDeleted ? undefined : item;
            }
        },

        _setItem: function (collection, item, state) {
            if (!state) {
                delete item[constants.offlineItemsStateMarker];
            } else {
                item[constants.offlineItemsStateMarker] = state;
            }

            collection[item._id] = item;
        },

        _shouldAutogenerateIdForContentType: function (contentType) {
            return !(this.setup && this.setup.typeSettings && this.setup.typeSettings[contentType] && this.setup.typeSettings[contentType].autoGenerateId === false);
        },

        _createItems: function (contentType, items, isSync, preserveState, success, error) {
            var self = this;
            this._getCollection(contentType)
                .then(function (collection) {
                    var itemsForCreate = _.isArray(items) ? items : [items];
                    var createdItems = _.map(itemsForCreate, function (currentItem, index) {
                        var itemToCreate = _.extend({}, currentItem);

                        itemToCreate._id = itemToCreate.Id || uuid.v1();
                        delete itemToCreate.Id;

                        var existingItem = self._getById(collection, itemToCreate._id);
                        var itemExists = !!existingItem;
                        var state;
                        if (itemExists && (!isSync && !preserveState)) {
                            // TODO: [offline] return the same error as the server does
                            return error(new Error('An item with the specified id already exists'));
                        } else {
                            if (isSync && preserveState && itemExists) {
                                state = existingItem[constants.offlineItemsStateMarker];
                            } else {
                                state = isSync ? undefined : offlineItemStates.created; // set the state to created only if not syncing
                            }
                        }

                        // we need to manually clone the dates in order to dereference them from the original object as
                        // _.extends will pass a reference to the original date instead of creating a new instance
                        if (currentItem.CreatedAt && currentItem.CreatedAt instanceof Date) {
                            itemToCreate.CreatedAt = utils.cloneDate(currentItem.CreatedAt);
                        } else {
                            itemToCreate.CreatedAt = new Date();
                        }

                        if (currentItem.ModifiedAt && currentItem.ModifiedAt instanceof Date) {
                            itemToCreate.ModifiedAt = utils.cloneDate(currentItem.ModifiedAt);
                        } else {
                            itemToCreate.ModifiedAt = utils.cloneDate(itemToCreate.CreatedAt);
                        }

                        itemToCreate.CreatedBy = itemToCreate.CreatedBy || self.everlive.setup.principalId || constants.guidEmpty;
                        itemToCreate.ModifiedBy = itemToCreate.ModifiedBy || itemToCreate.CreatedBy;
                        if (contentType === 'Users') {
                            itemToCreate.Owner = itemToCreate._id;
                        } else {
                            itemToCreate.Owner = itemToCreate.CreatedBy || constants.guidEmpty;
                        }

                        self._setItem(collection, _.extend({}, itemToCreate), state);
                        return itemToCreate;
                    });

                    return self._persistData(contentType).then(function () {
                        if (!self._shouldAutogenerateIdForContentType(contentType) && !isSync) {
                            createdItems = offlineTransformations.removeIdTransform(createdItems);
                        }
                        success(createdItems);
                    });
                }).catch(error);
        },

        _applyUpdateOperation: function (originalUpdateExpression, itemToUpdate, collection, isSync) {
            var dbOperators = utils.getDbOperators(originalUpdateExpression, true);
            var hasDbOperator = dbOperators.length !== 0;

            var updateExpression;
            if (hasDbOperator) {
                updateExpression = originalUpdateExpression;
            } else {
                updateExpression = {
                    $set: originalUpdateExpression
                };
            }
            var updateExpressionForUser = {
                ModifiedBy: this.everlive.setup.principalId || constants.guidEmpty
            };
            updateExpression.$set = _.extend(updateExpressionForUser, updateExpression.$set);

            if (isSync) {
                updateExpression.$set.ModifiedAt = utils.cloneDate(originalUpdateExpression.ModifiedAt);
            }

            mongoQuery(itemToUpdate, {}, updateExpression, {strict: true}); // Setting strict to true so only exact matches would be updated

            itemToUpdate._id = itemToUpdate._id || updateExpression._id || updateExpression.Id;
            delete itemToUpdate.Id;

            var newState;
            if (isSync) {
                newState = undefined;
            } else if (itemToUpdate[constants.offlineItemsStateMarker] === offlineItemStates.created) {
                newState = offlineItemStates.created;
            } else {
                newState = offlineItemStates.modified;
            }

            this._setItem(collection, itemToUpdate, newState);
        },

        _updateItems: function (dataQuery, updateExpression, filter, isSync, resolve, reject) {
            var self = this;

            self._getCollection(dataQuery.collectionName)
                .then(function (collection) {
                    var updateItems;

                    if (dataQuery.additionalOptions && dataQuery.additionalOptions.id) {
                        itemToUpdate = self._getById(collection, dataQuery.additionalOptions.id);
                        self._applyUpdateOperation(updateExpression, itemToUpdate, collection, isSync);
                        updateItems = [itemToUpdate];
                    } else {
                        updateItems = self._readInternal(collection, filter);
                        for (var i = 0; i < updateItems.length; i++) {
                            var itemToUpdate = updateItems[i];
                            var itemExists = !!self._getById(collection, itemToUpdate._id.toString());

                            if (!itemExists && !isSync) {
                                return reject(EverliveErrors.itemNotFound);
                            }

                            self._applyUpdateOperation(updateExpression, itemToUpdate, collection, isSync);
                        }
                    }

                    return self._persistData(dataQuery.collectionName)
                        .then(function () {
                            var updatedItemCount = updateItems.length;
                            var modifiedAtResult = updatedItemCount ? updateItems[0].ModifiedAt : new Date();

                            var result = {
                                ModifiedAt: modifiedAtResult,
                                result: updatedItemCount
                            };

                            resolve(result);
                        });
                }).catch(reject);
        },

        _clearItem: function (collection, item) {
            delete collection[item._id];
        },

        _removeItems: function (dataQuery, filter, isSync, resolve, reject) {
            var self = this;

            self._getCollection(dataQuery.collectionName)
                .then(function (collection) {
                    var itemsToRemove = self._readInternal(collection, filter);

                    for (var i = 0; i < itemsToRemove.length; i++) {
                        var itemToRemove = itemsToRemove[i];
                        itemToRemove._id = itemToRemove._id || itemToRemove.Id;
                        var itemExists = !!self._getById(collection, itemToRemove._id.toString());

                        if (!itemExists && !isSync) {
                            return reject(new EverliveError('Cannot delete item - item with id ' + itemToRemove._id + ' does not exist.'));
                        }

                        var removeFromMemory = itemToRemove[constants.offlineItemsStateMarker] === offlineItemStates.created || isSync;
                        if (removeFromMemory) {
                            self._clearItem(collection, itemToRemove);
                        } else {
                            self._setItem(collection, itemToRemove, offlineItemStates.deleted);
                        }
                    }

                    return self._persistData(dataQuery.collectionName)
                        .then(function () {
                            var response = self._transformOfflineResult(itemsToRemove.length);
                            resolve(response);
                        });
                }).catch(reject);
        },

        _applyTransformations: function (transformedResult, transformations) {
            if (Array.isArray(transformedResult.result)) {
                _.each(transformations, function (transformation) {
                    transformedResult.result.map(function (value, key) {
                        transformedResult.result[key] = transformation(value);
                    });
                });
            } else {
                _.each(transformations, function (transformation) {
                    transformedResult.result = transformation(transformedResult.result);
                });
            }
        },

        _transformOfflineResult: function (resultSet, count, dataQuery, additionalTransformations) {
            var transformedResult = {
                result: resultSet,
                count: count || (resultSet || []).length
            };

            if ((count !== undefined && count !== null) || Array.isArray(resultSet)) {
                transformedResult.count = count || resultSet.length;
            }

            var transformations = [];

            transformations.push(offlineTransformations.idTransform);
            transformations.push(offlineTransformations.removeMarkersTransform);

            if (dataQuery) {
                var includeCount = dataQuery.getHeader(Headers.includeCount);
                if (includeCount === false) {
                    delete transformedResult.count;
                }

                var singleFieldExpression = dataQuery.getHeader(Headers.singleField);
                if (typeof singleFieldExpression === 'string') {
                    transformations.push(offlineTransformations.singleFieldTransform.bind(this, singleFieldExpression));
                }
            }

            if (additionalTransformations) {
                transformations = transformations.concat(additionalTransformations);
            }

            this._applyTransformations(transformedResult, transformations);

            if (transformedResult.count === undefined) {
                delete transformedResult.count;
            }

            return transformedResult;
        },

        _transformPersistedData: function (contentType, contentTypeData) {
            var transformFields = [];

            if (contentType === 'Users') {
                transformFields = transformFields.concat(['Password', 'QuestionId', 'SecretAnswer']);
            }

            if (transformFields.length) {
                _.each(contentTypeData, function (contentTypeObject) {
                    offlineTransformations.removeFieldsTransform(contentTypeObject, transformFields);
                });
            }
        }
    };

    return OfflineModule;
})();
},{"../EverliveError":43,"../ExpandProcessor":44,"../Request":49,"../common":53,"../constants":54,"../query/DataQuery":63,"../query/RequestOptionsBuilder":66,"../utils":73,"./offlineTransformations":62}],60:[function(require,module,exports){
var constants = require('../constants');
var persistersModule = require('./offlinePersisters');
var LocalStoragePersister = persistersModule.LocalStoragePersister;
var FileSystemPersister = persistersModule.FileSystemPersister;
var OfflineStorageModule = require('./OfflineStorageModule');
var EverliveError = require('../EverliveError').EverliveError;
var isNativeScript = require('../everlive.platform').isNativeScript;
var common = require('../common');
var _ = common._;
var rsvp = common.rsvp;
var CryptographicProvider = require('../encryption/CryptographicProvider');

var defaultOfflineStorageOptions = {
    autoSync: true,
    enabled: true,
    conflicts: {
        strategy: constants.ConflictResolutionStrategy.ClientWins,
        implementation: null
    },
    offline: false,
    storage: {
        name: '',
        provider: isNativeScript ? constants.StorageProvider.FileSystem : constants.StorageProvider.LocalStorage,
        implementation: null,
        storagePath: constants.DefaultStoragePath
    },
    typeSettings: {},
    encryption: {
        provider: constants.EncryptionProvider.Default,
        implementation: null,
        key: ''
    }
};

module.exports = (function () {

    var conflictResolutionStrategies = {};

    conflictResolutionStrategies[constants.ConflictResolutionStrategy.ClientWins] = function (collection, local, server) {
        return new rsvp.Promise(function (resolve) {
            resolve(local);
        });
    };

    conflictResolutionStrategies[constants.ConflictResolutionStrategy.ServerWins] = function (collection, local, server) {
        return new rsvp.Promise(function (resolve) {
            resolve(server);
        });
    };

    var initStoragePersister = function initStoragePersister(options) {
        var persister;
        var storageProvider = options.storage.provider;
        var storageProviderImplementation = options.storage.implementation;
        var storageKey = options.storage.name || 'everliveOfflineStorage_' + this.setup.apiKey;
        if (_.isObject(storageProviderImplementation) && storageProvider === constants.StorageProvider.Custom) {
            persister = storageProviderImplementation;
        } else {
            switch (storageProvider) {
                case constants.StorageProvider.LocalStorage:
                    persister = new LocalStoragePersister(storageKey, this);
                    break;
                case constants.StorageProvider.FileSystem:
                    persister = new FileSystemPersister(storageKey, this);
                    break;
                case constants.StorageProvider.Custom:
                    throw new EverliveError('Custom storage provider requires an implementation object');
                default:
                    throw new EverliveError('Unsupported storage type ' + storageProvider);
            }
        }

        options.storage.implementation = persister;
        return persister;
    };

    var initEncryptionProvider = function initEncryptionProvider(options) {
        var encryptor;
        var encryptionProvider = options.encryption.provider;
        var encryptionImplementation = options.encryption.implementation;
        if (_.isObject(encryptionImplementation) && encryptionProvider === constants.EncryptionProvider.Custom) {
            encryptor = encryptionImplementation;
        } else {
            switch (encryptionProvider) {
                case constants.EncryptionProvider.Default:
                    encryptor = new CryptographicProvider(this);
                    break;
                case constants.EncryptionProvider.Custom:
                    throw new EverliveError('Custom encryption provider requires an implementation object');
                default:
                    throw new EverliveError('Unsupported encryption provider ' + encryptionProvider);
            }
        }

        options.encryption.implementation = encryptor;
        return encryptor;
    };

    var buildOfflineStorageModule = function buildOfflineStorageModule(storageOptions) {
        var options;
        if (storageOptions === true) { // explicit check for shorthand initialization
            options = _.defaults({}, defaultOfflineStorageOptions);
        } else if (_.isObject(storageOptions)) {
            options = _.defaults(storageOptions, defaultOfflineStorageOptions);
            options.storage = _.defaults(storageOptions.storage, defaultOfflineStorageOptions.storage);
            options.encryption = _.defaults(storageOptions.encryption, defaultOfflineStorageOptions.encryption);
            options.conflicts = _.defaults(storageOptions.conflicts, defaultOfflineStorageOptions.conflicts);
        } else {
            options = _.defaults({}, defaultOfflineStorageOptions);
            options.enabled = false;
        }

        var persister = initStoragePersister.call(this, options, storageOptions);
        var encryptionProvider = initEncryptionProvider.call(this, options);

        return new OfflineStorageModule(this, options, persister, encryptionProvider);
    };

    var initOfflineStorage = function (options) {
        this.offlineStorage = buildOfflineStorageModule.call(this, options.offlineStorage);
    };

    return {
        initOfflineStorage: initOfflineStorage
    }
}());
},{"../EverliveError":43,"../common":53,"../constants":54,"../encryption/CryptographicProvider":55,"../everlive.platform":56,"./OfflineStorageModule":59,"./offlinePersisters":61}],61:[function(require,module,exports){
var common = require('../common');
var _ = common._;
var platform = require('../everlive.platform');
var isNativeScript = platform.isNativeScript;
var isCordova = platform.isCordova;
var rsvp = common.rsvp;
var parseUtilities = require('../utils').parseUtilities;
var EverliveError = require('../EverliveError').EverliveError;
var util = require('util');
var LocalStore = require('../LocalStore');
var constants = require('../constants');

/**
 * Can be one of the following types: {@link LocalStoragePersister},
 * {@link FileSystemPersister} or a custom based on {@link BasePersister}
 * @memberOf OfflineModule
 * @instance
 * @member {BasePersister} local
 */

var BasePersister = (function () {

    /**
     * @class BasePersister
     * @classdesc An abstraction layer for all persisters. Every persister can write/read
     * data from a specific place. The data is saved as key-value pairs where the keys are
     * content types.
     */
    function BasePersister(key, sdk) {
        this.key = key;
        this.sdk = sdk;
    }

    BasePersister.prototype = {
        /**
         * Gets all the saved data.
         * @method getAllData
         * @memberof BasePersister
         * @param {Function} success A success callback
         * @param {Function} error An error callback
         * @returns {Object} Keys are the content types and the values are the corresponding data
         */
        getAllData: function (success, error) {
            throw new EverliveError('The method getAllData is not implemented');
        },

        /**
         * Returns the saved data for a specific content type
         * @method getData
         * @param {string} contentType The content type for which to retreive the data
         * @param {Function} success A success callback
         * @param {Function} error An error callback
         * @memberof BasePersister
         * @returns {Object} The retrieved data
         */
        getData: function (contentType, success, error) {
            throw new EverliveError('The method getData is not implemented');
        },

        /**
         * Saves data for a specific content type
         * @method saveData
         * @param {string} contentType The content for which to save the data
         * @param {object} data The data corresponding to the specified content type
         * @param {Function} success A success callback
         * @param {Function} error An error callback
         * @memberof BasePersister
         */
        saveData: function (contentType, data, success, error) {
            throw new EverliveError('The method saveData is not implemented');
        },

        /**
         * Clears the persisted data for a specific content type
         * @method clear
         * @param {string} contentType The content type for which to clear the data
         * @param {Function} success A success callback
         * @param {Function} error An error callback
         * @memberof BasePersister
         */
        purge: function (contentType, success, error) {
            throw new EverliveError('The method clear is not implemented');
        },

        /**
         * Clears the persisted data for a content type
         * @method clearAll
         * @memberof BasePersister
         * @param {Function} success A success callback
         * @param {Function} error An error callback
         */
        purgeAll: function (success, error) {
            throw new EverliveError('The method clearAll is not implemented');
        },

        _getKey: function (contentType) {
            return this.key + '_' + contentType;
        },

        _getEncryptionProvider: function () {
            return this.sdk.offlineStorage._getEncryptionProvider();
        }
    };

    return BasePersister;
}());

var LocalStoragePersister = (function () {
    /**
     * @class LocalStoragePersister
     * @extends BasePersister
     */
    function LocalStoragePersister(key, sdk) {
        BasePersister.apply(this, arguments);
        this._localStore = null;
    }

    util.inherits(LocalStoragePersister, BasePersister);

    //We need to offline storage path from the sdk.offlineStorage.setup in nodejs
    //but it is not available since it is created after the persisters are initialized
    //that is why we pospone the localstore initialization for the first time it is needed
    LocalStoragePersister.prototype._ensureLocalStore = function () {
        if (!this._localStore) {
            this._localStore = new LocalStore(this.sdk);
        }
    };

    LocalStoragePersister.prototype.getAllData = function (success, error) {
        var self = this;
        var contentTypes = this._getContentTypes();
        var allCollections = {};
        _.each(contentTypes, function (contentType) {
            allCollections[contentType] = new rsvp.Promise(function (resolve, reject) {
                self.getData(contentType, resolve, reject);
            });
        });

        rsvp.hash(allCollections).then(success, error);
    };

    LocalStoragePersister.prototype.getData = function (contentType, success, error) {
        try {
            var key = this._getKey(contentType);
            var storedItem = this._getItem(key) || '{}';
            var reviver = parseUtilities.getReviver();
            var storedItemObject = JSON.parse(storedItem, reviver);
            success(storedItemObject);
        } catch (e) {
            error(e);
        }
    };

    LocalStoragePersister.prototype.saveData = function (contentType, data, success, error) {
        try {
            var collectionsString = JSON.stringify(data);
            var contentTypeKey = this._getKey(contentType);
            this._setItem(contentTypeKey, collectionsString);
            success();
        } catch (e) {
            error(e);
        }
    };

    LocalStoragePersister.prototype.purge = function (contentType, success, error) {
        try {
            var key = this._getKey(contentType);
            this._removeItem(key);
            success();
        } catch (e) {
            error(e);
        }
    };

    LocalStoragePersister.prototype.purgeAll = function (success, error) {
        try {
            var self = this;

            var contentTypes = this._getContentTypes();
            _.each(contentTypes, function (contentType) {
                var contentTypeKey = self._getKey(contentType);
                self._removeItem(contentTypeKey);
            });

            var contentTypesKey = this._getContentTypesCollectionKey();
            this._removeItem(contentTypesKey);

            success();
        } catch (e) {
            error(e);
        }
    };

    LocalStoragePersister.prototype._getItem = function (key) {
        this._ensureLocalStore();
        var value = this._localStore.getItem(key);
        var encryptionProvider = this._getEncryptionProvider();
        return encryptionProvider.decrypt(value);
    };

    LocalStoragePersister.prototype._setItem = function (key, value) {
        this._ensureLocalStore();
        var encryptionProvider = this._getEncryptionProvider();
        value = encryptionProvider.encrypt(value);
		return this._localStore.setItem(key, value);

    };

    LocalStoragePersister.prototype._removeItem = function (key) {
        this._ensureLocalStore();
        return this._localStore.removeItem(key);
    };

    LocalStoragePersister.prototype._getKey = function (contentType) {
        this._ensureLocalStore();
        this._addTypeToCollectionsCache(contentType);
        return LocalStoragePersister.super_.prototype._getKey.apply(this, arguments);
    };

    LocalStoragePersister.prototype._getContentTypesCollectionKey = function () {
        return this.key + '@ContentTypes';
    };

    LocalStoragePersister.prototype._getContentTypes = function () {
        var collectionKey = this._getContentTypesCollectionKey();
        var localStorageString = this._getItem(collectionKey);

        if (localStorageString) {
            return JSON.parse(localStorageString);
        }

        return [];
    };

    LocalStoragePersister.prototype._setContentTypesCollection = function (collection) {
        var collectionKey = this._getContentTypesCollectionKey();
        this._setItem(collectionKey, JSON.stringify(collection));
    };

    LocalStoragePersister.prototype._addTypeToCollectionsCache = function (typeName) {
        var contentTypesCollection = this._getContentTypes();
        if (!_.contains(contentTypesCollection, typeName)) {
            contentTypesCollection.push(typeName);
            this._setContentTypesCollection(contentTypesCollection);
        }
    };

    return LocalStoragePersister;
}());

var FileSystemPersister = (function () {
    /**
     * @class FileSystemPersister
     * @extends BasePersister
     */
    function FileSystemPersister(key, sdk) {
        BasePersister.apply(this, arguments);

        if (!isCordova && !isNativeScript) {
            throw new EverliveError('FileSystemPersister can be used only with Cordova and NativeScript');
        }

        this.contentTypesStoreKey = '@ContentTypes';
    }

    util.inherits(FileSystemPersister, BasePersister);

    FileSystemPersister.prototype.getAllData = function (success, error) {
        var self = this;
        var errorHandler = this._fileSystemErrorHandler(error);
        var promises = {};
        this._getContentTypesMetadata(function (contentTypes) {
            Object.keys(contentTypes).forEach(function (contentType) {
                promises[contentType] = new rsvp.Promise(function (resolve, reject) {
                    self.getData(contentType, resolve, reject);
                });
            });

            rsvp.hash(promises).then(success, errorHandler);
        }, errorHandler);
    };

    FileSystemPersister.prototype.getData = function (contentType, success, error) {
        var self = this;
        var errorHandler = this._fileSystemErrorHandler(error);
        this._getFileFull(contentType, function (fileEntry) {
            self._readFileContent(fileEntry, success, errorHandler);
        }, error);
    };

    FileSystemPersister.prototype.saveData = function (contentType, data, success, error) {
        var self = this;
        var dataString = JSON.stringify(data);
        var errorHandler = this._fileSystemErrorHandler(error);
        this._getFileFull(contentType, function (fileEntry) {
            self._writeFileContent(fileEntry, dataString, function () {
                self._saveContentTypesMetadata(contentType, success, errorHandler);
            }, errorHandler);
        }, errorHandler);
    };

    FileSystemPersister.prototype.purge = function (contentType, success, error) {
        var self = this;
        var errorHandler = this._fileSystemErrorHandler(error);
        this._getFileFull(contentType, function (fileEntry) {
            self._removeFile(fileEntry, success, error);
        }, errorHandler);
    };

    FileSystemPersister.prototype.purgeAll = function (success, error) {
        var self = this;
        var errorHandler = this._fileSystemErrorHandler(error);
        this._resolveDataDirectory(function (dataDirEntry) {
            self._removeFilesDirectory(dataDirEntry, success, errorHandler);
        }, errorHandler);
    };

    FileSystemPersister.prototype._ensureProperties = function () {
        if (!this.filesDirectoryPath) {
            this.filesDirectoryPath = this.sdk.offlineStorage.setup.storage.storagePath;
        }

        if (!this.dataDirectoryPath) {
            if (isCordova) {
                if (cordova && !cordova.file) {
                    throw new EverliveError('You need to enable the cordova file plugin to use file offline storage. ' +
                    'Make sure that the "deviceReady" event has fired.');
                }

                this.dataDirectoryPath = cordova.file.dataDirectory;
            } else if (isNativeScript) {
                this.fs = require('file-system');
                this.dataDirectoryPath = this.fs.knownFolders.documents().path;
            }
        }
    };

    FileSystemPersister.prototype._getContentTypesMetadata = function (success, error) {
        this._ensureProperties();
        this.getData(this.contentTypesStoreKey, success, error);
    };

    FileSystemPersister.prototype._saveContentTypesMetadata = function (contentType, success, error) {
        this._ensureProperties();
        var self = this;
        this._getContentTypesMetadata(function (savedContentTypes) {
            savedContentTypes[contentType] = true;
            self._getFileFull(self.contentTypesStoreKey, function (contentTypesFile) {
                self._writeFileContent(contentTypesFile, JSON.stringify(savedContentTypes), success, error);
            }, error);
        });
    };

    FileSystemPersister.prototype._getFileFull = function (contentType, success, error) {
        this._ensureProperties();
        var self = this;
        this._ensureFilesDirectory(function () {
            var path = self._getFilePath(contentType);
            self._getFileFromSystem(path, success, error);
        }, error);
    };

    FileSystemPersister.prototype._removeFilesDirectory = function (directoryEntry, success, error) {
        this._ensureProperties();
        if (isCordova) {
            directoryEntry.getDirectory(this.filesDirectoryPath, {
                create: true,
                exclusive: false
            }, function (filesDirEntry) {
                filesDirEntry.removeRecursively(function () {
                    success();
                }, error);
            }, error)
        } else if (isNativeScript) {
            var filesDirectoryPath = this.fs.path.join(directoryEntry.path, this.filesDirectoryPath);
            var filesDirectory = this.fs.Folder.fromPath(filesDirectoryPath);
            filesDirectory.remove().then(success, error);
        }
    };

    FileSystemPersister.prototype._removeFile = function (fileEntry, success, error) {
        this._ensureProperties();
        if (isCordova) {
            fileEntry.remove(function () {
                success();
            }, error);
        } else if (isNativeScript) {
            fileEntry.remove().then(success, error);
        }
    };

    FileSystemPersister.prototype._readFileContent = function (fileEntry, success, error) {
        this._ensureProperties();
        var that = this;
        var readTextSuccess = function (content) {
            var encryptionProvider = that._getEncryptionProvider();
            content = encryptionProvider.decrypt(content);

            var reviver = parseUtilities.getReviver();
            var resultObject = JSON.parse(content || '{}', reviver);
            success(resultObject);
        };

        if (isCordova) {
            fileEntry.file(function (file) {
                var reader = new FileReader();
                reader.onloadend = function () {
                    readTextSuccess(this.result);
                };
                reader.onerror = error;
                reader.readAsText(file);
            }, error);
        } else if (isNativeScript) {
            fileEntry.readText().then(readTextSuccess, error);
        }
    };

    FileSystemPersister.prototype._writeFileContent = function (fileEntry, content, success, error) {
        this._ensureProperties();
        var encryptionProvider = this._getEncryptionProvider();
        content = encryptionProvider.encrypt(content);

        if (isCordova) {
            fileEntry.createWriter(function (fileWriter) {
                fileWriter.onwriteend = function () {
                    success();
                };

                fileWriter.onerror = error;
                fileWriter.write(content);
            }, error);
        } else if (isNativeScript) {
            fileEntry.writeText(content).then(success, error);
        }
    };

    FileSystemPersister.prototype._getFileFromSystem = function (path, success, error) {
        this._ensureProperties();
        this._resolveDataDirectory(function (directoryEntry) {
            if (isCordova) {
                directoryEntry.getFile(path, {
                    create: true,
                    exclusive: false
                }, success, error);
            } else if (isNativeScript) {
                try {
                    var fullFilePath = this.fs.path.join(directoryEntry.path, path);
                    var file = this.fs.File.fromPath(fullFilePath);
                    success(file);
                } catch (e) {
                    error(e);
                }
            }
        }.bind(this));
    };

    FileSystemPersister.prototype._getFilePath = function (contentType) {
        this._ensureProperties();
        return this.filesDirectoryPath + this._getKey(contentType);
    };

    FileSystemPersister.prototype._resolveDataDirectory = function (success, error) {
        this._ensureProperties();
        if (isCordova) {
            resolveLocalFileSystemURL(this.dataDirectoryPath, success, error);
        } else if (isNativeScript) {
            var dataDirectory = this.fs.Folder.fromPath(this.dataDirectoryPath);
            success(dataDirectory);
        }
    };

    FileSystemPersister.prototype._ensureFilesDirectory = function (success, error) {
        this._ensureProperties();
        var filesDirectoryPath = this.filesDirectoryPath;
        this._resolveDataDirectory(function (directoryEntry) {
            if (isCordova) {
                directoryEntry.getDirectory(filesDirectoryPath, {
                    create: true,
                    exclusive: false
                }, success, error);
            } else if (isNativeScript) {
                try {
                    var fileDirectoryPath = this.fs.path.join(directoryEntry.path, filesDirectoryPath);
                    this.fs.Folder.fromPath(fileDirectoryPath);
                    success();
                } catch (e) {
                    error (e);
                }
            }
        }.bind(this), error);
    };

    FileSystemPersister.prototype._fileSystemErrorHandler = function (callback) {
        if (!isNativeScript) {
            var errorsMap = {};
            _.each(Object.keys(FileError), function (error) {
                errorsMap[FileError[error]] = error;
            });

            return function (e) {
                e.message = errorsMap[e.code];
                callback && callback(e);
            }
        }

        return function (e) {
            callback && callback(e);
        }
    };

    return FileSystemPersister;
}());

module.exports = {
    BasePersister: BasePersister,
    LocalStoragePersister: LocalStoragePersister,
    FileSystemPersister: FileSystemPersister
};
},{"../EverliveError":43,"../LocalStore":47,"../common":53,"../constants":54,"../everlive.platform":56,"../utils":73,"file-system":"file-system","util":5}],62:[function(require,module,exports){
'use strict';

var constants = require('../constants');
var _ = require('../common')._;
var offlineItemStateMarker = constants.offlineItemsStateMarker;

var traverseAndApply = function (value, operation, additionalOptions) {
    if (_.isArray(value)) {
        return _.map(value, function (item) {
            return operation(item, additionalOptions);
        });
    } else {
        return operation(value, additionalOptions);
    }
};

var idTransformation = function (value) {
    if (typeof value === 'object' && value._id && !value.Id) {
        value.Id = value._id;
        delete value._id;
    }

    return value;
};

var removeIdTransform = function (value, opts) {
    var verifyStateCreated = opts.verifyStateCreated;
    var shouldModifyObject = verifyStateCreated ? value[constants.offlineItemsStateMarker] === constants.offlineItemStates.created : true;
    if (typeof value === 'object' && (value._id || value.Id) && shouldModifyObject) {
        delete value._id;
        delete value.Id;
    }

    return value;
};

var removeMarkerTransform = function (value) {
    delete value[offlineItemStateMarker];
    return value;
};

var offlineTransformations = {
    removeIdTransform: function (value, verifyStateCreated) {
        return traverseAndApply(value, removeIdTransform, {verifyStateCreated: verifyStateCreated});
    },
    idTransform: function (value) {
        return traverseAndApply(value, idTransformation);
    },
    singleFieldTransform: function (singleFieldExpression, value) {
        if (typeof value === 'undefined' || value === null) {
            return null;
        } else {
            return value[singleFieldExpression];
        }
    },
    traverseAndTransformFilterId: function (filterObj) {
        if (filterObj && filterObj.Id) {
            filterObj._id = filterObj.Id;
            delete filterObj.Id;
        }

        for (var prop in filterObj) {
            if (filterObj.hasOwnProperty(prop)) {
                var objectMember = filterObj[prop];
                if (typeof objectMember === 'object') {
                    offlineTransformations.traverseAndTransformFilterId(objectMember);
                }
            }
        }
    },
    removeMarkersTransform: function (value) {
        return traverseAndApply(value, removeMarkerTransform);
    },
    removeFieldsTransform: function (value, fields) {
        _.each(fields, function (field) {
            delete value[field];
        });

        return value;
    }
};

module.exports = offlineTransformations;
},{"../common":53,"../constants":54}],63:[function(require,module,exports){
var _ = require('../common')._;

module.exports = (function () {
    // TODO: [offline] Update the structure - filter field can be refactored for example and a skip/limit/sort property can be added
    var DataQuery = function (config) {
        this.collectionName = config.collectionName;
        this.headers = config.headers || {};
        this.filter = config.filter;
        this.onSuccess = config.onSuccess;
        this.onError = config.onError;
        this.operation = config.operation;
        this.parse = config.parse;
        this.additionalOptions = config.additionalOptions;
        this.data = config.data;
        this.useOffline = config.useOffline;
        this.applyOffline = config.applyOffline;
        this.noRetry = config.noRetry; //retry will be done by default, when a request fails because of expired token, once the authentication.completeAuthentication in sdk is called.
        this.skipAuth = config.skipAuth; //if set to true, the sdk will not require authorization if the data query fails because of expired token. Used internally for various login methods.
        this._normalizedHeaders = null;
        this.isSync = config.isSync;
    };

    DataQuery.prototype = {
        getHeader: function (header) {
            var self = this;
            var headerKeys = Object.keys(this.headers);

            if (!this._normalizedHeaders) {
                this._normalizedHeaders = {};
                _.each(headerKeys, function (headerKey) {
                    var normalizedKey = headerKey.toLowerCase();
                    var headerValue = self.headers[headerKey];
                    self._normalizedHeaders[normalizedKey] = headerValue;
                });
            }

            var normalizedHeader = header.toLowerCase();
            return this._normalizedHeaders[normalizedHeader];
        },

        getHeaderAsJSON: function (header) {
            var headerValue = this._normalizedHeaders[header.toLowerCase()];
            if (_.isObject(headerValue)) {
                return headerValue;
            }
            if (_.isString(headerValue)) {
                try {
                    return JSON.parse(headerValue);
                } catch (e) {
                    return headerValue;
                }
            } else {
                return headerValue;
            }
        }
    };

    DataQuery.operations = {
        read: 'read',
        create: 'create',
        update: 'update',
        remove: 'destroy',
        removeSingle: 'destroySingle',
        readById: 'readById',
        count: 'count',
        rawUpdate: 'rawUpdate',
        setAcl: 'setAcl',
        setOwner: 'setOwner',
        userLogin: 'login',
        userLogout: 'logout',
        userChangePassword: 'changePassword',
        userLoginWithProvider: 'loginWith',
        userLinkWithProvider: 'linkWith',
        userUnlinkFromProvider: 'unlinkFrom',
        filesUpdateContent: 'updateContent',
        filesGetDownloadUrlById: 'downloadUrlById'
    };

    return DataQuery;
}());
},{"../common":53}],64:[function(require,module,exports){
var Expression = require('../Expression');
var OperatorType = require('../constants').OperatorType;
var WhereQuery = require('./WhereQuery');
var QueryBuilder = require('./QueryBuilder');

module.exports = (function () {
    /**
     * @class Query
     * @classdesc A query class used to describe a request that will be made to the {{site.TelerikBackendServices}} JavaScript API.
     * @param {object} [filter] A [filter expression]({% slug rest-api-querying-filtering %}) definition.
     * @param {object} [fields] A [fields expression]({% slug rest-api-querying-Subset-of-fields %}) definition.
     * @param {object} [sort] A [sort expression]({% slug rest-api-querying-sorting %}) definition.
     * @param {number} [skip] Number of items to skip. Used for paging.
     * @param {number} [take] Number of items to take. Used for paging.
     * @param {object} [expand] An [expand expression]({% slug features-data-relations-defining-expand %}) definition.
     */
    function Query(filter, fields, sort, skip, take, expand) {
        this.filter = filter;
        this.fields = fields;
        this.sort = sort;
        this.toskip = skip;
        this.totake = take;
        this.expandExpression = expand;
        this.expr = new Expression(OperatorType.query);
    }

    Query.prototype = {
        /** Applies a filter to the current query. This allows you to retrieve only a subset of the items based on various filtering criteria.
         * @memberOf Query.prototype
         * @method where
         * @name where
         * @param {object} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @returns {Query}
         */
        /** Defines a filter definition for the current query.
         * @memberOf Query.prototype
         * @method where
         * @name where
         * @returns {WhereQuery}
         */
        where: function (filter) {
            if (filter) {
                return this._simple(OperatorType.filter, [filter]);
            }
            else {
                return new WhereQuery(this);
            }
        },
        /** Applies a fields selection to the current query. This allows you to retrieve only a subset of all available item fields.
         * @memberOf Query.prototype
         * @method select
         * @param {object} fieldsExpression A [fields expression]({% slug rest-api-querying-Subset-of-fields %}) definition.
         * @returns {Query}
         */
        select: function () {
            return this._simple(OperatorType.select, arguments);
        },
        // TODO
        //exclude: function () {
        //    return this._simple(OperatorType.exclude, arguments);
        //},
        /** Sorts the items in the current query in ascending order by the specified field.
         * @memberOf Query.prototype
         * @method order
         * @param {string} field The field name to order by in ascending order.
         * @returns {Query}
         */
        order: function (field) {
            return this._simple(OperatorType.order, [field]);
        },
        /** Sorts the items in the current query in descending order by the specified field.
         * @memberOf Query.prototype
         * @method orderDesc
         * @param {string} field The field name to order by in descending order.
         * @returns {Query}
         */
        orderDesc: function (field) {
            return this._simple(OperatorType.order_desc, [field]);
        },
        /** Skips a certain number of items from the beginning before returning the rest of the items. Used for paging.
         * @memberOf Query.prototype
         * @method skip
         * @see [query.take]{@link query.take}
         * @param {number} value The number of items to skip.
         * @returns {Query}
         */
        skip: function (value) {
            return this._simple(OperatorType.skip, [value]);
        },
        /** Takes a specified number of items from the query result. Used for paging.
         * @memberOf Query.prototype
         * @method take
         * @see [query.skip]{@link query.skip}
         * @param {number} value The number of items to take.
         * @returns {Query}
         */
        take: function (value) {
            return this._simple(OperatorType.take, [value]);
        },
        /** Sets an expand expression for the current query. This allows you to retrieve complex data sets using a single query based on relations between data types.
         * @memberOf Query.prototype
         * @method expand
         * @param {object} expandExpression An [expand expression]({% slug features-data-relations-defining-expand %}) definition.
         * @returns {Query}
         */
        expand: function (expandExpression) {
            return this._simple(OperatorType.expand, [expandExpression]);
        },
        /** Builds an object containing the different expressions that will be sent to {{site.TelerikBackendServices}}. It basically translates any previously specified expressions into standard queries that {{site.bs}} can understand.
         * @memberOf Query.prototype
         * @method build
         * @returns {{$where,$select,$sort,$skip,$take,$expand}}
         */
        build: function () {
            return new QueryBuilder(this).build();
        },
        _simple: function (op, oprs) {
            var args = [].slice.call(oprs);
            this.expr.addOperand(new Expression(op, args));
            return this;
        }
    };

    return Query;
}());
},{"../Expression":45,"../constants":54,"./QueryBuilder":65,"./WhereQuery":67}],65:[function(require,module,exports){
var constants = require('../constants');
var OperatorType = constants.OperatorType;
var _ = require('../common')._;
var GeoPoint = require('../GeoPoint');
var EverliveError = require('../EverliveError').EverliveError;
var Expression = require('../Expression');
var maxDistanceConsts = constants.maxDistanceConsts;
var radiusConsts = constants.radiusConsts;

module.exports = (function () {
    function QueryBuilder(query) {
        this.query = query;
        this.expr = query.expr;
    }

    QueryBuilder.prototype = {
        // TODO merge the two objects before returning them
        build: function () {
            var query = this.query;
            if (query.filter || query.fields || query.sort || query.toskip || query.totake || query.expandExpression) {
                return {
                    $where: query.filter || null,
                    $select: query.fields || null,
                    $sort: query.sort || null,
                    $skip: query.toskip || null,
                    $take: query.totake || null,
                    $expand: query.expandExpression || null
                };
            }
            return {
                $where: this._buildWhere(),
                $select: this._buildSelect(),
                $sort: this._buildSort(),
                $skip: this._getSkip(),
                $take: this._getTake(),
                $expand: this._getExpand()
            };
        },
        _getSkip: function () {
            var skipExpression = _.find(this.expr.operands, function (value, index, list) {
                return value.operator === OperatorType.skip;
            });
            return skipExpression ? skipExpression.operands[0] : null;
        },
        _getTake: function () {
            var takeExpression = _.find(this.expr.operands, function (value, index, list) {
                return value.operator === OperatorType.take;
            });
            return takeExpression ? takeExpression.operands[0] : null;
        },
        _getExpand: function () {
            var expandExpression = _.chain(this.expr.operands)
                .filter(function (value) {
                    return value.operator === OperatorType.expand;
                })
                .reduce(function (result, expression) { //expression contains operands and has operator type expand
                    return _.extend(result, expression.operands[0]);
                }, {})
                .value();
            return _.isEmpty(expandExpression) ? null : expandExpression;
        },
        _buildSelect: function () {
            var selectExpression = _.find(this.expr.operands, function (value, index, list) {
                return value.operator === OperatorType.select;
            });
            var result = {};
            if (selectExpression) {
                _.reduce(selectExpression.operands, function (memo, value) {
                    memo[value] = 1;
                    return memo;
                }, result);
                return result;
            }
            else {
                return null;
            }
        },
        _buildSort: function () {
            var sortExpressions = _.filter(this.expr.operands, function (value, index, list) {
                return value.operator === OperatorType.order || value.operator === OperatorType.order_desc;
            });
            var result = {};
            if (sortExpressions.length > 0) {
                _.reduce(sortExpressions, function (memo, value) {
                    memo[value.operands[0]] = value.operator === OperatorType.order ? 1 : -1;
                    return memo;
                }, result);
                return result;
            }
            else {
                return null;
            }
        },
        _buildWhere: function () {
            var whereExpression = _.find(this.expr.operands, function (value, index, list) {
                return value.operator === OperatorType.where;
            });
            if (whereExpression) {
                return this._build(new Expression(OperatorType.and, whereExpression.operands));
            }
            else {
                var filterExpression = _.find(this.expr.operands, function (value, index, list) {
                    return value.operator === OperatorType.filter;
                });
                if (filterExpression) {
                    return filterExpression.operands[0];
                }
                return null;
            }
        },
        _build: function (expr) {
            if (this._isSimple(expr)) {
                return this._simple(expr);
            }
            else if (this._isRegex(expr)) {
                return this._regex(expr);
            }
            else if (this._isGeo(expr)) {
                return this._geo(expr);
            }
            else if (this._isAnd(expr)) {
                return this._and(expr);
            }
            else if (this._isOr(expr)) {
                return this._or(expr);
            }
            else if (this._isNot(expr)) {
                return this._not(expr);
            }
        },
        _isSimple: function (expr) {
            return expr.operator >= OperatorType.equal && expr.operator <= OperatorType.size;
        },
        _simple: function (expr) {
            var term = {}, fieldTerm = {};
            var operands = expr.operands;
            var operator = this._translateoperator(expr.operator);
            if (operator) {
                term[operator] = operands[1];
            }
            else {
                term = operands[1];
            }
            fieldTerm[operands[0]] = term;
            return fieldTerm;
        },
        _isRegex: function (expr) {
            return expr.operator >= OperatorType.regex && expr.operator <= OperatorType.endsWith;
        },
        _regex: function (expr) {
            var fieldTerm = {};
            var regex = this._getRegex(expr);
            var regexValue = this._getRegexValue(regex);
            var operands = expr.operands;
            fieldTerm[operands[0]] = regexValue;
            return fieldTerm;
        },
        _getRegex: function (expr) {
            var pattern = expr.operands[1];
            var flags = expr.operands[2] ? expr.operands[2] : '';
            switch (expr.operator) {
                case OperatorType.regex:
                    return pattern instanceof RegExp ? pattern : new RegExp(pattern, flags);
                case OperatorType.startsWith:
                    return new RegExp("^" + pattern, flags);
                case OperatorType.endsWith:
                    return new RegExp(pattern + "$", flags);
                default:
                    throw new EverliveError('Unknown operator type.');
            }
        },
        _getRegexValue: function (regex) {
            var options = '';
            if (regex.global) {
                options += 'g';
            }
            if (regex.multiline) {
                options += 'm';
            }
            if (regex.ignoreCase) {
                options += 'i';
            }
            return {$regex: regex.source, $options: options};
        },
        _isGeo: function (expr) {
            return expr.operator >= OperatorType.nearShpere && expr.operator <= OperatorType.withinShpere;
        },
        _geo: function (expr) {
            var fieldTerm = {};
            var operands = expr.operands;
            fieldTerm[operands[0]] = this._getGeoTerm(expr);
            return fieldTerm;
        },
        _getGeoTerm: function (expr) {
            switch (expr.operator) {
                case OperatorType.nearShpere:
                    return this._getNearSphereTerm(expr);
                case OperatorType.withinBox:
                    return this._getWithinBox(expr);
                case OperatorType.withinPolygon:
                    return this._getWithinPolygon(expr);
                case OperatorType.withinShpere:
                    return this._getWithinCenterSphere(expr);
                default:
                    throw new EverliveError('Unknown operator type.');
            }
        },
        _getNearSphereTerm: function (expr) {
            var operands = expr.operands;
            var center = this._getGeoPoint(operands[1]);
            var maxDistance = operands[2];
            var metrics = operands[3];
            var maxDistanceConst;
            var term = {
                '$nearSphere': center
            };
            if (typeof maxDistance !== 'undefined') {
                maxDistanceConst = maxDistanceConsts[metrics] || maxDistanceConsts.radians;
                term[maxDistanceConst] = maxDistance;
            }
            return term;
        },
        _getWithinBox: function (expr) {
            var operands = expr.operands;
            var bottomLeft = this._getGeoPoint(operands[1]);
            var upperRight = this._getGeoPoint(operands[2]);
            return {
                '$within': {
                    '$box': [bottomLeft, upperRight]
                }
            };
        },
        _getWithinPolygon: function (expr) {
            var operands = expr.operands;
            var points = this._getGeoPoints(operands[1]);
            return {
                '$within': {
                    '$polygon': points
                }
            };
        },
        _getWithinCenterSphere: function (expr) {
            var operands = expr.operands;
            var center = this._getGeoPoint(operands[1]);
            var radius = operands[2];
            var metrics = operands[3];
            var radiusConst = radiusConsts[metrics] || radiusConsts.radians;
            var sphereInfo = {
                'center': center
            };
            sphereInfo[radiusConst] = radius;
            return {
                '$within': {
                    '$centerSphere': sphereInfo
                }
            };
        },
        _getGeoPoint: function (point) {
            if (_.isArray(point)) {
                return new GeoPoint(point[0], point[1]);
            }
            return point;
        },
        _getGeoPoints: function (points) {
            var self = this;
            return _.map(points, function (point) {
                return self._getGeoPoint(point);
            });
        },
        _isAnd: function (expr) {
            return expr.operator === OperatorType.and;
        },
        _and: function (expr) {
            var i, l, term, result = {};
            var operands = expr.operands;
            for (i = 0, l = operands.length; i < l; i++) {
                term = this._build(operands[i]);
                result = this._andAppend(result, term);
            }
            return result;
        },
        _andAppend: function (andObj, newObj) {
            var i, l, key, value, newValue;
            var keys = _.keys(newObj);
            for (i = 0, l = keys.length; i < l; i++) {
                key = keys[i];
                value = andObj[key];
                if (typeof value === 'undefined') {
                    andObj[key] = newObj[key];
                }
                else {
                    newValue = newObj[key];
                    if (typeof value === 'object' && typeof newValue === 'object') {
                        value = _.extend(value, newValue);
                    } else {
                        value = newValue;
                    }
                    andObj[key] = value;
                }
            }
            return andObj;
        },
        _isOr: function (expr) {
            return expr.operator === OperatorType.or;
        },
        _or: function (expr) {
            var i, l, term, result = [];
            var operands = expr.operands;
            for (i = 0, l = operands.length; i < l; i++) {
                term = this._build(operands[i]);
                result.push(term);
            }
            return {$or: result};
        },
        _isNot: function (expr) {
            return expr.operator === OperatorType.not;
        },
        _not: function (expr) {
            return {$not: this._build(expr.operands[0])};
        },
        _translateoperator: function (operator) {
            switch (operator) {
                case OperatorType.equal:
                    return null;
                case OperatorType.not_equal:
                    return '$ne';
                case OperatorType.gt:
                    return '$gt';
                case OperatorType.lt:
                    return '$lt';
                case OperatorType.gte:
                    return '$gte';
                case OperatorType.lte:
                    return '$lte';
                case OperatorType.isin:
                    return '$in';
                case OperatorType.notin:
                    return '$nin';
                case OperatorType.all:
                    return '$all';
                case OperatorType.size:
                    return '$size';
            }
            throw new EverliveError('Unknown operator type.');
        }
    };

    return QueryBuilder;
}());
},{"../EverliveError":43,"../Expression":45,"../GeoPoint":46,"../common":53,"../constants":54}],66:[function(require,module,exports){
var DataQuery = require('./DataQuery');
var Request = require('../Request');
var _ = require('../common')._;

module.exports = (function () {
    var RequestOptionsBuilder = {};

    RequestOptionsBuilder._buildEndpointUrl = function (dataQuery) {
        var endpoint = dataQuery.collectionName;
        if (dataQuery.additionalOptions && dataQuery.additionalOptions.id) {
            endpoint += '/' + dataQuery.additionalOptions.id;
        }

        return endpoint;
    };

    RequestOptionsBuilder._buildBaseObject = function (dataQuery) {
        var defaultObject = {
            endpoint: RequestOptionsBuilder._buildEndpointUrl(dataQuery),
            filter: dataQuery.filter,
            success: dataQuery.onSuccess,
            error: dataQuery.onError,
            data: dataQuery.data,
            headers: dataQuery.headers
        };

        if (dataQuery.parse) {
            defaultObject.parse = dataQuery.parse;
        }

        return defaultObject;
    };

    RequestOptionsBuilder._build = function (dataQuery, additionalOptions) {
        return _.extend(RequestOptionsBuilder._buildBaseObject(dataQuery), additionalOptions);
    };

    RequestOptionsBuilder[DataQuery.operations.read] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'GET'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.readById] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'GET'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.count] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'GET',
            endpoint: dataQuery.collectionName + '/_count'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.create] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.rawUpdate] = function (dataQuery) {
        var endpoint = dataQuery.collectionName;
        var filter = dataQuery.filter;
        var ofilter = null; // request options filter

        if (typeof filter === 'string') {
            endpoint += '/' + filter; // send the filter through query string
        } else if (typeof filter === 'object') {
            ofilter = filter; // send the filter as filter headers
        }

        return RequestOptionsBuilder._build(dataQuery, {
            method: 'PUT',
            endpoint: endpoint,
            filter: ofilter
        });
    };

    RequestOptionsBuilder[DataQuery.operations.update] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'PUT'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.remove] = function (dataQuery) {
        return _.extend(RequestOptionsBuilder._buildBaseObject(dataQuery), {
            method: 'DELETE'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.removeSingle] = RequestOptionsBuilder[DataQuery.operations.remove];

    RequestOptionsBuilder[DataQuery.operations.setAcl] = function (dataQuery) {
        var endpoint = dataQuery.collectionName;
        var filter = dataQuery.filter;

        if (typeof filter === 'string') { // if filter is string than will update a single item using the filter as an identifier
            endpoint += '/' + filter;
        } else if (typeof filter === 'object') { // else if it is an object than we will use it's id property
            endpoint += '/' + filter[idField];
        }
        endpoint += '/_acl';
        var method, data;
        if (dataQuery.additionalOptions.acl === null) {
            method = 'DELETE';
        } else {
            method = 'PUT';
            data = dataQuery.additionalOptions.acl;
        }

        return RequestOptionsBuilder._build(dataQuery, {
            method: method,
            endpoint: endpoint,
            data: data
        });
    };

    RequestOptionsBuilder[DataQuery.operations.setOwner] = function (dataQuery) {
        var endpoint = dataQuery.collectionName;
        var filter = dataQuery.filter;
        if (typeof filter === 'string') { // if filter is string than will update a single item using the filter as an identifier
            endpoint += '/' + filter;
        } else if (typeof filter === 'object') { // else if it is an object than we will use it's id property
            endpoint += '/' + filter[idField];
        }
        endpoint += '/_owner';

        return RequestOptionsBuilder._build(dataQuery, {
            method: 'PUT',
            endpoint: endpoint
        });
    };

    RequestOptionsBuilder[DataQuery.operations.userLogin] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST',
            endpoint: 'oauth/token',
            authHeaders: false,
            parse: Request.parsers.single
        });
    };

    RequestOptionsBuilder[DataQuery.operations.userLogout] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'GET',
            endpoint: 'oauth/logout'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.userChangePassword] = function (dataQuery) {
        var keepTokens = dataQuery.additionalOptions.keepTokens;
        var endpoint = 'Users/changepassword';
        if (keepTokens) {
            endpoint += '?keepTokens=true';
        }

        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST',
            endpoint: endpoint,
            authHeaders: false,
            parse: Request.parsers.single
        });
    };

    RequestOptionsBuilder[DataQuery.operations.userLoginWithProvider] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST',
            authHeaders: false
        });
    };

    RequestOptionsBuilder[DataQuery.operations.userLinkWithProvider] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST',
            endpoint: RequestOptionsBuilder._buildEndpointUrl(dataQuery) + '/link'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.userUnlinkFromProvider] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'POST',
            endpoint: RequestOptionsBuilder._buildEndpointUrl(dataQuery) + '/unlink'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.filesUpdateContent] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'PUT',
            endpoint: RequestOptionsBuilder._buildEndpointUrl(dataQuery) + '/Content'
        });
    };

    RequestOptionsBuilder[DataQuery.operations.filesGetDownloadUrlById] = function (dataQuery) {
        return RequestOptionsBuilder._build(dataQuery, {
            method: 'GET'
        });
    };

    return RequestOptionsBuilder;
}());
},{"../Request":49,"../common":53,"./DataQuery":63}],67:[function(require,module,exports){
var Expression = require('../Expression');
var OperatorType = require('../constants').OperatorType;

module.exports = (function () {
    /**
     * @classdesc A fluent API operation for creating a filter for a query by chaining different rules.
     * @class WhereQuery
     * @protected
     * @borrows WhereQuery#eq as WhereQuery#equal
     * @borrows WhereQuery#ne as WhereQuery#notEqual
     * @borrows WhereQuery#gt as WhereQuery#greaterThan
     * @borrows WhereQuery#gte as WhereQuery#greaterThanEqual
     * @borrows WhereQuery#lt as WhereQuery#lessThan
     * @borrows WhereQuery#lte as WhereQuery#lessThanEqual
     */
    function WhereQuery(parentQuery, exprOp, singleOperand) {
        this.parent = parentQuery;
        this.single = singleOperand;
        this.expr = new Expression(exprOp || OperatorType.where);
        this.parent.expr.addOperand(this.expr);
    }

    WhereQuery.prototype = {
        /**
         * Adds an `and` clause to the current condition and returns it for further chaining.
         * @method and
         * @memberOf WhereQuery.prototype
         * @returns {WhereQuery}
         */
        and: function () {
            return new WhereQuery(this, OperatorType.and);
        },
        /**
         * Adds an `or` clause to the current condition and returns it for further chaining.
         * @method or
         * @memberOf WhereQuery.prototype
         * @returns {WhereQuery}
         */
        or: function () {
            return new WhereQuery(this, OperatorType.or);
        },
        /**
         * Adds a `not` clause to the current condition and returns it for further chaining.
         * @method not
         * @memberOf WhereQuery.prototype
         * @returns {WhereQuery}
         */
        not: function () {
            return new WhereQuery(this, OperatorType.not, true);
        },
        _simple: function (operator) {
            var args = [].slice.call(arguments, 1);
            this.expr.addOperand(new Expression(operator, args));
            return this._done();
        },
        /**
         * Adds a condition that a field must be equal to a specific value.
         * @method eq
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {*} value Comparison value (to which the fields must be equal).
         * @returns {WhereQuery}
         */
        eq: function (field, value) {
            return this._simple(OperatorType.equal, field, value);
        },
        /**
         * Adds a condition that a field must *not* be equal to a specific value.
         * @method ne
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {*} value Comparison value (to which the field must not be equal).
         * @returns {WhereQuery}
         */
        ne: function (field, value) {
            return this._simple(OperatorType.not_equal, field, value);
        },
        /**
         * Adds a condition that a field must be `greater than` a certain value. Applicable to Number, String, and Date fields.
         * @method gt
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {*} value Comparison value (that the field should be greater than).
         * @returns {WhereQuery}
         */
        gt: function (field, value) {
            return this._simple(OperatorType.gt, field, value);
        },
        /**
         * Adds a condition that a field must be `greater than or equal` to a certain value. Applicable to Number, String, and Date fields.
         * @method gte
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {*} value Comparison value (that the field should be greater than or equal to).
         * @returns {WhereQuery}
         */
        gte: function (field, value) {
            return this._simple(OperatorType.gte, field, value);
        },
        /**
         * Adds a condition that a field must be `less than` a certain value. Applicable to Number, String, and Date fields.
         * @method lt
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {*} value Comparison value (that the field should be less than).
         * @returns {WhereQuery}
         */
        lt: function (field, value) {
            return this._simple(OperatorType.lt, field, value);
        },
        /**
         * Adds a condition that a field must be `less than or equal` to a certain value. Applicable to Number, String, and Date fields.
         * @method lte
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {*} value Comparison value (that the field should be less than or equal to).
         * @returns {WhereQuery}
         */
        lte: function (field, value) {
            return this._simple(OperatorType.lte, field, value);
        },
        /**
         * Adds a condition that a field must be in a set of values.
         * @method isin
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {Array} value An array of the values that the field should be in.
         * @returns {WhereQuery}
         */
        isin: function (field, value) {
            return this._simple(OperatorType.isin, field, value);
        },
        /**
         * Adds a condition that a field must *not* be in a set of values.
         * @method notin
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {Array} value An array of values that the field should not be in.
         * @returns {WhereQuery}
         */
        notin: function (field, value) {
            return this._simple(OperatorType.notin, field, value);
        },
        /**
         * Adds a condition that a field must include *all* of the specified values. Applicable to Array fields.
         * @method all
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {Array} value An array of values that the field must include.
         * @returns {WhereQuery}
         */
        all: function (field, value) {
            return this._simple(OperatorType.all, field, value);
        },
        /**
         * Adds a condition that a field must contain an array whose length is larger than a specified value. Applicable to Array fields.
         * @method size
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {number} value The size that the array must be bigger than.
         * @returns {WhereQuery}
         */
        size: function (field, value) {
            return this._simple(OperatorType.size, field, value);
        },
        /**
         * Adds a condition that a field must satisfy a specified regex.
         * @method regex
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {string} regularExpression Regular expression in PCRE format.
         * @param {string} [options] A string of regex options to use. See [specs]({http://docs.mongodb.org/manual/reference/operator/query/regex/#op._S_options}) for a description of available options.
         * @returns {WhereQuery}
         */
        regex: function (field, value, flags) {
            return this._simple(OperatorType.regex, field, value, flags);
        },
        /**
         * Adds a condition that a field value must *start* with a specified string.
         * @method startsWith
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {string} value The string that the field should start with.
         * @param {string} [options] A string of regex options to use. See [specs]({http://docs.mongodb.org/manual/reference/operator/query/regex/#op._S_options}) for a description of available options.
         * @returns {WhereQuery}
         */
        startsWith: function (field, value, flags) {
            return this._simple(OperatorType.startsWith, field, value, flags);
        },
        /**
         * Adds a condition that a field value must *end* with a specified string.
         * @method endsWith
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name.
         * @param {string} value The string that the field should end with.
         * @param {string} [options] A string of  regex options to use. See [specs]({http://docs.mongodb.org/manual/reference/operator/query/regex/#op._S_options}) for a description of available options.
         * @returns {WhereQuery}
         */
        endsWith: function (field, value, flags) {
            return this._simple(OperatorType.endsWith, field, value, flags);
        },
        /**
         * Adds a Geospatial condition that a specified geopoint must be within a certain distance from another geopoint. Applicable to GeoPoint fields only.
         * @method nearSphere
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name containing a {GeoPoint} in the following format: `(decimal_degrees_latitude,decimal_degrees_longitude)`, where *decimal_degrees_latitude* ranges from -90 to 90 and *decimal_degrees_longitude* ranges from -180 to 180. Example: `(42.6954322,123.3239467)`
         * @param {Everlive.GeoPoint} point Comparison geopoint value.
         * @param {number} distance Distance value.
         * @param {string} [metrics=radians] A string representing what unit of measurement is used for distance. Possible values: radians, km, miles.
         * @returns {WhereQuery}
         */
        nearSphere: function (field, point, distance, metrics) {
            return this._simple(OperatorType.nearShpere, field, point, distance, metrics);
        },
        /**
         * Adds a Geospatial condition that a specified geopoint must be within a specified coordinate rectangle. Applicable to GeoPoint fields only.
         * @method withinBox
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name containing a {GeoPoint} in the following format: `(decimal_degrees_latitude,decimal_degrees_longitude)`, where *decimal_degrees_latitude* ranges from -90 to 90 and *decimal_degrees_longitude* ranges from -180 to 180. Example: `(42.6954322,123.3239467)`
         * @param {Everlive.GeoPoint} pointBottomLeft Value representing the bottom left corner of the box.
         * @param {Everlive.GeoPoint} pointUpperRight Value representing the upper right corner of the box.
         * @example ```js
         var query = new Everlive.Query();
         query.where().withinBox('Location',
         new Everlive.GeoPoint(23.317871, 42.687709),
         new Everlive.GeoPoint(23.331346, 42.707075));
         ```
         * @returns {WhereQuery}
         */
        withinBox: function (field, pointBottomLeft, pointUpperRight) {
            return this._simple(OperatorType.withinBox, field, pointBottomLeft, pointUpperRight);
        },
        /**
         * Adds a Geospatial condition that a specified geopoint must be within a specified coordinate polygon. The polygon is specified as an array of geopoints. The last point in the array is implicitly connected to the first point thus closing the shape. Applicable to GeoPoint fields only.
         * @method withinPolygon
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name containing a {GeoPoint} in the following format: `(decimal_degrees_latitude,decimal_degrees_longitude)`, where *decimal_degrees_latitude* ranges from -90 to 90 and *decimal_degrees_longitude* ranges from -180 to 180. Example: `(42.6954322,123.3239467)`
         * @param {Everlive.GeoPoint[]} points Comparison value in the form of an array of geopoints defining the polygon.
         * @example ```js
         var point1 = new Everlive.GeoPoint(23.317871, 42.687709);
         var point2 = new Everlive.GeoPoint(42.698749, 42.698749);
         var point3 = new Everlive.GeoPoint(23.331346, 42.702282);

         var query = new Everlive.Query();
         query.where().withinPolygon("location", [point1, point2, point3]);
         * ```
         * @returns {WhereQuery}
         */
        withinPolygon: function (field, points) {
            return this._simple(OperatorType.withinPolygon, field, points);
        },
        /**
         * Adds a Geospatial condition that a specified geopoint must be within a coordinate circle. Applicable to GeoPoint fields only.
         * @method withinCenterSphere
         * @memberOf WhereQuery.prototype
         * @param {string} field Field name containing a {GeoPoint} in the following format: `(decimal_degrees_latitude,decimal_degrees_longitude)`, where *decimal_degrees_latitude* ranges from -90 to 90 and *decimal_degrees_longitude* ranges from -180 to 180. Example: `(42.6954322,123.3239467)`
         * @param {Everlive.GeoPoint} center Comparison value specifying the center of the coordinate circle.
         * @param {number} radius Value specifying the radius length.
         * @param {string} [metrics=radians] A string representing what unit of measurement is used for radius length. Possible values: radians, km, miles.
         * @returns {WhereQuery}
         */
        withinCenterSphere: function (field, center, radius, metrics) {
            return this._simple(OperatorType.withinShpere, field, center, radius, metrics);
        },
        /**
         * Ends the definition of the current WhereQuery. You need to call this method in order to continue with the definition of the parent `Query`. All other `WhereQuery` methods return the current instance of `WhereQuery` to allow chaining.
         * @method done
         * @memberOf WhereQuery.prototype
         * @returns {Query}
         */
        done: function () {
            if (this.parent instanceof WhereQuery) {
                return this.parent._done();
            } else {
                return this.parent;
            }
        },
        _done: function () {
            if (this.single) {
                return this.parent;
            } else {
                return this;
            }
        }
    };

    WhereQuery.prototype.equal = WhereQuery.prototype.eq;
    WhereQuery.prototype.notEqual = WhereQuery.prototype.ne;
    WhereQuery.prototype.greaterThan = WhereQuery.prototype.gt;
    WhereQuery.prototype.greaterThanEqual = WhereQuery.prototype.gte;
    WhereQuery.prototype.lessThan = WhereQuery.prototype.lt;
    WhereQuery.prototype.lessThanEqual = WhereQuery.prototype.lte;

    return WhereQuery;
}());
},{"../Expression":45,"../constants":54}],68:[function(require,module,exports){
var http = require('http');
module.exports = (function () {
    'use strict';

    function reqwest(options) {
        var httpRequestOptions = {
            url: options.url,
            method: options.method,
            headers: options.headers || {}
        };

        if (options.data) {
            httpRequestOptions.content = options.data; // NOTE: If we pass null/undefined, it will raise an exception in the http module.
        }

        httpRequestOptions.headers['Accept'] = 'application/json';
        httpRequestOptions.headers['Content-Type'] = 'application/json';

        var noop = function () {
        };
        var success = options.success || noop;
        var error = options.error || noop;

        var requestSuccessCallback = function (response) {
            var contentString = response.content.toString();
            if (response.statusCode < 400) {
                // Success callback calls a custom parse function
                success(contentString);
            } else {
                // Error callback relies on a JSON Object with ResponseText inside
                error({
                    responseText: contentString
                });
            }
        };

        var requestErrorCallback = function (err) {
            // error: function(jqXHR, textStatus, errorThrown)
            // when timeouting for example (i.e. no internet connectivity), we get an err with content { message: "timeout...", stack: null }
            error({
                responseText: err
            });
        };

        http.request(httpRequestOptions).then(requestSuccessCallback, requestErrorCallback);
    }

    return reqwest;
}());
},{"http":"http"}],69:[function(require,module,exports){
(function (Buffer){
var url = require('url');
var http = require('http');
var https = require('https');
var rsvp = require('rsvp');
var zlib = require('zlib');
var _ = require('underscore');

module.exports = (function () {
    'use strict';

    function reqwest(options) {
        var urlParts = url.parse(options.url);
        var request;
        if (urlParts.protocol === 'https:') {
            request = https.request;
        }
        else {
            request = http.request;
        }
        var headers = options.headers || {};
        options.success = options.success || _.noop;
        options.error = options.error || _.noop;

        headers['Content-Type'] = options.contentType;
        var req = request({
            method: options.method,
            hostname: urlParts.hostname,
            port: urlParts.port,
            path: urlParts.path,
            headers: headers
        }, function (res) {
            var json = '';
            var contentEncoding = res.headers['content-encoding'];
            var responseProxy;
            switch (contentEncoding){
                case 'gzip':
                    responseProxy = zlib.createGunzip();
                    res.pipe(responseProxy);
                    break;
                default:
                    responseProxy = res;
                    responseProxy.setEncoding('utf8');
                    break;
            }

            responseProxy.on('data', function (data) {
                json += data.toString();
            });

            responseProxy.on('end', function () {
                // 1xx Informational, 2xx Success, 3xx Redirection, 4xx Client Error, 5xx Server Error
                if (res.statusCode >= 200 && res.statusCode < 400) {
                    options.success(json, res);
                } else {
                    if (json) {
                        options.error({ responseText: json });
                    }
                    else { // empty response
                        var error = new Error('Response error.');
                        error.statusCode = res.statusCode;
                        options.error({ responseText: error });
                    }
                }
            });
        });

        req.on('error', function (e) {
            options.error({ responseText: e }); // TODO
        });

        if (options.data) {
            var contentEncoding = headers['content-encoding'];
            switch (contentEncoding){
                case 'gzip':
                    var buf = new Buffer(options.data, 'utf-8');
                    zlib.gzip(buf, function (err, result) {
                        req.end(result);
                    });
                    break;
                default:
                    req.end(options.data);
                    break;
            }
        }
        else {
            req.end();
        }
    }

    return reqwest;
}());
}).call(this,require("buffer").Buffer)

},{"buffer":"buffer","http":"http","https":"https","rsvp":29,"underscore":30,"url":"url","zlib":"zlib"}],70:[function(require,module,exports){
var buildPromise = require('../utils').buildPromise;
var DataQuery = require('../query/DataQuery');
var RequestOptionsBuilder = require('../query/RequestOptionsBuilder');
var rsvp = require('../common').rsvp;
var Request = require('../Request');
var idField = require('../constants').idField;
var Everlive = require('../Everlive');
var EverliveError = require('../EverliveError').EverliveError;
var EverliveErrors = require('../EverliveError').EverliveErrors;
var _ = require('../common')._;

module.exports = (function () {
    function mergeResultData(data, success) {
        return function (res, response) {
            var attrs = res.result;
            // support for kendo observable array
            if (_.isArray(data) || typeof data.length === 'number') {
                _.each(data, function (item, index) {
                    _.extend(item, attrs[index]);
                });
            }
            else {
                _.extend(data, attrs);
            }

            success(res, response);
        };
    }

    function mergeUpdateResultData(data, success) {
        return function (res) {
            var modifiedAt = res.ModifiedAt;
            data.ModifiedAt = modifiedAt;
            success(res);
        };
    }

    /**
     * @class Data
     * @classdesc A class that provides methods for all CRUD operations to a given {{site.bs}} data type. Covers advanced scenarios with custom headers and special server-side functionality.
     * @param {object} setup
     * @param {string} collectionName
     * @protected
     */
    function Data(setup, collectionName, offlineStorage, everlive) {
        this.setup = setup;
        this.collectionName = collectionName;
        this.options = null;
        this.offlineStorage = offlineStorage;
        this.everlive = everlive;
    }


    Data.prototype = {
        _isOnline: function () {
            return this.offlineStorage ? this.offlineStorage.isOnline() : true;
        },

        _getOfflineCreateData: function (query, requestResponse) {
            var createData;
            if (_.isArray(query.data)) {
                createData = [];
                for (var i = 0; i < query.data.length; i++) {
                    var objectToCreate = _.extend(query.data[i], requestResponse.result[i]);
                    createData.push(objectToCreate)
                }
            } else {
                createData = _.extend(query.data, requestResponse.result);
            }

            return createData;
        },
        _applyOffline: function (query, requestResponse) {
            var autoSyncEnabled = this.offlineStorage && this.offlineStorage.setup.autoSync;
            if (autoSyncEnabled) {
                switch (query.operation) {
                    case DataQuery.operations.read:
                    case DataQuery.operations.readById:
                        var syncReadQuery = new DataQuery(_.defaults({
                            data: requestResponse.result,
                            isSync: true
                        }, query));
                        return this.offlineStorage.create(syncReadQuery);
                    case DataQuery.operations.create:
                        var createData = this._getOfflineCreateData(query, requestResponse);
                        var createQuery = new DataQuery(_.defaults({
                            data: createData,
                            isSync: true
                        }, query));
                        return this.offlineStorage.create(createQuery);
                    default:
                        query.isSync = true;
                        return this.offlineStorage.processQuery(query);
                }
            }

            return new rsvp.Promise(function (resolve, reject) {
                resolve();
            });
        },

        _setOption: function (key, value) {
            this.options = this.options || {};
            if (_.isObject(value)) {
                this.options[key] = _.extend({}, this.options[key], value);
            } else {
                this.options[key] = value;
            }
            return this;
        },

        /**@memberOf Data.prototype
         * @method
         * Modifies whether the query should be invoked on the offline storage.
         * Default is true.
         * Only valid when offlineStorage is enabled.
         * @param workOffline
         * @returns {Data}
         * */
        useOffline: function (useOffline) {
            if (arguments.length !== 1) {
                throw new Error('A single value is expected in useOffline() query modifier');
            }
            return this._setOption('useOffline', useOffline);
        },

        isSync: function (isSync) {
            if (arguments.length !== 1) {
                throw new Error('A single value is expected in isSync() query modifier');
            }
            return this._setOption('isSync', isSync);
        },

        /**
         * @memberOf Data.prototype
         * @method
         * Modifies whether the query should invoke the {{@link Authentication.prototype.hasAuthenticationRequirement}}.
         * Default is false.
         * Only valid when authentication module has an onAuthenticationRequired function .
         * @param skipAuth
         * @returns {Data}
         * */
        skipAuth: function (skipAuth) {
            if (arguments.length !== 1) {
                throw new Error('A single value is expected in skipAuth() query modifier');
            }
            return this._setOption('skipAuth', skipAuth);
        },

        /**
         * Modifies whether the query should be applied offline, if the sdk is currenty working online.
         * Default is true.
         * Only valid when offlineStorage is enabled.
         * @memberOf Data.prototype
         * @method
         * @param applyOffline
         * @returns {Data}
         * */
        applyOffline: function (applyOffline) {
            if (arguments.length !== 1) {
                throw new Error('A single value is expected in applyOffline() query modifier');
            }
            return this._setOption('applyOffline', applyOffline);
        },

        /**
         * Sets additional non-standard HTTP headers in the current data request. See [List of Non-Standard HTTP Headers]{{% slug rest-api-headers}} for more information.
         * @memberOf Data.prototype
         * @method
         * @param {object} headers Additional headers to be sent with the data request.
         * @returns {Data}
         */
        withHeaders: function (headers) {
            return this._setOption('headers', headers);
        },
        /**
         * Sets an expand expression to be used in the data request. This allows you to retrieve complex data sets using a single query based on relations between data types.
         * @memberOf Data.prototype
         * @method
         * @param {object} expandExpression An [expand expression]({% slug features-data-relations-defining-expand %}) definition.
         * @returns {Data}
         */
        expand: function (expandExpression) {
            var expandHeader = {
                'X-Everlive-Expand': JSON.stringify(expandExpression)
            };
            return this.withHeaders(expandHeader);
        },

        /**
         * Processes a query with all of its options. Applies the operation online/offline
         * @param {DataQuery} query The query to process
         * @private
         * @param {DataQuery} query
         * @returns {Promise}
         */
        processDataQuery: function (query) {
            var self = this;

            var offlineStorageEnabled = this.everlive._isOfflineStorageEnabled();
            query.useOffline = offlineStorageEnabled ? !this.everlive.isOnline() : false;
            query.applyOffline = offlineStorageEnabled;

            if (this.options) {
                query = _.defaults(this.options, query);
            }

            this.options = null;
            if (!query.skipAuth && this.everlive.authentication && this.everlive.authentication.isAuthenticationInProgress()) {
                query.onError = _.wrap(query.onError, function (errorFunc, err) {
                    if (err.code === EverliveErrors.invalidToken.code || err.code === EverliveErrors.expiredToken.code) {
                        var whenAuthenticatedPromise = self.everlive.authentication._ensureAuthentication();
                        if (!query.noRetry) {
                            whenAuthenticatedPromise.then(function () {
                                return self.processDataQuery(query);
                            });
                        }
                    } else {
                        errorFunc.call(self, err);
                    }
                });

                //if we are currently authenticating, queue the data query after we have logged in
                if (self.everlive.authentication.isAuthenticating()) {
                    var whenAuthenticatedPromise = self.everlive.authentication._ensureAuthentication();
                    if (!query.noRetry) {
                        whenAuthenticatedPromise.then(function () {
                            return self.processDataQuery(query);
                        });
                    }
                    return whenAuthenticatedPromise
                }
            }

            if ((!query.isSync && this.offlineStorage && this.offlineStorage.isSynchronizing())) {
                query.onError.call(this, EverliveErrors.syncInProgress);
            } else if (!query.useOffline) {
                var originalSuccess = query.onSuccess;
                query.onSuccess = function () {
                    var args = arguments;
                    var data = args[0];
                    if (query.applyOffline) {
                        return self._applyOffline(query, data)
                            .then(function () {
                                originalSuccess.apply(this, args);
                            }, function () {
                                query.onError.apply(this, arguments);
                            });
                    } else {
                        return originalSuccess.apply(this, args);
                    }
                };

                var getRequestOptionsFromQuery = RequestOptionsBuilder[query.operation];
                var requestOptions = getRequestOptionsFromQuery(query);
                var request = new Request(this.setup, requestOptions);
                request.send();
            } else {
                if (!query.applyOffline) {
                    return query.onError.call(this, new EverliveError('The applyOffline must be false when working offline.'));
                }

                self.offlineStorage.processQuery(query).then(function () {
                    query.onSuccess.apply(this, arguments);
                }, function (err) {
                    if (!err.code) {
                        err = new EverliveError(err.message, EverliveErrors.generalDatabaseError.code);
                    }
                    query.onError.call(this, err);
                });
            }
        },
        // TODO implement options: { requestSettings: { executeServerCode: false } }. power fields queries could be added to that options argument
        /**
         * Gets all data items that match the filter. This allows you to retrieve a subset of the items based on various filtering criteria.
         * @memberOf Data.prototype
         * @method get
         * @name get
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Gets all data items that match the filter. This allows you to retrieve a subset of the items based on various filtering criteria.
         * @memberOf Data.prototype
         * @method get
         * @name get
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        get: function (filter, success, error) {
            var self = this;

            return buildPromise(function (successCb, errorCb) {
                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.read,
                    collectionName: self.collectionName,
                    filter: filter,
                    onSuccess: successCb,
                    onError: errorCb
                });

                return self.processDataQuery(dataQuery);
            }, success, error);
        },
        // TODO handle options
        // TODO think to pass the id as a filter

        /**
         * Gets a data item by ID.
         * @memberOf Data.prototype
         * @method getById
         * @name getById
         * @param {string} id ID of the item.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Gets an item by ID.
         * @memberOf Data.prototype
         * @method getById
         * @name getById
         * @param {string} id ID of the item.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         * */
        getById: function (id, success, error) {
            var self = this;

            return buildPromise(function (successCb, errorCb) {
                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.readById,
                    collectionName: self.collectionName,
                    parse: Request.parsers.single,
                    additionalOptions: {
                        id: id
                    },
                    onSuccess: successCb,
                    onError: errorCb
                });


                return self.processDataQuery(dataQuery);
            }, success, error);
        },

        /**
         * Gets the count of the data items that match the filter.
         * @memberOf Data.prototype
         * @method count
         * @name count
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Gets the count of the items that match the filter.
         * @memberOf Data.prototype
         * @method count
         * @name count
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        count: function (filter, success, error) {
            var self = this;

            return buildPromise(function (sucessCb, errorCb) {
                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.count,
                    collectionName: self.collectionName,
                    filter: filter,
                    parse: Request.parsers.single,
                    onSuccess: sucessCb,
                    onError: errorCb
                });
                return self.processDataQuery(dataQuery);
            }, success, error);
        },

        /**
         * Creates a data item.
         * @memberOf Data.prototype
         * @method create
         * @name create
         * @param {object|object[]} data Item or items that will be created.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Creates an item.
         * @memberOf Data.prototype
         * @method create
         * @name create
         * @param {object|object[]} data The item or items that will be created.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        create: function (data, success, error) {
            var self = this;

            return buildPromise(function (success, error) {
                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.create,
                    collectionName: self.collectionName,
                    data: data,
                    parse: Request.parsers.single,
                    onSuccess: mergeResultData(data, success),
                    onError: error
                });


                return self.processDataQuery(dataQuery);
            }, success, error);
        },
        /**
         * Updates all objects that match a filter with the specified update expression.
         * @memberOf Data.prototype
         * @method rawUpdate
         * @name rawUpdate
         * @param {object} updateObject Update object that contains the new values.
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Updates all objects that match a filter with the specified update expression.
         * @memberOf Data.prototype
         * @method rawUpdate
         * @name rawUpdate
         * @param {object} updateObject Update object that contains the new values.
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        /**
         * Updates an object by ID with the specified update expression.
         * @memberOf Data.prototype
         * @method rawUpdate
         * @name rawUpdate
         * @param {object} updatedObject Updated object that contains the new values.
         * @param {string} id The ID of the item.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Updates an object by ID with the specified update expression.
         * @memberOf Data.prototype
         * @method rawUpdate
         * @name rawUpdate
         * @param {object} updateObject Updated object that contains the new values.
         * @param {string} id The ID of the item.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        rawUpdate: function (attrs, filter, success, error) {
            var self = this;

            return buildPromise(function (success, error) {
                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.rawUpdate,
                    collectionName: self.collectionName,
                    filter: filter,
                    data: attrs,
                    onSuccess: success,
                    onError: error
                });
                return self.processDataQuery(dataQuery);
            }, success, error);
        },
        // TODO: Check if there is a case in which replace = true is passed to this function
        _update: function (attrs, filter, single, replace, success, error) {
            var self = this;

            return buildPromise(function (success, error) {
                var data = {};
                data[replace ? '$replace' : '$set'] = attrs;

                // if the update is for a single item - merge the update result and add the ModifiedAt field to the result
                var onSuccess = single ? mergeUpdateResultData(attrs, success) : success;

                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.update,
                    collectionName: self.collectionName,
                    parse: Request.parsers.update,
                    filter: filter,
                    data: data,
                    additionalOptions: {
                        id: single ? attrs[idField] : undefined
                    },
                    onSuccess: onSuccess,
                    onError: error
                });
                return self.processDataQuery(dataQuery);
            }, success, error);
        },

        /**
         * Updates a single data item. This operation takes an object that specifies both the data item to be updated and the updated values.
         * @memberOf Data.prototype
         * @method updateSingle
         * @name updateSingle
         * @param {object} item The item that will be updated. Note: the ID property of the item will be used to determine which item will be updated.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Updates the provided item.
         * @memberOf Data.prototype
         * @method updateSingle
         * @name updateSingle
         * @param {object} model The item that will be updated. Note: the ID property of the item will be used to determine which item will be updated.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        updateSingle: function (model, success, error) {
            return this._update(model, null, true, false, success, error);
        },

        /**
         * Updates all items that match a filter with the specified update object.
         * @memberOf Data.prototype
         * @method update
         * @name update
         * @param {object} updateObject The update object.
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Updates all items that match the filter with the specified update object.
         * @memberOf Data.prototype
         * @method update
         * @name update
         * @param {object} model The update object.
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        update: function (model, filter, success, error) {
            return this._update(model, filter, false, false, success, error);
        },
        _destroy: function (attrs, filter, single, success, error) {
            var self = this;

            return buildPromise(function (success, error) {
                var dataQuery = new DataQuery({
                    operation: single ? DataQuery.operations.removeSingle : DataQuery.operations.remove,
                    collectionName: self.collectionName,
                    filter: filter,
                    onSuccess: success,
                    onError: error,
                    additionalOptions: {
                        id: single ? attrs[idField] : undefined
                    }
                });
                return self.processDataQuery(dataQuery);
            }, success, error);
        },

        /**
         * Deletes a single data item by ID.
         * @memberOf Data.prototype
         * @method destroySingle
         * @name destroySingle
         * @param {object} item Object containing the item ID to be deleted.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Deletes a single data item by ID.
         * @memberOf Data.prototype
         * @method destroySingle
         * @name destroySingle
         * @param {object} model Object containing the item ID to be deleted.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        destroySingle: function (model, success, error) {
            return this._destroy(model, null, true, success, error);
        },

        /**
         * Deletes all data items that match a filter.
         * @memberOf Data.prototype
         * @method destroy
         * @name destroy
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Deletes all items that match the filter.
         * @memberOf Data.prototype
         * @method destroy
         * @name destroy
         * @param {object|null} filter A [filter expression]({% slug rest-api-querying-filtering %}) definition.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        destroy: function (filter, success, error) {
            return this._destroy(null, filter, false, success, error);
        },

        /**
         * Sets the Access Control List (ACL) of a specified data item.
         * @memberOf Data.prototype
         * @method setAcl
         * @name setAcl
         * @param {object} acl The acl object.
         * @param {object} item The item whose ACL will be updated. Note: the ID property of the item will be used to determine which item will be deleted.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Sets the Access Control List (ACL) of a specified data item.
         * @memberOf Data.prototype
         * @method setAcl
         * @name setAcl
         * @param {object} acl The acl object.
         * @param {object} item The item whose ACL will be updated. Note: the ID property of the item will be used to determine which item will be deleted.
         * @param {object} operationParameters An object which accepts operation parameters
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        /**
         * Sets the Access Control List (ACL) of a specified data item.
         * @memberOf Data.prototype
         * @method setAcl
         * @name setAcl
         * @param {object} acl The acl object.
         * @param {string} id The ID of the item.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Sets the Access Control List (ACL) of an item with a specified ID.
         * @memberOf Data.prototype
         * @method setAcl
         * @name setAcl
         * @param {object} acl The acl object.
         * @param {string} id The ID of the item.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        setAcl: function (acl, filter, success, error) {
            var self = this;

            return buildPromise(function (success, error) {
                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.setAcl,
                    collectionName: self.collectionName,
                    parse: Request.parsers.single,
                    filter: filter,
                    additionalOptions: {
                        acl: acl
                    },
                    onSuccess: success,
                    onError: error
                });

                return self.processDataQuery(dataQuery);
            }, success, error);
        },

        /**
         * Sets the owner of the specified data item.
         * @memberOf Data.prototype
         * @method setOwner
         * @name setOwner
         * @param {string} acl The new owner ID.
         * @param {object} item The item whose owner will be updated. Note: the ID property of the item will be used to determine which item will be deleted.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Sets the owner of the specified data item.
         * @memberOf Data.prototype
         * @method setOwner
         * @name setOwner
         * @param {string} acl The new owner ID.
         * @param {object} item The item whose owner will be updated. Note: the ID property of the item will be used to determine which item will be deleted.
         * @param {object} operationParameters An object which accepts operation parameters
         * @param {Function} [operationParameters.success] A success callback.
         * @param {Function} [operationParameters.error] An error callback.
         * @param {Boolean} [operationParameters.useOffline] Whether to invoke the operation on the offline storage. Default is based on the current mode of the Everlive instance.
         * @param {Boolean} [operationParameters.applyOffline=true] If working online, whether to also apply the operation on the local storage.
         */
        /**
         * Sets the owner of the specified data item.
         * @memberOf Data.prototype
         * @method setOwner
         * @name setOwner
         * @param {string} ownerId The new owner ID.
         * @param {string} id The ID of the item.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Sets the owner of the specified data item.
         * @memberOf Data.prototype
         * @method setOwner
         * @name setOwner
         * @param {string} ownerId The new owner ID.
         * @param {string} id The ID of the item.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        setOwner: function (ownerId, filter, success, error) {
            var self = this;

            return buildPromise(function (success, error) {
                var dataQuery = new DataQuery({
                    operation: DataQuery.operations.setOwner,
                    collectionName: self.collectionName,
                    filter: filter,
                    data: {
                        Owner: ownerId
                    },
                    onSuccess: success,
                    onError: error
                });
                return self.processDataQuery(dataQuery);
            }, success, error);
        },
        /**
         * Saves the provided data item. This operation will create or update the item depending on whether it is new or existing.
         * @memberOf Data.prototype
         * @method save
         * @name save
         * @param {object} item An object containing the item that is being saved.
         * @returns {Promise} The promise for the request.
         */
        /**
         * Saves the provided data item. This operation will create or update the item depending on whether it is new or existing.
         * @memberOf Data.prototype
         * @method save
         * @name save
         * @param {object} model An object containing the item that is being saved.
         * @param {Function} [success] A success callback.
         * @param {Function} [error] An error callback.
         */
        save: function (model, success, error) {
            var self = this;
            var isNew = this.isNew(model);

            return buildPromise(function (success, error) {
                function saveSuccess(res) {
                    res.type = isNew ? 'create' : 'update';
                    success(res);
                }

                function saveError(err) {
                    err.type = isNew ? 'create' : 'update';
                    error(err);
                }

                if (isNew) {
                    return self.create(model, saveSuccess, saveError);
                } else {
                    return self.updateSingle(model, saveSuccess, saveError);
                }
            }, success, error);
        },
        /**
         * Checks if the specified data item is new or not.
         * @memberOf Data.prototype
         * @method
         * @param model Item to check.
         * @returns {boolean}
         */
        isNew: function (model) {
            return typeof model[idField] === 'undefined';
        }
    };

    return Data;
}());

},{"../Everlive":42,"../EverliveError":43,"../Request":49,"../common":53,"../constants":54,"../query/DataQuery":63,"../query/RequestOptionsBuilder":66,"../utils":73}],71:[function(require,module,exports){
/**
 * @class Files
 * @protected
 * @extends Data
 */

var buildPromise = require('../utils').buildPromise;
var DataQuery = require('../query/DataQuery');
var Request = require('../Request');
var utils = require('../utils');

module.exports.addFilesFunctions = function addFilesFunctions(ns) {
    /**
     * Get a URL that can be used as an endpoint for uploading a file. It is specific to each {{site.TelerikBackendServices}} app.
     * @memberof Files.prototype
     * @method getUploadUrl
     * @returns {string}
     */
    ns.getUploadUrl = function () {
        return utils.buildUrl(this.setup) + this.collectionName;
    };

    /**
     * Get the download URL for a file.
     * @memberof Files.prototype
     * @method getDownloadUrl
     * @deprecated
     * @param {string} fileId The ID of the file.
     * @returns {string} url The download URL.
     */
    ns.getDownloadUrl = function (fileId) {
        return utils.buildUrl(this.setup) + this.collectionName + '/' + fileId + '/Download';
    };

    ns._getUpdateUrl = function (fileId) {
        return this.collectionName + '/' + fileId + '/Content';
    };

    /**
     * Get a URL that can be used as an endpoint for updating a file. It is specific to each {{site.TelerikBackendServices}} app.
     * @memberof Files.prototype
     * @method getUpdateUrl
     * @param {string} fileId The ID of the file.
     * @returns {string} url The update URL.
     */
    ns.getUpdateUrl = function (fileId) {
        return utils.buildUrl(this.setup) + this._getUpdateUrl(fileId);
    };

    /**
     * Updates a file's content
     * @memberof Files.prototype
     * @method updateContent
     * @param {string} fileId File ID.
     * @param {string} file File contents in base64 encoding.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     * @returns {Promise} The promise for the request
     */
    ns.updateContent = function (fileId, file, success, error) {
        var self = this;

        return buildPromise(function (success, error) {
            var dataQuery = new DataQuery({
                operation: DataQuery.operations.filesUpdateContent,
                // the passed file content is base64 encoded
                data: file,
                collectionName: self.collectionName,
                additionalOptions: {
                    id: fileId
                },
                onSuccess: success,
                onError: error
            });


            return self.processDataQuery(dataQuery);
        }, success, error);
    };

    /**
     * Gets the download URL for a file by ID.
     * @memberof Files.prototype
     * @method getDownloadUrlById
     * @param {string} fileId File ID.
     * @param operationParameters
     * @returns {Promise} The promise for the request
     */
    ns.getDownloadUrlById = function (fileId, success, error) {
        var self = this;

        return buildPromise(function (success, error) {
            var dataQuery = new DataQuery({
                operation: DataQuery.operations.filesGetDownloadUrlById,
                collectionName: self.collectionName,
                additionalOptions: {
                    id: fileId
                },
                parse: Request.parsers.single,
                onSuccess: function (data) {
                    success(data.result.Uri);
                },
                onError: error
            });


            return self.processDataQuery(dataQuery);
        }, success, error);
    };
};
},{"../Request":49,"../query/DataQuery":63,"../utils":73}],72:[function(require,module,exports){
/**
 * @class Users
 * @extends Data
 * @protected
 */

var utils = require('../utils');
var buildPromise = utils.buildPromise;
var guardUnset = utils.guardUnset;
var DataQuery = require('../query/DataQuery');
var Request = require('../Request');
var _ = require('../common')._;
var EverliveError = require('../EverliveError').EverliveError;
var EverliveErrors = require('../EverliveError').EverliveErrors;

module.exports.addUsersFunctions = function addUsersFunctions(ns, everlive) {

    /**
     * Registers a new user with username and password.
     * @memberOf Users.prototype
     * @method register
     * @name register
     * @param {string} username The new user's username.
     * @param {string} password The new user's password.
     * @param {object} userInfo Additional information for the user (ex. DisplayName, Email, etc.)
     * @returns {Promise} The promise for the request.
     */
    /**
     * Registers a new user using a username and a password.
     * @memberOf Users.prototype
     * @method register
     * @name register
     * @param {string} username The new user's username.
     * @param {string} password The new user's password.
     * @param attrs
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.register = function (username, password, attrs, success, error) {
        guardUnset(username, 'username');
        guardUnset(password, 'password');
        var user = {
            Username: username,
            Password: password
        };
        _.extend(user, attrs);
        return this.create(user, success, error);
    };

    /**
     * Gets information about the user that is currently authenticated to the {{site.bs}} JavaScript SDK.
     * @memberOf Users.prototype
     * @method currentUser
     * @name currentUser
     * @returns {Promise} The promise for the request.
     */
    /**
     * Gets information about the user that is currently authenticated to the {{site.bs}} JavaScript SDK.
     * @memberOf Users.prototype
     * @method currentUser
     * @name currentUser
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.currentUser = function (success, error) {
        var self = this;
        var id = self.everlive._isOfflineStorageEnabled() && self.everlive.isOffline() ? self.everlive.setup.principalId : 'me';
        return buildPromise(function (success, error) {
            if (id === 'me' && !self.everlive.setup.token && !self.everlive.setup.masterKey || !id) {
                return success({result: null});
            }

            self.getById(id).then(function (res) {
                    if (typeof res.result !== 'undefined') {
                        success({result: res.result});
                    } else {
                        success({result: null});
                    }
                },
                function (err) {
                    if (self.everlive.authentication && self.everlive.authentication.isAuthenticationInProgress()) {
                        success({result: null});
                    } else if (err.code === 601) { // invalid request, i.e. the access token is missing
                        success({result: null});
                    } else if (err.code === 801) {
                        error(EverliveErrors.invalidToken);
                    } else {
                        error(err);
                    }
                }
            );
        }, success, error);
    };

    /**
     * Changes the password of a user.
     * @memberOf Users.prototype
     * @method changePassword
     * @name changePassword
     * @param {string} username The user's username.
     * @param {string} password The user's password.
     * @param {string} newPassword The user's new password.
     * @param {boolean} keepTokens If set to true, the user tokens will be preserved even after the password change.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Changes the password of a user.
     * @memberOf Users.prototype
     * @method changePassword
     * @name changePassword
     * @param {string} username The user's username.
     * @param {string} password The user's password.
     * @param {string} newPassword The user's new password.
     * @param {boolean} keepTokens If set to true, the user tokens will be preserved even after the password change.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.changePassword = function (username, password, newPassword, keepTokens, success, error) {
        var self = this;
        return buildPromise(function (success, error) {
            success = _.wrap(success, function (success, data) {
                if (data && data.result) {
                    if (!keepTokens) {
                        ns.clearAuthorization();
                    }
                }
                return success(data);
            });

            var dataQuery = new DataQuery({
                operation: DataQuery.operations.userChangePassword,
                collectionName: self.collectionName,
                data: {
                    Username: username,
                    Password: password,
                    NewPassword: newPassword
                },
                additionalOptions: {
                    keepTokens: keepTokens
                },
                skipAuth: true,
                onSuccess: success,
                onError: error
            });

            return self.processDataQuery(dataQuery)
        }, success, error)
    };

    /**
     *
     * Logs in a user using a username and a password to the current {{site.bs}} JavaScript SDK instance. All requests initiated by the current {{site.bs}} JavaScript SDK instance will be authenticated with that user's credentials.
     * @memberOf Users.prototype
     * @method login
     * @name login
     * @param {string} username The user's username.
     * @param {string} password The user's password.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Logs in a user using a username and a password to the current {{site.bs}} JavaScript SDK instance. All requests initiated by the current {{site.bs}} JavaScript SDK instance will be authenticated with that user's credentials.
     * @memberOf Users.prototype
     * @method login
     * @name login
     * @deprecated
     * @param {string} username The user's username.
     * @param {string} password The user's password.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.login = function (username, password, success, error) {
        return everlive.authentication.login(username, password, success, error);

    };

    /**
     * Log out the user who is currently logged in.
     * @memberOf Users.prototype
     * @method logout
     * @name logout
     * @deprecated
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log out the user who is currently logged in.
     * @memberOf Users.prototype
     * @method logout
     * @name logout
     * @deprecated
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.logout = function (success, error) {
        return everlive.authentication.logout(success, error);

    };

    /**
     * Log in a user using an Facebook access token.
     * @memberOf Users.prototype
     * @method loginWithFacebook
     * @name loginWithFacebook
     * @param {string} accessToken Facebook access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using an Facebook access token.
     * @memberOf Users.prototype
     * @method loginWithFacebook
     * @name loginWithFacebook
     * @deprecated
     * @param {string} accessToken Facebook access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.loginWithFacebook = function (accessToken, success, error) {
        return everlive.authentication.loginWithFacebook(accessToken, success, error);
    };

    /**
     * Links a {{site.TelerikBackendServices}} user account to a Facebook access token.
     * @memberOf Users.prototype
     * @method linkWithFacebook
     * @name linkWithFacebook
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The Facebook access token that will be linked to the {{site.bs}} user account.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Links a Backend Services user with a Facebook access token.
     * @memberOf Users.prototype
     * @method linkWithFacebook
     * @name linkWithFacebook
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The Facebook access token that will be linked to the {{site.bs}} user account.         * @param {Function} [success] a success callback.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.linkWithFacebook = function (userId, accessToken, success, error) {
        var identity = {
            Provider: 'Facebook',
            Token: accessToken
        };
        return ns._linkWithProvider(identity, userId, success, error);
    };

    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Facebook token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromFacebook
     * @name unlinkFromFacebook
     * @param {string} userId The user's ID in {{site.bs}}.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Facebook token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromFacebook
     * @name unlinkFromFacebook
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.unlinkFromFacebook = function (userId, success, error) {
        return ns._unlinkFromProvider('Facebook', userId, success, error);
    };

    /**
     * Log in a user using an ADFS access token.
     * @memberOf Users.prototype
     * @method loginWithADFS
     * @name loginWithADFS
     * @param {string} accessToken ADFS access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using an ADFS access token.
     * @memberOf Users.prototype
     * @method loginWithADFS
     * @name loginWithADFS
     * @deprecated
     * @param {string} accessToken ADFS access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.loginWithADFS = function (accessToken, success, error) {
        return everlive.authentication.loginWithADFS(accessToken, success, error);
    };

    /**
     * Links a {{site.TelerikBackendServices}} user account to an ADFS access token.
     * @memberOf Users.prototype
     * @method linkWithADFS
     * @name linkWithADFS
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The ADFS access token that will be linked to the {{site.bs}} user account.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Links a {{site.TelerikBackendServices}} user account to an ADFS access token.
     * @memberOf Users.prototype
     * @method linkWithADFS
     * @name linkWithADFS
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The ADFS access token that will be linked to the {{site.bs}} user account.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.linkWithADFS = function (userId, accessToken, success, error) {
        var identity = {
            Provider: 'ADFS',
            Token: accessToken
        };
        return ns._linkWithProvider(identity, userId, success, error);
    };

    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the ADFS token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromADFS
     * @name unlinkFromADFS
     * @param {string} userId The user's ID in {{site.bs}}.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the ADFS token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromADFS
     * @name unlinkFromADFS
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.unlinkFromADFS = function (userId, success, error) {
        return ns._unlinkFromProvider('ADFS', userId, success, error);
    };

    /**
     * Log in a user using a LiveID access token.
     * @memberOf Users.prototype
     * @method loginWithLiveID
     * @name loginWithLiveID
     * @param {string} accessToken LiveID access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using a LiveID access token.
     * @memberOf Users.prototype
     * @method loginWithLiveID
     * @name loginWithLiveID
     * @deprecated
     * @param {string} accessToken LiveID access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.loginWithLiveID = function (accessToken, success, error) {
        return everlive.authentication.loginWithLiveID(accessToken, success, error);
    };

    /**
     * Links a {{site.TelerikBackendServices}} user account to a LiveId access token.
     * @memberOf Users.prototype
     * @method linkWithLiveID
     * @name linkWithLiveID
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The LiveID access token that will be linked to the {{site.bs}} user account.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Links a {{site.TelerikBackendServices}} user account to a LiveId access token.
     * @memberOf Users.prototype
     * @method linkWithLiveID
     * @name linkWithLiveID
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The LiveID access token that will be linked to the {{site.bs}} user account.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.linkWithLiveID = function (userId, accessToken, success, error) {
        var identity = {
            Provider: 'LiveID',
            Token: accessToken
        };
        return ns._linkWithProvider(identity, userId, success, error);
    };

    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the LiveID access token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromLiveID
     * @name unlinkFromLiveID
     * @param {string} userId The user's ID in {{site.bs}}.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the LiveID access token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromLiveID
     * @name unlinkFromLiveID
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.unlinkFromLiveID = function (userId, success, error) {
        return ns._unlinkFromProvider('LiveID', userId, success, error);
    };

    /**
     * Log in a user using a Google access token.
     * @memberOf Users.prototype
     * @method loginWithGoogle
     * @name loginWithGoogle
     * @param {string} accessToken Google access token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user using a Google access token.
     * @memberOf Users.prototype
     * @method loginWithGoogle
     * @name loginWithGoogle
     * @deprecated
     * @param {string} accessToken Google access token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.loginWithGoogle = function (accessToken, success, error) {
        return everlive.authentication.loginWithGoogle(accessToken, success, error);
    };

    /**
     * Links a {{site.TelerikBackendServices}} user account to a Google access token.
     * @memberOf Users.prototype
     * @method linkWithGoogle
     * @name linkWithGoogle
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The Google access token that will be linked to the {{site.bs}} user account.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Links a {{site.TelerikBackendServices}} user account to a Google access token.
     * @memberOf Users.prototype
     * @method linkWithGoogle
     * @name linkWithGoogle
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} accessToken The Google access token that will be linked to the {{site.bs}} user account.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.linkWithGoogle = function (userId, accessToken, success, error) {
        var identity = {
            Provider: 'Google',
            Token: accessToken
        };

        return ns._linkWithProvider(identity, userId, success, error);
    };

    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Google access token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromGoogle
     * @name unlinkFromGoogle
     * @param {string} userId The user's ID in {{site.bs}}.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Google access token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromGoogle
     * @name unlinkFromGoogle
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.unlinkFromGoogle = function (userId, success, error) {
        return ns._unlinkFromProvider('Google', userId, success, error);
    };

    /**
     * Log in a user with a Twitter token. A secret token needs to be provided.
     * @memberOf Users.prototype
     * @method loginWithTwitter
     * @name loginWithTwitter
     * @param {string} token Twitter token.
     * @param {string} tokenSecret Twitter secret token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Log in a user with a Twitter token. A secret token needs to be provided.
     * @memberOf Users.prototype
     * @method loginWithTwitter
     * @name loginWithTwitter
     * @param {string} token Twitter token.
     * @param {string} tokenSecret Twitter secret token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.loginWithTwitter = function (token, tokenSecret, success, error) {
        return everlive.authentication.loginWithTwitter(token, tokenSecret, success, error);
    };

    /**
     * Links a {{site.TelerikBackendServices}} user to a Twitter token. A secret token needs to be provided.
     * @memberOf Users.prototype
     * @method linkWithTwitter
     * @name linkWithTwitter
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} token The Twitter access token that will be linked to the {{site.bs}} user account.
     * @param {string} tokenSecret The Twitter secret token.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Links a {{site.TelerikBackendServices}} user to a Twitter token. A secret token needs to be provided.         * Links a Backend Services user with a Twitter token. A secret token needs to be provided.
     * @memberOf Users.prototype
     * @method linkWithTwitter
     * @name linkWithTwitter
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {string} token The Twitter access token that will be linked to the {{site.bs}} user account.
     * @param {string} tokenSecret The Twitter secret token.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.linkWithTwitter = function (userId, token, tokenSecret, success, error) {
        var identity = {
            Provider: 'Twitter',
            Token: token,
            TokenSecret: tokenSecret
        };

        return ns._linkWithProvider(identity, userId, success, error);
    };

    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Twitter access token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromTwitter
     * @name unlinkFromTwitter
     * @param {string} userId The user's ID in {{site.bs}}.
     * @returns {Promise} The promise for the request.
     */
    /**
     * Unlinks a {{site.TelerikBackendServices}} user account from the Twitter access token that it is linked to.
     * @memberOf Users.prototype
     * @method unlinkFromTwitter
     * @name unlinkFromTwitter
     * @param {string} userId The user's ID in {{site.bs}}.
     * @param {Function} [success] A success callback.
     * @param {Function} [error] An error callback.
     */
    ns.unlinkFromTwitter = function (userId, success, error) {
        return ns._unlinkFromProvider('Twitter', userId, success, error);
    };

    /**
     * Sets the token and token type that the {{site.TelerikBackendServices}} JavaScript SDK will use for authorization.
     * @memberOf Users.prototype
     * @method setAuthorization
     * @deprecated
     * @param {string} token Token that will be used for authorization.
     * @param {Everlive.TokenType} tokenType Token type. Currently only 'bearer' token is supported.
     * @param {string} principalId The id of the user that is logged in.
     */
    ns.setAuthorization = function setAuthorization(token, tokenType, principalId) {
        everlive.authentication.setAuthorization(token, tokenType, principalId)
    };

    /**
     * Clears the authentication token that the {{site.bs}} JavaScript SDK currently uses. Note that this is different than logging out, because the current authorization token is not invalidated.
     * @method clearAuthorization
     * @deprecated
     * @memberOf Users.prototype
     */
    ns.clearAuthorization = function clearAuthorization() {
        everlive.authentication.setAuthorization(null, null, null);
    };

    ns._linkWithProvider = function (identity, userId, success, error) {
        var self = this;
        return buildPromise(function (success, error) {
            var query = new DataQuery({
                additionalOptions: {
                    id: userId
                },
                operation: DataQuery.operations.userLinkWithProvider,
                collectionName: self.collectionName,
                data: identity,
                parse: Request.parsers.single,
                skipAuth: true,
                onSuccess: success,
                onError: error
            });

            return self.processDataQuery(query);
        }, success, error);
    };

    ns._unlinkFromProvider = function (providerName, userId, success, error) {
        var identity = {
            Provider: providerName
        };
        var self = this;
        return buildPromise(function (success, error) {
            var query = new DataQuery({
                additionalOptions: {
                    userId: userId
                },
                operation: DataQuery.operations.userUnlinkFromProvider,
                collectionName: self.collectionName,
                data: identity,
                parse: Request.parsers.single,
                skipAuth: true,
                onSuccess: success,
                onError: error
            });

            return self.processDataQuery(query);
        }, success, error);
    };
};
},{"../EverliveError":43,"../Request":49,"../common":53,"../query/DataQuery":63,"../utils":73}],73:[function(require,module,exports){
var EverliveError = require('./EverliveError').EverliveError;
var common = require('./common');
var _ = common._;
var rsvp = common.rsvp;
var Everlive = require('./Everlive');
var isNodejs = require('./everlive.platform').isNodejs;

var utils = {};

utils.guardUnset = function guardUnset(value, name, message) {
    if (!message) {
        message = 'The ' + name + ' is required';
    }
    if (typeof value === 'undefined' || value === null) {
        throw new EverliveError(message);
    }
};

utils.parseUtilities = {
    getReviver: function (parseOnlyCompleteDateTimeString) {
        var dateParser;
        if (parseOnlyCompleteDateTimeString) {
            dateParser = utils.parseUtilities.parseIsoDateString;
        } else {
            dateParser = utils.parseUtilities.parseOnlyCompleteDateTimeString;
        }

        return function (key, value) {
            if (typeof value === 'string') {
                var date = dateParser(value);
                if (date) {
                    value = date;
                }
            }

            return value;
        }
    },

    parseIsoDateString: function (string) {
        var match;
        if (match = string.match(/^(\d{4})(-(\d{2})(-(\d{2})(T(\d{2}):(\d{2})(:(\d{2})(\.(\d+))?)?(Z|((\+|-)(\d{2}):(\d{2}))))?))$/)) {
            // DateTime
            var secondParts = match[12];
            if (secondParts) {
                if (secondParts.length > 3) {
                    secondParts = Math.round(Number(secondParts.substr(0, 3) + '.' + secondParts.substr(3)));
                }
                else if (secondParts.length < 3) {
                    // if the secondParts are one or two characters then two or one zeros should be appended
                    // in order to have the correct number for milliseconds ('.67' means 670ms not 67ms)
                    secondParts += secondParts.length === 2 ? '0' : '00';
                }
            }
            var date = new Date(
                Date.UTC(
                    Number(match[1]), // year
                    (Number(match[3]) - 1) || 0, // month
                    Number(match[5]) || 0, // day
                    Number(match[7]) || 0, // hour
                    Number(match[8]) || 0, // minute
                    Number(match[10]) || 0, // second
                    Number(secondParts) || 0
                )
            );

            if (match[13] && match[13] !== "Z") {
                var h = Number(match[16]) || 0,
                    m = Number(match[17]) || 0;

                h *= 3600000;
                m *= 60000;

                var offset = h + m;
                if (match[15] === "+")
                    offset = -offset;

                date = new Date(date.valueOf() + offset);
            }

            return date;
        } else {
            return null;
        }
    },

    parseOnlyCompleteDateTimeString: function (string) {
        if (/^\d{4}-\d{2}-\d{2}$/.test(string)) {
            // Date
            return null;
        }

        if (/^(\d{2}):(\d{2})(:(\d{2})(\.(\d+))?)?(Z|((\+|-)(\d{2}):(\d{2})))?$/.test(string)) {
            // Time
            return null;
        }

        return utils.parseUtilities.parseIsoDateString(string);
    },

    traverse: function (obj, func) {
        var key, value, newValue;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                value = obj[key];
                newValue = func(key, value);
                obj[key] = newValue;
                if (value === newValue && typeof value === 'object') {
                    utils.parseUtilities.traverse(value, func);
                }
            }
        }
        return obj;
    },

    traverseAndRevive: function (data, reviver) {
        if (!reviver) {
            reviver = utils.parseUtilities.getReviver();
        }

        return utils.parseUtilities.traverse(data, reviver);
    },

    parseError: function (reviver, error) {
        if (typeof error === 'string' && error.length > 0) {
            try {
                error = JSON.parse(error);
                return {message: error.message, code: error.errorCode};
            } catch (e) {
                return error;
            }
        } else {
            return error;
        }
    },

    _parseInternal: function (reviver, data) {
        if (typeof data === 'string' && data.length > 0) {
            data = JSON.parse(data, reviver);
        } else if (typeof data === 'object') {
            utils.parseUtilities.traverseAndRevive(data, reviver);
        }

        return data;
    },

    _transformResult: function (data, additionalProperties) {
        if (data) {
            var result = {result: data.Result};
            _.extend(result, additionalProperties);
            return result;
        } else {
            return data;
        }
    },

    parseResult: function (reviver, data) {
        data = utils.parseUtilities._parseInternal.apply(null, arguments);
        return utils.parseUtilities._transformResult(data, {count: data.Count});
    },

    parseSingleResult: function (reviver, data) {
        data = utils.parseUtilities._parseInternal.apply(null, arguments);
        return utils.parseUtilities._transformResult(data);
    },

    parseUpdateResult: function (reviver, data) {
        data = utils.parseUtilities._parseInternal.apply(null, arguments);
        return utils.parseUtilities._transformResult(data, {ModifiedAt: data.ModifiedAt});
    }
};

utils.buildPromise = function buildPromise(operation, success, error) {
    var callbacks = utils.getCallbacks(success, error);
    operation(callbacks.success, callbacks.error);
    return callbacks.promise;
};

utils.getCallbacks = function (success, error) {
    var promise;
    var createPromise = function () {
        return new rsvp.Promise(function (resolve, reject) {
            success = function (data) {
                resolve(data);
            };
            error = function (error) {
                reject(error);
            };
        });
    };

    if (isNodejs) {
        // node js style continuation
        if (typeof success === 'function' && typeof error !== 'function') {
            var callback = success;
            success = function (data, response) {
                callback(null, data, response);
            };
            error = function (error) {
                callback(error);
            };
        } else if (typeof success !== 'function' && typeof error !== 'function') {
            promise = createPromise();
        }
    } else {
        if (typeof success !== 'function' && typeof error !== 'function') {
            promise = createPromise();
        }
    }

    return {promise: promise, success: success, error: error};
};

utils.buildAuthHeader = function buildAuthHeader(setup, options) {
    var authHeaderValue = null;
    if (options && options.authHeaders === false) {
        return authHeaderValue;
    }
    if (setup.token) {
        authHeaderValue = (setup.tokenType || 'bearer') + ' ' + setup.token;
    }
    else if (setup.masterKey) {
        authHeaderValue = 'masterkey ' + setup.masterKey;
    }
    if (authHeaderValue) {
        return {Authorization: authHeaderValue};
    } else {
        return null;
    }
};

utils.DeviceRegistrationResult = function DeviceRegistrationResult(token) {
    this.token = token;
};

utils.cloneDate = function (date) {
    return new Date(date);
};

utils.buildUrl = function (setup) {
    var url = '';
    if (typeof setup.scheme === 'string') {
        url += setup.scheme + ':';
    }
    url += setup.url;
    if (setup.apiKey) {
        url += setup.apiKey + '/';
    }
    return url;
};

utils.getDbOperators = function (expression, shallow) {
    var dbOperators = [];

    if (typeof expression === 'string') {
        return dbOperators;
    }

    var modifierKeys = Object.keys(expression);
    _.each(modifierKeys, function (key) {
        if (key.indexOf('$') === 0) {
            dbOperators.push(key);
        } else if (typeof expression[key] === 'object' && !shallow) {
            dbOperators = dbOperators.concat(utils.getDbOperators(expression[key]));
        }
    });

    return dbOperators;
};


var unsupportedDbOperators = [
    '$geoWithin',
    '$geoIntersects',
    '$near',
    '$within',
    '$nearSphere'
];

utils.getUnsupportedOperators = function (filter) {
    var dbOperators = utils.getDbOperators(filter);
    return _.intersection(dbOperators, unsupportedDbOperators);
};

module.exports = utils;

},{"./Everlive":42,"./EverliveError":43,"./common":53,"./everlive.platform":56}]},{},[57])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9qc3RpbWV6b25lZGV0ZWN0L2pzdHouanMiLCJub2RlX21vZHVsZXMvbWluZ28vbWluZ28uanMiLCJub2RlX21vZHVsZXMvbW9uZ28tcXVlcnkvZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL21vbmdvLXF1ZXJ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vbmdvLXF1ZXJ5L21vZHMuanMiLCJub2RlX21vZHVsZXMvbW9uZ28tcXVlcnkvbm9kZV9tb2R1bGVzL2NvbXBvbmVudC10eXBlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vbmdvLXF1ZXJ5L25vZGVfbW9kdWxlcy9kZWJ1Zy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL21vbmdvLXF1ZXJ5L25vZGVfbW9kdWxlcy9kZWJ1Zy9kZWJ1Zy5qcyIsIm5vZGVfbW9kdWxlcy9tb25nby1xdWVyeS9ub2RlX21vZHVsZXMvZGVidWcvbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vbmdvLXF1ZXJ5L25vZGVfbW9kdWxlcy9kb3QtY29tcG9uZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vbmdvLXF1ZXJ5L25vZGVfbW9kdWxlcy9kb3QtY29tcG9uZW50L25vZGVfbW9kdWxlcy90eXBlLWNvbXBvbmVudC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tb25nby1xdWVyeS9ub2RlX21vZHVsZXMvbW9uZ28tZXFsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vbmdvLXF1ZXJ5L25vZGVfbW9kdWxlcy9vYmplY3QtY29tcG9uZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21vbmdvLXF1ZXJ5L29wcy5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlLWNyeXB0b2pzLWFlcy9jcnlwdG9qcy5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlLWNyeXB0b2pzLWFlcy9saWIvYWVzLmpzIiwibm9kZV9tb2R1bGVzL25vZGUtY3J5cHRvanMtYWVzL2xpYi9jaXBoZXItY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlLWNyeXB0b2pzLWFlcy9saWIvY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlLWNyeXB0b2pzLWFlcy9saWIvZW5jLWJhc2U2NC5qcyIsIm5vZGVfbW9kdWxlcy9ub2RlLWNyeXB0b2pzLWFlcy9saWIvZXZwa2RmLmpzIiwibm9kZV9tb2R1bGVzL25vZGUtY3J5cHRvanMtYWVzL2xpYi9qc29uZm9ybWF0dGVyLmpzIiwibm9kZV9tb2R1bGVzL25vZGUtY3J5cHRvanMtYWVzL2xpYi9tZDUuanMiLCJub2RlX21vZHVsZXMvcmVxd2VzdC9yZXF3ZXN0LmpzIiwibm9kZV9tb2R1bGVzL3JzdnAvZGlzdC9yc3ZwLmpzIiwibm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvdW5kZXJzY29yZS5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL3JuZy1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvdXVpZC5qcyIsInNjcmlwdHMvYnMtZXhwYW5kLXByb2Nlc3Nvci9Db25zdGFudHMuanMiLCJzY3JpcHRzL2JzLWV4cGFuZC1wcm9jZXNzb3IvRXhlY3V0aW9uVHJlZS5qcyIsInNjcmlwdHMvYnMtZXhwYW5kLXByb2Nlc3Nvci9FeHBhbmRFcnJvci5qcyIsInNjcmlwdHMvYnMtZXhwYW5kLXByb2Nlc3Nvci9Qcm9jZXNzb3IuanMiLCJzY3JpcHRzL2JzLWV4cGFuZC1wcm9jZXNzb3IvUmVsYXRpb25Ob2RlLmpzIiwic2NyaXB0cy9icy1leHBhbmQtcHJvY2Vzc29yL1JlbGF0aW9uVHJlZUJ1aWxkZXIuanMiLCJzY3JpcHRzL2JzLWV4cGFuZC1wcm9jZXNzb3Ivbm9kZV9tb2R1bGVzL2FzeW5jL2xpYi9hc3luYy5qcyIsInNjcmlwdHMvYnMtZXhwYW5kLXByb2Nlc3Nvci9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS91bmRlcnNjb3JlLmpzIiwic3JjL0N1cnJlbnREZXZpY2UuanMiLCJzcmMvRXZlcmxpdmUuanMiLCJzcmMvRXZlcmxpdmVFcnJvci5qcyIsInNyYy9FeHBhbmRQcm9jZXNzb3IuanMiLCJzcmMvRXhwcmVzc2lvbi5qcyIsInNyYy9HZW9Qb2ludC5qcyIsInNyYy9Mb2NhbFN0b3JlLmpzIiwic3JjL1B1c2guanMiLCJzcmMvUmVxdWVzdC5qcyIsInNyYy9TZXR1cC5qcyIsInNyYy9hdXRoL0F1dGhlbnRpY2F0aW9uLmpzIiwic3JjL2F1dGgvQXV0aGVudGljYXRpb25TZXR1cC5qcyIsInNyYy9jb21tb24uanMiLCJzcmMvY29uc3RhbnRzLmpzIiwic3JjL2VuY3J5cHRpb24vQ3J5cHRvZ3JhcGhpY1Byb3ZpZGVyLmpzIiwic3JjL2V2ZXJsaXZlLnBsYXRmb3JtLmpzIiwic3JjL2luZGV4LmpzIiwic3JjL2tlbmRvL2tlbmRvLmV2ZXJsaXZlLmpzIiwic3JjL29mZmxpbmUvT2ZmbGluZVN0b3JhZ2VNb2R1bGUuanMiLCJzcmMvb2ZmbGluZS9vZmZsaW5lLmpzIiwic3JjL29mZmxpbmUvb2ZmbGluZVBlcnNpc3RlcnMuanMiLCJzcmMvb2ZmbGluZS9vZmZsaW5lVHJhbnNmb3JtYXRpb25zLmpzIiwic3JjL3F1ZXJ5L0RhdGFRdWVyeS5qcyIsInNyYy9xdWVyeS9RdWVyeS5qcyIsInNyYy9xdWVyeS9RdWVyeUJ1aWxkZXIuanMiLCJzcmMvcXVlcnkvUmVxdWVzdE9wdGlvbnNCdWlsZGVyLmpzIiwic3JjL3F1ZXJ5L1doZXJlUXVlcnkuanMiLCJzcmMvcmVxd2VzdC5uYXRpdmVzY3JpcHQuanMiLCJzcmMvcmVxd2VzdC5ub2RlanMuanMiLCJzcmMvdHlwZXMvRGF0YS5qcyIsInNyYy90eXBlcy9GaWxlcy5qcyIsInNyYy90eXBlcy9Vc2Vycy5qcyIsInNyYy91dGlscy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdldBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy8xREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqMkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2b0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1Z0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNubUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hnREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdm1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcGxEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcmdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzd2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfVxuICAgICAgdGhyb3cgVHlwZUVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LicpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgdmFyIG07XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSAwO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKGVtaXR0ZXIuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gMTtcbiAgZWxzZVxuICAgIHJldCA9IGVtaXR0ZXIuX2V2ZW50c1t0eXBlXS5sZW5ndGg7XG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gdHJ1ZTtcbiAgICB2YXIgY3VycmVudFF1ZXVlO1xuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB2YXIgaSA9IC0xO1xuICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICBjdXJyZW50UXVldWVbaV0oKTtcbiAgICAgICAgfVxuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG59XG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHF1ZXVlLnB1c2goZnVuKTtcbiAgICBpZiAoIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuIiwiLyoqXG4gKiBUaGlzIHNjcmlwdCBnaXZlcyB5b3UgdGhlIHpvbmUgaW5mbyBrZXkgcmVwcmVzZW50aW5nIHlvdXIgZGV2aWNlJ3MgdGltZSB6b25lIHNldHRpbmcuXG4gKlxuICogQG5hbWUganNUaW1lem9uZURldGVjdFxuICogQHZlcnNpb24gMS4wLjVcbiAqIEBhdXRob3IgSm9uIE55bGFuZGVyXG4gKiBAbGljZW5zZSBNSVQgTGljZW5zZSAtIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gKlxuICogRm9yIHVzYWdlIGFuZCBleGFtcGxlcywgdmlzaXQ6XG4gKiBodHRwOi8vcGVsbGVwaW0uYml0YnVja2V0Lm9yZy9qc3R6L1xuICpcbiAqIENvcHlyaWdodCAoYykgSm9uIE55bGFuZGVyXG4gKi9cblxuLypqc2xpbnQgdW5kZWY6IHRydWUgKi9cbi8qZ2xvYmFsIGNvbnNvbGUsIGV4cG9ydHMqL1xuXG4oZnVuY3Rpb24ocm9vdCkge1xuICAvKipcbiAgICogTmFtZXNwYWNlIHRvIGhvbGQgYWxsIHRoZSBjb2RlIGZvciB0aW1lem9uZSBkZXRlY3Rpb24uXG4gICAqL1xuICB2YXIganN0eiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAndXNlIHN0cmljdCc7XG4gICAgICB2YXIgSEVNSVNQSEVSRV9TT1VUSCA9ICdzJyxcbiAgICAgICAgICBcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBHZXRzIHRoZSBvZmZzZXQgaW4gbWludXRlcyBmcm9tIFVUQyBmb3IgYSBjZXJ0YWluIGRhdGUuXG4gICAgICAgICAgICogQHBhcmFtIHtEYXRlfSBkYXRlXG4gICAgICAgICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBnZXRfZGF0ZV9vZmZzZXQgPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gLWRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIChvZmZzZXQgIT09IG51bGwgPyBvZmZzZXQgOiAwKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZ2V0X2RhdGUgPSBmdW5jdGlvbiAoeWVhciwgbW9udGgsIGRhdGUpIHtcbiAgICAgICAgICAgICAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICBpZiAoeWVhciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZC5zZXRGdWxsWWVhcih5ZWFyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkLnNldE1vbnRoKG1vbnRoKTtcbiAgICAgICAgICAgICAgZC5zZXREYXRlKGRhdGUpO1xuICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZ2V0X2phbnVhcnlfb2Zmc2V0ID0gZnVuY3Rpb24gKHllYXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldF9kYXRlX29mZnNldChnZXRfZGF0ZSh5ZWFyLCAwICwyKSk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGdldF9qdW5lX29mZnNldCA9IGZ1bmN0aW9uICh5ZWFyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRfZGF0ZV9vZmZzZXQoZ2V0X2RhdGUoeWVhciwgNSwgMikpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBQcml2YXRlIG1ldGhvZC5cbiAgICAgICAgICAgKiBDaGVja3Mgd2hldGhlciBhIGdpdmVuIGRhdGUgaXMgaW4gZGF5bGlnaHQgc2F2aW5nIHRpbWUuXG4gICAgICAgICAgICogSWYgdGhlIGRhdGUgc3VwcGxpZWQgaXMgYWZ0ZXIgYXVndXN0LCB3ZSBhc3N1bWUgdGhhdCB3ZSdyZSBjaGVja2luZ1xuICAgICAgICAgICAqIGZvciBzb3V0aGVybiBoZW1pc3BoZXJlIERTVC5cbiAgICAgICAgICAgKiBAcGFyYW0ge0RhdGV9IGRhdGVcbiAgICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBkYXRlX2lzX2RzdCA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgICAgICAgIHZhciBpc19zb3V0aGVybiA9IGRhdGUuZ2V0TW9udGgoKSA+IDcsXG4gICAgICAgICAgICAgICAgICBiYXNlX29mZnNldCA9IGlzX3NvdXRoZXJuID8gZ2V0X2p1bmVfb2Zmc2V0KGRhdGUuZ2V0RnVsbFllYXIoKSkgOiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRfamFudWFyeV9vZmZzZXQoZGF0ZS5nZXRGdWxsWWVhcigpKSxcbiAgICAgICAgICAgICAgICAgIGRhdGVfb2Zmc2V0ID0gZ2V0X2RhdGVfb2Zmc2V0KGRhdGUpLFxuICAgICAgICAgICAgICAgICAgaXNfd2VzdCA9IGJhc2Vfb2Zmc2V0IDwgMCxcbiAgICAgICAgICAgICAgICAgIGRzdF9vZmZzZXQgPSBiYXNlX29mZnNldCAtIGRhdGVfb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGlmICghaXNfd2VzdCAmJiAhaXNfc291dGhlcm4pIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBkc3Rfb2Zmc2V0IDwgMDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBkc3Rfb2Zmc2V0ICE9PSAwO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIGRvZXMgc29tZSBiYXNpYyBjYWxjdWxhdGlvbnMgdG8gY3JlYXRlIGluZm9ybWF0aW9uIGFib3V0XG4gICAgICAgICAgICogdGhlIHVzZXIncyB0aW1lem9uZS4gSXQgdXNlcyBSRUZFUkVOQ0VfWUVBUiBhcyBhIHNvbGlkIHllYXIgZm9yIHdoaWNoXG4gICAgICAgICAgICogdGhlIHNjcmlwdCBoYXMgYmVlbiB0ZXN0ZWQgcmF0aGVyIHRoYW4gZGVwZW5kIG9uIHRoZSB5ZWFyIHNldCBieSB0aGVcbiAgICAgICAgICAgKiBjbGllbnQgZGV2aWNlLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogUmV0dXJucyBhIGtleSB0aGF0IGNhbiBiZSB1c2VkIHRvIGRvIGxvb2t1cHMgaW4ganN0ei5vbHNvbi50aW1lem9uZXMuXG4gICAgICAgICAgICogZWc6IFwiNzIwLDEsMlwiLiBcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICAgICAgICovXG5cbiAgICAgICAgICBsb29rdXBfa2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgamFudWFyeV9vZmZzZXQgPSBnZXRfamFudWFyeV9vZmZzZXQoKSxcbiAgICAgICAgICAgICAgICAgIGp1bmVfb2Zmc2V0ID0gZ2V0X2p1bmVfb2Zmc2V0KCksXG4gICAgICAgICAgICAgICAgICBkaWZmID0gamFudWFyeV9vZmZzZXQgLSBqdW5lX29mZnNldDtcblxuICAgICAgICAgICAgICBpZiAoZGlmZiA8IDApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBqYW51YXJ5X29mZnNldCArIFwiLDFcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChkaWZmID4gMCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGp1bmVfb2Zmc2V0ICsgXCIsMSxcIiArIEhFTUlTUEhFUkVfU09VVEg7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gamFudWFyeV9vZmZzZXQgKyBcIiwwXCI7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFVzZXMgZ2V0X3RpbWV6b25lX2luZm8oKSB0byBmb3JtdWxhdGUgYSBrZXkgdG8gdXNlIGluIHRoZSBvbHNvbi50aW1lem9uZXMgZGljdGlvbmFyeS5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIFJldHVybnMgYSBwcmltaXRpdmUgb2JqZWN0IG9uIHRoZSBmb3JtYXQ6XG4gICAgICAgICAgICogeyd0aW1lem9uZSc6IFRpbWVab25lLCAna2V5JyA6ICd0aGUga2V5IHVzZWQgdG8gZmluZCB0aGUgVGltZVpvbmUgb2JqZWN0J31cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEByZXR1cm5zIE9iamVjdFxuICAgICAgICAgICAqL1xuICAgICAgICAgIGRldGVybWluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIGtleSA9IGxvb2t1cF9rZXkoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBqc3R6LlRpbWVab25lKGpzdHoub2xzb24udGltZXpvbmVzW2tleV0pO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGlzIG9iamVjdCBjb250YWlucyBpbmZvcm1hdGlvbiBvbiB3aGVuIGRheWxpZ2h0IHNhdmluZ3Mgc3RhcnRzIGZvclxuICAgICAgICAgICAqIGRpZmZlcmVudCB0aW1lem9uZXMuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBUaGUgbGlzdCBpcyBzaG9ydCBmb3IgYSByZWFzb24uIE9mdGVuIHdlIGRvIG5vdCBoYXZlIHRvIGJlIHZlcnkgc3BlY2lmaWNcbiAgICAgICAgICAgKiB0byBzaW5nbGUgb3V0IHRoZSBjb3JyZWN0IHRpbWV6b25lLiBCdXQgd2hlbiB3ZSBkbywgdGhpcyBsaXN0IGNvbWVzIGluXG4gICAgICAgICAgICogaGFuZHkuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBFYWNoIHZhbHVlIGlzIGEgZGF0ZSBkZW5vdGluZyB3aGVuIGRheWxpZ2h0IHNhdmluZ3Mgc3RhcnRzIGZvciB0aGF0IHRpbWV6b25lLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGRzdF9zdGFydF9mb3IgPSBmdW5jdGlvbiAodHpfbmFtZSkge1xuXG4gICAgICAgICAgICB2YXIgcnVfcHJlX2RzdF9jaGFuZ2UgPSBuZXcgRGF0ZSgyMDEwLCA2LCAxNSwgMSwgMCwgMCwgMCksIC8vIEluIDIwMTAgUnVzc2lhIGhhZCBEU1QsIHRoaXMgYWxsb3dzIHVzIHRvIGRldGVjdCBSdXNzaWEgOilcbiAgICAgICAgICAgICAgICBkc3Rfc3RhcnRzID0ge1xuICAgICAgICAgICAgICAgICAgICAnQW1lcmljYS9EZW52ZXInOiBuZXcgRGF0ZSgyMDExLCAyLCAxMywgMywgMCwgMCwgMCksXG4gICAgICAgICAgICAgICAgICAgICdBbWVyaWNhL01hemF0bGFuJzogbmV3IERhdGUoMjAxMSwgMywgMywgMywgMCwgMCwgMCksXG4gICAgICAgICAgICAgICAgICAgICdBbWVyaWNhL0NoaWNhZ28nOiBuZXcgRGF0ZSgyMDExLCAyLCAxMywgMywgMCwgMCwgMCksXG4gICAgICAgICAgICAgICAgICAgICdBbWVyaWNhL01leGljb19DaXR5JzogbmV3IERhdGUoMjAxMSwgMywgMywgMywgMCwgMCwgMCksXG4gICAgICAgICAgICAgICAgICAgICdBbWVyaWNhL0FzdW5jaW9uJzogbmV3IERhdGUoMjAxMiwgOSwgNywgMywgMCwgMCwgMCksXG4gICAgICAgICAgICAgICAgICAgICdBbWVyaWNhL1NhbnRpYWdvJzogbmV3IERhdGUoMjAxMiwgOSwgMywgMywgMCwgMCwgMCksXG4gICAgICAgICAgICAgICAgICAgICdBbWVyaWNhL0NhbXBvX0dyYW5kZSc6IG5ldyBEYXRlKDIwMTIsIDksIDIxLCA1LCAwLCAwLCAwKSxcbiAgICAgICAgICAgICAgICAgICAgJ0FtZXJpY2EvTW9udGV2aWRlbyc6IG5ldyBEYXRlKDIwMTEsIDksIDIsIDMsIDAsIDAsIDApLFxuICAgICAgICAgICAgICAgICAgICAnQW1lcmljYS9TYW9fUGF1bG8nOiBuZXcgRGF0ZSgyMDExLCA5LCAxNiwgNSwgMCwgMCwgMCksXG4gICAgICAgICAgICAgICAgICAgICdBbWVyaWNhL0xvc19BbmdlbGVzJzogbmV3IERhdGUoMjAxMSwgMiwgMTMsIDgsIDAsIDAsIDApLFxuICAgICAgICAgICAgICAgICAgICAnQW1lcmljYS9TYW50YV9Jc2FiZWwnOiBuZXcgRGF0ZSgyMDExLCAzLCA1LCA4LCAwLCAwLCAwKSxcbiAgICAgICAgICAgICAgICAgICAgJ0FtZXJpY2EvSGF2YW5hJzogbmV3IERhdGUoMjAxMiwgMiwgMTAsIDIsIDAsIDAsIDApLFxuICAgICAgICAgICAgICAgICAgICAnQW1lcmljYS9OZXdfWW9yayc6IG5ldyBEYXRlKDIwMTIsIDIsIDEwLCA3LCAwLCAwLCAwKSxcbiAgICAgICAgICAgICAgICAgICAgJ0V1cm9wZS9IZWxzaW5raSc6IG5ldyBEYXRlKDIwMTMsIDIsIDMxLCA1LCAwLCAwLCAwKSxcbiAgICAgICAgICAgICAgICAgICAgJ1BhY2lmaWMvQXVja2xhbmQnOiBuZXcgRGF0ZSgyMDExLCA4LCAyNiwgNywgMCwgMCwgMCksXG4gICAgICAgICAgICAgICAgICAgICdBbWVyaWNhL0hhbGlmYXgnOiBuZXcgRGF0ZSgyMDExLCAyLCAxMywgNiwgMCwgMCwgMCksXG4gICAgICAgICAgICAgICAgICAgICdBbWVyaWNhL0dvb3NlX0JheSc6IG5ldyBEYXRlKDIwMTEsIDIsIDEzLCAyLCAxLCAwLCAwKSxcbiAgICAgICAgICAgICAgICAgICAgJ0FtZXJpY2EvTWlxdWVsb24nOiBuZXcgRGF0ZSgyMDExLCAyLCAxMywgNSwgMCwgMCwgMCksXG4gICAgICAgICAgICAgICAgICAgICdBbWVyaWNhL0dvZHRoYWInOiBuZXcgRGF0ZSgyMDExLCAyLCAyNywgMSwgMCwgMCwgMCksXG4gICAgICAgICAgICAgICAgICAgICdFdXJvcGUvTW9zY293JzogcnVfcHJlX2RzdF9jaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICdBc2lhL0FtbWFuJzogbmV3IERhdGUoMjAxMywgMiwgMjksIDEsIDAsIDAsIDApLFxuICAgICAgICAgICAgICAgICAgICAnQXNpYS9CZWlydXQnOiBuZXcgRGF0ZSgyMDEzLCAyLCAzMSwgMiwgMCwgMCwgMCksXG4gICAgICAgICAgICAgICAgICAgICdBc2lhL0RhbWFzY3VzJzogbmV3IERhdGUoMjAxMywgMywgNiwgMiwgMCwgMCwgMCksXG4gICAgICAgICAgICAgICAgICAgICdBc2lhL0plcnVzYWxlbSc6IG5ldyBEYXRlKDIwMTMsIDIsIDI5LCA1LCAwLCAwLCAwKSxcbiAgICAgICAgICAgICAgICAgICAgJ0FzaWEvWWVrYXRlcmluYnVyZyc6IHJ1X3ByZV9kc3RfY2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAnQXNpYS9PbXNrJzogcnVfcHJlX2RzdF9jaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICdBc2lhL0tyYXNub3lhcnNrJzogcnVfcHJlX2RzdF9jaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICdBc2lhL0lya3V0c2snOiBydV9wcmVfZHN0X2NoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgJ0FzaWEvWWFrdXRzayc6IHJ1X3ByZV9kc3RfY2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAnQXNpYS9WbGFkaXZvc3Rvayc6IHJ1X3ByZV9kc3RfY2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAnQXNpYS9CYWt1JzogbmV3IERhdGUoMjAxMywgMiwgMzEsIDQsIDAsIDApLFxuICAgICAgICAgICAgICAgICAgICAnQXNpYS9ZZXJldmFuJzogbmV3IERhdGUoMjAxMywgMiwgMzEsIDMsIDAsIDApLFxuICAgICAgICAgICAgICAgICAgICAnQXNpYS9LYW1jaGF0a2EnOiBydV9wcmVfZHN0X2NoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgJ0FzaWEvR2F6YSc6IG5ldyBEYXRlKDIwMTAsIDIsIDI3LCA0LCAwLCAwKSxcbiAgICAgICAgICAgICAgICAgICAgJ0FmcmljYS9DYWlybyc6IG5ldyBEYXRlKDIwMTAsIDQsIDEsIDMsIDAsIDApLFxuICAgICAgICAgICAgICAgICAgICAnRXVyb3BlL01pbnNrJzogcnVfcHJlX2RzdF9jaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICdQYWNpZmljL0FwaWEnOiBuZXcgRGF0ZSgyMDEwLCAxMCwgMSwgMSwgMCwgMCwgMCksXG4gICAgICAgICAgICAgICAgICAgICdQYWNpZmljL0ZpamknOiBuZXcgRGF0ZSgyMDEwLCAxMSwgMSwgMCwgMCwgMCksXG4gICAgICAgICAgICAgICAgICAgICdBdXN0cmFsaWEvUGVydGgnOiBuZXcgRGF0ZSgyMDA4LCAxMCwgMSwgMSwgMCwgMCwgMClcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHJldHVybiBkc3Rfc3RhcnRzW3R6X25hbWVdO1xuICAgICAgICAgIH07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGV0ZXJtaW5lOiBkZXRlcm1pbmUsXG4gICAgICAgICAgZGF0ZV9pc19kc3Q6IGRhdGVfaXNfZHN0LFxuICAgICAgICAgIGRzdF9zdGFydF9mb3I6IGRzdF9zdGFydF9mb3IgXG4gICAgICB9O1xuICB9KCkpO1xuXG4gIC8qKlxuICAgKiBTaW1wbGUgb2JqZWN0IHRvIHBlcmZvcm0gYW1iaWd1aXR5IGNoZWNrIGFuZCB0byByZXR1cm4gbmFtZSBvZiB0aW1lIHpvbmUuXG4gICAqL1xuICBqc3R6LlRpbWVab25lID0gZnVuY3Rpb24gKHR6X25hbWUpIHtcbiAgICAgICd1c2Ugc3RyaWN0JztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBrZXlzIGluIHRoaXMgb2JqZWN0IGFyZSB0aW1lem9uZXMgdGhhdCB3ZSBrbm93IG1heSBiZSBhbWJpZ3VvdXMgYWZ0ZXJcbiAgICAgICAgICogYSBwcmVsaW1pbmFyeSBzY2FuIHRocm91Z2ggdGhlIG9sc29uX3R6IG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGFycmF5IG9mIHRpbWV6b25lcyB0byBjb21wYXJlIG11c3QgYmUgaW4gdGhlIG9yZGVyIHRoYXQgZGF5bGlnaHQgc2F2aW5nc1xuICAgICAgICAgKiBzdGFydHMgZm9yIHRoZSByZWdpb25zLlxuICAgICAgICAgKi9cbiAgICAgIHZhciBBTUJJR1VJVElFUyA9IHtcbiAgICAgICAgICAgICAgJ0FtZXJpY2EvRGVudmVyJzogICAgICAgWydBbWVyaWNhL0RlbnZlcicsICdBbWVyaWNhL01hemF0bGFuJ10sXG4gICAgICAgICAgICAgICdBbWVyaWNhL0NoaWNhZ28nOiAgICAgIFsnQW1lcmljYS9DaGljYWdvJywgJ0FtZXJpY2EvTWV4aWNvX0NpdHknXSxcbiAgICAgICAgICAgICAgJ0FtZXJpY2EvU2FudGlhZ28nOiAgICAgWydBbWVyaWNhL1NhbnRpYWdvJywgJ0FtZXJpY2EvQXN1bmNpb24nLCAnQW1lcmljYS9DYW1wb19HcmFuZGUnXSxcbiAgICAgICAgICAgICAgJ0FtZXJpY2EvTW9udGV2aWRlbyc6ICAgWydBbWVyaWNhL01vbnRldmlkZW8nLCAnQW1lcmljYS9TYW9fUGF1bG8nXSxcbiAgICAgICAgICAgICAgJ0FzaWEvQmVpcnV0JzogICAgICAgICAgWydBc2lhL0FtbWFuJywgJ0FzaWEvSmVydXNhbGVtJywgJ0FzaWEvQmVpcnV0JywgJ0V1cm9wZS9IZWxzaW5raScsJ0FzaWEvRGFtYXNjdXMnXSxcbiAgICAgICAgICAgICAgJ1BhY2lmaWMvQXVja2xhbmQnOiAgICAgWydQYWNpZmljL0F1Y2tsYW5kJywgJ1BhY2lmaWMvRmlqaSddLFxuICAgICAgICAgICAgICAnQW1lcmljYS9Mb3NfQW5nZWxlcyc6ICBbJ0FtZXJpY2EvTG9zX0FuZ2VsZXMnLCAnQW1lcmljYS9TYW50YV9Jc2FiZWwnXSxcbiAgICAgICAgICAgICAgJ0FtZXJpY2EvTmV3X1lvcmsnOiAgICAgWydBbWVyaWNhL0hhdmFuYScsICdBbWVyaWNhL05ld19Zb3JrJ10sXG4gICAgICAgICAgICAgICdBbWVyaWNhL0hhbGlmYXgnOiAgICAgIFsnQW1lcmljYS9Hb29zZV9CYXknLCAnQW1lcmljYS9IYWxpZmF4J10sXG4gICAgICAgICAgICAgICdBbWVyaWNhL0dvZHRoYWInOiAgICAgIFsnQW1lcmljYS9NaXF1ZWxvbicsICdBbWVyaWNhL0dvZHRoYWInXSxcbiAgICAgICAgICAgICAgJ0FzaWEvRHViYWknOiAgICAgICAgICAgWydFdXJvcGUvTW9zY293J10sXG4gICAgICAgICAgICAgICdBc2lhL0RoYWthJzogICAgICAgICAgIFsnQXNpYS9ZZWthdGVyaW5idXJnJ10sXG4gICAgICAgICAgICAgICdBc2lhL0pha2FydGEnOiAgICAgICAgIFsnQXNpYS9PbXNrJ10sXG4gICAgICAgICAgICAgICdBc2lhL1NoYW5naGFpJzogICAgICAgIFsnQXNpYS9LcmFzbm95YXJzaycsICdBdXN0cmFsaWEvUGVydGgnXSxcbiAgICAgICAgICAgICAgJ0FzaWEvVG9reW8nOiAgICAgICAgICAgWydBc2lhL0lya3V0c2snXSxcbiAgICAgICAgICAgICAgJ0F1c3RyYWxpYS9CcmlzYmFuZSc6ICAgWydBc2lhL1lha3V0c2snXSxcbiAgICAgICAgICAgICAgJ1BhY2lmaWMvTm91bWVhJzogICAgICAgWydBc2lhL1ZsYWRpdm9zdG9rJ10sXG4gICAgICAgICAgICAgICdQYWNpZmljL1RhcmF3YSc6ICAgICAgIFsnQXNpYS9LYW1jaGF0a2EnLCAnUGFjaWZpYy9GaWppJ10sXG4gICAgICAgICAgICAgICdQYWNpZmljL1RvbmdhdGFwdSc6ICAgIFsnUGFjaWZpYy9BcGlhJ10sXG4gICAgICAgICAgICAgICdBc2lhL0JhZ2hkYWQnOiAgICAgICAgIFsnRXVyb3BlL01pbnNrJ10sXG4gICAgICAgICAgICAgICdBc2lhL0Jha3UnOiAgICAgICAgICAgIFsnQXNpYS9ZZXJldmFuJywnQXNpYS9CYWt1J10sXG4gICAgICAgICAgICAgICdBZnJpY2EvSm9oYW5uZXNidXJnJzogIFsnQXNpYS9HYXphJywgJ0FmcmljYS9DYWlybyddXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHRpbWV6b25lX25hbWUgPSB0el9uYW1lLFxuICAgICAgICAgIFxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIENoZWNrcyBpZiBhIHRpbWV6b25lIGhhcyBwb3NzaWJsZSBhbWJpZ3VpdGllcy4gSS5lIHRpbWV6b25lcyB0aGF0IGFyZSBzaW1pbGFyLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogRm9yIGV4YW1wbGUsIGlmIHRoZSBwcmVsaW1pbmFyeSBzY2FuIGRldGVybWluZXMgdGhhdCB3ZSdyZSBpbiBBbWVyaWNhL0RlbnZlci5cbiAgICAgICAgICAgKiBXZSBkb3VibGUgY2hlY2sgaGVyZSB0aGF0IHdlJ3JlIHJlYWxseSB0aGVyZSBhbmQgbm90IGluIEFtZXJpY2EvTWF6YXRsYW4uXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBUaGlzIGlzIGRvbmUgYnkgY2hlY2tpbmcga25vd24gZGF0ZXMgZm9yIHdoZW4gZGF5bGlnaHQgc2F2aW5ncyBzdGFydCBmb3IgZGlmZmVyZW50XG4gICAgICAgICAgICogdGltZXpvbmVzIGR1cmluZyAyMDEwIGFuZCAyMDExLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGFtYmlndWl0eV9jaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIGFtYmlndWl0eV9saXN0ID0gQU1CSUdVSVRJRVNbdGltZXpvbmVfbmFtZV0sXG4gICAgICAgICAgICAgICAgICBsZW5ndGggPSBhbWJpZ3VpdHlfbGlzdC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICAgIHR6ID0gYW1iaWd1aXR5X2xpc3RbMF07XG5cbiAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgdHogPSBhbWJpZ3VpdHlfbGlzdFtpXTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGpzdHouZGF0ZV9pc19kc3QoanN0ei5kc3Rfc3RhcnRfZm9yKHR6KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aW1lem9uZV9uYW1lID0gdHo7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIENoZWNrcyBpZiBpdCBpcyBwb3NzaWJsZSB0aGF0IHRoZSB0aW1lem9uZSBpcyBhbWJpZ3VvdXMuXG4gICAgICAgICAgICovXG4gICAgICAgICAgaXNfYW1iaWd1b3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIChBTUJJR1VJVElFU1t0aW1lem9uZV9uYW1lXSkgIT09ICd1bmRlZmluZWQnO1xuICAgICAgICAgIH07XG5cbiAgICAgIGlmIChpc19hbWJpZ3VvdXMoKSkge1xuICAgICAgICAgIGFtYmlndWl0eV9jaGVjaygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRpbWV6b25lX25hbWU7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgfTtcblxuICBqc3R6Lm9sc29uID0ge307XG5cbiAgLypcbiAgICogVGhlIGtleXMgaW4gdGhpcyBkaWN0aW9uYXJ5IGFyZSBjb21tYSBzZXBhcmF0ZWQgYXMgc3VjaDpcbiAgICpcbiAgICogRmlyc3QgdGhlIG9mZnNldCBjb21wYXJlZCB0byBVVEMgdGltZSBpbiBtaW51dGVzLlxuICAgKlxuICAgKiBUaGVuIGEgZmxhZyB3aGljaCBpcyAwIGlmIHRoZSB0aW1lem9uZSBkb2VzIG5vdCB0YWtlIGRheWxpZ2h0IHNhdmluZ3MgaW50byBhY2NvdW50IGFuZCAxIGlmIGl0XG4gICAqIGRvZXMuXG4gICAqXG4gICAqIFRoaXJkbHkgYW4gb3B0aW9uYWwgJ3MnIHNpZ25pZmllcyB0aGF0IHRoZSB0aW1lem9uZSBpcyBpbiB0aGUgc291dGhlcm4gaGVtaXNwaGVyZSxcbiAgICogb25seSBpbnRlcmVzdGluZyBmb3IgdGltZXpvbmVzIHdpdGggRFNULlxuICAgKlxuICAgKiBUaGUgbWFwcGVkIGFycmF5cyBpcyB1c2VkIGZvciBjb25zdHJ1Y3RpbmcgdGhlIGpzdHouVGltZVpvbmUgb2JqZWN0IGZyb20gd2l0aGluXG4gICAqIGpzdHouZGV0ZXJtaW5lX3RpbWV6b25lKCk7XG4gICAqL1xuICBqc3R6Lm9sc29uLnRpbWV6b25lcyA9IHtcbiAgICAgICctNzIwLDAnICAgOiAnUGFjaWZpYy9NYWp1cm8nLFxuICAgICAgJy02NjAsMCcgICA6ICdQYWNpZmljL1BhZ29fUGFnbycsXG4gICAgICAnLTYwMCwxJyAgIDogJ0FtZXJpY2EvQWRhaycsXG4gICAgICAnLTYwMCwwJyAgIDogJ1BhY2lmaWMvSG9ub2x1bHUnLFxuICAgICAgJy01NzAsMCcgICA6ICdQYWNpZmljL01hcnF1ZXNhcycsXG4gICAgICAnLTU0MCwwJyAgIDogJ1BhY2lmaWMvR2FtYmllcicsXG4gICAgICAnLTU0MCwxJyAgIDogJ0FtZXJpY2EvQW5jaG9yYWdlJyxcbiAgICAgICctNDgwLDEnICAgOiAnQW1lcmljYS9Mb3NfQW5nZWxlcycsXG4gICAgICAnLTQ4MCwwJyAgIDogJ1BhY2lmaWMvUGl0Y2Fpcm4nLFxuICAgICAgJy00MjAsMCcgICA6ICdBbWVyaWNhL1Bob2VuaXgnLFxuICAgICAgJy00MjAsMScgICA6ICdBbWVyaWNhL0RlbnZlcicsXG4gICAgICAnLTM2MCwwJyAgIDogJ0FtZXJpY2EvR3VhdGVtYWxhJyxcbiAgICAgICctMzYwLDEnICAgOiAnQW1lcmljYS9DaGljYWdvJyxcbiAgICAgICctMzYwLDEscycgOiAnUGFjaWZpYy9FYXN0ZXInLFxuICAgICAgJy0zMDAsMCcgICA6ICdBbWVyaWNhL0JvZ290YScsXG4gICAgICAnLTMwMCwxJyAgIDogJ0FtZXJpY2EvTmV3X1lvcmsnLFxuICAgICAgJy0yNzAsMCcgICA6ICdBbWVyaWNhL0NhcmFjYXMnLFxuICAgICAgJy0yNDAsMScgICA6ICdBbWVyaWNhL0hhbGlmYXgnLFxuICAgICAgJy0yNDAsMCcgICA6ICdBbWVyaWNhL1NhbnRvX0RvbWluZ28nLFxuICAgICAgJy0yNDAsMSxzJyA6ICdBbWVyaWNhL1NhbnRpYWdvJyxcbiAgICAgICctMjEwLDEnICAgOiAnQW1lcmljYS9TdF9Kb2hucycsXG4gICAgICAnLTE4MCwxJyAgIDogJ0FtZXJpY2EvR29kdGhhYicsXG4gICAgICAnLTE4MCwwJyAgIDogJ0FtZXJpY2EvQXJnZW50aW5hL0J1ZW5vc19BaXJlcycsXG4gICAgICAnLTE4MCwxLHMnIDogJ0FtZXJpY2EvTW9udGV2aWRlbycsXG4gICAgICAnLTEyMCwwJyAgIDogJ0FtZXJpY2EvTm9yb25oYScsXG4gICAgICAnLTEyMCwxJyAgIDogJ0FtZXJpY2EvTm9yb25oYScsXG4gICAgICAnLTYwLDEnICAgIDogJ0F0bGFudGljL0F6b3JlcycsXG4gICAgICAnLTYwLDAnICAgIDogJ0F0bGFudGljL0NhcGVfVmVyZGUnLFxuICAgICAgJzAsMCcgICAgICA6ICdVVEMnLFxuICAgICAgJzAsMScgICAgICA6ICdFdXJvcGUvTG9uZG9uJyxcbiAgICAgICc2MCwxJyAgICAgOiAnRXVyb3BlL0JlcmxpbicsXG4gICAgICAnNjAsMCcgICAgIDogJ0FmcmljYS9MYWdvcycsXG4gICAgICAnNjAsMSxzJyAgIDogJ0FmcmljYS9XaW5kaG9laycsXG4gICAgICAnMTIwLDEnICAgIDogJ0FzaWEvQmVpcnV0JyxcbiAgICAgICcxMjAsMCcgICAgOiAnQWZyaWNhL0pvaGFubmVzYnVyZycsXG4gICAgICAnMTgwLDAnICAgIDogJ0FzaWEvQmFnaGRhZCcsXG4gICAgICAnMTgwLDEnICAgIDogJ0V1cm9wZS9Nb3Njb3cnLFxuICAgICAgJzIxMCwxJyAgICA6ICdBc2lhL1RlaHJhbicsXG4gICAgICAnMjQwLDAnICAgIDogJ0FzaWEvRHViYWknLFxuICAgICAgJzI0MCwxJyAgICA6ICdBc2lhL0Jha3UnLFxuICAgICAgJzI3MCwwJyAgICA6ICdBc2lhL0thYnVsJyxcbiAgICAgICczMDAsMScgICAgOiAnQXNpYS9ZZWthdGVyaW5idXJnJyxcbiAgICAgICczMDAsMCcgICAgOiAnQXNpYS9LYXJhY2hpJyxcbiAgICAgICczMzAsMCcgICAgOiAnQXNpYS9Lb2xrYXRhJyxcbiAgICAgICczNDUsMCcgICAgOiAnQXNpYS9LYXRobWFuZHUnLFxuICAgICAgJzM2MCwwJyAgICA6ICdBc2lhL0RoYWthJyxcbiAgICAgICczNjAsMScgICAgOiAnQXNpYS9PbXNrJyxcbiAgICAgICczOTAsMCcgICAgOiAnQXNpYS9SYW5nb29uJyxcbiAgICAgICc0MjAsMScgICAgOiAnQXNpYS9LcmFzbm95YXJzaycsXG4gICAgICAnNDIwLDAnICAgIDogJ0FzaWEvSmFrYXJ0YScsXG4gICAgICAnNDgwLDAnICAgIDogJ0FzaWEvU2hhbmdoYWknLFxuICAgICAgJzQ4MCwxJyAgICA6ICdBc2lhL0lya3V0c2snLFxuICAgICAgJzUyNSwwJyAgICA6ICdBdXN0cmFsaWEvRXVjbGEnLFxuICAgICAgJzUyNSwxLHMnICA6ICdBdXN0cmFsaWEvRXVjbGEnLFxuICAgICAgJzU0MCwxJyAgICA6ICdBc2lhL1lha3V0c2snLFxuICAgICAgJzU0MCwwJyAgICA6ICdBc2lhL1Rva3lvJyxcbiAgICAgICc1NzAsMCcgICAgOiAnQXVzdHJhbGlhL0RhcndpbicsXG4gICAgICAnNTcwLDEscycgIDogJ0F1c3RyYWxpYS9BZGVsYWlkZScsXG4gICAgICAnNjAwLDAnICAgIDogJ0F1c3RyYWxpYS9CcmlzYmFuZScsXG4gICAgICAnNjAwLDEnICAgIDogJ0FzaWEvVmxhZGl2b3N0b2snLFxuICAgICAgJzYwMCwxLHMnICA6ICdBdXN0cmFsaWEvU3lkbmV5JyxcbiAgICAgICc2MzAsMSxzJyAgOiAnQXVzdHJhbGlhL0xvcmRfSG93ZScsXG4gICAgICAnNjYwLDEnICAgIDogJ0FzaWEvS2FtY2hhdGthJyxcbiAgICAgICc2NjAsMCcgICAgOiAnUGFjaWZpYy9Ob3VtZWEnLFxuICAgICAgJzY5MCwwJyAgICA6ICdQYWNpZmljL05vcmZvbGsnLFxuICAgICAgJzcyMCwxLHMnICA6ICdQYWNpZmljL0F1Y2tsYW5kJyxcbiAgICAgICc3MjAsMCcgICAgOiAnUGFjaWZpYy9UYXJhd2EnLFxuICAgICAgJzc2NSwxLHMnICA6ICdQYWNpZmljL0NoYXRoYW0nLFxuICAgICAgJzc4MCwwJyAgICA6ICdQYWNpZmljL1RvbmdhdGFwdScsXG4gICAgICAnNzgwLDEscycgIDogJ1BhY2lmaWMvQXBpYScsXG4gICAgICAnODQwLDAnICAgIDogJ1BhY2lmaWMvS2lyaXRpbWF0aSdcbiAgfTtcblxuICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZXhwb3J0cy5qc3R6ID0ganN0ejtcbiAgfSBlbHNlIHtcbiAgICByb290LmpzdHogPSBqc3R6O1xuICB9XG59KSh0aGlzKTtcblxuIiwiLy8gTWluZ28uanMgMC40LjBcclxuLy8gQ29weXJpZ2h0IChjKSAyMDE1IEZyYW5jaXMgQXNhbnRlIDxrb2ZyYXNhQGdtYWlsLmNvbT5cclxuLy8gTUlUXHJcblxyXG4oZnVuY3Rpb24gKHJvb3QsIHVuZGVmaW5lZCkge1xyXG5cclxuICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgLy8gZ2xvYmFsIG9uIHRoZSBzZXJ2ZXIsIHdpbmRvdyBpbiB0aGUgYnJvd3NlclxyXG4gIHZhciBNaW5nbyA9IHt9LCBwcmV2aW91c01pbmdvO1xyXG4gIHZhciBfO1xyXG5cclxuICAvLyBiYWNrdXAgcHJldmlvdXMgTWluZ29cclxuICBpZiAocm9vdCAhPSBudWxsKSB7XHJcbiAgICBwcmV2aW91c01pbmdvID0gcm9vdC5NaW5nbztcclxuICB9XHJcblxyXG4gIE1pbmdvLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByb290Lk1pbmdvID0gcHJldmlvdXNNaW5nbztcclxuICAgIHJldHVybiBNaW5nbztcclxuICB9O1xyXG5cclxuICB2YXIgbmF0aXZlU2NyaXB0RW5hYmxlZCA9IEJvb2xlYW4oKCh0eXBlb2YgYW5kcm9pZCAhPT0gJ3VuZGVmaW5lZCcgJiYgYW5kcm9pZCAmJiBhbmRyb2lkLndpZGdldCAmJiBhbmRyb2lkLndpZGdldC5CdXR0b24pXHJcbiAgfHwgKHR5cGVvZiBVSUJ1dHRvbiAhPT0gJ3VuZGVmaW5lZCcgJiYgVUlCdXR0b24pKSk7XHJcblxyXG4gIHZhciBub2RlRW5hYmxlZCA9ICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGV4cG9ydHMgJiYgJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiByZXF1aXJlICYmICd1bmRlZmluZWQnID09PSB0eXBlb2Ygd2luZG93ICYmICFuYXRpdmVTY3JpcHRFbmFibGVkKTtcclxuXHJcbiAgdmFyIGJyb3dzZXJpZnlFbmFibGVkID0gJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBleHBvcnRzICYmICd1bmRlZmluZWQnICE9PSB0eXBlb2YgcmVxdWlyZTtcclxuXHJcbiAgLy8gRXhwb3J0IHRoZSBNaW5nbyBvYmplY3QgZm9yIE5vZGUuanNcclxuICBpZiAobm9kZUVuYWJsZWQgfHwgbmF0aXZlU2NyaXB0RW5hYmxlZCB8fCBicm93c2VyaWZ5RW5hYmxlZCkge1xyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IE1pbmdvO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZXhwb3J0cyA9IE1pbmdvO1xyXG4gICAgfVxyXG4gICAgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpOyAvLyBnZXQgYSByZWZlcmVuY2UgdG8gdW5kZXJzY29yZVxyXG4gIH0gZWxzZSB7XHJcbiAgICByb290Lk1pbmdvID0gTWluZ287XHJcbiAgICBfID0gcm9vdC5fOyAvLyBnZXQgYSByZWZlcmVuY2UgdG8gdW5kZXJzY29yZVxyXG4gIH1cclxuXHJcbiAgLy8gcXVpY2sgcmVmZXJlbmNlIGZvclxyXG4gIHZhciBwcmltaXRpdmVzID0gW1xyXG4gICAgXy5pc1N0cmluZywgXy5pc0Jvb2xlYW4sIF8uaXNOdW1iZXIsIF8uaXNEYXRlLCBfLmlzTnVsbCwgXy5pc1JlZ0V4cFxyXG4gIF07XHJcblxyXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZShleHByKSB7XHJcbiAgICAvLyBub3JtYWxpemVkIHByaW1pdGl2ZXNcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJpbWl0aXZlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAocHJpbWl0aXZlc1tpXShleHByKSkge1xyXG4gICAgICAgIGlmIChfLmlzUmVnRXhwKGV4cHIpKSB7XHJcbiAgICAgICAgICByZXR1cm4ge1wiJHJlZ2V4XCI6IGV4cHJ9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4ge1wiJGVxXCI6IGV4cHJ9O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gbm9ybWFsaXplIG9iamVjdCBleHByZXNzaW9uXHJcbiAgICBpZiAoXy5pc09iamVjdChleHByKSkge1xyXG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhleHByKTtcclxuICAgICAgdmFyIG5vdFF1ZXJ5ID0gXy5pbnRlcnNlY3Rpb24oT3BzLnF1ZXJ5T3BlcmF0b3JzLCBrZXlzKS5sZW5ndGggPT09IDA7XHJcblxyXG4gICAgICAvLyBubyB2YWxpZCBxdWVyeSBvcGVyYXRvciBmb3VuZCwgc28gd2UgZG8gc2ltcGxlIGNvbXBhcmlzb25cclxuICAgICAgaWYgKG5vdFF1ZXJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIHtcIiRlcVwiOiBleHByfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gZW5zdXJlIHZhbGlkIHJlZ2V4XHJcbiAgICAgIGlmIChfLmNvbnRhaW5zKGtleXMsIFwiJHJlZ2V4XCIpKSB7XHJcbiAgICAgICAgdmFyIHJlZ2V4ID0gZXhwclsnJHJlZ2V4J107XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBleHByWyckb3B0aW9ucyddIHx8IFwiXCI7XHJcbiAgICAgICAgdmFyIG1vZGlmaWVycyA9IFwiXCI7XHJcbiAgICAgICAgaWYgKF8uaXNTdHJpbmcocmVnZXgpKSB7XHJcbiAgICAgICAgICBtb2RpZmllcnMgKz0gKHJlZ2V4Lmlnbm9yZUNhc2UgfHwgb3B0aW9ucy5pbmRleE9mKFwiaVwiKSA+PSAwKSA/IFwiaVwiIDogXCJcIjtcclxuICAgICAgICAgIG1vZGlmaWVycyArPSAocmVnZXgubXVsdGlsaW5lIHx8IG9wdGlvbnMuaW5kZXhPZihcIm1cIikgPj0gMCkgPyBcIm1cIiA6IFwiXCI7XHJcbiAgICAgICAgICBtb2RpZmllcnMgKz0gKHJlZ2V4Lmdsb2JhbCB8fCBvcHRpb25zLmluZGV4T2YoXCJnXCIpID49IDApID8gXCJnXCIgOiBcIlwiO1xyXG4gICAgICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4LCBtb2RpZmllcnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBleHByWyckcmVnZXgnXSA9IHJlZ2V4O1xyXG4gICAgICAgIGRlbGV0ZSBleHByWyckb3B0aW9ucyddO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGV4cHI7XHJcbiAgfVxyXG5cclxuICAvLyBTZXR0aW5ncyB1c2VkIGJ5IE1pbmdvIGludGVybmFsbHlcclxuICB2YXIgc2V0dGluZ3MgPSB7XHJcbiAgICBrZXk6IFwiX2lkXCJcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBTZXR1cCBkZWZhdWx0IHNldHRpbmdzIGZvciBNaW5nb1xyXG4gICAqIEBwYXJhbSBvcHRpb25zXHJcbiAgICovXHJcbiAgTWluZ28uc2V0dXAgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgXy5leHRlbmQoc2V0dGluZ3MsIG9wdGlvbnMgfHwge30pO1xyXG4gIH07XHJcblxyXG5cclxuICAvKipcclxuICAgKiBRdWVyeSBvYmplY3QgdG8gdGVzdCBjb2xsZWN0aW9uIGVsZW1lbnRzIHdpdGhcclxuICAgKiBAcGFyYW0gY3JpdGVyaWEgdGhlIHBhc3MgY3JpdGVyaWEgZm9yIHRoZSBxdWVyeVxyXG4gICAqIEBwYXJhbSBwcm9qZWN0aW9uIG9wdGlvbmFsIHByb2plY3Rpb24gc3BlY2lmaWVyc1xyXG4gICAqIEBjb25zdHJ1Y3RvclxyXG4gICAqL1xyXG4gIE1pbmdvLlF1ZXJ5ID0gZnVuY3Rpb24gKGNyaXRlcmlhLCBwcm9qZWN0aW9uKSB7XHJcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWluZ28uUXVlcnkpKVxyXG4gICAgICByZXR1cm4gbmV3IE1pbmdvLlF1ZXJ5KGNyaXRlcmlhLCBwcm9qZWN0aW9uKTtcclxuXHJcbiAgICB0aGlzLl9jcml0ZXJpYSA9IGNyaXRlcmlhO1xyXG4gICAgdGhpcy5fcHJvamVjdGlvbiA9IHByb2plY3Rpb247XHJcbiAgICB0aGlzLl9jb21waWxlZCA9IFtdO1xyXG4gICAgdGhpcy5fY29tcGlsZSgpO1xyXG4gIH07XHJcblxyXG4gIE1pbmdvLlF1ZXJ5LnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBfY29tcGlsZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgaWYgKF8uaXNFbXB0eSh0aGlzLl9jcml0ZXJpYSkpIHJldHVybjtcclxuXHJcbiAgICAgIGlmIChfLmlzQXJyYXkodGhpcy5fY3JpdGVyaWEpIHx8IF8uaXNGdW5jdGlvbih0aGlzLl9jcml0ZXJpYSkgfHwgIV8uaXNPYmplY3QodGhpcy5fY3JpdGVyaWEpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0eXBlIGZvciBjcml0ZXJpYVwiKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yICh2YXIgZmllbGQgaW4gdGhpcy5fY3JpdGVyaWEpIHtcclxuICAgICAgICBpZiAodGhpcy5fY3JpdGVyaWEuaGFzT3duUHJvcGVydHkoZmllbGQpKSB7XHJcbiAgICAgICAgICB2YXIgZXhwciA9IHRoaXMuX2NyaXRlcmlhW2ZpZWxkXTtcclxuICAgICAgICAgIGlmIChfLmNvbnRhaW5zKFsnJGFuZCcsICckb3InLCAnJG5vcicsICckd2hlcmUnXSwgZmllbGQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NPcGVyYXRvcihmaWVsZCwgZmllbGQsIGV4cHIpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gbm9ybWFsaXplIGV4cHJlc3Npb25cclxuICAgICAgICAgICAgZXhwciA9IG5vcm1hbGl6ZShleHByKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgb3AgaW4gZXhwcikge1xyXG4gICAgICAgICAgICAgIGlmIChleHByLmhhc093blByb3BlcnR5KG9wKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc09wZXJhdG9yKGZpZWxkLCBvcCwgZXhwcltvcF0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBfcHJvY2Vzc09wZXJhdG9yOiBmdW5jdGlvbiAoZmllbGQsIG9wZXJhdG9yLCB2YWx1ZSkge1xyXG4gICAgICB2YXIgY29tcGlsZWRTZWxlY3RvcjtcclxuICAgICAgaWYgKF8uY29udGFpbnMoT3BzLnNpbXBsZU9wZXJhdG9ycywgb3BlcmF0b3IpKSB7XHJcbiAgICAgICAgY29tcGlsZWRTZWxlY3RvciA9IHtcclxuICAgICAgICAgIHRlc3Q6IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgdmFyIGFjdHVhbFZhbHVlID0gcmVzb2x2ZShvYmosIGZpZWxkKTtcclxuICAgICAgICAgICAgLy8gdmFsdWUgb2Ygb3BlcmF0b3IgbXVzdCBhbHJlYWR5IGJlIGZ1bGx5IHJlc29sdmVkLlxyXG4gICAgICAgICAgICByZXR1cm4gc2ltcGxlT3BlcmF0b3JzW29wZXJhdG9yXShhY3R1YWxWYWx1ZSwgdmFsdWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgIH0gZWxzZSBpZiAoXy5jb250YWlucyhPcHMuY29tcG91bmRPcGVyYXRvcnMsIG9wZXJhdG9yKSkge1xyXG4gICAgICAgIGNvbXBpbGVkU2VsZWN0b3IgPSBjb21wb3VuZE9wZXJhdG9yc1tvcGVyYXRvcl0oZmllbGQsIHZhbHVlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHF1ZXJ5IG9wZXJhdG9yICdcIiArIG9wZXJhdG9yICsgXCInIGRldGVjdGVkXCIpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2NvbXBpbGVkLnB1c2goY29tcGlsZWRTZWxlY3Rvcik7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIHRoZSBvYmplY3QgcGFzc2VzIHRoZSBxdWVyeSBjcml0ZXJpYS4gUmV0dXJucyB0cnVlIGlmIHNvLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKiBAcGFyYW0gb2JqXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGVzdDogZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NvbXBpbGVkLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9jb21waWxlZFtpXS50ZXN0KG9iaikpIHtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGVyZm9ybXMgYSBxdWVyeSBvbiBhIGNvbGxlY3Rpb24gYW5kIHJldHVybnMgYSBjdXJzb3Igb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25cclxuICAgICAqIEBwYXJhbSBwcm9qZWN0aW9uXHJcbiAgICAgKiBAcmV0dXJucyB7TWluZ28uQ3Vyc29yfVxyXG4gICAgICovXHJcbiAgICBmaW5kOiBmdW5jdGlvbiAoY29sbGVjdGlvbiwgcHJvamVjdGlvbikge1xyXG4gICAgICByZXR1cm4gbmV3IE1pbmdvLkN1cnNvcihjb2xsZWN0aW9uLCB0aGlzLCBwcm9qZWN0aW9uKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgbWF0Y2hlZCBkb2N1bWVudHMgZnJvbSB0aGUgY29sbGVjdGlvbiByZXR1cm5pbmcgdGhlIHJlbWFpbmRlclxyXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoY29sbGVjdGlvbikge1xyXG4gICAgICB2YXIgYXJyID0gW107XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sbGVjdGlvbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmICghdGhpcy50ZXN0KGNvbGxlY3Rpb25baV0pKSB7XHJcbiAgICAgICAgICBhcnIucHVzaChjb2xsZWN0aW9uW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGFycjtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBpZiAobm9kZUVuYWJsZWQpIHtcclxuXHJcbiAgICB2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnc3RyZWFtJykuVHJhbnNmb3JtO1xyXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XHJcblxyXG4gICAgTWluZ28uUXVlcnkucHJvdG90eXBlLnN0cmVhbSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgIHJldHVybiBuZXcgTWluZ28uU3RyZWFtKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIFRyYW5zZm9ybSBjbGFzc1xyXG4gICAgICogQHBhcmFtIHF1ZXJ5XHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xyXG4gICAgICogQHJldHVybnMge01pbmdvLlN0cmVhbX1cclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICBNaW5nby5TdHJlYW0gPSBmdW5jdGlvbiAocXVlcnksIG9wdGlvbnMpIHtcclxuXHJcbiAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNaW5nby5TdHJlYW0pKVxyXG4gICAgICAgIHJldHVybiBuZXcgTWluZ28uU3RyZWFtKHF1ZXJ5LCBvcHRpb25zKTtcclxuXHJcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICBfLmV4dGVuZChvcHRpb25zLCB7b2JqZWN0TW9kZTogdHJ1ZX0pO1xyXG4gICAgICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuICAgICAgLy8gcXVlcnkgZm9yIHRoaXMgc3RyZWFtXHJcbiAgICAgIHRoaXMuX3F1ZXJ5ID0gcXVlcnk7XHJcbiAgICB9O1xyXG4gICAgLy8gZXh0ZW5kIFRyYW5zZm9ybVxyXG4gICAgdXRpbC5pbmhlcml0cyhNaW5nby5TdHJlYW0sIFRyYW5zZm9ybSk7XHJcblxyXG4gICAgTWluZ28uU3RyZWFtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgZG9uZSkge1xyXG4gICAgICBpZiAoXy5pc09iamVjdChjaHVuaykgJiYgdGhpcy5fcXVlcnkudGVzdChjaHVuaykpIHtcclxuICAgICAgICBpZiAoXy5pc0VtcHR5KHRoaXMuX3F1ZXJ5Ll9wcm9qZWN0aW9uKSkge1xyXG4gICAgICAgICAgdGhpcy5wdXNoKGNodW5rKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdmFyIGN1cnNvciA9IG5ldyBNaW5nby5DdXJzb3IoW2NodW5rXSwgdGhpcy5fcXVlcnkpO1xyXG4gICAgICAgICAgaWYgKGN1cnNvci5oYXNOZXh0KCkpIHtcclxuICAgICAgICAgICAgdGhpcy5wdXNoKGN1cnNvci5uZXh0KCkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBkb25lKCk7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3Vyc29yIHRvIGl0ZXJhdGUgYW5kIHBlcmZvcm0gZmlsdGVyaW5nIG9uIG1hdGNoZWQgb2JqZWN0c1xyXG4gICAqIEBwYXJhbSBjb2xsZWN0aW9uXHJcbiAgICogQHBhcmFtIHF1ZXJ5XHJcbiAgICogQHBhcmFtIHByb2plY3Rpb25cclxuICAgKiBAY29uc3RydWN0b3JcclxuICAgKi9cclxuICBNaW5nby5DdXJzb3IgPSBmdW5jdGlvbiAoY29sbGVjdGlvbiwgcXVlcnksIHByb2plY3Rpb24pIHtcclxuXHJcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWluZ28uQ3Vyc29yKSlcclxuICAgICAgcmV0dXJuIG5ldyBNaW5nby5DdXJzb3IoY29sbGVjdGlvbiwgcXVlcnksIHByb2plY3Rpb24pO1xyXG5cclxuICAgIHRoaXMuX3F1ZXJ5ID0gcXVlcnk7XHJcbiAgICB0aGlzLl9jb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcclxuICAgIHRoaXMuX3Byb2plY3Rpb24gPSBwcm9qZWN0aW9uIHx8IHF1ZXJ5Ll9wcm9qZWN0aW9uO1xyXG4gICAgdGhpcy5fb3BlcmF0b3JzID0ge307XHJcbiAgICB0aGlzLl9yZXN1bHQgPSBmYWxzZTtcclxuICAgIHRoaXMuX3Bvc2l0aW9uID0gMDtcclxuICB9O1xyXG5cclxuICBNaW5nby5DdXJzb3IucHJvdG90eXBlID0ge1xyXG5cclxuICAgIF9mZXRjaDogZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAodGhpcy5fcmVzdWx0ICE9PSBmYWxzZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yZXN1bHQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGluamVjdCBwcm9qZWN0aW9uIG9wZXJhdG9yXHJcbiAgICAgIGlmIChfLmlzT2JqZWN0KHRoaXMuX3Byb2plY3Rpb24pKSB7XHJcbiAgICAgICAgXy5leHRlbmQodGhpcy5fb3BlcmF0b3JzLCB7XCIkcHJvamVjdFwiOiB0aGlzLl9wcm9qZWN0aW9ufSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghXy5pc0FycmF5KHRoaXMuX2NvbGxlY3Rpb24pICYmICFfLmlzT2JqZWN0KHRoaXMuX2NvbGxlY3Rpb24pKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgY29sbGVjdGlvbiBpcyBub3Qgb2YgdmFsaWQgdHlwZS4gTXVzdCBiZSBhbiBBcnJheS5cIik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGZpbHRlciBjb2xsZWN0aW9uXHJcbiAgICAgIHRoaXMuX3Jlc3VsdCA9IF8uZmlsdGVyKHRoaXMuX2NvbGxlY3Rpb24sIHRoaXMuX3F1ZXJ5LnRlc3QsIHRoaXMuX3F1ZXJ5KTtcclxuICAgICAgdmFyIHBpcGVsaW5lID0gW107XHJcblxyXG4gICAgICBfLmVhY2goWyckc29ydCcsICckc2tpcCcsICckbGltaXQnLCAnJHByb2plY3QnXSwgZnVuY3Rpb24gKG9wKSB7XHJcbiAgICAgICAgaWYgKF8uaGFzKHNlbGYuX29wZXJhdG9ycywgb3ApKSB7XHJcbiAgICAgICAgICBwaXBlbGluZS5wdXNoKF8ucGljayhzZWxmLl9vcGVyYXRvcnMsIG9wKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmIChwaXBlbGluZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdmFyIGFnZ3JlZ2F0b3IgPSBuZXcgTWluZ28uQWdncmVnYXRvcihwaXBlbGluZSk7XHJcbiAgICAgICAgdGhpcy5fcmVzdWx0ID0gYWdncmVnYXRvci5ydW4odGhpcy5fcmVzdWx0LCB0aGlzLl9xdWVyeSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMuX3Jlc3VsdDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGZXRjaCBhbmQgcmV0dXJuIGFsbCBtYXRjaGVkIHJlc3VsdHNcclxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgYWxsOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9mZXRjaCgpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZldGNoIGFuZCByZXR1cm4gdGhlIGZpcnN0IG1hdGNoaW5nIHJlc3VsdFxyXG4gICAgICogQHJldHVybnMge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgZmlyc3Q6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY291bnQoKSA+IDAgPyB0aGlzLl9mZXRjaCgpWzBdIDogbnVsbDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGZXRjaCBhbmQgcmV0dXJuIHRoZSBsYXN0IG1hdGNoaW5nIG9iamVjdCBmcm9tIHRoZSByZXN1bHRcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIGxhc3Q6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY291bnQoKSA+IDAgPyB0aGlzLl9mZXRjaCgpW3RoaXMuY291bnQoKSAtIDFdIDogbnVsbDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb3VudHMgdGhlIG51bWJlciBvZiBtYXRjaGVkIG9iamVjdHMgZm91bmRcclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGNvdW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9mZXRjaCgpLmxlbmd0aDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgY3Vyc29yIHRoYXQgYmVnaW5zIHJldHVybmluZyByZXN1bHRzIG9ubHkgYWZ0ZXIgcGFzc2luZyBvciBza2lwcGluZyBhIG51bWJlciBvZiBkb2N1bWVudHMuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbiB0aGUgbnVtYmVyIG9mIHJlc3VsdHMgdG8gc2tpcC5cclxuICAgICAqIEByZXR1cm4ge01pbmdvLkN1cnNvcn0gUmV0dXJucyB0aGUgY3Vyc29yLCBzbyB5b3UgY2FuIGNoYWluIHRoaXMgY2FsbC5cclxuICAgICAqL1xyXG4gICAgc2tpcDogZnVuY3Rpb24gKG4pIHtcclxuICAgICAgXy5leHRlbmQodGhpcy5fb3BlcmF0b3JzLCB7XCIkc2tpcFwiOiBufSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cmFpbnMgdGhlIHNpemUgb2YgYSBjdXJzb3IncyByZXN1bHQgc2V0LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG4gdGhlIG51bWJlciBvZiByZXN1bHRzIHRvIGxpbWl0IHRvLlxyXG4gICAgICogQHJldHVybiB7TWluZ28uQ3Vyc29yfSBSZXR1cm5zIHRoZSBjdXJzb3IsIHNvIHlvdSBjYW4gY2hhaW4gdGhpcyBjYWxsLlxyXG4gICAgICovXHJcbiAgICBsaW1pdDogZnVuY3Rpb24gKG4pIHtcclxuICAgICAgXy5leHRlbmQodGhpcy5fb3BlcmF0b3JzLCB7XCIkbGltaXRcIjogbn0pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHJlc3VsdHMgb3JkZXJlZCBhY2NvcmRpbmcgdG8gYSBzb3J0IHNwZWNpZmljYXRpb24uXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW9kaWZpZXIgYW4gb2JqZWN0IG9mIGtleSBhbmQgdmFsdWVzIHNwZWNpZnlpbmcgdGhlIHNvcnQgb3JkZXIuIDEgZm9yIGFzY2VuZGluZyBhbmQgLTEgZm9yIGRlc2NlbmRpbmdcclxuICAgICAqIEByZXR1cm4ge01pbmdvLkN1cnNvcn0gUmV0dXJucyB0aGUgY3Vyc29yLCBzbyB5b3UgY2FuIGNoYWluIHRoaXMgY2FsbC5cclxuICAgICAqL1xyXG4gICAgc29ydDogZnVuY3Rpb24gKG1vZGlmaWVyKSB7XHJcbiAgICAgIF8uZXh0ZW5kKHRoaXMuX29wZXJhdG9ycywge1wiJHNvcnRcIjogbW9kaWZpZXJ9KTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbmV4dCBkb2N1bWVudCBpbiBhIGN1cnNvci5cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3QgfCBCb29sZWFufVxyXG4gICAgICovXHJcbiAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmICh0aGlzLmhhc05leHQoKSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9mZXRjaCgpW3RoaXMuX3Bvc2l0aW9uKytdO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY3Vyc29yIGhhcyBkb2N1bWVudHMgYW5kIGNhbiBiZSBpdGVyYXRlZC5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBoYXNOZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNvdW50KCkgPiB0aGlzLl9wb3NpdGlvbjtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVjaWZpZXMgdGhlIGV4Y2x1c2l2ZSB1cHBlciBib3VuZCBmb3IgYSBzcGVjaWZpYyBmaWVsZFxyXG4gICAgICogQHBhcmFtIGV4cHJcclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIG1heDogZnVuY3Rpb24gKGV4cHIpIHtcclxuICAgICAgcmV0dXJuIGdyb3VwT3BlcmF0b3JzLiRtYXgodGhpcy5fZmV0Y2goKSwgZXhwcik7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3BlY2lmaWVzIHRoZSBpbmNsdXNpdmUgbG93ZXIgYm91bmQgZm9yIGEgc3BlY2lmaWMgZmllbGRcclxuICAgICAqIEBwYXJhbSBleHByXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBtaW46IGZ1bmN0aW9uIChleHByKSB7XHJcbiAgICAgIHJldHVybiBncm91cE9wZXJhdG9ycy4kbWluKHRoaXMuX2ZldGNoKCksIGV4cHIpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgYSBmdW5jdGlvbiB0byBlYWNoIGRvY3VtZW50IGluIGEgY3Vyc29yIGFuZCBjb2xsZWN0cyB0aGUgcmV0dXJuIHZhbHVlcyBpbiBhbiBhcnJheS5cclxuICAgICAqIEBwYXJhbSBjYWxsYmFja1xyXG4gICAgICogQHJldHVybnMge0FycmF5fVxyXG4gICAgICovXHJcbiAgICBtYXA6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICByZXR1cm4gXy5tYXAodGhpcy5fZmV0Y2goKSwgY2FsbGJhY2spO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgYSBKYXZhU2NyaXB0IGZ1bmN0aW9uIGZvciBldmVyeSBkb2N1bWVudCBpbiBhIGN1cnNvci5cclxuICAgICAqIEBwYXJhbSBjYWxsYmFja1xyXG4gICAgICovXHJcbiAgICBmb3JFYWNoOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgXy5lYWNoKHRoaXMuX2ZldGNoKCksIGNhbGxiYWNrKTtcclxuICAgIH1cclxuXHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQWdncmVnYXRvciBmb3IgZGVmaW5pbmcgZmlsdGVyIHVzaW5nIG1vbmdvREIgYWdncmVnYXRpb24gcGlwZWxpbmUgc3ludGF4XHJcbiAgICogQHBhcmFtIG9wZXJhdG9ycyBhbiBBcnJheSBvZiBwaXBlbGluZSBvcGVyYXRvcnNcclxuICAgKiBAY29uc3RydWN0b3JcclxuICAgKi9cclxuICBNaW5nby5BZ2dyZWdhdG9yID0gZnVuY3Rpb24gKG9wZXJhdG9ycykge1xyXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1pbmdvLkFnZ3JlZ2F0b3IpKVxyXG4gICAgICByZXR1cm4gbmV3IE1pbmdvLkFnZ3JlZ2F0b3Iob3BlcmF0b3JzKTtcclxuXHJcbiAgICB0aGlzLl9vcGVyYXRvcnMgPSBvcGVyYXRvcnM7XHJcbiAgfTtcclxuXHJcbiAgTWluZ28uQWdncmVnYXRvci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBseSB0aGUgcGlwZWxpbmUgb3BlcmF0aW9ucyBvdmVyIHRoZSBjb2xsZWN0aW9uIGJ5IG9yZGVyIG9mIHRoZSBzZXF1ZW5jZSBhZGRlZFxyXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb24gYW4gYXJyYXkgb2Ygb2JqZWN0cyB0byBwcm9jZXNzXHJcbiAgICAgKiBAcGFyYW0gcXVlcnkgdGhlIGBNaW5nby5RdWVyeWAgb2JqZWN0IHRvIHVzZSBhcyBjb250ZXh0XHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIHJ1bjogZnVuY3Rpb24gKGNvbGxlY3Rpb24sIHF1ZXJ5KSB7XHJcbiAgICAgIGlmICghXy5pc0VtcHR5KHRoaXMuX29wZXJhdG9ycykpIHtcclxuICAgICAgICAvLyBydW4gYWdncmVnYXRpb24gcGlwZWxpbmVcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX29wZXJhdG9ycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgdmFyIG9wZXJhdG9yID0gdGhpcy5fb3BlcmF0b3JzW2ldO1xyXG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIG9wZXJhdG9yKSB7XHJcbiAgICAgICAgICAgIGlmIChvcGVyYXRvci5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHF1ZXJ5IGluc3RhbmNlb2YgTWluZ28uUXVlcnkpIHtcclxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24gPSBwaXBlbGluZU9wZXJhdG9yc1trZXldLmNhbGwocXVlcnksIGNvbGxlY3Rpb24sIG9wZXJhdG9yW2tleV0pO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uID0gcGlwZWxpbmVPcGVyYXRvcnNba2V5XShjb2xsZWN0aW9uLCBvcGVyYXRvcltrZXldKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0cmlldmUgdGhlIHZhbHVlIG9mIGEgZ2l2ZW4ga2V5IG9uIGFuIG9iamVjdFxyXG4gICAqIEBwYXJhbSBvYmpcclxuICAgKiBAcGFyYW0gZmllbGRcclxuICAgKiBAcmV0dXJucyB7Kn1cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGdldFZhbHVlKG9iaiwgZmllbGQpIHtcclxuICAgIHJldHVybiBfLnJlc3VsdChvYmosIGZpZWxkKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc29sdmUgdGhlIHZhbHVlIG9mIHRoZSBmaWVsZCAoZG90IHNlcGFyYXRlZCkgb24gdGhlIGdpdmVuIG9iamVjdFxyXG4gICAqIEBwYXJhbSBvYmpcclxuICAgKiBAcGFyYW0gZmllbGRcclxuICAgKiBAcmV0dXJucyB7Kn1cclxuICAgKi9cclxuICBmdW5jdGlvbiByZXNvbHZlKG9iaiwgZmllbGQpIHtcclxuICAgIGlmICghZmllbGQpIHtcclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIHZhciBuYW1lcyA9IGZpZWxkLnNwbGl0KFwiLlwiKTtcclxuICAgIHZhciB2YWx1ZSA9IG9iajtcclxuICAgIHZhciBpc1RleHQ7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpc1RleHQgPSBuYW1lc1tpXS5tYXRjaCgvXlxcZCskLykgPT09IG51bGw7XHJcblxyXG4gICAgICBpZiAoaXNUZXh0ICYmIF8uaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICB2YXIgcmVzID0gW107XHJcbiAgICAgICAgXy5lYWNoKHZhbHVlLCBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgaWYgKF8uaXNPYmplY3QoaXRlbSkpIHtcclxuICAgICAgICAgICAgcmVzLnB1c2gocmVzb2x2ZShpdGVtLCBuYW1lc1tpXSkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhbHVlID0gcmVzO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhbHVlID0gZ2V0VmFsdWUodmFsdWUsIG5hbWVzW2ldKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBlcmZvcm1zIGEgcXVlcnkgb24gYSBjb2xsZWN0aW9uIGFuZCByZXR1cm5zIGEgY3Vyc29yIG9iamVjdC5cclxuICAgKiBAcGFyYW0gY29sbGVjdGlvblxyXG4gICAqIEBwYXJhbSBjcml0ZXJpYVxyXG4gICAqIEBwYXJhbSBwcm9qZWN0aW9uXHJcbiAgICogQHJldHVybnMge01pbmdvLkN1cnNvcn1cclxuICAgKi9cclxuICBNaW5nby5maW5kID0gZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGNyaXRlcmlhLCBwcm9qZWN0aW9uKSB7XHJcbiAgICByZXR1cm4gKG5ldyBNaW5nby5RdWVyeShjcml0ZXJpYSkpLmZpbmQoY29sbGVjdGlvbiwgcHJvamVjdGlvbik7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIG5ldyBhcnJheSB3aXRob3V0IG9iamVjdHMgd2hpY2ggbWF0Y2ggdGhlIGNyaXRlcmlhXHJcbiAgICogQHBhcmFtIGNvbGxlY3Rpb25cclxuICAgKiBAcGFyYW0gY3JpdGVyaWFcclxuICAgKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAgICovXHJcbiAgTWluZ28ucmVtb3ZlID0gZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGNyaXRlcmlhKSB7XHJcbiAgICByZXR1cm4gKG5ldyBNaW5nby5RdWVyeShjcml0ZXJpYSkpLnJlbW92ZShjb2xsZWN0aW9uKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gdGhlIHJlc3VsdCBjb2xsZWN0aW9uIGFmdGVyIHJ1bm5pbmcgdGhlIGFnZ3JlZ2F0aW9uIHBpcGVsaW5lIGZvciB0aGUgZ2l2ZW4gY29sbGVjdGlvblxyXG4gICAqIEBwYXJhbSBjb2xsZWN0aW9uXHJcbiAgICogQHBhcmFtIHBpcGVsaW5lXHJcbiAgICogQHJldHVybnMge0FycmF5fVxyXG4gICAqL1xyXG4gIE1pbmdvLmFnZ3JlZ2F0ZSA9IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBwaXBlbGluZSkge1xyXG4gICAgaWYgKCFfLmlzQXJyYXkocGlwZWxpbmUpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFnZ3JlZ2F0aW9uIHBpcGVsaW5lIG11c3QgYmUgYW4gYXJyYXlcIilcclxuICAgIH1cclxuICAgIHJldHVybiAobmV3IE1pbmdvLkFnZ3JlZ2F0b3IocGlwZWxpbmUpKS5ydW4oY29sbGVjdGlvbik7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogTWl4aW4gZm9yIEJhY2tib25lLkNvbGxlY3Rpb24gb2JqZWN0c1xyXG4gICAqL1xyXG4gIE1pbmdvLkNvbGxlY3Rpb25NaXhpbiA9IHtcclxuICAgIC8qKlxyXG4gICAgICogUnVucyBhIHF1ZXJ5IGFuZCByZXR1cm5zIGEgY3Vyc29yIHRvIHRoZSByZXN1bHRcclxuICAgICAqIEBwYXJhbSBjcml0ZXJpYVxyXG4gICAgICogQHBhcmFtIHByb2plY3Rpb25cclxuICAgICAqIEByZXR1cm5zIHtNaW5nby5DdXJzb3J9XHJcbiAgICAgKi9cclxuICAgIHF1ZXJ5OiBmdW5jdGlvbiAoY3JpdGVyaWEsIHByb2plY3Rpb24pIHtcclxuICAgICAgcmV0dXJuIE1pbmdvLmZpbmQodGhpcy50b0pTT04oKSwgY3JpdGVyaWEsIHByb2plY3Rpb24pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJ1bnMgdGhlIGdpdmVuIGFnZ3JlZ2F0aW9uIG9wZXJhdG9ycyBvbiB0aGlzIGNvbGxlY3Rpb25cclxuICAgICAqIEBwYXJhbXMgcGlwZWxpbmVcclxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgYWdncmVnYXRlOiBmdW5jdGlvbiAocGlwZWxpbmUpIHtcclxuICAgICAgdmFyIGFyZ3MgPSBbdGhpcy50b0pTT04oKSwgcGlwZWxpbmVdO1xyXG4gICAgICByZXR1cm4gTWluZ28uYWdncmVnYXRlLmFwcGx5KG51bGwsIGFyZ3MpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHZhciBwaXBlbGluZU9wZXJhdG9ycyA9IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdyb3VwcyBkb2N1bWVudHMgdG9nZXRoZXIgZm9yIHRoZSBwdXJwb3NlIG9mIGNhbGN1bGF0aW5nIGFnZ3JlZ2F0ZSB2YWx1ZXMgYmFzZWQgb24gYSBjb2xsZWN0aW9uIG9mIGRvY3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29sbGVjdGlvblxyXG4gICAgICogQHBhcmFtIGV4cHJcclxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgJGdyb3VwOiBmdW5jdGlvbiAoY29sbGVjdGlvbiwgZXhwcikge1xyXG4gICAgICAvLyBsb29rdXAga2V5IGZvciBncm91cGluZ1xyXG4gICAgICB2YXIgaWRLZXkgPSBleHByW3NldHRpbmdzLmtleV07XHJcbiAgICAgIHZhciBpbmRleGVzID0gW107XHJcbiAgICAgIC8vIGdyb3VwIGNvbGxlY3Rpb24gYnkga2V5XHJcbiAgICAgIHZhciBncm91cHMgPSBfLmdyb3VwQnkoY29sbGVjdGlvbiwgZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgIHZhciBrZXkgPSBjb21wdXRlVmFsdWUob2JqLCBpZEtleSwgaWRLZXkpO1xyXG4gICAgICAgIGluZGV4ZXMucHVzaChrZXkpO1xyXG4gICAgICAgIHJldHVybiBrZXk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gZ3JvdXAgaW5kZXhlc1xyXG4gICAgICBpbmRleGVzID0gXy51bmlxKGluZGV4ZXMpO1xyXG5cclxuICAgICAgLy8gcmVtb3ZlIHRoZSBncm91cCBrZXlcclxuICAgICAgZXhwciA9IF8ub21pdChleHByLCBzZXR0aW5ncy5rZXkpO1xyXG5cclxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICBfLmVhY2goaW5kZXhlcywgZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgdmFyIG9iaiA9IHt9O1xyXG4gICAgICAgIG9ialtzZXR0aW5ncy5rZXldID0gaW5kZXg7XHJcbiAgICAgICAgLy8gY29tcHV0ZSByZW1haW5pbmcga2V5cyBpbiBleHByZXNzaW9uXHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGV4cHIpIHtcclxuICAgICAgICAgIGlmIChleHByLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgb2JqW2tleV0gPSBhY2N1bXVsYXRlKGdyb3Vwc1tpbmRleF0sIGtleSwgZXhwcltrZXldKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0LnB1c2gob2JqKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbHRlcnMgdGhlIGRvY3VtZW50IHN0cmVhbSwgYW5kIG9ubHkgYWxsb3dzIG1hdGNoaW5nIGRvY3VtZW50cyB0byBwYXNzIGludG8gdGhlIG5leHQgcGlwZWxpbmUgc3RhZ2UuXHJcbiAgICAgKiAkbWF0Y2ggdXNlcyBzdGFuZGFyZCBNb25nb0RCIHF1ZXJpZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25cclxuICAgICAqIEBwYXJhbSBleHByXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8Kn1cclxuICAgICAqL1xyXG4gICAgJG1hdGNoOiBmdW5jdGlvbiAoY29sbGVjdGlvbiwgZXhwcikge1xyXG4gICAgICByZXR1cm4gKG5ldyBNaW5nby5RdWVyeShleHByKSkuZmluZChjb2xsZWN0aW9uKS5hbGwoKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNoYXBlcyBhIGRvY3VtZW50IHN0cmVhbS5cclxuICAgICAqICRwcm9qZWN0IGNhbiByZW5hbWUsIGFkZCwgb3IgcmVtb3ZlIGZpZWxkcyBhcyB3ZWxsIGFzIGNyZWF0ZSBjb21wdXRlZCB2YWx1ZXMgYW5kIHN1Yi1kb2N1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25cclxuICAgICAqIEBwYXJhbSBleHByXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgICRwcm9qZWN0OiBmdW5jdGlvbiAoY29sbGVjdGlvbiwgZXhwcikge1xyXG5cclxuICAgICAgaWYgKF8uaXNFbXB0eShleHByKSkge1xyXG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyByZXN1bHQgY29sbGVjdGlvblxyXG4gICAgICB2YXIgcHJvamVjdGVkID0gW107XHJcbiAgICAgIHZhciBvYmpLZXlzID0gXy5rZXlzKGV4cHIpO1xyXG4gICAgICB2YXIgaWRPbmx5RXhjbHVkZWRFeHByZXNzaW9uID0gZmFsc2U7XHJcblxyXG4gICAgICBpZiAoXy5jb250YWlucyhvYmpLZXlzLCBzZXR0aW5ncy5rZXkpKSB7XHJcbiAgICAgICAgdmFyIGlkID0gZXhwcltzZXR0aW5ncy5rZXldO1xyXG4gICAgICAgIGlmIChpZCA9PT0gMCB8fCBpZCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgIG9iaktleXMgPSBfLndpdGhvdXQob2JqS2V5cywgc2V0dGluZ3Mua2V5KTtcclxuICAgICAgICAgIGlmIChfLmlzRW1wdHkob2JqS2V5cykpIHtcclxuICAgICAgICAgICAgaWRPbmx5RXhjbHVkZWRFeHByZXNzaW9uID0gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gaWYgbm90IHNwZWNpZmllZCB0aGUgYWRkIHRoZSBJRCBmaWVsZFxyXG4gICAgICAgIG9iaktleXMucHVzaChzZXR0aW5ncy5rZXkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbGxlY3Rpb24ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgb2JqID0gY29sbGVjdGlvbltpXTtcclxuICAgICAgICB2YXIgY2xvbmVPYmogPSB7fTtcclxuICAgICAgICB2YXIgZm91bmRTbGljZSA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBmb3VuZEV4Y2x1c2lvbiA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBkcm9wS2V5cyA9IFtdO1xyXG4gICAgICAgIGlmIChpZE9ubHlFeGNsdWRlZEV4cHJlc3Npb24pIHtcclxuICAgICAgICAgIGRyb3BLZXlzLnB1c2goc2V0dGluZ3Mua2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXy5lYWNoKG9iaktleXMsIGZ1bmN0aW9uIChrZXkpIHtcclxuXHJcbiAgICAgICAgICB2YXIgc3ViRXhwciA9IGV4cHJba2V5XTtcclxuICAgICAgICAgIHZhciBuZXdWYWx1ZTtcclxuICAgICAgICAgIGlmIChrZXkgIT09IHNldHRpbmdzLmtleSAmJiBzdWJFeHByID09PSAwKSB7XHJcbiAgICAgICAgICAgIGZvdW5kRXhjbHVzaW9uID0gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyB0aW55IG9wdGltaXphdGlvbiBoZXJlIHRvIHNraXAgb3ZlciBpZFxyXG4gICAgICAgICAgaWYgKGtleSA9PT0gc2V0dGluZ3Mua2V5ICYmIF8uaXNFbXB0eShzdWJFeHByKSkge1xyXG4gICAgICAgICAgICBuZXdWYWx1ZSA9IG9ialtrZXldO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKHN1YkV4cHIpKSB7XHJcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gY29tcHV0ZVZhbHVlKG9iaiwgc3ViRXhwciwga2V5KTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoc3ViRXhwciA9PT0gMSB8fCBzdWJFeHByID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gXy5yZXN1bHQob2JqLCBrZXkpO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KHN1YkV4cHIpKSB7XHJcbiAgICAgICAgICAgIHZhciBvcGVyYXRvciA9IF8ua2V5cyhzdWJFeHByKTtcclxuICAgICAgICAgICAgb3BlcmF0b3IgPSBvcGVyYXRvci5sZW5ndGggPiAxID8gZmFsc2UgOiBvcGVyYXRvclswXTtcclxuICAgICAgICAgICAgaWYgKG9wZXJhdG9yICE9PSBmYWxzZSAmJiBfLmNvbnRhaW5zKE9wcy5wcm9qZWN0aW9uT3BlcmF0b3JzLCBvcGVyYXRvcikpIHtcclxuICAgICAgICAgICAgICAvLyBhcHBseSB0aGUgcHJvamVjdGlvbiBvcGVyYXRvciBvbiB0aGUgb3BlcmF0b3IgZXhwcmVzc2lvbiBmb3IgdGhlIGtleVxyXG4gICAgICAgICAgICAgIHZhciB0ZW1wID0gcHJvamVjdGlvbk9wZXJhdG9yc1tvcGVyYXRvcl0ob2JqLCBzdWJFeHByW29wZXJhdG9yXSwga2V5KTtcclxuICAgICAgICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQodGVtcCkpIHtcclxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gdGVtcDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKG9wZXJhdG9yID09ICckc2xpY2UnKSB7XHJcbiAgICAgICAgICAgICAgICBmb3VuZFNsaWNlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgLy8gY29tcHV0ZSB0aGUgdmFsdWUgZm9yIHRoZSBzdWIgZXhwcmVzc2lvbiBmb3IgdGhlIGtleVxyXG4gICAgICAgICAgICAgIG5ld1ZhbHVlID0gY29tcHV0ZVZhbHVlKG9iaiwgc3ViRXhwciwga2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZHJvcEtleXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGNsb25lT2JqW2tleV0gPSBfLmlzT2JqZWN0KG5ld1ZhbHVlKSA/IF8uY2xvbmUobmV3VmFsdWUpIDogbmV3VmFsdWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gaWYgcHJvamVjdGlvbiBpbmNsdWRlZCAkc2xpY2Ugb3BlcmF0b3JcclxuICAgICAgICAvLyBBbHNvIGlmIGV4Y2x1c2lvbiBmaWVsZHMgYXJlIGZvdW5kIG9yIHdlIHdhbnQgdG8gZXhjbHVkZSBvbmx5IHRoZSBpZCBmaWVsZFxyXG4gICAgICAgIC8vIGluY2x1ZGUga2V5cyB0aGF0IHdlcmUgbm90IGV4cGxpY2l0bHkgZXhjbHVkZWRcclxuICAgICAgICBpZiAoZm91bmRTbGljZSB8fCBmb3VuZEV4Y2x1c2lvbiB8fCBpZE9ubHlFeGNsdWRlZEV4cHJlc3Npb24pIHtcclxuICAgICAgICAgIGNsb25lT2JqID0gXy5kZWZhdWx0cyhjbG9uZU9iaiwgXy5vbWl0KG9iaiwgZHJvcEtleXMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJvamVjdGVkLnB1c2goY2xvbmVPYmopO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcHJvamVjdGVkO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc3RyaWN0cyB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyBpbiBhbiBhZ2dyZWdhdGlvbiBwaXBlbGluZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29sbGVjdGlvblxyXG4gICAgICogQHBhcmFtIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fCp9XHJcbiAgICAgKi9cclxuICAgICRsaW1pdDogZnVuY3Rpb24gKGNvbGxlY3Rpb24sIHZhbHVlKSB7XHJcbiAgICAgIHJldHVybiBfLmZpcnN0KGNvbGxlY3Rpb24sIHZhbHVlKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTa2lwcyBvdmVyIGEgc3BlY2lmaWVkIG51bWJlciBvZiBkb2N1bWVudHMgZnJvbSB0aGUgcGlwZWxpbmUgYW5kIHJldHVybnMgdGhlIHJlc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25cclxuICAgICAqIEBwYXJhbSB2YWx1ZVxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgICRza2lwOiBmdW5jdGlvbiAoY29sbGVjdGlvbiwgdmFsdWUpIHtcclxuICAgICAgcmV0dXJuIF8ucmVzdChjb2xsZWN0aW9uLCB2YWx1ZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGFrZXMgYW4gYXJyYXkgb2YgZG9jdW1lbnRzIGFuZCByZXR1cm5zIHRoZW0gYXMgYSBzdHJlYW0gb2YgZG9jdW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb2xsZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0gZXhwclxyXG4gICAgICogQHJldHVybnMge0FycmF5fVxyXG4gICAgICovXHJcbiAgICAkdW53aW5kOiBmdW5jdGlvbiAoY29sbGVjdGlvbiwgZXhwcikge1xyXG4gICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgIHZhciBmaWVsZCA9IGV4cHIuc3Vic3RyKDEpO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbGxlY3Rpb24ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgb2JqID0gY29sbGVjdGlvbltpXTtcclxuICAgICAgICAvLyBtdXN0IHRocm93IGFuIGVycm9yIGlmIHZhbHVlIGlzIG5vdCBhbiBhcnJheVxyXG4gICAgICAgIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iaiwgZmllbGQpO1xyXG4gICAgICAgIGlmIChfLmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICBfLmVhY2godmFsdWUsIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgIHZhciB0bXAgPSBfLmNsb25lKG9iaik7XHJcbiAgICAgICAgICAgIHRtcFtmaWVsZF0gPSBpdGVtO1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaCh0bXApO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRhcmdldCBmaWVsZCAnXCIgKyBmaWVsZCArIFwiJyBpcyBub3Qgb2YgdHlwZSBBcnJheS5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGFrZXMgYWxsIGlucHV0IGRvY3VtZW50cyBhbmQgcmV0dXJucyB0aGVtIGluIGEgc3RyZWFtIG9mIHNvcnRlZCBkb2N1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25cclxuICAgICAqIEBwYXJhbSBzb3J0S2V5c1xyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgICRzb3J0OiBmdW5jdGlvbiAoY29sbGVjdGlvbiwgc29ydEtleXMpIHtcclxuICAgICAgaWYgKCFfLmlzRW1wdHkoc29ydEtleXMpICYmIF8uaXNPYmplY3Qoc29ydEtleXMpKSB7XHJcbiAgICAgICAgdmFyIG1vZGlmaWVycyA9IF8ua2V5cyhzb3J0S2V5cyk7XHJcbiAgICAgICAgbW9kaWZpZXJzLnJldmVyc2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgIHZhciBpbmRleGVzID0gW107XHJcbiAgICAgICAgICB2YXIgZ3JvdXBlZCA9IF8uZ3JvdXBCeShjb2xsZWN0aW9uLCBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHJlc29sdmUob2JqLCBrZXkpO1xyXG4gICAgICAgICAgICBpbmRleGVzLnB1c2godmFsdWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIGluZGV4ZXMgPSBfLnNvcnRCeShfLnVuaXEoaW5kZXhlcyksIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBpZiAoc29ydEtleXNba2V5XSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgaW5kZXhlcy5yZXZlcnNlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjb2xsZWN0aW9uID0gW107XHJcbiAgICAgICAgICBfLmVhY2goaW5kZXhlcywgZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoY29sbGVjdGlvbiwgZ3JvdXBlZFtpdGVtXSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICB2YXIgY29tcG91bmRPcGVyYXRvcnMgPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBKb2lucyBxdWVyeSBjbGF1c2VzIHdpdGggYSBsb2dpY2FsIEFORCByZXR1cm5zIGFsbCBkb2N1bWVudHMgdGhhdCBtYXRjaCB0aGUgY29uZGl0aW9ucyBvZiBib3RoIGNsYXVzZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHNlbGVjdG9yXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHt7dGVzdDogRnVuY3Rpb259fVxyXG4gICAgICovXHJcbiAgICAkYW5kOiBmdW5jdGlvbiAoc2VsZWN0b3IsIHZhbHVlKSB7XHJcbiAgICAgIGlmICghXy5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZXhwcmVzc2lvbiBmb3IgJGFuZCBjcml0ZXJpYVwiKTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgcXVlcmllcyA9IFtdO1xyXG4gICAgICBfLmVhY2godmFsdWUsIGZ1bmN0aW9uIChleHByKSB7XHJcbiAgICAgICAgcXVlcmllcy5wdXNoKG5ldyBNaW5nby5RdWVyeShleHByKSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0ZXN0OiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXJpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKCFxdWVyaWVzW2ldLnRlc3Qob2JqKSkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEpvaW5zIHF1ZXJ5IGNsYXVzZXMgd2l0aCBhIGxvZ2ljYWwgT1IgcmV0dXJucyBhbGwgZG9jdW1lbnRzIHRoYXQgbWF0Y2ggdGhlIGNvbmRpdGlvbnMgb2YgZWl0aGVyIGNsYXVzZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc2VsZWN0b3JcclxuICAgICAqIEBwYXJhbSB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge3t0ZXN0OiBGdW5jdGlvbn19XHJcbiAgICAgKi9cclxuICAgICRvcjogZnVuY3Rpb24gKHNlbGVjdG9yLCB2YWx1ZSkge1xyXG4gICAgICBpZiAoIV8uaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGV4cHJlc3Npb24gZm9yICRvciBjcml0ZXJpYVwiKTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgcXVlcmllcyA9IFtdO1xyXG4gICAgICBfLmVhY2godmFsdWUsIGZ1bmN0aW9uIChleHByKSB7XHJcbiAgICAgICAgcXVlcmllcy5wdXNoKG5ldyBNaW5nby5RdWVyeShleHByKSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0ZXN0OiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXJpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHF1ZXJpZXNbaV0udGVzdChvYmopKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSm9pbnMgcXVlcnkgY2xhdXNlcyB3aXRoIGEgbG9naWNhbCBOT1IgcmV0dXJucyBhbGwgZG9jdW1lbnRzIHRoYXQgZmFpbCB0byBtYXRjaCBib3RoIGNsYXVzZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHNlbGVjdG9yXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHt7dGVzdDogRnVuY3Rpb259fVxyXG4gICAgICovXHJcbiAgICAkbm9yOiBmdW5jdGlvbiAoc2VsZWN0b3IsIHZhbHVlKSB7XHJcbiAgICAgIGlmICghXy5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZXhwcmVzc2lvbiBmb3IgJG5vciBjcml0ZXJpYVwiKTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgcXVlcnkgPSB0aGlzLiRvcihcIiRvclwiLCB2YWx1ZSk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdGVzdDogZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgcmV0dXJuICFxdWVyeS50ZXN0KG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEludmVydHMgdGhlIGVmZmVjdCBvZiBhIHF1ZXJ5IGV4cHJlc3Npb24gYW5kIHJldHVybnMgZG9jdW1lbnRzIHRoYXQgZG8gbm90IG1hdGNoIHRoZSBxdWVyeSBleHByZXNzaW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzZWxlY3RvclxyXG4gICAgICogQHBhcmFtIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7e3Rlc3Q6IEZ1bmN0aW9ufX1cclxuICAgICAqL1xyXG4gICAgJG5vdDogZnVuY3Rpb24gKHNlbGVjdG9yLCB2YWx1ZSkge1xyXG4gICAgICB2YXIgY3JpdGVyaWEgPSB7fTtcclxuICAgICAgY3JpdGVyaWFbc2VsZWN0b3JdID0gbm9ybWFsaXplKHZhbHVlKTtcclxuICAgICAgdmFyIHF1ZXJ5ID0gbmV3IE1pbmdvLlF1ZXJ5KGNyaXRlcmlhKTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0ZXN0OiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICByZXR1cm4gIXF1ZXJ5LnRlc3Qob2JqKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWF0Y2hlcyBkb2N1bWVudHMgdGhhdCBzYXRpc2Z5IGEgSmF2YVNjcmlwdCBleHByZXNzaW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzZWxlY3RvclxyXG4gICAgICogQHBhcmFtIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7e3Rlc3Q6IHRlc3R9fVxyXG4gICAgICovXHJcbiAgICAkd2hlcmU6IGZ1bmN0aW9uIChzZWxlY3RvciwgdmFsdWUpIHtcclxuICAgICAgaWYgKCFfLmlzRnVuY3Rpb24odmFsdWUpKSB7XHJcbiAgICAgICAgdmFsdWUgPSBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gXCIgKyB2YWx1ZSArIFwiO1wiKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHRlc3Q6IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgIHJldHVybiB2YWx1ZS5jYWxsKG9iaikgPT09IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICB9O1xyXG5cclxuICB2YXIgc2ltcGxlT3BlcmF0b3JzID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHRoYXQgdHdvIHZhbHVlcyBhcmUgZXF1YWwuIFBzZXVkbyBvcGVyYXRvciBpbnRyb2R1Y2VkIGZvciBjb252ZW5pZW5jZSBhbmQgY29uc2lzdGVuY3lcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYVxyXG4gICAgICogQHBhcmFtIGJcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICAkZXE6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgIGEgPSBfLmlzQXJyYXkoYSkgPyBhIDogW2FdO1xyXG4gICAgICBhID0gXy5maW5kKGEsIGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICByZXR1cm4gXy5pc0VxdWFsKHZhbCwgYik7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gYSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hdGNoZXMgYWxsIHZhbHVlcyB0aGF0IGFyZSBub3QgZXF1YWwgdG8gdGhlIHZhbHVlIHNwZWNpZmllZCBpbiB0aGUgcXVlcnkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFcclxuICAgICAqIEBwYXJhbSBiXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgJG5lOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICByZXR1cm4gIXRoaXMuJGVxKGEsIGIpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hdGNoZXMgYW55IG9mIHRoZSB2YWx1ZXMgdGhhdCBleGlzdCBpbiBhbiBhcnJheSBzcGVjaWZpZWQgaW4gdGhlIHF1ZXJ5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhXHJcbiAgICAgKiBAcGFyYW0gYlxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgICRpbjogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgYSA9IF8uaXNBcnJheShhKSA/IGEgOiBbYV07XHJcbiAgICAgIHJldHVybiBfLmludGVyc2VjdGlvbihhLCBiKS5sZW5ndGggPiAwO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hdGNoZXMgdmFsdWVzIHRoYXQgZG8gbm90IGV4aXN0IGluIGFuIGFycmF5IHNwZWNpZmllZCB0byB0aGUgcXVlcnkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFcclxuICAgICAqIEBwYXJhbSBiXHJcbiAgICAgKiBAcmV0dXJucyB7Knxib29sZWFufVxyXG4gICAgICovXHJcbiAgICAkbmluOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICByZXR1cm4gXy5pc1VuZGVmaW5lZChhKSB8fCAhdGhpcy4kaW4oYSwgYik7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWF0Y2hlcyB2YWx1ZXMgdGhhdCBhcmUgbGVzcyB0aGFuIHRoZSB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhlIHF1ZXJ5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhXHJcbiAgICAgKiBAcGFyYW0gYlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgICRsdDogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgYSA9IF8uaXNBcnJheShhKSA/IGEgOiBbYV07XHJcbiAgICAgIGEgPSBfLmZpbmQoYSwgZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICAgIHJldHVybiB2YWwgPCBiXHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gYSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hdGNoZXMgdmFsdWVzIHRoYXQgYXJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgdmFsdWUgc3BlY2lmaWVkIGluIHRoZSBxdWVyeS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYVxyXG4gICAgICogQHBhcmFtIGJcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICAkbHRlOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICBhID0gXy5pc0FycmF5KGEpID8gYSA6IFthXTtcclxuICAgICAgYSA9IF8uZmluZChhLCBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbCA8PSBiXHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gYSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hdGNoZXMgdmFsdWVzIHRoYXQgYXJlIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgc3BlY2lmaWVkIGluIHRoZSBxdWVyeS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYVxyXG4gICAgICogQHBhcmFtIGJcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICAkZ3Q6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgIGEgPSBfLmlzQXJyYXkoYSkgPyBhIDogW2FdO1xyXG4gICAgICBhID0gXy5maW5kKGEsIGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICByZXR1cm4gdmFsID4gYlxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIGEgIT09IHVuZGVmaW5lZDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXRjaGVzIHZhbHVlcyB0aGF0IGFyZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIHNwZWNpZmllZCBpbiB0aGUgcXVlcnkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFcclxuICAgICAqIEBwYXJhbSBiXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgJGd0ZTogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgYSA9IF8uaXNBcnJheShhKSA/IGEgOiBbYV07XHJcbiAgICAgIGEgPSBfLmZpbmQoYSwgZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICAgIHJldHVybiB2YWwgPj0gYlxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIGEgIT09IHVuZGVmaW5lZDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQZXJmb3JtcyBhIG1vZHVsbyBvcGVyYXRpb24gb24gdGhlIHZhbHVlIG9mIGEgZmllbGQgYW5kIHNlbGVjdHMgZG9jdW1lbnRzIHdpdGggYSBzcGVjaWZpZWQgcmVzdWx0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhXHJcbiAgICAgKiBAcGFyYW0gYlxyXG4gICAgICogQHJldHVybnMgeyp8Ym9vbGVhbnxib29sZWFufVxyXG4gICAgICovXHJcbiAgICAkbW9kOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICBhID0gXy5pc0FycmF5KGEpID8gYSA6IFthXTtcclxuICAgICAgYSA9IF8uZmluZChhLCBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgcmV0dXJuIF8uaXNOdW1iZXIodmFsKSAmJiBfLmlzQXJyYXkoYikgJiYgYi5sZW5ndGggPT09IDIgJiYgKHZhbCAlIGJbMF0pID09PSBiWzFdO1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIGEgIT09IHVuZGVmaW5lZDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZWxlY3RzIGRvY3VtZW50cyB3aGVyZSB2YWx1ZXMgbWF0Y2ggYSBzcGVjaWZpZWQgcmVndWxhciBleHByZXNzaW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhXHJcbiAgICAgKiBAcGFyYW0gYlxyXG4gICAgICogQHJldHVybnMgeyp8Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgJHJlZ2V4OiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICBhID0gXy5pc0FycmF5KGEpID8gYSA6IFthXTtcclxuICAgICAgYSA9IF8uZmluZChhLCBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgcmV0dXJuIF8uaXNTdHJpbmcodmFsKSAmJiBfLmlzUmVnRXhwKGIpICYmICghIXZhbC5tYXRjaChiKSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gYSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hdGNoZXMgZG9jdW1lbnRzIHRoYXQgaGF2ZSB0aGUgc3BlY2lmaWVkIGZpZWxkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhXHJcbiAgICAgKiBAcGFyYW0gYlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW58Knxib29sZWFufVxyXG4gICAgICovXHJcbiAgICAkZXhpc3RzOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICByZXR1cm4gKGIgPT09IGZhbHNlICYmIF8uaXNVbmRlZmluZWQoYSkpIHx8IChiID09PSB0cnVlICYmICFfLmlzVW5kZWZpbmVkKGEpKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXRjaGVzIGFycmF5cyB0aGF0IGNvbnRhaW4gYWxsIGVsZW1lbnRzIHNwZWNpZmllZCBpbiB0aGUgcXVlcnkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFcclxuICAgICAqIEBwYXJhbSBiXHJcbiAgICAgKiBAcmV0dXJucyBib29sZWFuXHJcbiAgICAgKi9cclxuICAgICRhbGw6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgdmFyIG1hdGNoZWQgPSBmYWxzZTtcclxuICAgICAgaWYgKF8uaXNBcnJheShhKSAmJiBfLmlzQXJyYXkoYikpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGlmIChfLmlzT2JqZWN0KGJbaV0pICYmIF8uY29udGFpbnMoXy5rZXlzKGJbaV0pLCBcIiRlbGVtTWF0Y2hcIikpIHtcclxuICAgICAgICAgICAgbWF0Y2hlZCA9IG1hdGNoZWQgfHwgc2VsZi4kZWxlbU1hdGNoKGEsIGJbaV0uJGVsZW1NYXRjaCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBvcmRlciBvZiBhcmd1bWVudHMgbWF0dGVyLiB1bmRlcnNjb3JlIG1haW50YWlucyBvcmRlciBhZnRlciBpbnRlcnNlY3Rpb25cclxuICAgICAgICAgICAgcmV0dXJuIF8uaW50ZXJzZWN0aW9uKGIsIGEpLmxlbmd0aCA9PT0gYi5sZW5ndGg7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBtYXRjaGVkO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlbGVjdHMgZG9jdW1lbnRzIGlmIHRoZSBhcnJheSBmaWVsZCBpcyBhIHNwZWNpZmllZCBzaXplLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhXHJcbiAgICAgKiBAcGFyYW0gYlxyXG4gICAgICogQHJldHVybnMgeyp8Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgJHNpemU6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgIHJldHVybiBfLmlzQXJyYXkoYSkgJiYgXy5pc051bWJlcihiKSAmJiAoYS5sZW5ndGggPT09IGIpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlbGVjdHMgZG9jdW1lbnRzIGlmIGVsZW1lbnQgaW4gdGhlIGFycmF5IGZpZWxkIG1hdGNoZXMgYWxsIHRoZSBzcGVjaWZpZWQgJGVsZW1NYXRjaCBjb25kaXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFcclxuICAgICAqIEBwYXJhbSBiXHJcbiAgICAgKi9cclxuICAgICRlbGVtTWF0Y2g6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgIGlmIChfLmlzQXJyYXkoYSkgJiYgIV8uaXNFbXB0eShhKSkge1xyXG4gICAgICAgIHZhciBxdWVyeSA9IG5ldyBNaW5nby5RdWVyeShiKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGlmIChxdWVyeS50ZXN0KGFbaV0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VsZWN0cyBkb2N1bWVudHMgaWYgYSBmaWVsZCBpcyBvZiB0aGUgc3BlY2lmaWVkIHR5cGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFcclxuICAgICAqIEBwYXJhbSBiXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgJHR5cGU6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgIHN3aXRjaCAoYikge1xyXG4gICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgIHJldHVybiBfLmlzTnVtZXJpYyhhKSAmJiAoYSArIFwiXCIpLmluZGV4T2YoXCIuXCIpICE9PSAtMTtcclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgcmV0dXJuIF8uaXNTdHJpbmcoYSk7XHJcbiAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgcmV0dXJuIF8uaXNPYmplY3QoYSk7XHJcbiAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgcmV0dXJuIF8uaXNBcnJheShhKTtcclxuICAgICAgICBjYXNlIDg6XHJcbiAgICAgICAgICByZXR1cm4gXy5pc0Jvb2xlYW4oYSk7XHJcbiAgICAgICAgY2FzZSA5OlxyXG4gICAgICAgICAgcmV0dXJuIF8uaXNEYXRlKGEpO1xyXG4gICAgICAgIGNhc2UgMTA6XHJcbiAgICAgICAgICByZXR1cm4gXy5pc051bGwoYSk7XHJcbiAgICAgICAgY2FzZSAxMTpcclxuICAgICAgICAgIHJldHVybiBfLmlzUmVnRXhwKGEpO1xyXG4gICAgICAgIGNhc2UgMTY6XHJcbiAgICAgICAgICByZXR1cm4gXy5pc051bWVyaWMoYSkgJiYgYSA8PSAyMTQ3NDgzNjQ3ICYmIChhICsgXCJcIikuaW5kZXhPZihcIi5cIikgPT09IC0xO1xyXG4gICAgICAgIGNhc2UgMTg6XHJcbiAgICAgICAgICByZXR1cm4gXy5pc051bWVyaWMoYSkgJiYgYSA+IDIxNDc0ODM2NDcgJiYgYSA8PSA5MjIzMzcyMDM2ODU0Nzc1ODA3ICYmIChhICsgXCJcIikuaW5kZXhPZihcIi5cIikgPT09IC0xO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgfTtcclxuXHJcbiAgdmFyIHByb2plY3Rpb25PcGVyYXRvcnMgPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9qZWN0cyB0aGUgZmlyc3QgZWxlbWVudCBpbiBhbiBhcnJheSB0aGF0IG1hdGNoZXMgdGhlIHF1ZXJ5IGNvbmRpdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb2JqXHJcbiAgICAgKiBAcGFyYW0gZmllbGRcclxuICAgICAqIEBwYXJhbSBleHByXHJcbiAgICAgKi9cclxuICAgICQ6IGZ1bmN0aW9uIChvYmosIGV4cHIsIGZpZWxkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIiQgbm90IGltcGxlbWVudGVkXCIpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb2plY3RzIG9ubHkgdGhlIGZpcnN0IGVsZW1lbnQgZnJvbSBhbiBhcnJheSB0aGF0IG1hdGNoZXMgdGhlIHNwZWNpZmllZCAkZWxlbU1hdGNoIGNvbmRpdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb2JqXHJcbiAgICAgKiBAcGFyYW0gZmllbGRcclxuICAgICAqIEBwYXJhbSBleHByXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgJGVsZW1NYXRjaDogZnVuY3Rpb24gKG9iaiwgZXhwciwgZmllbGQpIHtcclxuICAgICAgdmFyIGFycmF5ID0gcmVzb2x2ZShvYmosIGZpZWxkKTtcclxuICAgICAgdmFyIHF1ZXJ5ID0gbmV3IE1pbmdvLlF1ZXJ5KGV4cHIpO1xyXG5cclxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQoYXJyYXkpIHx8ICFfLmlzQXJyYXkoYXJyYXkpKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChxdWVyeS50ZXN0KGFycmF5W2ldKSkge1xyXG4gICAgICAgICAgcmV0dXJuIFthcnJheVtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIExpbWl0cyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHByb2plY3RlZCBmcm9tIGFuIGFycmF5LiBTdXBwb3J0cyBza2lwIGFuZCBsaW1pdCBzbGljZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9ialxyXG4gICAgICogQHBhcmFtIGZpZWxkXHJcbiAgICAgKiBAcGFyYW0gZXhwclxyXG4gICAgICovXHJcbiAgICAkc2xpY2U6IGZ1bmN0aW9uIChvYmosIGV4cHIsIGZpZWxkKSB7XHJcbiAgICAgIHZhciBhcnJheSA9IHJlc29sdmUob2JqLCBmaWVsZCk7XHJcblxyXG4gICAgICBpZiAoIV8uaXNBcnJheShhcnJheSkpIHtcclxuICAgICAgICByZXR1cm4gYXJyYXk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFfLmlzQXJyYXkoZXhwcikpIHtcclxuICAgICAgICBpZiAoIV8uaXNOdW1iZXIoZXhwcikpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdHlwZSBmb3IgJHNsaWNlIG9wZXJhdG9yXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBleHByID0gZXhwciA8IDAgPyBbZXhwcl0gOiBbMCwgZXhwcl07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gTW9uZ29EQiAkc2xpY2Ugd29ya3MgYSBiaXQgZGlmZmVyZW50bHkgZnJvbSBBcnJheS5zbGljZVxyXG4gICAgICAgIC8vIFVzZXMgc2luZ2xlIGFyZ3VtZW50IGZvciAnbGltaXQnIGFuZCBhcnJheSBhcmd1bWVudCBbc2tpcCwgbGltaXRdXHJcbiAgICAgICAgdmFyIHNraXAgPSAoZXhwclswXSA8IDApID8gYXJyYXkubGVuZ3RoICsgZXhwclswXSA6IGV4cHI7XHJcbiAgICAgICAgdmFyIGxpbWl0ID0gc2tpcCArIGV4cHJbMV07XHJcbiAgICAgICAgZXhwciA9IFtza2lwLCBsaW1pdF07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJyYXksIGV4cHIpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHZhciBncm91cE9wZXJhdG9ycyA9IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHRoZSB1bmlxdWUgdmFsdWVzIGZvciB0aGUgc2VsZWN0ZWQgZmllbGQgYW1vbmcgZm9yIGVhY2ggZG9jdW1lbnQgaW4gdGhhdCBncm91cC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29sbGVjdGlvblxyXG4gICAgICogQHBhcmFtIGV4cHJcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICAkYWRkVG9TZXQ6IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBleHByKSB7XHJcbiAgICAgIHZhciByZXN1bHQgPSBfLm1hcChjb2xsZWN0aW9uLCBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbXB1dGVWYWx1ZShvYmosIGV4cHIpO1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIF8udW5pcShyZXN1bHQpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHN1bSBvZiBhbGwgdGhlIHZhbHVlcyBpbiBhIGdyb3VwLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb2xsZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0gZXhwclxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgICRzdW06IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBleHByKSB7XHJcbiAgICAgIGlmIChfLmlzTnVtYmVyKGV4cHIpKSB7XHJcbiAgICAgICAgLy8gdGFrZSBhIHNob3J0IGN1dCBpZiBleHByIGlzIG51bWJlciBsaXRlcmFsXHJcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb24ubGVuZ3RoICogZXhwcjtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gXy5yZWR1Y2UoY29sbGVjdGlvbiwgZnVuY3Rpb24gKGFjYywgb2JqKSB7XHJcbiAgICAgICAgLy8gcGFzcyBlbXB0eSBmaWVsZCB0byBhdm9pZCBuYW1pbmcgY29uZmxpY3RzIHdpdGggZmllbGRzIG9uIGRvY3VtZW50c1xyXG4gICAgICAgIHJldHVybiBhY2MgKyBjb21wdXRlVmFsdWUob2JqLCBleHByKTtcclxuICAgICAgfSwgMCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgaGlnaGVzdCB2YWx1ZSBpbiBhIGdyb3VwLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb2xsZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0gZXhwclxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgICRtYXg6IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBleHByKSB7XHJcbiAgICAgIHZhciBvYmogPSBfLm1heChjb2xsZWN0aW9uLCBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbXB1dGVWYWx1ZShvYmosIGV4cHIpO1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIGNvbXB1dGVWYWx1ZShvYmosIGV4cHIpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGxvd2VzdCB2YWx1ZSBpbiBhIGdyb3VwLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb2xsZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0gZXhwclxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgICRtaW46IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBleHByKSB7XHJcbiAgICAgIHZhciBvYmogPSBfLm1pbihjb2xsZWN0aW9uLCBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbXB1dGVWYWx1ZShvYmosIGV4cHIpO1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIGNvbXB1dGVWYWx1ZShvYmosIGV4cHIpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gYXZlcmFnZSBvZiBhbGwgdGhlIHZhbHVlcyBpbiBhIGdyb3VwLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb2xsZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0gZXhwclxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgJGF2ZzogZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGV4cHIpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuJHN1bShjb2xsZWN0aW9uLCBleHByKSAvIChjb2xsZWN0aW9uLmxlbmd0aCB8fCAxKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCB2YWx1ZXMgZm9yIHRoZSBzZWxlY3RlZCBmaWVsZCBhbW9uZyBmb3IgZWFjaCBkb2N1bWVudCBpbiB0aGF0IGdyb3VwLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb2xsZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0gZXhwclxyXG4gICAgICogQHJldHVybnMge0FycmF5fCp9XHJcbiAgICAgKi9cclxuICAgICRwdXNoOiBmdW5jdGlvbiAoY29sbGVjdGlvbiwgZXhwcikge1xyXG4gICAgICByZXR1cm4gXy5tYXAoY29sbGVjdGlvbiwgZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgIHJldHVybiBjb21wdXRlVmFsdWUob2JqLCBleHByKTtcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgdmFsdWUgaW4gYSBncm91cC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29sbGVjdGlvblxyXG4gICAgICogQHBhcmFtIGV4cHJcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICAkZmlyc3Q6IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBleHByKSB7XHJcbiAgICAgIHJldHVybiAoY29sbGVjdGlvbi5sZW5ndGggPiAwKSA/IGNvbXB1dGVWYWx1ZShjb2xsZWN0aW9uWzBdLCBleHByKSA6IHVuZGVmaW5lZDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBsYXN0IHZhbHVlIGluIGEgZ3JvdXAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25cclxuICAgICAqIEBwYXJhbSBleHByXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgJGxhc3Q6IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBleHByKSB7XHJcbiAgICAgIHJldHVybiAoY29sbGVjdGlvbi5sZW5ndGggPiAwKSA/IGNvbXB1dGVWYWx1ZShjb2xsZWN0aW9uW2NvbGxlY3Rpb24ubGVuZ3RoIC0gMV0sIGV4cHIpIDogdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG5cclxuICAvLy8vLy8vLy8vLyBDb21tb24gQWdncmVnYXRpb24gT3BlcmF0b3JzIC8vLy8vLy8vLy8vXHJcblxyXG4gIHZhciBhcml0aG1ldGljT3BlcmF0b3JzID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgdGhlIHN1bSBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvYmpcclxuICAgICAqIEBwYXJhbSBleHByXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICAkYWRkOiBmdW5jdGlvbiAob2JqLCBleHByKSB7XHJcbiAgICAgIHZhciBhcmdzID0gY29tcHV0ZVZhbHVlKG9iaiwgZXhwcik7XHJcbiAgICAgIHJldHVybiBfLnJlZHVjZShhcmdzLCBmdW5jdGlvbiAobWVtbywgbnVtKSB7XHJcbiAgICAgICAgcmV0dXJuIG1lbW8gKyBudW07XHJcbiAgICAgIH0sIDApO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRha2VzIGFuIGFycmF5IHRoYXQgY29udGFpbnMgdHdvIG51bWJlcnMgb3IgdHdvIGRhdGVzIGFuZCBzdWJ0cmFjdHMgdGhlIHNlY29uZCB2YWx1ZSBmcm9tIHRoZSBmaXJzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb2JqXHJcbiAgICAgKiBAcGFyYW0gZXhwclxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgJHN1YnRyYWN0OiBmdW5jdGlvbiAob2JqLCBleHByKSB7XHJcbiAgICAgIHZhciBhcmdzID0gY29tcHV0ZVZhbHVlKG9iaiwgZXhwcik7XHJcbiAgICAgIHJldHVybiBhcmdzWzBdIC0gYXJnc1sxXTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUYWtlcyB0d28gbnVtYmVycyBhbmQgZGl2aWRlcyB0aGUgZmlyc3QgbnVtYmVyIGJ5IHRoZSBzZWNvbmQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9ialxyXG4gICAgICogQHBhcmFtIGV4cHJcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgICRkaXZpZGU6IGZ1bmN0aW9uIChvYmosIGV4cHIpIHtcclxuICAgICAgdmFyIGFyZ3MgPSBjb21wdXRlVmFsdWUob2JqLCBleHByKTtcclxuICAgICAgcmV0dXJuIGFyZ3NbMF0gLyBhcmdzWzFdO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIHRoZSBwcm9kdWN0IG9mIGFuIGFycmF5IG9mIG51bWJlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9ialxyXG4gICAgICogQHBhcmFtIGV4cHJcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgICRtdWx0aXBseTogZnVuY3Rpb24gKG9iaiwgZXhwcikge1xyXG4gICAgICB2YXIgYXJncyA9IGNvbXB1dGVWYWx1ZShvYmosIGV4cHIpO1xyXG4gICAgICByZXR1cm4gXy5yZWR1Y2UoYXJncywgZnVuY3Rpb24gKG1lbW8sIG51bSkge1xyXG4gICAgICAgIHJldHVybiBtZW1vICogbnVtO1xyXG4gICAgICB9LCAxKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUYWtlcyB0d28gbnVtYmVycyBhbmQgY2FsY3VsYXRlcyB0aGUgbW9kdWxvIG9mIHRoZSBmaXJzdCBudW1iZXIgZGl2aWRlZCBieSB0aGUgc2Vjb25kLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvYmpcclxuICAgICAqIEBwYXJhbSBleHByXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICAkbW9kOiBmdW5jdGlvbiAob2JqLCBleHByKSB7XHJcbiAgICAgIHZhciBhcmdzID0gY29tcHV0ZVZhbHVlKG9iaiwgZXhwcik7XHJcbiAgICAgIHJldHVybiBhcmdzWzBdICUgYXJnc1sxXTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICB2YXIgc3RyaW5nT3BlcmF0b3JzID0ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29uY2F0ZW5hdGVzIHR3byBzdHJpbmdzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvYmpcclxuICAgICAqIEBwYXJhbSBleHByXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfCp9XHJcbiAgICAgKi9cclxuICAgICRjb25jYXQ6IGZ1bmN0aW9uIChvYmosIGV4cHIpIHtcclxuICAgICAgdmFyIGFyZ3MgPSBjb21wdXRlVmFsdWUob2JqLCBleHByKTtcclxuICAgICAgLy8gZG9lcyBub3QgYWxsb3cgY29uY2F0ZW5hdGlvbiB3aXRoIG51bGxzXHJcbiAgICAgIGlmIChfLmNvbnRhaW5zKGFyZ3MsIG51bGwpIHx8IF8uY29udGFpbnMoYXJncywgdW5kZWZpbmVkKSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBhcmdzLmpvaW4oXCJcIik7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcGFyZXMgdHdvIHN0cmluZ3MgYW5kIHJldHVybnMgYW4gaW50ZWdlciB0aGF0IHJlZmxlY3RzIHRoZSBjb21wYXJpc29uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvYmpcclxuICAgICAqIEBwYXJhbSBleHByXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICAkc3RyY2FzZWNtcDogZnVuY3Rpb24gKG9iaiwgZXhwcikge1xyXG4gICAgICB2YXIgYXJncyA9IGNvbXB1dGVWYWx1ZShvYmosIGV4cHIpO1xyXG4gICAgICBhcmdzWzBdID0gXy5pc0VtcHR5KGFyZ3NbMF0pID8gXCJcIiA6IGFyZ3NbMF0udG9VcHBlckNhc2UoKTtcclxuICAgICAgYXJnc1sxXSA9IF8uaXNFbXB0eShhcmdzWzFdKSA/IFwiXCIgOiBhcmdzWzFdLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgIGlmIChhcmdzWzBdID4gYXJnc1sxXSkge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAoYXJnc1swXSA8IGFyZ3NbMV0pID8gLTEgOiAwO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBzdWJzdHJpbmcgb2YgYSBzdHJpbmcsIHN0YXJ0aW5nIGF0IGEgc3BlY2lmaWVkIGluZGV4IHBvc2l0aW9uIGFuZCBpbmNsdWRpbmcgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgY2hhcmFjdGVycy5cclxuICAgICAqIFRoZSBpbmRleCBpcyB6ZXJvLWJhc2VkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvYmpcclxuICAgICAqIEBwYXJhbSBleHByXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICAkc3Vic3RyOiBmdW5jdGlvbiAob2JqLCBleHByKSB7XHJcbiAgICAgIHZhciBhcmdzID0gY29tcHV0ZVZhbHVlKG9iaiwgZXhwcik7XHJcbiAgICAgIGlmIChfLmlzU3RyaW5nKGFyZ3NbMF0pKSB7XHJcbiAgICAgICAgaWYgKGFyZ3NbMV0gPCAwKSB7XHJcbiAgICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgICAgICB9IGVsc2UgaWYgKGFyZ3NbMl0gPCAwKSB7XHJcbiAgICAgICAgICByZXR1cm4gYXJnc1swXS5zdWJzdHIoYXJnc1sxXSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiBhcmdzWzBdLnN1YnN0cihhcmdzWzFdLCBhcmdzWzJdKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgYSBzdHJpbmcgdG8gbG93ZXJjYXNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvYmpcclxuICAgICAqIEBwYXJhbSBleHByXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICAkdG9Mb3dlcjogZnVuY3Rpb24gKG9iaiwgZXhwcikge1xyXG4gICAgICB2YXIgdmFsdWUgPSBjb21wdXRlVmFsdWUob2JqLCBleHByKTtcclxuICAgICAgcmV0dXJuIF8uaXNFbXB0eSh2YWx1ZSkgPyBcIlwiIDogdmFsdWUudG9Mb3dlckNhc2UoKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBhIHN0cmluZyB0byB1cHBlcmNhc2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9ialxyXG4gICAgICogQHBhcmFtIGV4cHJcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgICR0b1VwcGVyOiBmdW5jdGlvbiAob2JqLCBleHByKSB7XHJcbiAgICAgIHZhciB2YWx1ZSA9IGNvbXB1dGVWYWx1ZShvYmosIGV4cHIpO1xyXG4gICAgICByZXR1cm4gXy5pc0VtcHR5KHZhbHVlKSA/IFwiXCIgOiB2YWx1ZS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHZhciBkYXRlT3BlcmF0b3JzID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBkYXkgb2YgdGhlIHllYXIgZm9yIGEgZGF0ZSBhcyBhIG51bWJlciBiZXR3ZWVuIDEgYW5kIDM2NiAobGVhcCB5ZWFyKS5cclxuICAgICAqIEBwYXJhbSBvYmpcclxuICAgICAqIEBwYXJhbSBleHByXHJcbiAgICAgKi9cclxuICAgICRkYXlPZlllYXI6IGZ1bmN0aW9uIChvYmosIGV4cHIpIHtcclxuICAgICAgdmFyIGQgPSBjb21wdXRlVmFsdWUob2JqLCBleHByKTtcclxuICAgICAgaWYgKF8uaXNEYXRlKHZhbHVlKSkge1xyXG4gICAgICAgIHZhciBzdGFydCA9IG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgMCwgMCk7XHJcbiAgICAgICAgdmFyIGRpZmYgPSBkIC0gc3RhcnQ7XHJcbiAgICAgICAgdmFyIG9uZURheSA9IDEwMDAgKiA2MCAqIDYwICogMjQ7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoZGlmZiAvIG9uZURheSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBkYXkgb2YgdGhlIG1vbnRoIGZvciBhIGRhdGUgYXMgYSBudW1iZXIgYmV0d2VlbiAxIGFuZCAzMS5cclxuICAgICAqIEBwYXJhbSBvYmpcclxuICAgICAqIEBwYXJhbSBleHByXHJcbiAgICAgKi9cclxuICAgICRkYXlPZk1vbnRoOiBmdW5jdGlvbiAob2JqLCBleHByKSB7XHJcbiAgICAgIHZhciBkID0gY29tcHV0ZVZhbHVlKG9iaiwgZXhwcik7XHJcbiAgICAgIHJldHVybiBfLmlzRGF0ZShkKSA/IGQuZ2V0RGF0ZSgpIDogdW5kZWZpbmVkO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRheSBvZiB0aGUgd2VlayBmb3IgYSBkYXRlIGFzIGEgbnVtYmVyIGJldHdlZW4gMSAoU3VuZGF5KSBhbmQgNyAoU2F0dXJkYXkpLlxyXG4gICAgICogQHBhcmFtIG9ialxyXG4gICAgICogQHBhcmFtIGV4cHJcclxuICAgICAqL1xyXG4gICAgJGRheU9mV2VlazogZnVuY3Rpb24gKG9iaiwgZXhwcikge1xyXG4gICAgICB2YXIgZCA9IGNvbXB1dGVWYWx1ZShvYmosIGV4cHIpO1xyXG4gICAgICByZXR1cm4gXy5pc0RhdGUoZCkgPyBkLmdldERheSgpICsgMSA6IHVuZGVmaW5lZDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB5ZWFyIGZvciBhIGRhdGUgYXMgYSBudW1iZXIgKGUuZy4gMjAxNCkuXHJcbiAgICAgKiBAcGFyYW0gb2JqXHJcbiAgICAgKiBAcGFyYW0gZXhwclxyXG4gICAgICovXHJcbiAgICAkeWVhcjogZnVuY3Rpb24gKG9iaiwgZXhwcikge1xyXG4gICAgICB2YXIgZCA9IGNvbXB1dGVWYWx1ZShvYmosIGV4cHIpO1xyXG4gICAgICByZXR1cm4gXy5pc0RhdGUoZCkgPyBkLmdldEZ1bGxZZWFyKCkgKyAxIDogdW5kZWZpbmVkO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG1vbnRoIGZvciBhIGRhdGUgYXMgYSBudW1iZXIgYmV0d2VlbiAxIChKYW51YXJ5KSBhbmQgMTIgKERlY2VtYmVyKS5cclxuICAgICAqIEBwYXJhbSBvYmpcclxuICAgICAqIEBwYXJhbSBleHByXHJcbiAgICAgKi9cclxuICAgICRtb250aDogZnVuY3Rpb24gKG9iaiwgZXhwcikge1xyXG4gICAgICB2YXIgZCA9IGNvbXB1dGVWYWx1ZShvYmosIGV4cHIpO1xyXG4gICAgICByZXR1cm4gXy5pc0RhdGUoZCkgPyBkLmdldE1vbnRoKCkgKyAxIDogdW5kZWZpbmVkO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHdlZWsgbnVtYmVyIGZvciBhIGRhdGUgYXMgYSBudW1iZXIgYmV0d2VlbiAwXHJcbiAgICAgKiAodGhlIHBhcnRpYWwgd2VlayB0aGF0IHByZWNlZGVzIHRoZSBmaXJzdCBTdW5kYXkgb2YgdGhlIHllYXIpIGFuZCA1MyAobGVhcCB5ZWFyKS5cclxuICAgICAqIEBwYXJhbSBvYmpcclxuICAgICAqIEBwYXJhbSBleHByXHJcbiAgICAgKi9cclxuICAgICR3ZWVrOiBmdW5jdGlvbiAob2JqLCBleHByKSB7XHJcbiAgICAgIHZhciBkID0gY29tcHV0ZVZhbHVlKG9iaiwgZXhwcik7XHJcbiAgICAgIC8vIFRPRE9cclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IEltcGxlbWVudGVkXCIpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGhvdXIgZm9yIGEgZGF0ZSBhcyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDIzLlxyXG4gICAgICogQHBhcmFtIG9ialxyXG4gICAgICogQHBhcmFtIGV4cHJcclxuICAgICAqL1xyXG4gICAgJGhvdXI6IGZ1bmN0aW9uIChvYmosIGV4cHIpIHtcclxuICAgICAgdmFyIGQgPSBjb21wdXRlVmFsdWUob2JqLCBleHByKTtcclxuICAgICAgcmV0dXJuIF8uaXNEYXRlKGQpID8gZC5nZXRIb3VycygpIDogdW5kZWZpbmVkO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG1pbnV0ZSBmb3IgYSBkYXRlIGFzIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgNTkuXHJcbiAgICAgKiBAcGFyYW0gb2JqXHJcbiAgICAgKiBAcGFyYW0gZXhwclxyXG4gICAgICovXHJcbiAgICAkbWludXRlOiBmdW5jdGlvbiAob2JqLCBleHByKSB7XHJcbiAgICAgIHZhciBkID0gY29tcHV0ZVZhbHVlKG9iaiwgZXhwcik7XHJcbiAgICAgIHJldHVybiBfLmlzRGF0ZShkKSA/IGQuZ2V0TWludXRlcygpIDogdW5kZWZpbmVkO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHNlY29uZHMgZm9yIGEgZGF0ZSBhcyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDYwIChsZWFwIHNlY29uZHMpLlxyXG4gICAgICogQHBhcmFtIG9ialxyXG4gICAgICogQHBhcmFtIGV4cHJcclxuICAgICAqL1xyXG4gICAgJHNlY29uZDogZnVuY3Rpb24gKG9iaiwgZXhwcikge1xyXG4gICAgICB2YXIgZCA9IGNvbXB1dGVWYWx1ZShvYmosIGV4cHIpO1xyXG4gICAgICByZXR1cm4gXy5pc0RhdGUoZCkgPyBkLmdldFNlY29uZHMoKSA6IHVuZGVmaW5lZDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBtaWxsaXNlY29uZHMgb2YgYSBkYXRlIGFzIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgOTk5LlxyXG4gICAgICogQHBhcmFtIG9ialxyXG4gICAgICogQHBhcmFtIGV4cHJcclxuICAgICAqL1xyXG4gICAgJG1pbGxpc2Vjb25kOiBmdW5jdGlvbiAob2JqLCBleHByKSB7XHJcbiAgICAgIHZhciBkID0gY29tcHV0ZVZhbHVlKG9iaiwgZXhwcik7XHJcbiAgICAgIHJldHVybiBfLmlzRGF0ZShkKSA/IGQuZ2V0TWlsbGlzZWNvbmRzKCkgOiB1bmRlZmluZWQ7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZGF0ZSBhcyBhIGZvcm1hdHRlZCBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0gb2JqXHJcbiAgICAgKiBAcGFyYW0gZXhwclxyXG4gICAgICovXHJcbiAgICAkZGF0ZVRvU3RyaW5nOiBmdW5jdGlvbiAob2JqLCBleHByKSB7XHJcbiAgICAgIHZhciBmbXQgPSBleHByWydmb3JtYXQnXTtcclxuICAgICAgdmFyIGRhdGUgPSBjb21wdXRlVmFsdWUob2JqLCBleHByWydkYXRlJ10pO1xyXG4gICAgICAvLyBUT0RPOiB1c2UgcHl0aG9uLXN0eWxlIGRhdGUgZm9ybWF0dGluZ1xyXG4gICAgICAvKlxyXG4gICAgICAgJVlcdFllYXIgKDQgZGlnaXRzLCB6ZXJvIHBhZGRlZClcdDAwMDAtOTk5OVxyXG4gICAgICAgJW1cdE1vbnRoICgyIGRpZ2l0cywgemVybyBwYWRkZWQpXHQwMS0xMlxyXG4gICAgICAgJWRcdERheSBvZiBNb250aCAoMiBkaWdpdHMsIHplcm8gcGFkZGVkKVx0MDEtMzFcclxuICAgICAgICVIXHRIb3VyICgyIGRpZ2l0cywgemVybyBwYWRkZWQsIDI0LWhvdXIgY2xvY2spXHQwMC0yM1xyXG4gICAgICAgJU1cdE1pbnV0ZSAoMiBkaWdpdHMsIHplcm8gcGFkZGVkKVx0MDAtNTlcclxuICAgICAgICVTXHRTZWNvbmQgKDIgZGlnaXRzLCB6ZXJvIHBhZGRlZClcdDAwLTYwXHJcbiAgICAgICAlTFx0TWlsbGlzZWNvbmQgKDMgZGlnaXRzLCB6ZXJvIHBhZGRlZClcdDAwMC05OTlcclxuICAgICAgICVqXHREYXkgb2YgeWVhciAoMyBkaWdpdHMsIHplcm8gcGFkZGVkKVx0MDAxLTM2NlxyXG4gICAgICAgJXdcdERheSBvZiB3ZWVrICgxLVN1bmRheSwgNy1TYXR1cmRheSlcdDEtN1xyXG4gICAgICAgJVVcdFdlZWsgb2YgeWVhciAoMiBkaWdpdHMsIHplcm8gcGFkZGVkKVx0MDAtNTNcclxuICAgICAgICUlXHRQZXJjZW50IENoYXJhY3RlciBhcyBhIExpdGVyYWxcdCVcclxuICAgICAgICovXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBJbXBsZW1lbnRlZFwiKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICB2YXIgc2V0T3BlcmF0b3JzID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdHdvIHNldHMgaGF2ZSB0aGUgc2FtZSBlbGVtZW50cy5cclxuICAgICAqIEBwYXJhbSBvYmpcclxuICAgICAqIEBwYXJhbSBleHByXHJcbiAgICAgKi9cclxuICAgICRzZXRFcXVhbHM6IGZ1bmN0aW9uIChvYmosIGV4cHIpIHtcclxuICAgICAgdmFyIGFyZ3MgPSBjb21wdXRlVmFsdWUob2JqLCBleHByKTtcclxuICAgICAgdmFyIGZpcnN0ID0gXy51bmlxKGFyZ3NbMF0pO1xyXG4gICAgICB2YXIgc2Vjb25kID0gXy51bmlxKGFyZ3NbMV0pO1xyXG4gICAgICBpZiAoZmlyc3QubGVuZ3RoICE9PSBzZWNvbmQubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBfLmRpZmZlcmVuY2UoZmlyc3QsIHNlY29uZCkubGVuZ3RoID09IDA7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY29tbW9uIGVsZW1lbnRzIG9mIHRoZSBpbnB1dCBzZXRzLlxyXG4gICAgICogQHBhcmFtIG9ialxyXG4gICAgICogQHBhcmFtIGV4cHJcclxuICAgICAqL1xyXG4gICAgJHNldEludGVyc2VjdGlvbjogZnVuY3Rpb24gKG9iaiwgZXhwcikge1xyXG4gICAgICB2YXIgYXJncyA9IGNvbXB1dGVWYWx1ZShvYmosIGV4cHIpO1xyXG4gICAgICByZXR1cm4gXy5pbnRlcnNlY3Rpb24oYXJnc1swXSwgYXJnc1sxXSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBlbGVtZW50cyBvZiBhIHNldCB0aGF0IGRvIG5vdCBhcHBlYXIgaW4gYSBzZWNvbmQgc2V0LlxyXG4gICAgICogQHBhcmFtIG9ialxyXG4gICAgICogQHBhcmFtIGV4cHJcclxuICAgICAqL1xyXG4gICAgJHNldERpZmZlcmVuY2U6IGZ1bmN0aW9uIChvYmosIGV4cHIpIHtcclxuICAgICAgdmFyIGFyZ3MgPSBjb21wdXRlVmFsdWUob2JqLCBleHByKTtcclxuICAgICAgcmV0dXJuIF8uZGlmZmVyZW5jZShhcmdzWzBdLCBhcmdzWzFdKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgc2V0IHRoYXQgaG9sZHMgYWxsIGVsZW1lbnRzIG9mIHRoZSBpbnB1dCBzZXRzLlxyXG4gICAgICogQHBhcmFtIG9ialxyXG4gICAgICogQHBhcmFtIGV4cHJcclxuICAgICAqL1xyXG4gICAgJHNldFVuaW9uOiBmdW5jdGlvbiAob2JqLCBleHByKSB7XHJcbiAgICAgIHZhciBhcmdzID0gY29tcHV0ZVZhbHVlKG9iaiwgZXhwcik7XHJcbiAgICAgIHJldHVybiBfLnVuaW9uKGFyZ3NbMF0sIGFyZ3NbMV0pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBhbGwgZWxlbWVudHMgb2YgYSBzZXQgYXBwZWFyIGluIGEgc2Vjb25kIHNldC5cclxuICAgICAqIEBwYXJhbSBvYmpcclxuICAgICAqIEBwYXJhbSBleHByXHJcbiAgICAgKi9cclxuICAgICRzZXRJc1N1YnNldDogZnVuY3Rpb24gKG9iaiwgZXhwcikge1xyXG4gICAgICB2YXIgYXJncyA9IGNvbXB1dGVWYWx1ZShvYmosIGV4cHIpO1xyXG4gICAgICByZXR1cm4gXy5pbnRlcnNlY3Rpb24oYXJnc1swXSwgYXJnc1sxXSkubGVuZ3RoID09PSBhcmdzWzBdLmxlbmd0aDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgYW55IGVsZW1lbnRzIG9mIGEgc2V0IGV2YWx1YXRlIHRvIHRydWUsIGFuZCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKiBAcGFyYW0gb2JqXHJcbiAgICAgKiBAcGFyYW0gZXhwclxyXG4gICAgICovXHJcbiAgICAkYW55RWxlbWVudFRydWU6IGZ1bmN0aW9uIChvYmosIGV4cHIpIHtcclxuICAgICAgLy8gbW9uZ29kYiBuZXN0cyB0aGUgYXJyYXkgZXhwcmVzc2lvbiBpbiBhbm90aGVyXHJcbiAgICAgIHZhciBhcmdzID0gY29tcHV0ZVZhbHVlKG9iaiwgZXhwcilbMF07XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmICghIWFyZ3NbaV0pXHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGFsbCBlbGVtZW50cyBvZiBhIHNldCBldmFsdWF0ZSB0byB0cnVlLCBhbmQgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICogQHBhcmFtIG9ialxyXG4gICAgICogQHBhcmFtIGV4cHJcclxuICAgICAqL1xyXG4gICAgJGFsbEVsZW1lbnRzVHJ1ZTogZnVuY3Rpb24gKG9iaiwgZXhwcikge1xyXG4gICAgICAvLyBtb25nb2RiIG5lc3RzIHRoZSBhcnJheSBleHByZXNzaW9uIGluIGFub3RoZXJcclxuICAgICAgdmFyIGFyZ3MgPSBjb21wdXRlVmFsdWUob2JqLCBleHByKVswXTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKCFhcmdzW2ldKVxyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHZhciBjb25kaXRpb25hbE9wZXJhdG9ycyA9IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgdGVybmFyeSBvcGVyYXRvciB0aGF0IGV2YWx1YXRlcyBvbmUgZXhwcmVzc2lvbixcclxuICAgICAqIGFuZCBkZXBlbmRpbmcgb24gdGhlIHJlc3VsdCByZXR1cm5zIHRoZSB2YWx1ZSBvZiBvbmUgZm9sbG93aW5nIGV4cHJlc3Npb25zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvYmpcclxuICAgICAqIEBwYXJhbSBleHByXHJcbiAgICAgKi9cclxuICAgICRjb25kOiBmdW5jdGlvbiAob2JqLCBleHByKSB7XHJcbiAgICAgIHZhciBpZkV4cHIsIHRoZW5FeHByLCBlbHNlRXhwcjtcclxuICAgICAgaWYgKF8uaXNBcnJheShleHByKSkge1xyXG4gICAgICAgIGlmIChleHByLmxlbmd0aCAhPSAzKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50cyBmb3IgJGNvbmQgb3BlcmF0b3JcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmRXhwciA9IGV4cHJbMF07XHJcbiAgICAgICAgdGhlbkV4cHIgPSBleHByWzFdO1xyXG4gICAgICAgIGVsc2VFeHByID0gZXhwclsyXTtcclxuICAgICAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KGV4cHIpKSB7XHJcbiAgICAgICAgaWZFeHByID0gZXhwclsnaWYnXTtcclxuICAgICAgICB0aGVuRXhwciA9IGV4cHJbJ3RoZW4nXTtcclxuICAgICAgICBlbHNlRXhwciA9IGV4cHJbJ2Vsc2UnXTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgY29uZGl0aW9uID0gY29tcHV0ZVZhbHVlKG9iaiwgaWZFeHByKTtcclxuICAgICAgcmV0dXJuIGNvbmRpdGlvbiA/IGNvbXB1dGVWYWx1ZShvYmosIHRoZW5FeHByKSA6IGNvbXB1dGVWYWx1ZShvYmosIGVsc2VFeHByKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFdmFsdWF0ZXMgYW4gZXhwcmVzc2lvbiBhbmQgcmV0dXJucyB0aGUgZmlyc3QgZXhwcmVzc2lvbiBpZiBpdCBldmFsdWF0ZXMgdG8gYSBub24tbnVsbCB2YWx1ZS5cclxuICAgICAqIE90aGVyd2lzZSwgJGlmTnVsbCByZXR1cm5zIHRoZSBzZWNvbmQgZXhwcmVzc2lvbidzIHZhbHVlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvYmpcclxuICAgICAqIEBwYXJhbSBleHByXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgJGlmTnVsbDogZnVuY3Rpb24gKG9iaiwgZXhwcikge1xyXG4gICAgICBpZiAoIV8uaXNBcnJheShleHByKSB8fCBleHByLmxlbmd0aCAhPSAyKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudHMgZm9yICRpZk51bGwgb3BlcmF0b3JcIik7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGFyZ3MgPSBjb21wdXRlVmFsdWUob2JqLCBleHByKTtcclxuICAgICAgcmV0dXJuIChhcmdzWzBdID09PSBudWxsIHx8IGFyZ3NbMF0gPT09IHVuZGVmaW5lZCkgPyBhcmdzWzFdIDogYXJnc1swXTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICB2YXIgY29tcGFyaXNvbk9wZXJhdG9ycyA9IHtcclxuICAgIC8qKlxyXG4gICAgICogQ29tcGFyZXMgdHdvIHZhbHVlcyBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBjb21wYXJpc29uIGFzIGFuIGludGVnZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9ialxyXG4gICAgICogQHBhcmFtIGV4cHJcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgICRjbXA6IGZ1bmN0aW9uIChvYmosIGV4cHIpIHtcclxuICAgICAgdmFyIGFyZ3MgPSBjb21wdXRlVmFsdWUob2JqLCBleHByKTtcclxuICAgICAgaWYgKGFyZ3NbMF0gPiBhcmdzWzFdKSB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIChhcmdzWzBdIDwgYXJnc1sxXSkgPyAtMSA6IDA7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gY29tYmluZSBhZ2dyZWdhdGUgb3BlcmF0b3JzXHJcbiAgdmFyIGFnZ3JlZ2F0ZU9wZXJhdG9ycyA9IF8uZXh0ZW5kKFxyXG4gICAgICB7fSxcclxuICAgICAgYXJpdGhtZXRpY09wZXJhdG9ycyxcclxuICAgICAgY29tcGFyaXNvbk9wZXJhdG9ycyxcclxuICAgICAgY29uZGl0aW9uYWxPcGVyYXRvcnMsXHJcbiAgICAgIGRhdGVPcGVyYXRvcnMsXHJcbiAgICAgIHNldE9wZXJhdG9ycyxcclxuICAgICAgc3RyaW5nT3BlcmF0b3JzXHJcbiAgKTtcclxuXHJcbiAgLy8gbWl4aW4gY29tcGFyaXNvbiBvcGVyYXRvcnNcclxuICBfLmVhY2goW1wiJGVxXCIsIFwiJG5lXCIsIFwiJGd0XCIsIFwiJGd0ZVwiLCBcIiRsdFwiLCBcIiRsdGVcIl0sIGZ1bmN0aW9uIChvcCkge1xyXG4gICAgYWdncmVnYXRlT3BlcmF0b3JzW29wXSA9IGZ1bmN0aW9uIChvYmosIGV4cHIpIHtcclxuICAgICAgdmFyIGFyZ3MgPSBjb21wdXRlVmFsdWUob2JqLCBleHByKTtcclxuICAgICAgcmV0dXJuIHNpbXBsZU9wZXJhdG9yc1tvcF0oYXJnc1swXSwgYXJnc1sxXSk7XHJcbiAgICB9O1xyXG4gIH0pO1xyXG5cclxuICB2YXIgT3BzID0ge1xyXG4gICAgc2ltcGxlT3BlcmF0b3JzOiBfLmtleXMoc2ltcGxlT3BlcmF0b3JzKSxcclxuICAgIGNvbXBvdW5kT3BlcmF0b3JzOiBfLmtleXMoY29tcG91bmRPcGVyYXRvcnMpLFxyXG4gICAgYWdncmVnYXRlT3BlcmF0b3JzOiBfLmtleXMoYWdncmVnYXRlT3BlcmF0b3JzKSxcclxuICAgIGdyb3VwT3BlcmF0b3JzOiBfLmtleXMoZ3JvdXBPcGVyYXRvcnMpLFxyXG4gICAgcGlwZWxpbmVPcGVyYXRvcnM6IF8ua2V5cyhwaXBlbGluZU9wZXJhdG9ycyksXHJcbiAgICBwcm9qZWN0aW9uT3BlcmF0b3JzOiBfLmtleXMocHJvamVjdGlvbk9wZXJhdG9ycylcclxuICB9O1xyXG4gIE9wcy5xdWVyeU9wZXJhdG9ycyA9IF8udW5pb24oT3BzLnNpbXBsZU9wZXJhdG9ycywgT3BzLmNvbXBvdW5kT3BlcmF0b3JzKTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIGV2YWx1YXRpbmcgYSAkZ3JvdXAgb3BlcmF0aW9uIG92ZXIgYSBjb2xsZWN0aW9uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gY29sbGVjdGlvblxyXG4gICAqIEBwYXJhbSBmaWVsZCB0aGUgbmFtZSBvZiB0aGUgYWdncmVnYXRlIG9wZXJhdG9yIG9yIGZpZWxkXHJcbiAgICogQHBhcmFtIGV4cHIgdGhlIGV4cHJlc3Npb24gb2YgdGhlIGFnZ3JlZ2F0ZSBvcGVyYXRvciBmb3IgdGhlIGZpZWxkXHJcbiAgICogQHJldHVybnMgeyp9XHJcbiAgICovXHJcbiAgZnVuY3Rpb24gYWNjdW11bGF0ZShjb2xsZWN0aW9uLCBmaWVsZCwgZXhwcikge1xyXG4gICAgaWYgKF8uY29udGFpbnMoT3BzLmdyb3VwT3BlcmF0b3JzLCBmaWVsZCkpIHtcclxuICAgICAgcmV0dXJuIGdyb3VwT3BlcmF0b3JzW2ZpZWxkXShjb2xsZWN0aW9uLCBleHByKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoXy5pc09iamVjdChleHByKSkge1xyXG4gICAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICAgIGZvciAodmFyIGtleSBpbiBleHByKSB7XHJcbiAgICAgICAgaWYgKGV4cHIuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBhY2N1bXVsYXRlKGNvbGxlY3Rpb24sIGtleSwgZXhwcltrZXldKTtcclxuICAgICAgICAgIC8vIG11c3QgcnVuIE9OTFkgb25lIGdyb3VwIG9wZXJhdG9yIHBlciBleHByZXNzaW9uXHJcbiAgICAgICAgICAvLyBpZiBzbywgcmV0dXJuIHJlc3VsdCBvZiB0aGUgY29tcHV0ZWQgdmFsdWVcclxuICAgICAgICAgIGlmIChfLmNvbnRhaW5zKE9wcy5ncm91cE9wZXJhdG9ycywga2V5KSkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHRba2V5XTtcclxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG1vcmUga2V5cyBpbiBleHByZXNzaW9uIHRoaXMgaXMgYmFkXHJcbiAgICAgICAgICAgIGlmIChfLmtleXMoZXhwcikubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgJGdyb3VwIGV4cHJlc3Npb24gJ1wiICsgSlNPTi5zdHJpbmdpZnkoZXhwcikgKyBcIidcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbXB1dGVzIHRoZSBhY3R1YWwgdmFsdWUgb2YgdGhlIGV4cHJlc3Npb24gdXNpbmcgdGhlIGdpdmVuIG9iamVjdCBhcyBjb250ZXh0XHJcbiAgICpcclxuICAgKiBAcGFyYW0gb2JqIHRoZSBjdXJyZW50IG9iamVjdCBmcm9tIHRoZSBjb2xsZWN0aW9uXHJcbiAgICogQHBhcmFtIGV4cHIgdGhlIGV4cHJlc3Npb24gZm9yIHRoZSBnaXZlbiBmaWVsZFxyXG4gICAqIEBwYXJhbSBmaWVsZCB0aGUgZmllbGQgbmFtZSAobWF5IGFsc28gYmUgYW4gYWdncmVnYXRlIG9wZXJhdG9yKVxyXG4gICAqIEByZXR1cm5zIHsqfVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGNvbXB1dGVWYWx1ZShvYmosIGV4cHIsIGZpZWxkKSB7XHJcblxyXG4gICAgLy8gaWYgdGhlIGZpZWxkIG9mIHRoZSBvYmplY3QgaXMgYSB2YWxpZCBvcGVyYXRvclxyXG4gICAgaWYgKF8uY29udGFpbnMoT3BzLmFnZ3JlZ2F0ZU9wZXJhdG9ycywgZmllbGQpKSB7XHJcbiAgICAgIHJldHVybiBhZ2dyZWdhdGVPcGVyYXRvcnNbZmllbGRdKG9iaiwgZXhwcik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWYgZXhwciBpcyBhIHZhcmlhYmxlIGZvciBhbiBvYmplY3QgZmllbGRcclxuICAgIC8vIGZpZWxkIG5vdCB1c2VkIGluIHRoaXMgY2FzZVxyXG4gICAgaWYgKF8uaXNTdHJpbmcoZXhwcikgJiYgZXhwci5sZW5ndGggPiAwICYmIGV4cHJbMF0gPT09IFwiJFwiKSB7XHJcbiAgICAgIHJldHVybiByZXNvbHZlKG9iaiwgZXhwci5zbGljZSgxKSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlc3VsdDtcclxuXHJcbiAgICBpZiAoXy5pc0FycmF5KGV4cHIpKSB7XHJcbiAgICAgIHJlc3VsdCA9IFtdO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICByZXN1bHQucHVzaChjb21wdXRlVmFsdWUob2JqLCBleHByW2ldLCBudWxsKSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoXy5pc09iamVjdChleHByKSkge1xyXG4gICAgICByZXN1bHQgPSB7fTtcclxuICAgICAgZm9yICh2YXIga2V5IGluIGV4cHIpIHtcclxuICAgICAgICBpZiAoZXhwci5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICByZXN1bHRba2V5XSA9IGNvbXB1dGVWYWx1ZShvYmosIGV4cHJba2V5XSwga2V5KTtcclxuXHJcbiAgICAgICAgICAvLyBtdXN0IHJ1biBPTkxZIG9uZSBhZ2dyZWdhdGUgb3BlcmF0b3IgcGVyIGV4cHJlc3Npb25cclxuICAgICAgICAgIC8vIGlmIHNvLCByZXR1cm4gcmVzdWx0IG9mIHRoZSBjb21wdXRlZCB2YWx1ZVxyXG4gICAgICAgICAgaWYgKF8uY29udGFpbnMoT3BzLmFnZ3JlZ2F0ZU9wZXJhdG9ycywga2V5KSkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHRba2V5XTtcclxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG1vcmUga2V5cyBpbiBleHByZXNzaW9uIHRoaXMgaXMgYmFkXHJcbiAgICAgICAgICAgIGlmIChfLmtleXMoZXhwcikubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYWdncmVnYXRpb24gZXhwcmVzc2lvbiAnXCIgKyBKU09OLnN0cmluZ2lmeShleHByKSArIFwiJ1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIGNoZWNrIGFuZCByZXR1cm4gdmFsdWUgaWYgYWxyZWFkeSBpbiBhIHJlc29sdmVkIHN0YXRlXHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJpbWl0aXZlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChwcmltaXRpdmVzW2ldKGV4cHIpKSB7XHJcbiAgICAgICAgICByZXR1cm4gZXhwcjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbn0odGhpcykpOyIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBvcHMgPSByZXF1aXJlKCcuL29wcycpO1xudmFyIGVxbCA9IHJlcXVpcmUoJ21vbmdvLWVxbCcpO1xudmFyIGRvdCA9IHJlcXVpcmUoJ2RvdC1jb21wb25lbnQnKTtcbnZhciB0eXBlID0gcmVxdWlyZSgnY29tcG9uZW50LXR5cGUnKTtcbnZhciBvYmplY3QgPSByZXF1aXJlKCdvYmplY3QtY29tcG9uZW50Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdtb25nby1xdWVyeScpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZpbHRlcjtcbmV4cG9ydHMub3BzID0gb3BzO1xuXG4vKipcbiAqIEZpbHRlcnMgYW4gYG9iamAgYnkgdGhlIGdpdmVuIGBxdWVyeWAgZm9yIHN1YmRvY3VtZW50cy5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R8Qm9vbGVhbn0gZmFsc2UgaWYgbm8gbWF0Y2gsIG9yIG1hdGNoZWQgc3ViZG9jc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmaWx0ZXIob2JqLCBxdWVyeSl7XG4gIG9iaiA9IG9iaiB8fCB7fTtcbiAgdmFyIHJldCA9IHt9O1xuXG4gIGZvciAodmFyIGtleSBpbiBxdWVyeSkge1xuICAgIGlmICghcXVlcnkuaGFzT3duUHJvcGVydHkoa2V5KSkgY29udGludWU7XG5cbiAgICAvLyBzZWFyY2ggdmFsdWVcbiAgICB2YXIgdmFsID0gcXVlcnlba2V5XTtcblxuICAgIC8vIHNwbGl0IHRoZSBrZXkgaW50byBwcmVmaXggYW5kIHN1ZmZpeFxuICAgIHZhciBrZXlzID0ga2V5LnNwbGl0KCcuJyk7XG4gICAgdmFyIHRhcmdldCA9IG9iajtcbiAgICB2YXIgcHJlZml4LCBzZWFyY2g7XG4gICAgdmFyIG1hdGNoZXMgPSBbXTtcblxuICAgIHdhbGtfa2V5czpcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRhcmdldCA9IHRhcmdldFtrZXlzW2ldXTtcblxuICAgICAgc3dpdGNoICh0eXBlKHRhcmdldCkpIHtcbiAgICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICAgIC8vIGlmIGl0J3MgYW4gYXJyYXkgc3ViZG9jdW1lbnQgc2VhcmNoIHdlIHN0b3AgaGVyZVxuICAgICAgICAgIHByZWZpeCA9IGtleXMuc2xpY2UoMCwgaSArIDEpLmpvaW4oJy4nKTtcbiAgICAgICAgICBzZWFyY2ggPSBrZXlzLnNsaWNlKGkgKyAxKS5qb2luKCcuJyk7XG5cbiAgICAgICAgICBkZWJ1Zygnc2VhcmNoaW5nIGFycmF5IFwiJXNcIicsIHByZWZpeCk7XG5cbiAgICAgICAgICAvLyB3ZSBzcGVjaWFsIGNhc2Ugb3BlcmF0b3JzIHRoYXQgZG9uJ3Qgd2FsayB0aGUgYXJyYXlcbiAgICAgICAgICBpZiAodmFsLiRzaXplICYmICFzZWFyY2gubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZSh2YWwsIHRhcmdldCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gd2FsayBzdWJkb2NzXG4gICAgICAgICAgdmFyIHN1YnNldCA9IHJldFtwcmVmaXhdIHx8IHRhcmdldDtcblxuICAgICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBzdWJzZXQubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgICBpZiAoc2VhcmNoLmxlbmd0aCkge1xuICAgICAgICAgICAgICB2YXIgcSA9IHt9O1xuICAgICAgICAgICAgICBxW3NlYXJjaF0gPSB2YWw7XG4gICAgICAgICAgICAgIGlmICgnb2JqZWN0JyA9PSB0eXBlKHN1YnNldFtpaV0pKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoJ2F0dGVtcHRpbmcgc3ViZG9jIHNlYXJjaCB3aXRoIHF1ZXJ5ICVqJywgcSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlcihzdWJzZXRbaWldLCBxKSkge1xuICAgICAgICAgICAgICAgICAgLy8gd2UgaWdub3JlIHRoZSByZXQgdmFsdWUgb2YgZmlsdGVyXG4gICAgICAgICAgICAgICAgICBpZiAoIXJldFtwcmVmaXhdIHx8ICF+cmV0W3ByZWZpeF0uaW5kZXhPZihzdWJzZXRbaWldKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2goc3Vic2V0W2lpXSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkZWJ1ZygncGVyZm9ybWluZyBzaW1wbGUgYXJyYXkgaXRlbSBzZWFyY2gnKTtcbiAgICAgICAgICAgICAgaWYgKGNvbXBhcmUodmFsLCBzdWJzZXRbaWldKSkge1xuICAgICAgICAgICAgICAgIGlmICghcmV0W3ByZWZpeF0gfHwgIX5yZXRbcHJlZml4XS5pbmRleE9mKHN1YnNldFtpaV0pKSB7XG4gICAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2goc3Vic2V0W2lpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXRbcHJlZml4XSA9IHJldFtwcmVmaXhdIHx8IFtdO1xuICAgICAgICAgICAgcmV0W3ByZWZpeF0ucHVzaC5hcHBseShyZXRbcHJlZml4XSwgbWF0Y2hlcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gd2UgZG9uJ3QgY29udGludWUgdGhlIGtleSBzZWFyY2hcbiAgICAgICAgICBicmVhayB3YWxrX2tleXM7XG5cbiAgICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgICAvLyBpZiB3ZSBjYW4ndCBmaW5kIHRoZSBrZXlcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICBpZiAobnVsbCAhPSBrZXlzW2kgKyAxXSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmICghY29tcGFyZSh2YWwsIHRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWNvbXBhcmUodmFsLCB0YXJnZXQpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBDb21wYXJlcyB0aGUgZ2l2ZW4gbWF0Y2hlciB3aXRoIHRoZSBkb2N1bWVudCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBtYXRjaGVyXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29tcGFyZShtYXRjaGVyLCB2YWwpe1xuICBpZiAoJ29iamVjdCcgIT0gdHlwZShtYXRjaGVyKSkge1xuICAgIHJldHVybiBlcWwobWF0Y2hlciwgdmFsKTtcbiAgfVxuXG4gIHZhciBrZXlzID0gb2JqZWN0LmtleXMobWF0Y2hlcik7XG4gIGlmICgnJCcgPT0ga2V5c1swXVswXSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciBzdWItb2JqZWN0IG1hdGNoaW5nXG4gICAgICBpZiAoJyRlbGVtTWF0Y2gnID09IGtleXNbaV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlICE9PSBmaWx0ZXIodmFsLCBtYXRjaGVyLiRlbGVtTWF0Y2gpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFvcHNba2V5c1tpXV0obWF0Y2hlcltrZXlzW2ldXSwgdmFsKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZXFsKG1hdGNoZXIsIHZhbCk7XG4gIH1cbn1cbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBtb2RzID0gcmVxdWlyZSgnLi9tb2RzJyk7XG52YXIgZmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXInKTtcbnZhciBkb3QgPSByZXF1aXJlKCdkb3QtY29tcG9uZW50Jyk7XG52YXIgdHlwZSA9IHJlcXVpcmUoJ2NvbXBvbmVudC10eXBlJyk7XG52YXIgb2JqZWN0ID0gcmVxdWlyZSgnb2JqZWN0LWNvbXBvbmVudCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbW9uZ28tcXVlcnknKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBxdWVyeTtcblxuLyoqXG4gKiBFeHBvcnQgZmlsdGVyIGhlbHBlci5cbiAqL1xuXG5leHBvcnRzLmZpbHRlciA9IGZpbHRlcjtcblxuLyoqXG4gKiBFeHBvcnQgbW9kaWZpZXJzLlxuICovXG5cbmV4cG9ydHMubW9kcyA9IG1vZHM7XG5cbi8qKlxuICogRXhlY3V0ZSBhIHF1ZXJ5LlxuICpcbiAqIE9wdGlvbnM6XG4gKiAgLSBgc3RyaWN0YCBvbmx5IG1vZGlmeSBpZiBxdWVyeSBtYXRjaGVzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0byBhbHRlclxuICogQHBhcmFtIHtPYmplY3R9IHF1ZXJ5IHRvIGZpbHRlciBtb2RpZmljYXRpb25zIGJ5XG4gKiBAcGFyYW0ge09iamVjdH0gdXBkYXRlIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuXG5mdW5jdGlvbiBxdWVyeShvYmosIHF1ZXJ5LCB1cGRhdGUsIG9wdHMpe1xuICBvYmogPSBvYmogfHwge307XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICBxdWVyeSA9IHF1ZXJ5IHx8IHt9O1xuICB1cGRhdGUgPSB1cGRhdGUgfHwge307XG5cbiAgLy8gc3RyaWN0IG1vZGVcbiAgdmFyIHN0cmljdCA9ICEhb3B0cy5zdHJpY3Q7XG5cbiAgdmFyIG1hdGNoO1xuICB2YXIgbG9nID0gW107XG5cbiAgaWYgKG9iamVjdC5sZW5ndGgocXVlcnkpKSB7XG4gICAgbWF0Y2ggPSBmaWx0ZXIob2JqLCBxdWVyeSk7XG4gIH1cblxuICBpZiAoIXN0cmljdCB8fCBmYWxzZSAhPT0gbWF0Y2gpIHtcbiAgICB2YXIga2V5cyA9IG9iamVjdC5rZXlzKHVwZGF0ZSk7XG4gICAgdmFyIHRyYW5zYWN0aW9ucyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKG1vZHNba2V5c1tpXV0pIHtcbiAgICAgICAgZGVidWcoJ2ZvdW5kIG1vZGlmaWVyIFwiJXNcIicsIGtleXNbaV0pO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdXBkYXRlW2tleXNbaV1dKSB7XG4gICAgICAgICAgdmFyIHBvcyA9IGtleS5pbmRleE9mKCcuJC4nKTtcblxuICAgICAgICAgIGlmICh+cG9zKSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0ga2V5LnN1YnN0cigwLCBwb3MpO1xuICAgICAgICAgICAgdmFyIHN1ZmZpeCA9IGtleS5zdWJzdHIocG9zICsgMyk7XG5cbiAgICAgICAgICAgIGlmIChtYXRjaFtwcmVmaXhdKSB7XG4gICAgICAgICAgICAgIGRlYnVnKCdleGVjdXRpbmcgXCIlc1wiICVzIG9uIGZpcnN0IG1hdGNoIHdpdGhpbiBcIiVzXCInLCBrZXksIGtleXNbaV0sIHByZWZpeCk7XG4gICAgICAgICAgICAgIHZhciBmbiA9IG1vZHNba2V5c1tpXV0obWF0Y2hbcHJlZml4XVswXSwgc3VmZml4LCB1cGRhdGVba2V5c1tpXV1ba2V5XSk7XG4gICAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgIC8vIHByb2R1Y2UgYSBrZXkgbmFtZSByZXBsYWNpbmcgJCB3aXRoIHRoZSBhY3R1YWwgaW5kZXhcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiB0aGlzIGlzIHVubmVjZXNzYXJpbHkgZXhwZW5zaXZlXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gZG90LmdldChvYmosIHByZWZpeCkuaW5kZXhPZihtYXRjaFtwcmVmaXhdWzBdKTtcbiAgICAgICAgICAgICAgICBmbi5rZXkgPSBwcmVmaXggKyAnLicgKyBpbmRleCArICcuJyArIHN1ZmZpeDtcbiAgICAgICAgICAgICAgICBmbi5vcCA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25zLnB1c2goZm4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkZWJ1ZygnaWdub3JpbmcgXCIlc1wiICVzIC0gbm8gbWF0Y2hlcyB3aXRoaW4gXCIlc1wiJywga2V5LCBrZXlzW2ldLCBwcmVmaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZm4gPSBtb2RzW2tleXNbaV1dKG9iaiwga2V5LCB1cGRhdGVba2V5c1tpXV1ba2V5XSk7XG4gICAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgICAgZm4ua2V5ID0ga2V5O1xuICAgICAgICAgICAgICBmbi5vcCA9IGtleXNbaV07XG4gICAgICAgICAgICAgIHRyYW5zYWN0aW9ucy5wdXNoKGZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnKCdza2lwcGluZyB1bmtub3duIG1vZGlmaWVyIFwiJXNcIicsIGtleXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0cmFuc2FjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAvLyBpZiB3ZSBnb3QgaGVyZSBlcnJvciBmcmVlIHdlIHByb2Nlc3MgYWxsIHRyYW5zYWN0aW9uc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2FjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGZuID0gdHJhbnNhY3Rpb25zW2ldO1xuICAgICAgICB2YXIgdmFsID0gZm4oKTtcbiAgICAgICAgbG9nLnB1c2goeyBvcDogZm4ub3AsIGtleTogZm4ua2V5LCB2YWx1ZTogdmFsIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkZWJ1Zygnbm8gbWF0Y2hlcyBmb3IgcXVlcnkgJWonLCBxdWVyeSk7XG4gIH1cblxuICByZXR1cm4gbG9nO1xufVxuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGVxbCA9IHJlcXVpcmUoJ21vbmdvLWVxbCcpO1xudmFyIGRvdCA9IHJlcXVpcmUoJ2RvdC1jb21wb25lbnQnKTtcbnZhciB0eXBlID0gcmVxdWlyZSgnY29tcG9uZW50LXR5cGUnKTtcbnZhciBrZXlzID0gcmVxdWlyZSgnb2JqZWN0LWNvbXBvbmVudCcpLmtleXM7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdtb25nby1xdWVyeScpO1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgYCRzZXRgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdG8gbW9kaWZ5XG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0byBhbHRlclxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIHRvIHNldFxuICogQHJldHVybiB7RnVuY3Rpb259IHRyYW5zYWN0aW9uICh1bmxlc3Mgbm9vcClcbiAqL1xuXG5leHBvcnRzLiRzZXQgPSBmdW5jdGlvbiAkc2V0KG9iaiwgcGF0aCwgdmFsKXtcbiAgdmFyIGtleSA9IHBhdGguc3BsaXQoJy4nKS5wb3AoKTtcbiAgb2JqID0gZG90LnBhcmVudChvYmosIHBhdGgsIHRydWUpO1xuXG4gIHN3aXRjaCAodHlwZShvYmopKSB7XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmICghZXFsKG9ialtrZXldLCB2YWwpKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgIG9ialtrZXldID0gdmFsO1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGlmIChudW1lcmljKGtleSkpIHtcbiAgICAgICAgaWYgKCFlcWwob2JqW2tleV0sIHZhbCkpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIG9ialtrZXldID0gdmFsO1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhblxcJ3QgYXBwZW5kIHRvIGFycmF5IHVzaW5nIHN0cmluZyBmaWVsZCBuYW1lIFsnICsga2V5ICsgJ10nKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignJHNldCBvbmx5IHN1cHBvcnRzIG9iamVjdCBub3QgJyArIHR5cGUob2JqKSk7XG4gIH1cbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYW4gYCR1bnNldGAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0byBtb2RpZnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRvIGFsdGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgdG8gc2V0XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdHJhbnNhY3Rpb24gKHVubGVzcyBub29wKVxuICovXG5cbmV4cG9ydHMuJHVuc2V0ID0gZnVuY3Rpb24gJHVuc2V0KG9iaiwgcGF0aCl7XG4gIHZhciBrZXkgPSBwYXRoLnNwbGl0KCcuJykucG9wKCk7XG4gIG9iaiA9IGRvdC5wYXJlbnQob2JqLCBwYXRoKTtcblxuICBzd2l0Y2ggKHR5cGUob2JqKSkge1xuICAgIGNhc2UgJ2FycmF5JzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgIC8vIHJlbWluZGVyOiBgZGVsZXRlIGFyclsxXWAgPT09IGBkZWxldGUgYXJyWycxJ11gIFshXVxuICAgICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHdlIGZhaWwgc2lsZW50bHlcbiAgICAgICAgZGVidWcoJ2lnbm9yaW5nIHVuc2V0IG9mIGluZXhpc3Rpbmcga2V5Jyk7XG4gICAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBgJHJlbmFtZWAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0byBtb2RpZnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRvIGFsdGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgdG8gc2V0XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdHJhbnNhY3Rpb24gKHVubGVzcyBub29wKVxuICovXG5cbmV4cG9ydHMuJHJlbmFtZSA9IGZ1bmN0aW9uICRyZW5hbWUob2JqLCBwYXRoLCBuZXdLZXkpe1xuICAvLyB0YXJnZXQgPSBzb3VyY2VcbiAgaWYgKHBhdGggPT0gbmV3S2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCckcmVuYW1lIHNvdXJjZSBtdXN0IGRpZmZlciBmcm9tIHRhcmdldCcpO1xuICB9XG5cbiAgLy8gdGFyZ2V0IGlzIHBhcmVudCBvZiBzb3VyY2VcbiAgaWYgKDAgPT09IHBhdGguaW5kZXhPZihuZXdLZXkgKyAnLicpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCckcmVuYW1lIHRhcmdldCBtYXkgbm90IGJlIGEgcGFyZW50IG9mIHNvdXJjZScpO1xuICB9XG5cbiAgdmFyIHAgPSBkb3QucGFyZW50KG9iaiwgcGF0aCk7XG4gIHZhciB0ID0gdHlwZShwKTtcblxuICBpZiAoJ29iamVjdCcgPT0gdCkge1xuICAgIHZhciBrZXkgPSBwYXRoLnNwbGl0KCcuJykucG9wKCk7XG5cbiAgICBpZiAocC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHZhbCA9IHBba2V5XTtcbiAgICAgICAgZGVsZXRlIHBba2V5XTtcblxuICAgICAgICAvLyB0YXJnZXQgZG9lcyBpbml0aWFsaXplIHRoZSBwYXRoXG4gICAgICAgIHZhciBuZXdwID0gZG90LnBhcmVudChvYmosIG5ld0tleSwgdHJ1ZSk7XG5cbiAgICAgICAgLy8gYW5kIGFsc28gZmFpbHMgc2lsZW50bHkgdXBvbiB0eXBlIG1pc21hdGNoXG4gICAgICAgIGlmICgnb2JqZWN0JyA9PSB0eXBlKG5ld3ApKSB7XG4gICAgICAgICAgbmV3cFtuZXdLZXkuc3BsaXQoJy4nKS5wb3AoKV0gPSB2YWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVidWcoJ2ludmFsaWQgJHJlbmFtZSB0YXJnZXQgcGF0aCB0eXBlJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBuZXcga2V5XG4gICAgICAgIHJldHVybiBuZXdLZXk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZygnaWdub3JpbmcgcmVuYW1lIGZyb20gaW5leGlzdGluZyBzb3VyY2UnKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoJ3VuZGVmaW5lZCcgIT0gdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignJHJlbmFtZSBzb3VyY2UgZmllbGQgaW52YWxpZCcpO1xuICB9XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGFuIGAkaW5jYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHRvIG1vZGlmeVxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdG8gYWx0ZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSB0byBzZXRcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0cmFuc2FjdGlvbiAodW5sZXNzIG5vb3ApXG4gKi9cblxuZXhwb3J0cy4kaW5jID0gZnVuY3Rpb24gJGluYyhvYmosIHBhdGgsIGluYyl7XG4gIGlmICgnbnVtYmVyJyAhPSB0eXBlKGluYykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01vZGlmaWVyICRpbmMgYWxsb3dlZCBmb3IgbnVtYmVycyBvbmx5Jyk7XG4gIH1cblxuICBvYmogPSBkb3QucGFyZW50KG9iaiwgcGF0aCwgdHJ1ZSk7XG4gIHZhciBrZXkgPSBwYXRoLnNwbGl0KCcuJykucG9wKCk7XG5cbiAgc3dpdGNoICh0eXBlKG9iaikpIHtcbiAgICBjYXNlICdhcnJheSc6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBpZiAoJ251bWJlcicgIT0gdHlwZShvYmpba2V5XSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhcHBseSAkaW5jIG1vZGlmaWVyIHRvIG5vbi1udW1iZXInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgIG9ialtrZXldICs9IGluYztcbiAgICAgICAgICByZXR1cm4gaW5jO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmKCdvYmplY3QnID09IHR5cGUob2JqKSB8fCBudW1lcmljKGtleSkpe1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICBvYmpba2V5XSA9IGluYztcbiAgICAgICAgICByZXR1cm4gaW5jO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5cXCd0IGFwcGVuZCB0byBhcnJheSB1c2luZyBzdHJpbmcgZmllbGQgbmFtZSBbJyArIGtleSArICddJyk7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhcHBseSAkaW5jIG1vZGlmaWVyIHRvIG5vbi1udW1iZXInKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhbiBgJHBvcGAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0byBtb2RpZnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRvIGFsdGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgdG8gc2V0XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdHJhbnNhY3Rpb24gKHVubGVzcyBub29wKVxuICovXG5cbmV4cG9ydHMuJHBvcCA9IGZ1bmN0aW9uICRwb3Aob2JqLCBwYXRoLCB2YWwpe1xuICBvYmogPSBkb3QucGFyZW50KG9iaiwgcGF0aCk7XG4gIHZhciBrZXkgPSBwYXRoLnNwbGl0KCcuJykucG9wKCk7XG5cbiAgLy8gd2UgbWFrZSBzdXJlIHRoZSBhcnJheSBpcyBub3QganVzdCB0aGUgcGFyZW50IG9mIHRoZSBtYWluIGtleVxuICBzd2l0Y2ggKHR5cGUob2JqKSkge1xuICAgIGNhc2UgJ2FycmF5JzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZShvYmpba2V5XSkpIHtcbiAgICAgICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgICAgICBpZiAob2JqW2tleV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIGlmICgtMSA9PSB2YWwpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBvYmpba2V5XS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBtb25nb2RiIGFsbG93cyBhbnkgdmFsdWUgdG8gcG9wXG4gICAgICAgICAgICAgICAgICByZXR1cm4gb2JqW2tleV0ucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgICAgZGVidWcoJ2lnbm9yaW5nIHBvcCB0byBpbmV4aXN0aW5nIGtleScpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYXBwbHkgJHBvcCBtb2RpZmllciB0byBub24tYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoJ2lnbm9yaW5nIHBvcCB0byBpbmV4aXN0aW5nIGtleScpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgZGVidWcoJ2lnbm9yaW5nIHBvcCB0byBpbmV4aXN0aW5nIGtleScpO1xuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBgJHB1c2hgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdG8gbW9kaWZ5XG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0byBhbHRlclxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIHRvIHB1c2hcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0cmFuc2FjdGlvbiAodW5sZXNzIG5vb3ApXG4gKi9cblxuZXhwb3J0cy4kcHVzaCA9IGZ1bmN0aW9uICRwdXNoKG9iaiwgcGF0aCwgdmFsKXtcbiAgb2JqID0gZG90LnBhcmVudChvYmosIHBhdGgsIHRydWUpO1xuICB2YXIga2V5ID0gcGF0aC5zcGxpdCgnLicpLnBvcCgpO1xuXG4gIHN3aXRjaCAodHlwZShvYmopKSB7XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBpZiAoJ2FycmF5JyA9PSB0eXBlKG9ialtrZXldKSkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgb2JqW2tleV0ucHVzaCh2YWwpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFwcGx5ICRwdXNoLyRwdXNoQWxsIG1vZGlmaWVyIHRvIG5vbi1hcnJheScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICBvYmpba2V5XSA9IFt2YWxdO1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBpZiAoJ2FycmF5JyA9PSB0eXBlKG9ialtrZXldKSkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgb2JqW2tleV0ucHVzaCh2YWwpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFwcGx5ICRwdXNoLyRwdXNoQWxsIG1vZGlmaWVyIHRvIG5vbi1hcnJheScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG51bWVyaWMoa2V5KSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICBvYmpba2V5XSA9IFt2YWxdO1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhblxcJ3QgYXBwZW5kIHRvIGFycmF5IHVzaW5nIHN0cmluZyBmaWVsZCBuYW1lIFsnICsga2V5ICsgJ10nKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgYCRwdXNoQWxsYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHRvIG1vZGlmeVxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdG8gYWx0ZXJcbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyB0byBwdXNoXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdHJhbnNhY3Rpb24gKHVubGVzcyBub29wKVxuICovXG5cbmV4cG9ydHMuJHB1c2hBbGwgPSBmdW5jdGlvbiAkcHVzaEFsbChvYmosIHBhdGgsIHZhbCl7XG4gIGlmICgnYXJyYXknICE9IHR5cGUodmFsKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTW9kaWZpZXIgJHB1c2hBbGwvcHVsbEFsbCBhbGxvd2VkIGZvciBhcnJheXMgb25seScpO1xuICB9XG5cbiAgb2JqID0gZG90LnBhcmVudChvYmosIHBhdGgsIHRydWUpO1xuICB2YXIga2V5ID0gcGF0aC5zcGxpdCgnLicpLnBvcCgpO1xuXG4gIHN3aXRjaCAodHlwZShvYmopKSB7XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBpZiAoJ2FycmF5JyA9PSB0eXBlKG9ialtrZXldKSkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgb2JqW2tleV0ucHVzaC5hcHBseShvYmpba2V5XSwgdmFsKTtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhcHBseSAkcHVzaC8kcHVzaEFsbCBtb2RpZmllciB0byBub24tYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgb2JqW2tleV0gPSB2YWw7XG4gICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXJyYXknOlxuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGlmICgnYXJyYXknID09IHR5cGUob2JqW2tleV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBvYmpba2V5XS5wdXNoLmFwcGx5KG9ialtrZXldLCB2YWwpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFwcGx5ICRwdXNoLyRwdXNoQWxsIG1vZGlmaWVyIHRvIG5vbi1hcnJheScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG51bWVyaWMoa2V5KSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICBvYmpba2V5XSA9IHZhbDtcbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5cXCd0IGFwcGVuZCB0byBhcnJheSB1c2luZyBzdHJpbmcgZmllbGQgbmFtZSBbJyArIGtleSArICddJyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGAkcHVsbGAuXG4gKi9cblxuZXhwb3J0cy4kcHVsbCA9IGZ1bmN0aW9uICRwdWxsKG9iaiwgcGF0aCwgdmFsKXtcbiAgb2JqID0gZG90LnBhcmVudChvYmosIHBhdGgsIHRydWUpO1xuICB2YXIga2V5ID0gcGF0aC5zcGxpdCgnLicpLnBvcCgpO1xuICB2YXIgdCA9IHR5cGUob2JqKTtcblxuICBzd2l0Y2ggKHQpIHtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGlmICgnYXJyYXknID09IHR5cGUob2JqW2tleV0pKSB7XG4gICAgICAgICAgdmFyIHB1bGxlZCA9IFtdO1xuICAgICAgICAgIHZhciBzcGxpY2UgPSBwdWxsKG9ialtrZXldLCBbdmFsXSwgcHVsbGVkKTtcbiAgICAgICAgICBpZiAocHVsbGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIHNwbGljZSgpO1xuICAgICAgICAgICAgICByZXR1cm4gcHVsbGVkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYXBwbHkgJHB1bGwvJHB1bGxBbGwgbW9kaWZpZXIgdG8gbm9uLWFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXJyYXknOlxuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGlmICgnYXJyYXknID09IHR5cGUob2JqW2tleV0pKSB7XG4gICAgICAgICAgdmFyIHB1bGxlZCA9IFtdO1xuICAgICAgICAgIHZhciBzcGxpY2UgPSBwdWxsKG9ialtrZXldLCBbdmFsXSwgcHVsbGVkKTtcbiAgICAgICAgICBpZiAocHVsbGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIHNwbGljZSgpO1xuICAgICAgICAgICAgICByZXR1cm4gcHVsbGVkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYXBwbHkgJHB1bGwvJHB1bGxBbGwgbW9kaWZpZXIgdG8gbm9uLWFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnKCdpZ25vcmluZyBwdWxsIHRvIG5vbiBhcnJheScpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKCd1bmRlZmluZWQnICE9IHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMRUZUX1NVQkZJRUxEIG9ubHkgc3VwcG9ydHMgT2JqZWN0OiBoZWxsbyBub3Q6ICcgKyB0KTtcbiAgICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGAkcHVsbEFsbGAuXG4gKi9cblxuZXhwb3J0cy4kcHVsbEFsbCA9IGZ1bmN0aW9uICRwdWxsQWxsKG9iaiwgcGF0aCwgdmFsKXtcbiAgaWYgKCdhcnJheScgIT0gdHlwZSh2YWwpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNb2RpZmllciAkcHVzaEFsbC9wdWxsQWxsIGFsbG93ZWQgZm9yIGFycmF5cyBvbmx5Jyk7XG4gIH1cblxuICBvYmogPSBkb3QucGFyZW50KG9iaiwgcGF0aCwgdHJ1ZSk7XG4gIHZhciBrZXkgPSBwYXRoLnNwbGl0KCcuJykucG9wKCk7XG4gIHZhciB0ID0gdHlwZShvYmopO1xuXG4gIHN3aXRjaCAodCkge1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgaWYgKCdhcnJheScgPT0gdHlwZShvYmpba2V5XSkpIHtcbiAgICAgICAgICB2YXIgcHVsbGVkID0gW107XG4gICAgICAgICAgdmFyIHNwbGljZSA9IHB1bGwob2JqW2tleV0sIHZhbCwgcHVsbGVkKTtcbiAgICAgICAgICBpZiAocHVsbGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIHNwbGljZSgpO1xuICAgICAgICAgICAgICByZXR1cm4gcHVsbGVkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYXBwbHkgJHB1bGwvJHB1bGxBbGwgbW9kaWZpZXIgdG8gbm9uLWFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXJyYXknOlxuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGlmICgnYXJyYXknID09IHR5cGUob2JqW2tleV0pKSB7XG4gICAgICAgICAgdmFyIHB1bGxlZCA9IFtdO1xuICAgICAgICAgIHZhciBzcGxpY2UgPSBwdWxsKG9ialtrZXldLCB2YWwsIHB1bGxlZCk7XG4gICAgICAgICAgaWYgKHB1bGxlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICBzcGxpY2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHB1bGxlZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFwcGx5ICRwdWxsLyRwdWxsQWxsIG1vZGlmaWVyIHRvIG5vbi1hcnJheScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1ZygnaWdub3JpbmcgcHVsbCB0byBub24gYXJyYXknKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICgndW5kZWZpbmVkJyAhPSB0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTEVGVF9TVUJGSUVMRCBvbmx5IHN1cHBvcnRzIE9iamVjdDogaGVsbG8gbm90OiAnICsgdCk7XG4gICAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBgJGFkZFRvU2V0YC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHRvIG1vZGlmeVxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdG8gYWx0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSB0byBwdXNoXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGludGVybmFsLCB0cnVlIGlmIHJlY3Vyc2luZ1xuICogQHJldHVybiB7RnVuY3Rpb259IHRyYW5zYWN0aW9uICh1bmxlc3Mgbm9vcClcbiAqL1xuXG5leHBvcnRzLiRhZGRUb1NldCA9IGZ1bmN0aW9uICRhZGRUb1NldChvYmosIHBhdGgsIHZhbCwgcmVjdXJzaW5nKXtcbiAgaWYgKCFyZWN1cnNpbmcgJiYgJ2FycmF5JyA9PSB0eXBlKHZhbC4kZWFjaCkpIHtcbiAgICB2YXIgZm5zID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWwuJGVhY2gubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgZm4gPSAkYWRkVG9TZXQob2JqLCBwYXRoLCB2YWwuJGVhY2hbaV0sIHRydWUpO1xuICAgICAgaWYgKGZuKSBmbnMucHVzaChmbik7XG4gICAgfVxuICAgIGlmIChmbnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykgdmFsdWVzLnB1c2goZm5zW2ldKCkpO1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIG9iaiA9IGRvdC5wYXJlbnQob2JqLCBwYXRoLCB0cnVlKTtcbiAgdmFyIGtleSA9IHBhdGguc3BsaXQoJy4nKS5wb3AoKTtcblxuICBzd2l0Y2ggKHR5cGUob2JqKSkge1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgaWYgKCdhcnJheScgPT0gdHlwZShvYmpba2V5XSkpIHtcbiAgICAgICAgICBpZiAoIWhhcyhvYmpba2V5XSwgdmFsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIG9ialtrZXldLnB1c2godmFsKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFwcGx5ICRhZGRUb1NldCBtb2RpZmllciB0byBub24tYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgb2JqW2tleV0gPSBbdmFsXTtcbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdhcnJheSc6XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgaWYgKCdhcnJheScgPT0gdHlwZShvYmpba2V5XSkpIHtcbiAgICAgICAgICBpZiAoIWhhcyhvYmpba2V5XSwgdmFsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIG9ialtrZXldLnB1c2godmFsKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFwcGx5ICRhZGRUb1NldCBtb2RpZmllciB0byBub24tYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChudW1lcmljKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgb2JqW2tleV0gPSBbdmFsXTtcbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5cXCd0IGFwcGVuZCB0byBhcnJheSB1c2luZyBzdHJpbmcgZmllbGQgbmFtZSBbJyArIGtleSArICddJyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxufTtcblxuLyoqXG4gKiBIZWxwZXIgZm9yIGRldGVybWluaW5nIGlmIGFuIGFycmF5IGhhcyB0aGUgZ2l2ZW4gdmFsdWUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSB0byBjaGVja1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBoYXMoYXJyYXksIHZhbCl7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGVxbCh2YWwsIGFycmF5W2ldKSkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEFycmF5I2ZpbHRlciBmdW5jdGlvbiBnZW5lcmF0b3IgZm9yIGAkcHVsbGAvYCRwdWxsQWxsYCBvcGVyYXRpb25zLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IG9mIHZhbHVlcyB0byBtYXRjaFxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgdG8gcG9wdWxhdGUgd2l0aCByZXN1bHRzXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdGhhdCBzcGxpY2VzIHRoZSBhcnJheVxuICovXG5cbmZ1bmN0aW9uIHB1bGwoYXJyLCB2YWxzLCBwdWxsZWQpe1xuICB2YXIgaW5kZXhlcyA9IFtdO1xuXG4gIGZvciAodmFyIGEgPSAwOyBhIDwgYXJyLmxlbmd0aDsgYSsrKSB7XG4gICAgdmFyIHZhbCA9IGFyclthXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFscy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG1hdGNoZXIgPSB2YWxzW2ldO1xuICAgICAgaWYgKCdvYmplY3QnID09IHR5cGUobWF0Y2hlcikpIHtcbiAgICAgICAgLy8gd2Ugb25seSBhcmUgb25seSBpbnRlcmVzdGVkIGluIG9iaiA8LT4gb2JqIGNvbXBhcmlzb25zXG4gICAgICAgIGlmICgnb2JqZWN0JyA9PSB0eXBlKHZhbCkpIHtcbiAgICAgICAgICB2YXIgbWF0Y2ggPSBmYWxzZTtcblxuICAgICAgICAgIGlmIChrZXlzKG1hdGNoZXIpLmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBtYXRjaGVyKSB7XG4gICAgICAgICAgICAgIGlmIChtYXRjaGVyLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCBhdCBsZWFzdCBvbmUgbWF0Y2hpbmcga2V5IHRvIHB1bGxcbiAgICAgICAgICAgICAgICBpZiAoZXFsKG1hdGNoZXJbaV0sIHZhbFtpXSkpIHtcbiAgICAgICAgICAgICAgICAgIG1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gaWYgYSBzaW5nbGUga2V5IGRvZXNuJ3QgbWF0Y2ggd2UgbW92ZSBvblxuICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoIWtleXModmFsKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHB1bGwgYHt9YCBtYXRjaGVzIFt7fV1cbiAgICAgICAgICAgIG1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGluZGV4ZXMucHVzaChhKTtcbiAgICAgICAgICAgIHB1bGxlZC5wdXNoKHZhbCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVidWcoJ2lnbm9yaW5nIHB1bGwgbWF0Y2ggYWdhaW5zdCBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVxbChtYXRjaGVyLCB2YWwpKSB7XG4gICAgICAgICAgaW5kZXhlcy5wdXNoKGEpO1xuICAgICAgICAgIHB1bGxlZC5wdXNoKHZhbCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGV4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpbmRleCA9IGluZGV4ZXNbaV07XG4gICAgICBhcnIuc3BsaWNlKGluZGV4IC0gaSwgMSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciB0byBkZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBudW1lcmljLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgbnVtZXJpY1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbnVtZXJpYyh2YWwpe1xuICByZXR1cm4gJ251bWJlcicgPT0gdHlwZSh2YWwpIHx8IE51bWJlcih2YWwpID09IHZhbDtcbn1cbiIsIi8qKlxuICogdG9TdHJpbmcgcmVmLlxuICovXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogUmV0dXJuIHRoZSB0eXBlIG9mIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCl7XG4gIHN3aXRjaCAodG9TdHJpbmcuY2FsbCh2YWwpKSB7XG4gICAgY2FzZSAnW29iamVjdCBEYXRlXSc6IHJldHVybiAnZGF0ZSc7XG4gICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzogcmV0dXJuICdyZWdleHAnO1xuICAgIGNhc2UgJ1tvYmplY3QgQXJndW1lbnRzXSc6IHJldHVybiAnYXJndW1lbnRzJztcbiAgICBjYXNlICdbb2JqZWN0IEFycmF5XSc6IHJldHVybiAnYXJyYXknO1xuICAgIGNhc2UgJ1tvYmplY3QgRXJyb3JdJzogcmV0dXJuICdlcnJvcic7XG4gIH1cblxuICBpZiAodmFsID09PSBudWxsKSByZXR1cm4gJ251bGwnO1xuICBpZiAodmFsID09PSB1bmRlZmluZWQpIHJldHVybiAndW5kZWZpbmVkJztcbiAgaWYgKHZhbCAhPT0gdmFsKSByZXR1cm4gJ25hbic7XG4gIGlmICh2YWwgJiYgdmFsLm5vZGVUeXBlID09PSAxKSByZXR1cm4gJ2VsZW1lbnQnO1xuXG4gIHZhbCA9IHZhbC52YWx1ZU9mXG4gICAgPyB2YWwudmFsdWVPZigpXG4gICAgOiBPYmplY3QucHJvdG90eXBlLnZhbHVlT2YuYXBwbHkodmFsKVxuXG4gIHJldHVybiB0eXBlb2YgdmFsO1xufTtcbiIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5cbi8qKlxuICogVXNlIGNocm9tZS5zdG9yYWdlLmxvY2FsIGlmIHdlIGFyZSBpbiBhbiBhcHBcbiAqL1xuXG52YXIgc3RvcmFnZTtcblxuaWYgKHR5cGVvZiBjaHJvbWUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjaHJvbWUuc3RvcmFnZSAhPT0gJ3VuZGVmaW5lZCcpXG4gIHN0b3JhZ2UgPSBjaHJvbWUuc3RvcmFnZS5sb2NhbDtcbmVsc2VcbiAgc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcbiAgJ2xpZ2h0c2VhZ3JlZW4nLFxuICAnZm9yZXN0Z3JlZW4nLFxuICAnZ29sZGVucm9kJyxcbiAgJ2RvZGdlcmJsdWUnLFxuICAnZGFya29yY2hpZCcsXG4gICdjcmltc29uJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIHJldHVybiAoJ1dlYmtpdEFwcGVhcmFuY2UnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSkgfHxcbiAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gICAgKHdpbmRvdy5jb25zb2xlICYmIChjb25zb2xlLmZpcmVidWcgfHwgKGNvbnNvbGUuZXhjZXB0aW9uICYmIGNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpO1xufVxuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xufTtcblxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoKSB7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cbiAgYXJnc1swXSA9ICh1c2VDb2xvcnMgPyAnJWMnIDogJycpXG4gICAgKyB0aGlzLm5hbWVzcGFjZVxuICAgICsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKVxuICAgICsgYXJnc1swXVxuICAgICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKVxuICAgICsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdXNlQ29sb3JzKSByZXR1cm4gYXJncztcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3MgPSBbYXJnc1swXSwgYywgJ2NvbG9yOiBpbmhlcml0J10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDEpKTtcblxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16JV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICBpbmRleCsrO1xuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbiAgcmV0dXJuIGFyZ3M7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gc3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG4iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZGVidWc7XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbmV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5leHBvcnRzLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAqL1xuXG5leHBvcnRzLm5hbWVzID0gW107XG5leHBvcnRzLnNraXBzID0gW107XG5cbi8qKlxuICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICpcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyY2FzZWQgbGV0dGVyLCBpLmUuIFwiblwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFByZXZpb3VzbHkgYXNzaWduZWQgY29sb3IuXG4gKi9cblxudmFyIHByZXZDb2xvciA9IDA7XG5cbi8qKlxuICogUHJldmlvdXMgbG9nIHRpbWVzdGFtcC5cbiAqL1xuXG52YXIgcHJldlRpbWU7XG5cbi8qKlxuICogU2VsZWN0IGEgY29sb3IuXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IoKSB7XG4gIHJldHVybiBleHBvcnRzLmNvbG9yc1twcmV2Q29sb3IrKyAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlYnVnKG5hbWVzcGFjZSkge1xuXG4gIC8vIGRlZmluZSB0aGUgYGRpc2FibGVkYCB2ZXJzaW9uXG4gIGZ1bmN0aW9uIGRpc2FibGVkKCkge1xuICB9XG4gIGRpc2FibGVkLmVuYWJsZWQgPSBmYWxzZTtcblxuICAvLyBkZWZpbmUgdGhlIGBlbmFibGVkYCB2ZXJzaW9uXG4gIGZ1bmN0aW9uIGVuYWJsZWQoKSB7XG5cbiAgICB2YXIgc2VsZiA9IGVuYWJsZWQ7XG5cbiAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxuICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICBzZWxmLmRpZmYgPSBtcztcbiAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgIHByZXZUaW1lID0gY3VycjtcblxuICAgIC8vIGFkZCB0aGUgYGNvbG9yYCBpZiBub3Qgc2V0XG4gICAgaWYgKG51bGwgPT0gc2VsZi51c2VDb2xvcnMpIHNlbGYudXNlQ29sb3JzID0gZXhwb3J0cy51c2VDb2xvcnMoKTtcbiAgICBpZiAobnVsbCA9PSBzZWxmLmNvbG9yICYmIHNlbGYudXNlQ29sb3JzKSBzZWxmLmNvbG9yID0gc2VsZWN0Q29sb3IoKTtcblxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVvXG4gICAgICBhcmdzID0gWyclbyddLmNvbmNhdChhcmdzKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16JV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuXG4gICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmZvcm1hdEFyZ3MpIHtcbiAgICAgIGFyZ3MgPSBleHBvcnRzLmZvcm1hdEFyZ3MuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfVxuICAgIHZhciBsb2dGbiA9IGVuYWJsZWQubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cbiAgZW5hYmxlZC5lbmFibGVkID0gdHJ1ZTtcblxuICB2YXIgZm4gPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKSA/IGVuYWJsZWQgOiBkaXNhYmxlZDtcblxuICBmbi5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cbiAgcmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIHZhciBzcGxpdCA9IChuYW1lc3BhY2VzIHx8ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICBleHBvcnRzLmVuYWJsZSgnJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cbiIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpe1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB2YWwpIHJldHVybiBwYXJzZSh2YWwpO1xuICByZXR1cm4gb3B0aW9ucy5sb25nXG4gICAgPyBsb25nKHZhbClcbiAgICA6IHNob3J0KHZhbCk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhzdHIpO1xuICBpZiAoIW1hdGNoKSByZXR1cm47XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNob3J0KG1zKSB7XG4gIGlmIChtcyA+PSBkKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICBpZiAobXMgPj0gaCkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgaWYgKG1zID49IG0pIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIGlmIChtcyA+PSBzKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9uZyhtcykge1xuICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JylcbiAgICB8fCBwbHVyYWwobXMsIGgsICdob3VyJylcbiAgICB8fCBwbHVyYWwobXMsIG0sICdtaW51dGUnKVxuICAgIHx8IHBsdXJhbChtcywgcywgJ3NlY29uZCcpXG4gICAgfHwgbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcbiAgaWYgKG1zIDwgbikgcmV0dXJuO1xuICBpZiAobXMgPCBuICogMS41KSByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZTtcbiAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJztcbn1cbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB0eXBlID0gcmVxdWlyZSgndHlwZS1jb21wb25lbnQnKTtcblxuLyoqXG4gKiBHZXRzIGEgY2VydGFpbiBgcGF0aGAgZnJvbSB0aGUgYG9iamAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHJldHVybiB7T2JqZWN0fSBmb3VuZCBvYmplY3QsIG9yIGB1bmRlZmluZWRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5nZXQgPSBmdW5jdGlvbihvYmosIHBhdGgpe1xuICBpZiAofnBhdGguaW5kZXhPZignLicpKSB7XG4gICAgdmFyIHBhciA9IHBhcmVudChvYmosIHBhdGgpO1xuICAgIHZhciBtYWluS2V5ID0gcGF0aC5zcGxpdCgnLicpLnBvcCgpO1xuICAgIHZhciB0ID0gdHlwZShwYXIpO1xuICAgIGlmICgnb2JqZWN0JyA9PSB0IHx8ICdhcnJheScgPT0gdCkgcmV0dXJuIHBhclttYWluS2V5XTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqW3BhdGhdO1xuICB9XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGdpdmVuIGBwYXRoYCB0byBgdmFsYCBpbiBgb2JqYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAUGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5zZXQgPSBmdW5jdGlvbihvYmosIHBhdGgsIHZhbCl7XG4gIGlmICh+cGF0aC5pbmRleE9mKCcuJykpIHtcbiAgICB2YXIgcGFyID0gcGFyZW50KG9iaiwgcGF0aCwgdHJ1ZSk7XG4gICAgdmFyIG1haW5LZXkgPSBwYXRoLnNwbGl0KCcuJykucG9wKCk7XG4gICAgaWYgKHBhciAmJiAnb2JqZWN0JyA9PSB0eXBlKHBhcikpIHBhclttYWluS2V5XSA9IHZhbDtcbiAgfSBlbHNlIHtcbiAgICBvYmpbcGF0aF0gPSB2YWw7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0cyB0aGUgcGFyZW50IG9iamVjdCBmb3IgYSBnaXZlbiBrZXkgKGRvdCBub3RhdGlvbiBhd2FyZSkuXG4gKlxuICogLSBJZiBhIHBhcmVudCBvYmplY3QgZG9lc24ndCBleGlzdCwgaXQncyBpbml0aWFsaXplZC5cbiAqIC0gQXJyYXkgaW5kZXggbG9va3VwIGlzIHN1cHBvcnRlZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgb2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge0Jvb2xlYW59IHRydWUgaWYgaXQgc2hvdWxkIGluaXRpYWxpemUgdGhlIHBhdGhcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wYXJlbnQgPSBwYXJlbnQ7XG5cbmZ1bmN0aW9uIHBhcmVudChvYmosIGtleSwgaW5pdCl7XG4gIGlmICh+a2V5LmluZGV4T2YoJy4nKSkge1xuICAgIHZhciBwaWVjZXMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgICB2YXIgcmV0ID0gb2JqO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwaWVjZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAvLyBpZiB0aGUga2V5IGlzIGEgbnVtYmVyIHN0cmluZyBhbmQgcGFyZW50IGlzIGFuIGFycmF5XG4gICAgICBpZiAoTnVtYmVyKHBpZWNlc1tpXSkgPT0gcGllY2VzW2ldICYmICdhcnJheScgPT0gdHlwZShyZXQpKSB7XG4gICAgICAgIHJldCA9IHJldFtwaWVjZXNbaV1dO1xuICAgICAgfSBlbHNlIGlmICgnb2JqZWN0JyA9PSB0eXBlKHJldCkpIHtcbiAgICAgICAgaWYgKGluaXQgJiYgIXJldC5oYXNPd25Qcm9wZXJ0eShwaWVjZXNbaV0pKSB7XG4gICAgICAgICAgcmV0W3BpZWNlc1tpXV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmV0KSByZXQgPSByZXRbcGllY2VzW2ldXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbn1cbiIsIlxuLyoqXG4gKiB0b1N0cmluZyByZWYuXG4gKi9cblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHR5cGUgb2YgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsKXtcbiAgc3dpdGNoICh0b1N0cmluZy5jYWxsKHZhbCkpIHtcbiAgICBjYXNlICdbb2JqZWN0IEZ1bmN0aW9uXSc6IHJldHVybiAnZnVuY3Rpb24nO1xuICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOiByZXR1cm4gJ2RhdGUnO1xuICAgIGNhc2UgJ1tvYmplY3QgUmVnRXhwXSc6IHJldHVybiAncmVnZXhwJztcbiAgICBjYXNlICdbb2JqZWN0IEFyZ3VtZW50c10nOiByZXR1cm4gJ2FyZ3VtZW50cyc7XG4gICAgY2FzZSAnW29iamVjdCBBcnJheV0nOiByZXR1cm4gJ2FycmF5JztcbiAgfVxuXG4gIGlmICh2YWwgPT09IG51bGwpIHJldHVybiAnbnVsbCc7XG4gIGlmICh2YWwgPT09IHVuZGVmaW5lZCkgcmV0dXJuICd1bmRlZmluZWQnO1xuICBpZiAodmFsID09PSBPYmplY3QodmFsKSkgcmV0dXJuICdvYmplY3QnO1xuXG4gIHJldHVybiB0eXBlb2YgdmFsO1xufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB0eXBlID0gcmVxdWlyZSgnY29tcG9uZW50LXR5cGUnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVxbDtcblxuLyoqXG4gKiBNb25nb0RCIHN0eWxlIHZhbHVlIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXRjaGVyXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhleSBtYXRjaFxuICovXG5cbmZ1bmN0aW9uIGVxbChtYXRjaGVyLCB2YWwpe1xuICBzd2l0Y2ggKHR5cGUobWF0Y2hlcikpIHtcbiAgICBjYXNlICdudWxsJzpcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgLy8gd2UgdHJlYXQgbnVsbCBhcyB1bmRlZmluZWRcbiAgICAgIHJldHVybiBudWxsID09IHZhbDtcblxuICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICByZXR1cm4gbWF0Y2hlci50ZXN0KHZhbCk7XG5cbiAgICBjYXNlICdhcnJheSc6XG4gICAgICBpZiAoJ2FycmF5JyA9PSB0eXBlKHZhbCkgJiYgbWF0Y2hlci5sZW5ndGggPT0gdmFsLmxlbmd0aCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoIWVxbCh2YWxbaV0sIG1hdGNoZXJbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAvLyBvYmplY3QgY2FuIG1hdGNoIGtleXMgaW4gYW55IG9yZGVyXG4gICAgICB2YXIga2V5cyA9IHt9O1xuXG4gICAgICAvLyB3ZSBtYXRjaCBhbGwgdmFsdWVzIG9mIGBtYXRjaGVyYCBpbiBgdmFsYFxuICAgICAgZm9yICh2YXIgaSBpbiBtYXRjaGVyKSB7XG4gICAgICAgIGlmIChtYXRjaGVyLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgaWYgKCF2YWwuaGFzT3duUHJvcGVydHkoaSkgfHwgIWVxbChtYXRjaGVyW2ldLCB2YWxbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGtleXNbaV0gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyB3ZSBtYWtlIHN1cmUgYHZhbGAgZG9lc24ndCBoYXZlIGV4dHJhIGtleXNcbiAgICAgIGZvciAodmFyIGkgaW4gdmFsKSB7XG4gICAgICAgIGlmICh2YWwuaGFzT3duUHJvcGVydHkoaSkgJiYgIWtleXMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG1hdGNoZXIgPT09IHZhbDtcbiAgfVxufVxuIiwiXG4vKipcbiAqIEhPUCByZWYuXG4gKi9cblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogUmV0dXJuIG93biBrZXlzIGluIGBvYmpgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbihvYmope1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBrZXlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gb3duIHZhbHVlcyBpbiBgb2JqYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy52YWx1ZXMgPSBmdW5jdGlvbihvYmope1xuICB2YXIgdmFscyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgdmFscy5wdXNoKG9ialtrZXldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHM7XG59O1xuXG4vKipcbiAqIE1lcmdlIGBiYCBpbnRvIGBhYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYVxuICogQHBhcmFtIHtPYmplY3R9IGJcbiAqIEByZXR1cm4ge09iamVjdH0gYVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLm1lcmdlID0gZnVuY3Rpb24oYSwgYil7XG4gIGZvciAodmFyIGtleSBpbiBiKSB7XG4gICAgaWYgKGhhcy5jYWxsKGIsIGtleSkpIHtcbiAgICAgIGFba2V5XSA9IGJba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGE7XG59O1xuXG4vKipcbiAqIFJldHVybiBsZW5ndGggb2YgYG9iamAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmxlbmd0aCA9IGZ1bmN0aW9uKG9iail7XG4gIHJldHVybiBleHBvcnRzLmtleXMob2JqKS5sZW5ndGg7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGVtcHR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuaXNFbXB0eSA9IGZ1bmN0aW9uKG9iail7XG4gIHJldHVybiAwID09IGV4cG9ydHMubGVuZ3RoKG9iaik7XG59OyIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBlcWwgPSByZXF1aXJlKCdtb25nby1lcWwnKTtcbnZhciB0eXBlID0gcmVxdWlyZSgnY29tcG9uZW50LXR5cGUnKTtcblxuLyoqXG4gKiAkbmU6IG5vdCBlcXVhbC5cbiAqL1xuXG5leHBvcnRzLiRuZSA9IGZ1bmN0aW9uICRuZShtYXRjaGVyLCB2YWwpe1xuICByZXR1cm4gIWVxbChtYXRjaGVyLCB2YWwpO1xufTtcblxuLyoqXG4gKiAkZ3Q6IGdyZWF0ZXIgdGhhbi5cbiAqL1xuXG5leHBvcnRzLiRndCA9IGZ1bmN0aW9uICRndChtYXRjaGVyLCB2YWwpe1xuICByZXR1cm4gdHlwZShtYXRjaGVyKSA9PT0gJ251bWJlcicgJiYgdmFsID4gbWF0Y2hlcjtcbn07XG5cbi8qKlxuICogJGd0ZTogZ3JlYXRlciB0aGFuIGVxdWFsLlxuICovXG5cbmV4cG9ydHMuJGd0ZSA9IGZ1bmN0aW9uICRndGUobWF0Y2hlciwgdmFsKXtcbiAgcmV0dXJuIHR5cGUobWF0Y2hlcikgPT09ICdudW1iZXInICYmIHZhbCA+PSBtYXRjaGVyO1xufTtcblxuLyoqXG4gKiAkbHQ6IGxlc3MgdGhhbi5cbiAqL1xuXG5leHBvcnRzLiRsdCA9IGZ1bmN0aW9uICRsdChtYXRjaGVyLCB2YWwpe1xuICByZXR1cm4gdHlwZShtYXRjaGVyKSA9PT0gJ251bWJlcicgJiYgdmFsIDwgbWF0Y2hlcjtcbn07XG5cbi8qKlxuICogJGx0ZTogbGVzcyB0aGFuIGVxdWFsLlxuICovXG5cbmV4cG9ydHMuJGx0ZSA9IGZ1bmN0aW9uICRsdGUobWF0Y2hlciwgdmFsKXtcbiAgcmV0dXJuIHR5cGUobWF0Y2hlcikgPT09ICdudW1iZXInICYmIHZhbCA8PSBtYXRjaGVyO1xufTtcblxuLyoqXG4gKiAkcmVnZXg6IHN1cHBseSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBhcyBhIHN0cmluZy5cbiAqL1xuXG5leHBvcnRzLiRyZWdleCA9IGZ1bmN0aW9uICRyZWdleChtYXRjaGVyLCB2YWwpe1xuICAvLyBUT0RPOiBhZGQgJG9wdGlvbnMgc3VwcG9ydFxuICBpZiAoJ3JlZ2V4cCcgIT0gdHlwZSgnbWF0Y2hlcicpKSBtYXRjaGVyID0gbmV3IFJlZ0V4cChtYXRjaGVyKTtcbiAgcmV0dXJuIG1hdGNoZXIudGVzdCh2YWwpO1xufTtcblxuLyoqXG4gKiAkZXhpc3RzOiBrZXkgZXhpc3RzLlxuICovXG5cbmV4cG9ydHMuJGV4aXN0cyA9IGZ1bmN0aW9uICRleGlzdHMobWF0Y2hlciwgdmFsKXtcbiAgaWYgKG1hdGNoZXIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkICE9PSB2YWw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZCA9PT0gdmFsO1xuICB9XG59O1xuXG4vKipcbiAqICRpbjogdmFsdWUgaW4gYXJyYXkuXG4gKi9cblxuZXhwb3J0cy4kaW4gPSBmdW5jdGlvbiAkaW4obWF0Y2hlciwgdmFsKXtcbiAgaWYgKCdhcnJheScgIT0gdHlwZShtYXRjaGVyKSkgcmV0dXJuIGZhbHNlO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoZXIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZXFsKG1hdGNoZXJbaV0sIHZhbCkpIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogJG5pbjogdmFsdWUgbm90IGluIGFycmF5LlxuICovXG5cbmV4cG9ydHMuJG5pbiA9IGZ1bmN0aW9uICRuaW4obWF0Y2hlciwgdmFsKXtcbiAgcmV0dXJuICFleHBvcnRzLiRpbihtYXRjaGVyLCB2YWwpO1xufTtcblxuLyoqXG4gKiBAc2l6ZTogYXJyYXkgbGVuZ3RoXG4gKi9cblxuZXhwb3J0cy4kc2l6ZSA9IGZ1bmN0aW9uKG1hdGNoZXIsIHZhbCl7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbCkgJiYgbWF0Y2hlciA9PSB2YWwubGVuZ3RoO1xufTtcbiIsInZhciBDcnlwdG9KUyA9IHJlcXVpcmUoJy4vbGliL2NvcmUnKS5DcnlwdG9KUztcbnJlcXVpcmUoJy4vbGliL2VuYy1iYXNlNjQnKTtcbnJlcXVpcmUoJy4vbGliL21kNScpO1xucmVxdWlyZSgnLi9saWIvZXZwa2RmJyk7XG5yZXF1aXJlKCcuL2xpYi9jaXBoZXItY29yZScpO1xucmVxdWlyZSgnLi9saWIvYWVzJyk7XG52YXIgSnNvbkZvcm1hdHRlciA9IHJlcXVpcmUoJy4vbGliL2pzb25mb3JtYXR0ZXInKS5Kc29uRm9ybWF0dGVyO1xuXG5leHBvcnRzLkNyeXB0b0pTID0gQ3J5cHRvSlM7XG5leHBvcnRzLkpzb25Gb3JtYXR0ZXIgPSBKc29uRm9ybWF0dGVyOyIsInZhciBDcnlwdG9KUyA9IHJlcXVpcmUoJy4vY29yZScpLkNyeXB0b0pTO1xyXG5cclxuLypcbkNyeXB0b0pTIHYzLjEuMlxuY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzXG4oYykgMjAwOS0yMDEzIGJ5IEplZmYgTW90dC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbmNvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qcy93aWtpL0xpY2Vuc2VcbiovXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gU2hvcnRjdXRzXHJcbiAgICB2YXIgQyA9IENyeXB0b0pTO1xyXG4gICAgdmFyIENfbGliID0gQy5saWI7XHJcbiAgICB2YXIgQmxvY2tDaXBoZXIgPSBDX2xpYi5CbG9ja0NpcGhlcjtcclxuICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XHJcblxyXG4gICAgLy8gTG9va3VwIHRhYmxlc1xyXG4gICAgdmFyIFNCT1ggPSBbXTtcclxuICAgIHZhciBJTlZfU0JPWCA9IFtdO1xyXG4gICAgdmFyIFNVQl9NSVhfMCA9IFtdO1xyXG4gICAgdmFyIFNVQl9NSVhfMSA9IFtdO1xyXG4gICAgdmFyIFNVQl9NSVhfMiA9IFtdO1xyXG4gICAgdmFyIFNVQl9NSVhfMyA9IFtdO1xyXG4gICAgdmFyIElOVl9TVUJfTUlYXzAgPSBbXTtcclxuICAgIHZhciBJTlZfU1VCX01JWF8xID0gW107XHJcbiAgICB2YXIgSU5WX1NVQl9NSVhfMiA9IFtdO1xyXG4gICAgdmFyIElOVl9TVUJfTUlYXzMgPSBbXTtcclxuXHJcbiAgICAvLyBDb21wdXRlIGxvb2t1cCB0YWJsZXNcclxuICAgIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gQ29tcHV0ZSBkb3VibGUgdGFibGVcclxuICAgICAgICB2YXIgZCA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGkgPCAxMjgpIHtcclxuICAgICAgICAgICAgICAgIGRbaV0gPSBpIDw8IDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkW2ldID0gKGkgPDwgMSkgXiAweDExYjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gV2FsayBHRigyXjgpXHJcbiAgICAgICAgdmFyIHggPSAwO1xyXG4gICAgICAgIHZhciB4aSA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBDb21wdXRlIHNib3hcclxuICAgICAgICAgICAgdmFyIHN4ID0geGkgXiAoeGkgPDwgMSkgXiAoeGkgPDwgMikgXiAoeGkgPDwgMykgXiAoeGkgPDwgNCk7XHJcbiAgICAgICAgICAgIHN4ID0gKHN4ID4+PiA4KSBeIChzeCAmIDB4ZmYpIF4gMHg2MztcclxuICAgICAgICAgICAgU0JPWFt4XSA9IHN4O1xyXG4gICAgICAgICAgICBJTlZfU0JPWFtzeF0gPSB4O1xyXG5cclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBtdWx0aXBsaWNhdGlvblxyXG4gICAgICAgICAgICB2YXIgeDIgPSBkW3hdO1xyXG4gICAgICAgICAgICB2YXIgeDQgPSBkW3gyXTtcclxuICAgICAgICAgICAgdmFyIHg4ID0gZFt4NF07XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wdXRlIHN1YiBieXRlcywgbWl4IGNvbHVtbnMgdGFibGVzXHJcbiAgICAgICAgICAgIHZhciB0ID0gKGRbc3hdICogMHgxMDEpIF4gKHN4ICogMHgxMDEwMTAwKTtcclxuICAgICAgICAgICAgU1VCX01JWF8wW3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpO1xyXG4gICAgICAgICAgICBTVUJfTUlYXzFbeF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpO1xyXG4gICAgICAgICAgICBTVUJfTUlYXzJbeF0gPSAodCA8PCA4KSAgfCAodCA+Pj4gMjQpO1xyXG4gICAgICAgICAgICBTVUJfTUlYXzNbeF0gPSB0O1xyXG5cclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBpbnYgc3ViIGJ5dGVzLCBpbnYgbWl4IGNvbHVtbnMgdGFibGVzXHJcbiAgICAgICAgICAgIHZhciB0ID0gKHg4ICogMHgxMDEwMTAxKSBeICh4NCAqIDB4MTAwMDEpIF4gKHgyICogMHgxMDEpIF4gKHggKiAweDEwMTAxMDApO1xyXG4gICAgICAgICAgICBJTlZfU1VCX01JWF8wW3N4XSA9ICh0IDw8IDI0KSB8ICh0ID4+PiA4KTtcclxuICAgICAgICAgICAgSU5WX1NVQl9NSVhfMVtzeF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpO1xyXG4gICAgICAgICAgICBJTlZfU1VCX01JWF8yW3N4XSA9ICh0IDw8IDgpICB8ICh0ID4+PiAyNCk7XHJcbiAgICAgICAgICAgIElOVl9TVUJfTUlYXzNbc3hdID0gdDtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgbmV4dCBjb3VudGVyXHJcbiAgICAgICAgICAgIGlmICgheCkge1xyXG4gICAgICAgICAgICAgICAgeCA9IHhpID0gMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHggPSB4MiBeIGRbZFtkW3g4IF4geDJdXV07XHJcbiAgICAgICAgICAgICAgICB4aSBePSBkW2RbeGldXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0oKSk7XHJcblxyXG4gICAgLy8gUHJlY29tcHV0ZWQgUmNvbiBsb29rdXBcclxuICAgIHZhciBSQ09OID0gWzB4MDAsIDB4MDEsIDB4MDIsIDB4MDQsIDB4MDgsIDB4MTAsIDB4MjAsIDB4NDAsIDB4ODAsIDB4MWIsIDB4MzZdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQUVTIGJsb2NrIGNpcGhlciBhbGdvcml0aG0uXHJcbiAgICAgKi9cclxuICAgIHZhciBBRVMgPSBDX2FsZ28uQUVTID0gQmxvY2tDaXBoZXIuZXh0ZW5kKHtcclxuICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBTaG9ydGN1dHNcclxuICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuX2tleTtcclxuICAgICAgICAgICAgdmFyIGtleVdvcmRzID0ga2V5LndvcmRzO1xyXG4gICAgICAgICAgICB2YXIga2V5U2l6ZSA9IGtleS5zaWdCeXRlcyAvIDQ7XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wdXRlIG51bWJlciBvZiByb3VuZHNcclxuICAgICAgICAgICAgdmFyIG5Sb3VuZHMgPSB0aGlzLl9uUm91bmRzID0ga2V5U2l6ZSArIDZcclxuXHJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgbnVtYmVyIG9mIGtleSBzY2hlZHVsZSByb3dzXHJcbiAgICAgICAgICAgIHZhciBrc1Jvd3MgPSAoblJvdW5kcyArIDEpICogNDtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbXB1dGUga2V5IHNjaGVkdWxlXHJcbiAgICAgICAgICAgIHZhciBrZXlTY2hlZHVsZSA9IHRoaXMuX2tleVNjaGVkdWxlID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGtzUm93ID0gMDsga3NSb3cgPCBrc1Jvd3M7IGtzUm93KyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChrc1JvdyA8IGtleVNpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXlTY2hlZHVsZVtrc1Jvd10gPSBrZXlXb3Jkc1trc1Jvd107XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0ga2V5U2NoZWR1bGVba3NSb3cgLSAxXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoa3NSb3cgJSBrZXlTaXplKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSb3Qgd29yZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3ViIHdvcmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IChTQk9YW3QgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3QgJiAweGZmXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1peCBSY29uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgXj0gUkNPTlsoa3NSb3cgLyBrZXlTaXplKSB8IDBdIDw8IDI0O1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5U2l6ZSA+IDYgJiYga3NSb3cgJSBrZXlTaXplID09IDQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3ViIHdvcmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IChTQk9YW3QgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3QgJiAweGZmXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGtleVNjaGVkdWxlW2tzUm93XSA9IGtleVNjaGVkdWxlW2tzUm93IC0ga2V5U2l6ZV0gXiB0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wdXRlIGludiBrZXkgc2NoZWR1bGVcclxuICAgICAgICAgICAgdmFyIGludktleVNjaGVkdWxlID0gdGhpcy5faW52S2V5U2NoZWR1bGUgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaW52S3NSb3cgPSAwOyBpbnZLc1JvdyA8IGtzUm93czsgaW52S3NSb3crKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtzUm93ID0ga3NSb3dzIC0gaW52S3NSb3c7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGludktzUm93ICUgNCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0ga2V5U2NoZWR1bGVba3NSb3ddO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGtleVNjaGVkdWxlW2tzUm93IC0gNF07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGludktzUm93IDwgNCB8fCBrc1JvdyA8PSA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gdDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gSU5WX1NVQl9NSVhfMFtTQk9YW3QgPj4+IDI0XV0gXiBJTlZfU1VCX01JWF8xW1NCT1hbKHQgPj4+IDE2KSAmIDB4ZmZdXSBeXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSU5WX1NVQl9NSVhfMltTQk9YWyh0ID4+PiA4KSAmIDB4ZmZdXSBeIElOVl9TVUJfTUlYXzNbU0JPWFt0ICYgMHhmZl1dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZW5jcnlwdEJsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RvQ3J5cHRCbG9jayhNLCBvZmZzZXQsIHRoaXMuX2tleVNjaGVkdWxlLCBTVUJfTUlYXzAsIFNVQl9NSVhfMSwgU1VCX01JWF8yLCBTVUJfTUlYXzMsIFNCT1gpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGRlY3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xyXG4gICAgICAgICAgICAvLyBTd2FwIDJuZCBhbmQgNHRoIHJvd3NcclxuICAgICAgICAgICAgdmFyIHQgPSBNW29mZnNldCArIDFdO1xyXG4gICAgICAgICAgICBNW29mZnNldCArIDFdID0gTVtvZmZzZXQgKyAzXTtcclxuICAgICAgICAgICAgTVtvZmZzZXQgKyAzXSA9IHQ7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9kb0NyeXB0QmxvY2soTSwgb2Zmc2V0LCB0aGlzLl9pbnZLZXlTY2hlZHVsZSwgSU5WX1NVQl9NSVhfMCwgSU5WX1NVQl9NSVhfMSwgSU5WX1NVQl9NSVhfMiwgSU5WX1NVQl9NSVhfMywgSU5WX1NCT1gpO1xyXG5cclxuICAgICAgICAgICAgLy8gSW52IHN3YXAgMm5kIGFuZCA0dGggcm93c1xyXG4gICAgICAgICAgICB2YXIgdCA9IE1bb2Zmc2V0ICsgMV07XHJcbiAgICAgICAgICAgIE1bb2Zmc2V0ICsgMV0gPSBNW29mZnNldCArIDNdO1xyXG4gICAgICAgICAgICBNW29mZnNldCArIDNdID0gdDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZG9DcnlwdEJsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0LCBrZXlTY2hlZHVsZSwgU1VCX01JWF8wLCBTVUJfTUlYXzEsIFNVQl9NSVhfMiwgU1VCX01JWF8zLCBTQk9YKSB7XHJcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0XHJcbiAgICAgICAgICAgIHZhciBuUm91bmRzID0gdGhpcy5fblJvdW5kcztcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCBpbnB1dCwgYWRkIHJvdW5kIGtleVxyXG4gICAgICAgICAgICB2YXIgczAgPSBNW29mZnNldF0gICAgIF4ga2V5U2NoZWR1bGVbMF07XHJcbiAgICAgICAgICAgIHZhciBzMSA9IE1bb2Zmc2V0ICsgMV0gXiBrZXlTY2hlZHVsZVsxXTtcclxuICAgICAgICAgICAgdmFyIHMyID0gTVtvZmZzZXQgKyAyXSBeIGtleVNjaGVkdWxlWzJdO1xyXG4gICAgICAgICAgICB2YXIgczMgPSBNW29mZnNldCArIDNdIF4ga2V5U2NoZWR1bGVbM107XHJcblxyXG4gICAgICAgICAgICAvLyBLZXkgc2NoZWR1bGUgcm93IGNvdW50ZXJcclxuICAgICAgICAgICAgdmFyIGtzUm93ID0gNDtcclxuXHJcbiAgICAgICAgICAgIC8vIFJvdW5kc1xyXG4gICAgICAgICAgICBmb3IgKHZhciByb3VuZCA9IDE7IHJvdW5kIDwgblJvdW5kczsgcm91bmQrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gU2hpZnQgcm93cywgc3ViIGJ5dGVzLCBtaXggY29sdW1ucywgYWRkIHJvdW5kIGtleVxyXG4gICAgICAgICAgICAgICAgdmFyIHQwID0gU1VCX01JWF8wW3MwID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMxID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczIgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczMgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHQxID0gU1VCX01JWF8wW3MxID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMyID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczMgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczAgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHQyID0gU1VCX01JWF8wW3MyID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMzID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczAgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczEgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHQzID0gU1VCX01JWF8wW3MzID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMwID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczEgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczIgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBzdGF0ZVxyXG4gICAgICAgICAgICAgICAgczAgPSB0MDtcclxuICAgICAgICAgICAgICAgIHMxID0gdDE7XHJcbiAgICAgICAgICAgICAgICBzMiA9IHQyO1xyXG4gICAgICAgICAgICAgICAgczMgPSB0MztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU2hpZnQgcm93cywgc3ViIGJ5dGVzLCBhZGQgcm91bmQga2V5XHJcbiAgICAgICAgICAgIHZhciB0MCA9ICgoU0JPWFtzMCA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMSA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMyID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMyAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xyXG4gICAgICAgICAgICB2YXIgdDEgPSAoKFNCT1hbczEgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczIgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMyA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczAgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcclxuICAgICAgICAgICAgdmFyIHQyID0gKChTQk9YW3MyID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMzID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczAgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MxICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK107XHJcbiAgICAgICAgICAgIHZhciB0MyA9ICgoU0JPWFtzMyA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMxID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMiAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xyXG5cclxuICAgICAgICAgICAgLy8gU2V0IG91dHB1dFxyXG4gICAgICAgICAgICBNW29mZnNldF0gICAgID0gdDA7XHJcbiAgICAgICAgICAgIE1bb2Zmc2V0ICsgMV0gPSB0MTtcclxuICAgICAgICAgICAgTVtvZmZzZXQgKyAyXSA9IHQyO1xyXG4gICAgICAgICAgICBNW29mZnNldCArIDNdID0gdDM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAga2V5U2l6ZTogMjU2LzMyXHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9ucyB0byB0aGUgY2lwaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqICAgICB2YXIgY2lwaGVydGV4dCA9IENyeXB0b0pTLkFFUy5lbmNyeXB0KG1lc3NhZ2UsIGtleSwgY2ZnKTtcclxuICAgICAqICAgICB2YXIgcGxhaW50ZXh0ICA9IENyeXB0b0pTLkFFUy5kZWNyeXB0KGNpcGhlcnRleHQsIGtleSwgY2ZnKTtcclxuICAgICAqL1xyXG4gICAgQy5BRVMgPSBCbG9ja0NpcGhlci5fY3JlYXRlSGVscGVyKEFFUyk7XHJcbn0oKSk7XHJcbiIsInZhciBDcnlwdG9KUyA9IHJlcXVpcmUoJy4vY29yZScpLkNyeXB0b0pTO1xyXG5cclxuLypcbkNyeXB0b0pTIHYzLjEuMlxuY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzXG4oYykgMjAwOS0yMDEzIGJ5IEplZmYgTW90dC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbmNvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qcy93aWtpL0xpY2Vuc2VcbiovXG4vKipcclxuICogQ2lwaGVyIGNvcmUgY29tcG9uZW50cy5cclxuICovXHJcbkNyeXB0b0pTLmxpYi5DaXBoZXIgfHwgKGZ1bmN0aW9uICh1bmRlZmluZWQpIHtcclxuICAgIC8vIFNob3J0Y3V0c1xyXG4gICAgdmFyIEMgPSBDcnlwdG9KUztcclxuICAgIHZhciBDX2xpYiA9IEMubGliO1xyXG4gICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlO1xyXG4gICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcclxuICAgIHZhciBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtID0gQ19saWIuQnVmZmVyZWRCbG9ja0FsZ29yaXRobTtcclxuICAgIHZhciBDX2VuYyA9IEMuZW5jO1xyXG4gICAgdmFyIFV0ZjggPSBDX2VuYy5VdGY4O1xyXG4gICAgdmFyIEJhc2U2NCA9IENfZW5jLkJhc2U2NDtcclxuICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XHJcbiAgICB2YXIgRXZwS0RGID0gQ19hbGdvLkV2cEtERjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFic3RyYWN0IGJhc2UgY2lwaGVyIHRlbXBsYXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBrZXlTaXplIFRoaXMgY2lwaGVyJ3Mga2V5IHNpemUuIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGl2U2l6ZSBUaGlzIGNpcGhlcidzIElWIHNpemUuIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9FTkNfWEZPUk1fTU9ERSBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBlbmNyeXB0aW9uIG1vZGUuXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gX0RFQ19YRk9STV9NT0RFIEEgY29uc3RhbnQgcmVwcmVzZW50aW5nIGRlY3J5cHRpb24gbW9kZS5cclxuICAgICAqL1xyXG4gICAgdmFyIENpcGhlciA9IENfbGliLkNpcGhlciA9IEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uZXh0ZW5kKHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0gaXYgVGhlIElWIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCgpLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIHRoaXMgY2lwaGVyIGluIGVuY3J5cHRpb24gbW9kZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7Q2lwaGVyfSBBIGNpcGhlciBpbnN0YW5jZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIGNpcGhlciA9IENyeXB0b0pTLmFsZ28uQUVTLmNyZWF0ZUVuY3J5cHRvcihrZXlXb3JkQXJyYXksIHsgaXY6IGl2V29yZEFycmF5IH0pO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNyZWF0ZUVuY3J5cHRvcjogZnVuY3Rpb24gKGtleSwgY2ZnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZSh0aGlzLl9FTkNfWEZPUk1fTU9ERSwga2V5LCBjZmcpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgdGhpcyBjaXBoZXIgaW4gZGVjcnlwdGlvbiBtb2RlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJ9IEEgY2lwaGVyIGluc3RhbmNlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgY2lwaGVyID0gQ3J5cHRvSlMuYWxnby5BRVMuY3JlYXRlRGVjcnlwdG9yKGtleVdvcmRBcnJheSwgeyBpdjogaXZXb3JkQXJyYXkgfSk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY3JlYXRlRGVjcnlwdG9yOiBmdW5jdGlvbiAoa2V5LCBjZmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKHRoaXMuX0RFQ19YRk9STV9NT0RFLCBrZXksIGNmZyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGNpcGhlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4Zm9ybU1vZGUgRWl0aGVyIHRoZSBlbmNyeXB0aW9uIG9yIGRlY3J5cHRpb24gdHJhbnNvcm1hdGlvbiBtb2RlIGNvbnN0YW50LlxyXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgY2lwaGVyID0gQ3J5cHRvSlMuYWxnby5BRVMuY3JlYXRlKENyeXB0b0pTLmFsZ28uQUVTLl9FTkNfWEZPUk1fTU9ERSwga2V5V29yZEFycmF5LCB7IGl2OiBpdldvcmRBcnJheSB9KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoeGZvcm1Nb2RlLCBrZXksIGNmZykge1xyXG4gICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcclxuICAgICAgICAgICAgdGhpcy5jZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFN0b3JlIHRyYW5zZm9ybSBtb2RlIGFuZCBrZXlcclxuICAgICAgICAgICAgdGhpcy5feGZvcm1Nb2RlID0geGZvcm1Nb2RlO1xyXG4gICAgICAgICAgICB0aGlzLl9rZXkgPSBrZXk7XHJcblxyXG4gICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCB2YWx1ZXNcclxuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlc2V0cyB0aGlzIGNpcGhlciB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgY2lwaGVyLnJlc2V0KCk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gUmVzZXQgZGF0YSBidWZmZXJcclxuICAgICAgICAgICAgQnVmZmVyZWRCbG9ja0FsZ29yaXRobS5yZXNldC5jYWxsKHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1jaXBoZXIgbG9naWNcclxuICAgICAgICAgICAgdGhpcy5fZG9SZXNldCgpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgZGF0YSB0byBiZSBlbmNyeXB0ZWQgb3IgZGVjcnlwdGVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBkYXRhVXBkYXRlIFRoZSBkYXRhIHRvIGVuY3J5cHQgb3IgZGVjcnlwdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRhdGEgYWZ0ZXIgcHJvY2Vzc2luZy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5wcm9jZXNzKCdkYXRhJyk7XHJcbiAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIucHJvY2Vzcyh3b3JkQXJyYXkpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uIChkYXRhVXBkYXRlKSB7XHJcbiAgICAgICAgICAgIC8vIEFwcGVuZFxyXG4gICAgICAgICAgICB0aGlzLl9hcHBlbmQoZGF0YVVwZGF0ZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBQcm9jZXNzIGF2YWlsYWJsZSBibG9ja3NcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3MoKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGaW5hbGl6ZXMgdGhlIGVuY3J5cHRpb24gb3IgZGVjcnlwdGlvbiBwcm9jZXNzLlxyXG4gICAgICAgICAqIE5vdGUgdGhhdCB0aGUgZmluYWxpemUgb3BlcmF0aW9uIGlzIGVmZmVjdGl2ZWx5IGEgZGVzdHJ1Y3RpdmUsIHJlYWQtb25jZSBvcGVyYXRpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGRhdGFVcGRhdGUgVGhlIGZpbmFsIGRhdGEgdG8gZW5jcnlwdCBvciBkZWNyeXB0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGF0YSBhZnRlciBmaW5hbCBwcm9jZXNzaW5nLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLmZpbmFsaXplKCk7XHJcbiAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIuZmluYWxpemUoJ2RhdGEnKTtcclxuICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5maW5hbGl6ZSh3b3JkQXJyYXkpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoZGF0YVVwZGF0ZSkge1xyXG4gICAgICAgICAgICAvLyBGaW5hbCBkYXRhIHVwZGF0ZVxyXG4gICAgICAgICAgICBpZiAoZGF0YVVwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYXBwZW5kKGRhdGFVcGRhdGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWNpcGhlciBsb2dpY1xyXG4gICAgICAgICAgICB2YXIgZmluYWxQcm9jZXNzZWREYXRhID0gdGhpcy5fZG9GaW5hbGl6ZSgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZpbmFsUHJvY2Vzc2VkRGF0YTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBrZXlTaXplOiAxMjgvMzIsXHJcblxyXG4gICAgICAgIGl2U2l6ZTogMTI4LzMyLFxyXG5cclxuICAgICAgICBfRU5DX1hGT1JNX01PREU6IDEsXHJcblxyXG4gICAgICAgIF9ERUNfWEZPUk1fTU9ERTogMixcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBzaG9ydGN1dCBmdW5jdGlvbnMgdG8gYSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIHRvIGNyZWF0ZSBhIGhlbHBlciBmb3IuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIGVuY3J5cHQgYW5kIGRlY3J5cHQgc2hvcnRjdXQgZnVuY3Rpb25zLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgQUVTID0gQ3J5cHRvSlMubGliLkNpcGhlci5fY3JlYXRlSGVscGVyKENyeXB0b0pTLmFsZ28uQUVTKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBfY3JlYXRlSGVscGVyOiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBzZWxlY3RDaXBoZXJTdHJhdGVneShrZXkpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBhc3N3b3JkQmFzZWRDaXBoZXI7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTZXJpYWxpemFibGVDaXBoZXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY2lwaGVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGVuY3J5cHQ6IGZ1bmN0aW9uIChtZXNzYWdlLCBrZXksIGNmZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0Q2lwaGVyU3RyYXRlZ3koa2V5KS5lbmNyeXB0KGNpcGhlciwgbWVzc2FnZSwga2V5LCBjZmcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGRlY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXJ0ZXh0LCBrZXksIGNmZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0Q2lwaGVyU3RyYXRlZ3koa2V5KS5kZWNyeXB0KGNpcGhlciwgY2lwaGVydGV4dCwga2V5LCBjZmcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSgpKVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBYnN0cmFjdCBiYXNlIHN0cmVhbSBjaXBoZXIgdGVtcGxhdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbnVtYmVyIG9mIDMyLWJpdCB3b3JkcyB0aGlzIGNpcGhlciBvcGVyYXRlcyBvbi4gRGVmYXVsdDogMSAoMzIgYml0cylcclxuICAgICAqL1xyXG4gICAgdmFyIFN0cmVhbUNpcGhlciA9IENfbGliLlN0cmVhbUNpcGhlciA9IENpcGhlci5leHRlbmQoe1xyXG4gICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgcGFydGlhbCBibG9ja3NcclxuICAgICAgICAgICAgdmFyIGZpbmFsUHJvY2Vzc2VkQmxvY2tzID0gdGhpcy5fcHJvY2VzcyghISdmbHVzaCcpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZpbmFsUHJvY2Vzc2VkQmxvY2tzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJsb2NrU2l6ZTogMVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNb2RlIG5hbWVzcGFjZS5cclxuICAgICAqL1xyXG4gICAgdmFyIENfbW9kZSA9IEMubW9kZSA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWJzdHJhY3QgYmFzZSBibG9jayBjaXBoZXIgbW9kZSB0ZW1wbGF0ZS5cclxuICAgICAqL1xyXG4gICAgdmFyIEJsb2NrQ2lwaGVyTW9kZSA9IENfbGliLkJsb2NrQ2lwaGVyTW9kZSA9IEJhc2UuZXh0ZW5kKHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIHRoaXMgbW9kZSBmb3IgZW5jcnlwdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgQSBibG9jayBjaXBoZXIgaW5zdGFuY2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gaXYgVGhlIElWIHdvcmRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgbW9kZSA9IENyeXB0b0pTLm1vZGUuQ0JDLmNyZWF0ZUVuY3J5cHRvcihjaXBoZXIsIGl2LndvcmRzKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBjcmVhdGVFbmNyeXB0b3I6IGZ1bmN0aW9uIChjaXBoZXIsIGl2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkVuY3J5cHRvci5jcmVhdGUoY2lwaGVyLCBpdik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyB0aGlzIG1vZGUgZm9yIGRlY3J5cHRpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIEEgYmxvY2sgY2lwaGVyIGluc3RhbmNlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGl2IFRoZSBJViB3b3Jkcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIG1vZGUgPSBDcnlwdG9KUy5tb2RlLkNCQy5jcmVhdGVEZWNyeXB0b3IoY2lwaGVyLCBpdi53b3Jkcyk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY3JlYXRlRGVjcnlwdG9yOiBmdW5jdGlvbiAoY2lwaGVyLCBpdikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5EZWNyeXB0b3IuY3JlYXRlKGNpcGhlciwgaXYpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBtb2RlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBBIGJsb2NrIGNpcGhlciBpbnN0YW5jZS5cclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBpdiBUaGUgSVYgd29yZHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBtb2RlID0gQ3J5cHRvSlMubW9kZS5DQkMuRW5jcnlwdG9yLmNyZWF0ZShjaXBoZXIsIGl2LndvcmRzKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2lwaGVyLCBpdikge1xyXG4gICAgICAgICAgICB0aGlzLl9jaXBoZXIgPSBjaXBoZXI7XHJcbiAgICAgICAgICAgIHRoaXMuX2l2ID0gaXY7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaXBoZXIgQmxvY2sgQ2hhaW5pbmcgbW9kZS5cclxuICAgICAqL1xyXG4gICAgdmFyIENCQyA9IENfbW9kZS5DQkMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFic3RyYWN0IGJhc2UgQ0JDIG1vZGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIENCQyA9IEJsb2NrQ2lwaGVyTW9kZS5leHRlbmQoKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ0JDIGVuY3J5cHRvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDQkMuRW5jcnlwdG9yID0gQ0JDLmV4dGVuZCh7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQcm9jZXNzZXMgdGhlIGRhdGEgYmxvY2sgYXQgb2Zmc2V0LlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyBUaGUgZGF0YSB3b3JkcyB0byBvcGVyYXRlIG9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFRoZSBvZmZzZXQgd2hlcmUgdGhlIGJsb2NrIHN0YXJ0cy5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogICAgIG1vZGUucHJvY2Vzc0Jsb2NrKGRhdGEud29yZHMsIG9mZnNldCk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcclxuICAgICAgICAgICAgICAgIHZhciBjaXBoZXIgPSB0aGlzLl9jaXBoZXI7XHJcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gY2lwaGVyLmJsb2NrU2l6ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBYT1IgYW5kIGVuY3J5cHRcclxuICAgICAgICAgICAgICAgIHhvckJsb2NrLmNhbGwodGhpcywgd29yZHMsIG9mZnNldCwgYmxvY2tTaXplKTtcclxuICAgICAgICAgICAgICAgIGNpcGhlci5lbmNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhpcyBibG9jayB0byB1c2Ugd2l0aCBuZXh0IGJsb2NrXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmV2QmxvY2sgPSB3b3Jkcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGJsb2NrU2l6ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ0JDIGRlY3J5cHRvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDQkMuRGVjcnlwdG9yID0gQ0JDLmV4dGVuZCh7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQcm9jZXNzZXMgdGhlIGRhdGEgYmxvY2sgYXQgb2Zmc2V0LlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyBUaGUgZGF0YSB3b3JkcyB0byBvcGVyYXRlIG9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFRoZSBvZmZzZXQgd2hlcmUgdGhlIGJsb2NrIHN0YXJ0cy5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogICAgIG1vZGUucHJvY2Vzc0Jsb2NrKGRhdGEud29yZHMsIG9mZnNldCk7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcclxuICAgICAgICAgICAgICAgIHZhciBjaXBoZXIgPSB0aGlzLl9jaXBoZXI7XHJcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gY2lwaGVyLmJsb2NrU2l6ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGlzIGJsb2NrIHRvIHVzZSB3aXRoIG5leHQgYmxvY2tcclxuICAgICAgICAgICAgICAgIHZhciB0aGlzQmxvY2sgPSB3b3Jkcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGJsb2NrU2l6ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRGVjcnlwdCBhbmQgWE9SXHJcbiAgICAgICAgICAgICAgICBjaXBoZXIuZGVjcnlwdEJsb2NrKHdvcmRzLCBvZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgeG9yQmxvY2suY2FsbCh0aGlzLCB3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgYmxvY2sgYmVjb21lcyB0aGUgcHJldmlvdXMgYmxvY2tcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZCbG9jayA9IHRoaXNCbG9jaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB4b3JCbG9jayh3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUpIHtcclxuICAgICAgICAgICAgLy8gU2hvcnRjdXRcclxuICAgICAgICAgICAgdmFyIGl2ID0gdGhpcy5faXY7XHJcblxyXG4gICAgICAgICAgICAvLyBDaG9vc2UgbWl4aW5nIGJsb2NrXHJcbiAgICAgICAgICAgIGlmIChpdikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGJsb2NrID0gaXY7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIElWIGZvciBzdWJzZXF1ZW50IGJsb2Nrc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faXYgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2sgPSB0aGlzLl9wcmV2QmxvY2s7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFhPUiBibG9ja3NcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja1NpemU7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgd29yZHNbb2Zmc2V0ICsgaV0gXj0gYmxvY2tbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBDQkM7XHJcbiAgICB9KCkpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFkZGluZyBuYW1lc3BhY2UuXHJcbiAgICAgKi9cclxuICAgIHZhciBDX3BhZCA9IEMucGFkID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQS0NTICM1LzcgcGFkZGluZyBzdHJhdGVneS5cclxuICAgICAqL1xyXG4gICAgdmFyIFBrY3M3ID0gQ19wYWQuUGtjczcgPSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGFkcyBkYXRhIHVzaW5nIHRoZSBhbGdvcml0aG0gZGVmaW5lZCBpbiBQS0NTICM1LzcuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gZGF0YSBUaGUgZGF0YSB0byBwYWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbXVsdGlwbGUgdGhhdCB0aGUgZGF0YSBzaG91bGQgYmUgcGFkZGVkIHRvLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICBDcnlwdG9KUy5wYWQuUGtjczcucGFkKHdvcmRBcnJheSwgNCk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcGFkOiBmdW5jdGlvbiAoZGF0YSwgYmxvY2tTaXplKSB7XHJcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0XHJcbiAgICAgICAgICAgIHZhciBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XHJcblxyXG4gICAgICAgICAgICAvLyBDb3VudCBwYWRkaW5nIGJ5dGVzXHJcbiAgICAgICAgICAgIHZhciBuUGFkZGluZ0J5dGVzID0gYmxvY2tTaXplQnl0ZXMgLSBkYXRhLnNpZ0J5dGVzICUgYmxvY2tTaXplQnl0ZXM7XHJcblxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgcGFkZGluZyB3b3JkXHJcbiAgICAgICAgICAgIHZhciBwYWRkaW5nV29yZCA9IChuUGFkZGluZ0J5dGVzIDw8IDI0KSB8IChuUGFkZGluZ0J5dGVzIDw8IDE2KSB8IChuUGFkZGluZ0J5dGVzIDw8IDgpIHwgblBhZGRpbmdCeXRlcztcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBwYWRkaW5nXHJcbiAgICAgICAgICAgIHZhciBwYWRkaW5nV29yZHMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuUGFkZGluZ0J5dGVzOyBpICs9IDQpIHtcclxuICAgICAgICAgICAgICAgIHBhZGRpbmdXb3Jkcy5wdXNoKHBhZGRpbmdXb3JkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcGFkZGluZyA9IFdvcmRBcnJheS5jcmVhdGUocGFkZGluZ1dvcmRzLCBuUGFkZGluZ0J5dGVzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXHJcbiAgICAgICAgICAgIGRhdGEuY29uY2F0KHBhZGRpbmcpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVucGFkcyBkYXRhIHRoYXQgaGFkIGJlZW4gcGFkZGVkIHVzaW5nIHRoZSBhbGdvcml0aG0gZGVmaW5lZCBpbiBQS0NTICM1LzcuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gZGF0YSBUaGUgZGF0YSB0byB1bnBhZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgQ3J5cHRvSlMucGFkLlBrY3M3LnVucGFkKHdvcmRBcnJheSk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdW5wYWQ6IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIC8vIEdldCBudW1iZXIgb2YgcGFkZGluZyBieXRlcyBmcm9tIGxhc3QgYnl0ZVxyXG4gICAgICAgICAgICB2YXIgblBhZGRpbmdCeXRlcyA9IGRhdGEud29yZHNbKGRhdGEuc2lnQnl0ZXMgLSAxKSA+Pj4gMl0gJiAweGZmO1xyXG5cclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHBhZGRpbmdcclxuICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyAtPSBuUGFkZGluZ0J5dGVzO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBYnN0cmFjdCBiYXNlIGJsb2NrIGNpcGhlciB0ZW1wbGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBudW1iZXIgb2YgMzItYml0IHdvcmRzIHRoaXMgY2lwaGVyIG9wZXJhdGVzIG9uLiBEZWZhdWx0OiA0ICgxMjggYml0cylcclxuICAgICAqL1xyXG4gICAgdmFyIEJsb2NrQ2lwaGVyID0gQ19saWIuQmxvY2tDaXBoZXIgPSBDaXBoZXIuZXh0ZW5kKHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJvcGVydHkge01vZGV9IG1vZGUgVGhlIGJsb2NrIG1vZGUgdG8gdXNlLiBEZWZhdWx0OiBDQkNcclxuICAgICAgICAgKiBAcHJvcGVydHkge1BhZGRpbmd9IHBhZGRpbmcgVGhlIHBhZGRpbmcgc3RyYXRlZ3kgdG8gdXNlLiBEZWZhdWx0OiBQa2NzN1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNmZzogQ2lwaGVyLmNmZy5leHRlbmQoe1xyXG4gICAgICAgICAgICBtb2RlOiBDQkMsXHJcbiAgICAgICAgICAgIHBhZGRpbmc6IFBrY3M3XHJcbiAgICAgICAgfSksXHJcblxyXG4gICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIFJlc2V0IGNpcGhlclxyXG4gICAgICAgICAgICBDaXBoZXIucmVzZXQuY2FsbCh0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xyXG4gICAgICAgICAgICB2YXIgY2ZnID0gdGhpcy5jZmc7XHJcbiAgICAgICAgICAgIHZhciBpdiA9IGNmZy5pdjtcclxuICAgICAgICAgICAgdmFyIG1vZGUgPSBjZmcubW9kZTtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlc2V0IGJsb2NrIG1vZGVcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9FTkNfWEZPUk1fTU9ERSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1vZGVDcmVhdG9yID0gbW9kZS5jcmVhdGVFbmNyeXB0b3I7XHJcbiAgICAgICAgICAgIH0gZWxzZSAvKiBpZiAodGhpcy5feGZvcm1Nb2RlID09IHRoaXMuX0RFQ19YRk9STV9NT0RFKSAqLyB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbW9kZUNyZWF0b3IgPSBtb2RlLmNyZWF0ZURlY3J5cHRvcjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBLZWVwIGF0IGxlYXN0IG9uZSBibG9jayBpbiB0aGUgYnVmZmVyIGZvciB1bnBhZGRpbmdcclxuICAgICAgICAgICAgICAgIHRoaXMuX21pbkJ1ZmZlclNpemUgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX21vZGUgPSBtb2RlQ3JlYXRvci5jYWxsKG1vZGUsIHRoaXMsIGl2ICYmIGl2LndvcmRzKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21vZGUucHJvY2Vzc0Jsb2NrKHdvcmRzLCBvZmZzZXQpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0XHJcbiAgICAgICAgICAgIHZhciBwYWRkaW5nID0gdGhpcy5jZmcucGFkZGluZztcclxuXHJcbiAgICAgICAgICAgIC8vIEZpbmFsaXplXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl94Zm9ybU1vZGUgPT0gdGhpcy5fRU5DX1hGT1JNX01PREUpIHtcclxuICAgICAgICAgICAgICAgIC8vIFBhZCBkYXRhXHJcbiAgICAgICAgICAgICAgICBwYWRkaW5nLnBhZCh0aGlzLl9kYXRhLCB0aGlzLmJsb2NrU2l6ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUHJvY2VzcyBmaW5hbCBibG9ja3NcclxuICAgICAgICAgICAgICAgIHZhciBmaW5hbFByb2Nlc3NlZEJsb2NrcyA9IHRoaXMuX3Byb2Nlc3MoISEnZmx1c2gnKTtcclxuICAgICAgICAgICAgfSBlbHNlIC8qIGlmICh0aGlzLl94Zm9ybU1vZGUgPT0gdGhpcy5fREVDX1hGT1JNX01PREUpICovIHtcclxuICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgZmluYWwgYmxvY2tzXHJcbiAgICAgICAgICAgICAgICB2YXIgZmluYWxQcm9jZXNzZWRCbG9ja3MgPSB0aGlzLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVW5wYWQgZGF0YVxyXG4gICAgICAgICAgICAgICAgcGFkZGluZy51bnBhZChmaW5hbFByb2Nlc3NlZEJsb2Nrcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmaW5hbFByb2Nlc3NlZEJsb2NrcztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBibG9ja1NpemU6IDEyOC8zMlxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGNvbGxlY3Rpb24gb2YgY2lwaGVyIHBhcmFtZXRlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGNpcGhlcnRleHQgVGhlIHJhdyBjaXBoZXJ0ZXh0LlxyXG4gICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGtleSBUaGUga2V5IHRvIHRoaXMgY2lwaGVydGV4dC5cclxuICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBpdiBUaGUgSVYgdXNlZCBpbiB0aGUgY2lwaGVyaW5nIG9wZXJhdGlvbi5cclxuICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBzYWx0IFRoZSBzYWx0IHVzZWQgd2l0aCBhIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uLlxyXG4gICAgICogQHByb3BlcnR5IHtDaXBoZXJ9IGFsZ29yaXRobSBUaGUgY2lwaGVyIGFsZ29yaXRobS5cclxuICAgICAqIEBwcm9wZXJ0eSB7TW9kZX0gbW9kZSBUaGUgYmxvY2sgbW9kZSB1c2VkIGluIHRoZSBjaXBoZXJpbmcgb3BlcmF0aW9uLlxyXG4gICAgICogQHByb3BlcnR5IHtQYWRkaW5nfSBwYWRkaW5nIFRoZSBwYWRkaW5nIHNjaGVtZSB1c2VkIGluIHRoZSBjaXBoZXJpbmcgb3BlcmF0aW9uLlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgYmxvY2sgc2l6ZSBvZiB0aGUgY2lwaGVyLlxyXG4gICAgICogQHByb3BlcnR5IHtGb3JtYXR9IGZvcm1hdHRlciBUaGUgZGVmYXVsdCBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIGNvbnZlcnQgdGhpcyBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhIHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgdmFyIENpcGhlclBhcmFtcyA9IENfbGliLkNpcGhlclBhcmFtcyA9IEJhc2UuZXh0ZW5kKHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgY2lwaGVyIHBhcmFtcyBvYmplY3QuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2lwaGVyUGFyYW1zIEFuIG9iamVjdCB3aXRoIGFueSBvZiB0aGUgcG9zc2libGUgY2lwaGVyIHBhcmFtZXRlcnMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBjaXBoZXJQYXJhbXMgPSBDcnlwdG9KUy5saWIuQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7XHJcbiAgICAgICAgICogICAgICAgICBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0V29yZEFycmF5LFxyXG4gICAgICAgICAqICAgICAgICAga2V5OiBrZXlXb3JkQXJyYXksXHJcbiAgICAgICAgICogICAgICAgICBpdjogaXZXb3JkQXJyYXksXHJcbiAgICAgICAgICogICAgICAgICBzYWx0OiBzYWx0V29yZEFycmF5LFxyXG4gICAgICAgICAqICAgICAgICAgYWxnb3JpdGhtOiBDcnlwdG9KUy5hbGdvLkFFUyxcclxuICAgICAgICAgKiAgICAgICAgIG1vZGU6IENyeXB0b0pTLm1vZGUuQ0JDLFxyXG4gICAgICAgICAqICAgICAgICAgcGFkZGluZzogQ3J5cHRvSlMucGFkLlBLQ1M3LFxyXG4gICAgICAgICAqICAgICAgICAgYmxvY2tTaXplOiA0LFxyXG4gICAgICAgICAqICAgICAgICAgZm9ybWF0dGVyOiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTFxyXG4gICAgICAgICAqICAgICB9KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2lwaGVyUGFyYW1zKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWl4SW4oY2lwaGVyUGFyYW1zKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIGNpcGhlciBwYXJhbXMgb2JqZWN0IHRvIGEgc3RyaW5nLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtGb3JtYXR9IGZvcm1hdHRlciAoT3B0aW9uYWwpIFRoZSBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIHVzZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZ2lmaWVkIGNpcGhlciBwYXJhbXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdGhyb3dzIEVycm9yIElmIG5laXRoZXIgdGhlIGZvcm1hdHRlciBub3IgdGhlIGRlZmF1bHQgZm9ybWF0dGVyIGlzIHNldC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IGNpcGhlclBhcmFtcyArICcnO1xyXG4gICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gY2lwaGVyUGFyYW1zLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSBjaXBoZXJQYXJhbXMudG9TdHJpbmcoQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoZm9ybWF0dGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoZm9ybWF0dGVyIHx8IHRoaXMuZm9ybWF0dGVyKS5zdHJpbmdpZnkodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3JtYXQgbmFtZXNwYWNlLlxyXG4gICAgICovXHJcbiAgICB2YXIgQ19mb3JtYXQgPSBDLmZvcm1hdCA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogT3BlblNTTCBmb3JtYXR0aW5nIHN0cmF0ZWd5LlxyXG4gICAgICovXHJcbiAgICB2YXIgT3BlblNTTEZvcm1hdHRlciA9IENfZm9ybWF0Lk9wZW5TU0wgPSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgYSBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhbiBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN9IGNpcGhlclBhcmFtcyBUaGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgb3BlblNTTFN0cmluZyA9IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMLnN0cmluZ2lmeShjaXBoZXJQYXJhbXMpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKGNpcGhlclBhcmFtcykge1xyXG4gICAgICAgICAgICAvLyBTaG9ydGN1dHNcclxuICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBjaXBoZXJQYXJhbXMuY2lwaGVydGV4dDtcclxuICAgICAgICAgICAgdmFyIHNhbHQgPSBjaXBoZXJQYXJhbXMuc2FsdDtcclxuXHJcbiAgICAgICAgICAgIC8vIEZvcm1hdFxyXG4gICAgICAgICAgICBpZiAoc2FsdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHdvcmRBcnJheSA9IFdvcmRBcnJheS5jcmVhdGUoWzB4NTM2MTZjNzQsIDB4NjU2NDVmNWZdKS5jb25jYXQoc2FsdCkuY29uY2F0KGNpcGhlcnRleHQpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHdvcmRBcnJheSA9IGNpcGhlcnRleHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB3b3JkQXJyYXkudG9TdHJpbmcoQmFzZTY0KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyBhbiBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nIHRvIGEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlblNTTFN0ciBUaGUgT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gVGhlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgY2lwaGVyUGFyYW1zID0gQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wucGFyc2Uob3BlblNTTFN0cmluZyk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChvcGVuU1NMU3RyKSB7XHJcbiAgICAgICAgICAgIC8vIFBhcnNlIGJhc2U2NFxyXG4gICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IEJhc2U2NC5wYXJzZShvcGVuU1NMU3RyKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0XHJcbiAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0V29yZHMgPSBjaXBoZXJ0ZXh0LndvcmRzO1xyXG5cclxuICAgICAgICAgICAgLy8gVGVzdCBmb3Igc2FsdFxyXG4gICAgICAgICAgICBpZiAoY2lwaGVydGV4dFdvcmRzWzBdID09IDB4NTM2MTZjNzQgJiYgY2lwaGVydGV4dFdvcmRzWzFdID09IDB4NjU2NDVmNWYpIHtcclxuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3Qgc2FsdFxyXG4gICAgICAgICAgICAgICAgdmFyIHNhbHQgPSBXb3JkQXJyYXkuY3JlYXRlKGNpcGhlcnRleHRXb3Jkcy5zbGljZSgyLCA0KSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHNhbHQgZnJvbSBjaXBoZXJ0ZXh0XHJcbiAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0V29yZHMuc3BsaWNlKDAsIDQpO1xyXG4gICAgICAgICAgICAgICAgY2lwaGVydGV4dC5zaWdCeXRlcyAtPSAxNjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIENpcGhlclBhcmFtcy5jcmVhdGUoeyBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0LCBzYWx0OiBzYWx0IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGNpcGhlciB3cmFwcGVyIHRoYXQgcmV0dXJucyBjaXBoZXJ0ZXh0IGFzIGEgc2VyaWFsaXphYmxlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICB2YXIgU2VyaWFsaXphYmxlQ2lwaGVyID0gQ19saWIuU2VyaWFsaXphYmxlQ2lwaGVyID0gQmFzZS5leHRlbmQoe1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7Rm9ybWF0dGVyfSBmb3JtYXQgVGhlIGZvcm1hdHRpbmcgc3RyYXRlZ3kgdG8gY29udmVydCBjaXBoZXIgcGFyYW0gb2JqZWN0cyB0byBhbmQgZnJvbSBhIHN0cmluZy4gRGVmYXVsdDogT3BlblNTTFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNmZzogQmFzZS5leHRlbmQoe1xyXG4gICAgICAgICAgICBmb3JtYXQ6IE9wZW5TU0xGb3JtYXR0ZXJcclxuICAgICAgICB9KSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5jcnlwdHMgYSBtZXNzYWdlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGVuY3J5cHQuXHJcbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IEEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCBrZXkpO1xyXG4gICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwga2V5LCB7IGl2OiBpdiB9KTtcclxuICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsIGtleSwgeyBpdjogaXYsIGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZW5jcnlwdDogZnVuY3Rpb24gKGNpcGhlciwgbWVzc2FnZSwga2V5LCBjZmcpIHtcclxuICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXHJcbiAgICAgICAgICAgIGNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xyXG5cclxuICAgICAgICAgICAgLy8gRW5jcnlwdFxyXG4gICAgICAgICAgICB2YXIgZW5jcnlwdG9yID0gY2lwaGVyLmNyZWF0ZUVuY3J5cHRvcihrZXksIGNmZyk7XHJcbiAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gZW5jcnlwdG9yLmZpbmFsaXplKG1lc3NhZ2UpO1xyXG5cclxuICAgICAgICAgICAgLy8gU2hvcnRjdXRcclxuICAgICAgICAgICAgdmFyIGNpcGhlckNmZyA9IGVuY3J5cHRvci5jZmc7XHJcblxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgYW5kIHJldHVybiBzZXJpYWxpemFibGUgY2lwaGVyIHBhcmFtc1xyXG4gICAgICAgICAgICByZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7XHJcbiAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0LFxyXG4gICAgICAgICAgICAgICAga2V5OiBrZXksXHJcbiAgICAgICAgICAgICAgICBpdjogY2lwaGVyQ2ZnLml2LFxyXG4gICAgICAgICAgICAgICAgYWxnb3JpdGhtOiBjaXBoZXIsXHJcbiAgICAgICAgICAgICAgICBtb2RlOiBjaXBoZXJDZmcubW9kZSxcclxuICAgICAgICAgICAgICAgIHBhZGRpbmc6IGNpcGhlckNmZy5wYWRkaW5nLFxyXG4gICAgICAgICAgICAgICAgYmxvY2tTaXplOiBjaXBoZXIuYmxvY2tTaXplLFxyXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVyOiBjZmcuZm9ybWF0XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlY3J5cHRzIHNlcmlhbGl6ZWQgY2lwaGVydGV4dC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfHN0cmluZ30gY2lwaGVydGV4dCBUaGUgY2lwaGVydGV4dCB0byBkZWNyeXB0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcGxhaW50ZXh0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBmb3JtYXR0ZWRDaXBoZXJ0ZXh0LCBrZXksIHsgaXY6IGl2LCBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xyXG4gICAgICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBjaXBoZXJ0ZXh0UGFyYW1zLCBrZXksIHsgaXY6IGl2LCBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRlY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIGNpcGhlcnRleHQsIGtleSwgY2ZnKSB7XHJcbiAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xyXG4gICAgICAgICAgICBjZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIENpcGhlclBhcmFtc1xyXG4gICAgICAgICAgICBjaXBoZXJ0ZXh0ID0gdGhpcy5fcGFyc2UoY2lwaGVydGV4dCwgY2ZnLmZvcm1hdCk7XHJcblxyXG4gICAgICAgICAgICAvLyBEZWNyeXB0XHJcbiAgICAgICAgICAgIHZhciBwbGFpbnRleHQgPSBjaXBoZXIuY3JlYXRlRGVjcnlwdG9yKGtleSwgY2ZnKS5maW5hbGl6ZShjaXBoZXJ0ZXh0LmNpcGhlcnRleHQpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyBzZXJpYWxpemVkIGNpcGhlcnRleHQgdG8gQ2lwaGVyUGFyYW1zLFxyXG4gICAgICAgICAqIGVsc2UgYXNzdW1lZCBDaXBoZXJQYXJhbXMgYWxyZWFkeSBhbmQgcmV0dXJucyBjaXBoZXJ0ZXh0IHVuY2hhbmdlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfHN0cmluZ30gY2lwaGVydGV4dCBUaGUgY2lwaGVydGV4dC5cclxuICAgICAgICAgKiBAcGFyYW0ge0Zvcm1hdHRlcn0gZm9ybWF0IFRoZSBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIHVzZSB0byBwYXJzZSBzZXJpYWxpemVkIGNpcGhlcnRleHQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IFRoZSB1bnNlcmlhbGl6ZWQgY2lwaGVydGV4dC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLl9wYXJzZShjaXBoZXJ0ZXh0U3RyaW5nT3JQYXJhbXMsIGZvcm1hdCk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3BhcnNlOiBmdW5jdGlvbiAoY2lwaGVydGV4dCwgZm9ybWF0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2lwaGVydGV4dCA9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdC5wYXJzZShjaXBoZXJ0ZXh0LCB0aGlzKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjaXBoZXJ0ZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBLZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiBuYW1lc3BhY2UuXHJcbiAgICAgKi9cclxuICAgIHZhciBDX2tkZiA9IEMua2RmID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVuU1NMIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICB2YXIgT3BlblNTTEtkZiA9IENfa2RmLk9wZW5TU0wgPSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVyaXZlcyBhIGtleSBhbmQgSVYgZnJvbSBhIHBhc3N3b3JkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZCB0byBkZXJpdmUgZnJvbS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga2V5U2l6ZSBUaGUgc2l6ZSBpbiB3b3JkcyBvZiB0aGUga2V5IHRvIGdlbmVyYXRlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpdlNpemUgVGhlIHNpemUgaW4gd29yZHMgb2YgdGhlIElWIHRvIGdlbmVyYXRlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gc2FsdCAoT3B0aW9uYWwpIEEgNjQtYml0IHNhbHQgdG8gdXNlLiBJZiBvbWl0dGVkLCBhIHNhbHQgd2lsbCBiZSBnZW5lcmF0ZWQgcmFuZG9tbHkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IEEgY2lwaGVyIHBhcmFtcyBvYmplY3Qgd2l0aCB0aGUga2V5LCBJViwgYW5kIHNhbHQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBkZXJpdmVkUGFyYW1zID0gQ3J5cHRvSlMua2RmLk9wZW5TU0wuZXhlY3V0ZSgnUGFzc3dvcmQnLCAyNTYvMzIsIDEyOC8zMik7XHJcbiAgICAgICAgICogICAgIHZhciBkZXJpdmVkUGFyYW1zID0gQ3J5cHRvSlMua2RmLk9wZW5TU0wuZXhlY3V0ZSgnUGFzc3dvcmQnLCAyNTYvMzIsIDEyOC8zMiwgJ3NhbHRzYWx0Jyk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZXhlY3V0ZTogZnVuY3Rpb24gKHBhc3N3b3JkLCBrZXlTaXplLCBpdlNpemUsIHNhbHQpIHtcclxuICAgICAgICAgICAgLy8gR2VuZXJhdGUgcmFuZG9tIHNhbHRcclxuICAgICAgICAgICAgaWYgKCFzYWx0KSB7XHJcbiAgICAgICAgICAgICAgICBzYWx0ID0gV29yZEFycmF5LnJhbmRvbSg2NC84KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRGVyaXZlIGtleSBhbmQgSVZcclxuICAgICAgICAgICAgdmFyIGtleSA9IEV2cEtERi5jcmVhdGUoeyBrZXlTaXplOiBrZXlTaXplICsgaXZTaXplIH0pLmNvbXB1dGUocGFzc3dvcmQsIHNhbHQpO1xyXG5cclxuICAgICAgICAgICAgLy8gU2VwYXJhdGUga2V5IGFuZCBJVlxyXG4gICAgICAgICAgICB2YXIgaXYgPSBXb3JkQXJyYXkuY3JlYXRlKGtleS53b3Jkcy5zbGljZShrZXlTaXplKSwgaXZTaXplICogNCk7XHJcbiAgICAgICAgICAgIGtleS5zaWdCeXRlcyA9IGtleVNpemUgKiA0O1xyXG5cclxuICAgICAgICAgICAgLy8gUmV0dXJuIHBhcmFtc1xyXG4gICAgICAgICAgICByZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7IGtleToga2V5LCBpdjogaXYsIHNhbHQ6IHNhbHQgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgc2VyaWFsaXphYmxlIGNpcGhlciB3cmFwcGVyIHRoYXQgZGVyaXZlcyB0aGUga2V5IGZyb20gYSBwYXNzd29yZCxcclxuICAgICAqIGFuZCByZXR1cm5zIGNpcGhlcnRleHQgYXMgYSBzZXJpYWxpemFibGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHZhciBQYXNzd29yZEJhc2VkQ2lwaGVyID0gQ19saWIuUGFzc3dvcmRCYXNlZENpcGhlciA9IFNlcmlhbGl6YWJsZUNpcGhlci5leHRlbmQoe1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7S0RGfSBrZGYgVGhlIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uIHRvIHVzZSB0byBnZW5lcmF0ZSBhIGtleSBhbmQgSVYgZnJvbSBhIHBhc3N3b3JkLiBEZWZhdWx0OiBPcGVuU1NMXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2ZnOiBTZXJpYWxpemFibGVDaXBoZXIuY2ZnLmV4dGVuZCh7XHJcbiAgICAgICAgICAgIGtkZjogT3BlblNTTEtkZlxyXG4gICAgICAgIH0pLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbmNyeXB0cyBhIG1lc3NhZ2UgdXNpbmcgYSBwYXNzd29yZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBlbmNyeXB0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gQSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCAncGFzc3dvcmQnKTtcclxuICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCAncGFzc3dvcmQnLCB7IGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZW5jcnlwdDogZnVuY3Rpb24gKGNpcGhlciwgbWVzc2FnZSwgcGFzc3dvcmQsIGNmZykge1xyXG4gICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcclxuICAgICAgICAgICAgY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XHJcblxyXG4gICAgICAgICAgICAvLyBEZXJpdmUga2V5IGFuZCBvdGhlciBwYXJhbXNcclxuICAgICAgICAgICAgdmFyIGRlcml2ZWRQYXJhbXMgPSBjZmcua2RmLmV4ZWN1dGUocGFzc3dvcmQsIGNpcGhlci5rZXlTaXplLCBjaXBoZXIuaXZTaXplKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCBJViB0byBjb25maWdcclxuICAgICAgICAgICAgY2ZnLml2ID0gZGVyaXZlZFBhcmFtcy5pdjtcclxuXHJcbiAgICAgICAgICAgIC8vIEVuY3J5cHRcclxuICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBTZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdC5jYWxsKHRoaXMsIGNpcGhlciwgbWVzc2FnZSwgZGVyaXZlZFBhcmFtcy5rZXksIGNmZyk7XHJcblxyXG4gICAgICAgICAgICAvLyBNaXggaW4gZGVyaXZlZCBwYXJhbXNcclxuICAgICAgICAgICAgY2lwaGVydGV4dC5taXhJbihkZXJpdmVkUGFyYW1zKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBjaXBoZXJ0ZXh0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlY3J5cHRzIHNlcmlhbGl6ZWQgY2lwaGVydGV4dCB1c2luZyBhIHBhc3N3b3JkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN8c3RyaW5nfSBjaXBoZXJ0ZXh0IFRoZSBjaXBoZXJ0ZXh0IHRvIGRlY3J5cHQuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcGxhaW50ZXh0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgZm9ybWF0dGVkQ2lwaGVydGV4dCwgJ3Bhc3N3b3JkJywgeyBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xyXG4gICAgICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgY2lwaGVydGV4dFBhcmFtcywgJ3Bhc3N3b3JkJywgeyBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRlY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIGNpcGhlcnRleHQsIHBhc3N3b3JkLCBjZmcpIHtcclxuICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXHJcbiAgICAgICAgICAgIGNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gQ2lwaGVyUGFyYW1zXHJcbiAgICAgICAgICAgIGNpcGhlcnRleHQgPSB0aGlzLl9wYXJzZShjaXBoZXJ0ZXh0LCBjZmcuZm9ybWF0KTtcclxuXHJcbiAgICAgICAgICAgIC8vIERlcml2ZSBrZXkgYW5kIG90aGVyIHBhcmFtc1xyXG4gICAgICAgICAgICB2YXIgZGVyaXZlZFBhcmFtcyA9IGNmZy5rZGYuZXhlY3V0ZShwYXNzd29yZCwgY2lwaGVyLmtleVNpemUsIGNpcGhlci5pdlNpemUsIGNpcGhlcnRleHQuc2FsdCk7XHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgSVYgdG8gY29uZmlnXHJcbiAgICAgICAgICAgIGNmZy5pdiA9IGRlcml2ZWRQYXJhbXMuaXY7XHJcblxyXG4gICAgICAgICAgICAvLyBEZWNyeXB0XHJcbiAgICAgICAgICAgIHZhciBwbGFpbnRleHQgPSBTZXJpYWxpemFibGVDaXBoZXIuZGVjcnlwdC5jYWxsKHRoaXMsIGNpcGhlciwgY2lwaGVydGV4dCwgZGVyaXZlZFBhcmFtcy5rZXksIGNmZyk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcGxhaW50ZXh0O1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59KCkpO1xyXG4iLCIvKlxuQ3J5cHRvSlMgdjMuMS4yXG5jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanNcbihjKSAyMDA5LTIwMTMgYnkgSmVmZiBNb3R0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzL3dpa2kvTGljZW5zZVxuKi9cbi8qKlxyXG4gKiBDcnlwdG9KUyBjb3JlIGNvbXBvbmVudHMuXHJcbiAqL1xyXG52YXIgQ3J5cHRvSlMgPSBDcnlwdG9KUyB8fCAoZnVuY3Rpb24gKE1hdGgsIHVuZGVmaW5lZCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcnlwdG9KUyBuYW1lc3BhY2UuXHJcbiAgICAgKi9cclxuICAgIHZhciBDID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaWJyYXJ5IG5hbWVzcGFjZS5cclxuICAgICAqL1xyXG4gICAgdmFyIENfbGliID0gQy5saWIgPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEJhc2Ugb2JqZWN0IGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlLlxyXG4gICAgICovXHJcbiAgICB2YXIgQmFzZSA9IENfbGliLkJhc2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIEYoKSB7fVxyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoaXMgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3ZlcnJpZGVzIFByb3BlcnRpZXMgdG8gY29weSBpbnRvIHRoZSBuZXcgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBuZXcgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICAgICB2YXIgTXlUeXBlID0gQ3J5cHRvSlMubGliLkJhc2UuZXh0ZW5kKHtcclxuICAgICAgICAgICAgICogICAgICAgICBmaWVsZDogJ3ZhbHVlJyxcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICogICAgICAgICB9XHJcbiAgICAgICAgICAgICAqICAgICB9KTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGV4dGVuZDogZnVuY3Rpb24gKG92ZXJyaWRlcykge1xyXG4gICAgICAgICAgICAgICAgLy8gU3Bhd25cclxuICAgICAgICAgICAgICAgIEYucHJvdG90eXBlID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHZhciBzdWJ0eXBlID0gbmV3IEYoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBdWdtZW50XHJcbiAgICAgICAgICAgICAgICBpZiAob3ZlcnJpZGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VidHlwZS5taXhJbihvdmVycmlkZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBkZWZhdWx0IGluaXRpYWxpemVyXHJcbiAgICAgICAgICAgICAgICBpZiAoIXN1YnR5cGUuaGFzT3duUHJvcGVydHkoJ2luaXQnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YnR5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VidHlwZS4kc3VwZXIuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZXIncyBwcm90b3R5cGUgaXMgdGhlIHN1YnR5cGUgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICBzdWJ0eXBlLmluaXQucHJvdG90eXBlID0gc3VidHlwZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZWZlcmVuY2Ugc3VwZXJ0eXBlXHJcbiAgICAgICAgICAgICAgICBzdWJ0eXBlLiRzdXBlciA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YnR5cGU7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRXh0ZW5kcyB0aGlzIG9iamVjdCBhbmQgcnVucyB0aGUgaW5pdCBtZXRob2QuXHJcbiAgICAgICAgICAgICAqIEFyZ3VtZW50cyB0byBjcmVhdGUoKSB3aWxsIGJlIHBhc3NlZCB0byBpbml0KCkuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5ldyBvYmplY3QuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogICAgIHZhciBpbnN0YW5jZSA9IE15VHlwZS5jcmVhdGUoKTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5leHRlbmQoKTtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLmluaXQuYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBvYmplY3QuXHJcbiAgICAgICAgICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGFkZCBzb21lIGxvZ2ljIHdoZW4geW91ciBvYmplY3RzIGFyZSBjcmVhdGVkLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiAgICAgdmFyIE15VHlwZSA9IENyeXB0b0pTLmxpYi5CYXNlLmV4dGVuZCh7XHJcbiAgICAgICAgICAgICAqICAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgKiAgICAgICAgICAgICAvLyAuLi5cclxuICAgICAgICAgICAgICogICAgICAgICB9XHJcbiAgICAgICAgICAgICAqICAgICB9KTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDb3BpZXMgcHJvcGVydGllcyBpbnRvIHRoaXMgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyBUaGUgcHJvcGVydGllcyB0byBtaXggaW4uXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICAgICBNeVR5cGUubWl4SW4oe1xyXG4gICAgICAgICAgICAgKiAgICAgICAgIGZpZWxkOiAndmFsdWUnXHJcbiAgICAgICAgICAgICAqICAgICB9KTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIG1peEluOiBmdW5jdGlvbiAocHJvcGVydGllcykge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcGVydHlOYW1lIGluIHByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcGVydHlOYW1lXSA9IHByb3BlcnRpZXNbcHJvcGVydHlOYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSUUgd29uJ3QgY29weSB0b1N0cmluZyB1c2luZyB0aGUgbG9vcCBhYm92ZVxyXG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoJ3RvU3RyaW5nJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvU3RyaW5nID0gcHJvcGVydGllcy50b1N0cmluZztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIG9iamVjdC5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY2xvbmUuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqICAgICB2YXIgY2xvbmUgPSBpbnN0YW5jZS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmluaXQucHJvdG90eXBlLmV4dGVuZCh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9KCkpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IHdvcmRzIFRoZSBhcnJheSBvZiAzMi1iaXQgd29yZHMuXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc2lnQnl0ZXMgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGlzIHdvcmQgYXJyYXkuXHJcbiAgICAgKi9cclxuICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXkgPSBCYXNlLmV4dGVuZCh7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIHdvcmQgYXJyYXkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyAoT3B0aW9uYWwpIEFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc2lnQnl0ZXMgKE9wdGlvbmFsKSBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGJ5dGVzIGluIHRoZSB3b3Jkcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKCk7XHJcbiAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbMHgwMDAxMDIwMywgMHgwNDA1MDYwN10pO1xyXG4gICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoWzB4MDAwMTAyMDMsIDB4MDQwNTA2MDddLCA2KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBpbml0OiBmdW5jdGlvbiAod29yZHMsIHNpZ0J5dGVzKSB7XHJcbiAgICAgICAgICAgIHdvcmRzID0gdGhpcy53b3JkcyA9IHdvcmRzIHx8IFtdO1xyXG5cclxuICAgICAgICAgICAgaWYgKHNpZ0J5dGVzICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyA9IHNpZ0J5dGVzO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyA9IHdvcmRzLmxlbmd0aCAqIDQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIHdvcmQgYXJyYXkgdG8gYSBzdHJpbmcuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXIgKE9wdGlvbmFsKSBUaGUgZW5jb2Rpbmcgc3RyYXRlZ3kgdG8gdXNlLiBEZWZhdWx0OiBDcnlwdG9KUy5lbmMuSGV4XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmdpZmllZCB3b3JkIGFycmF5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5ICsgJyc7XHJcbiAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSB3b3JkQXJyYXkudG9TdHJpbmcoKTtcclxuICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheS50b1N0cmluZyhDcnlwdG9KUy5lbmMuVXRmOCk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIChlbmNvZGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoZW5jb2RlciB8fCBIZXgpLnN0cmluZ2lmeSh0aGlzKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25jYXRlbmF0ZXMgYSB3b3JkIGFycmF5IHRvIHRoaXMgd29yZCBhcnJheS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkgdG8gYXBwZW5kLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGlzIHdvcmQgYXJyYXkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHdvcmRBcnJheTEuY29uY2F0KHdvcmRBcnJheTIpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbmNhdDogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xyXG4gICAgICAgICAgICAvLyBTaG9ydGN1dHNcclxuICAgICAgICAgICAgdmFyIHRoaXNXb3JkcyA9IHRoaXMud29yZHM7XHJcbiAgICAgICAgICAgIHZhciB0aGF0V29yZHMgPSB3b3JkQXJyYXkud29yZHM7XHJcbiAgICAgICAgICAgIHZhciB0aGlzU2lnQnl0ZXMgPSB0aGlzLnNpZ0J5dGVzO1xyXG4gICAgICAgICAgICB2YXIgdGhhdFNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2xhbXAgZXhjZXNzIGJpdHNcclxuICAgICAgICAgICAgdGhpcy5jbGFtcCgpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29uY2F0XHJcbiAgICAgICAgICAgIGlmICh0aGlzU2lnQnl0ZXMgJSA0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDb3B5IG9uZSBieXRlIGF0IGEgdGltZVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0U2lnQnl0ZXM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aGF0Qnl0ZSA9ICh0aGF0V29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXNXb3Jkc1sodGhpc1NpZ0J5dGVzICsgaSkgPj4+IDJdIHw9IHRoYXRCeXRlIDw8ICgyNCAtICgodGhpc1NpZ0J5dGVzICsgaSkgJSA0KSAqIDgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoYXRXb3Jkcy5sZW5ndGggPiAweGZmZmYpIHtcclxuICAgICAgICAgICAgICAgIC8vIENvcHkgb25lIHdvcmQgYXQgYSB0aW1lXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoYXRTaWdCeXRlczsgaSArPSA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpc1dvcmRzWyh0aGlzU2lnQnl0ZXMgKyBpKSA+Pj4gMl0gPSB0aGF0V29yZHNbaSA+Pj4gMl07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDb3B5IGFsbCB3b3JkcyBhdCBvbmNlXHJcbiAgICAgICAgICAgICAgICB0aGlzV29yZHMucHVzaC5hcHBseSh0aGlzV29yZHMsIHRoYXRXb3Jkcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyArPSB0aGF0U2lnQnl0ZXM7XHJcblxyXG4gICAgICAgICAgICAvLyBDaGFpbmFibGVcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyBpbnNpZ25pZmljYW50IGJpdHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHdvcmRBcnJheS5jbGFtcCgpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYW1wOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xyXG4gICAgICAgICAgICB2YXIgd29yZHMgPSB0aGlzLndvcmRzO1xyXG4gICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB0aGlzLnNpZ0J5dGVzO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2xhbXBcclxuICAgICAgICAgICAgd29yZHNbc2lnQnl0ZXMgPj4+IDJdICY9IDB4ZmZmZmZmZmYgPDwgKDMyIC0gKHNpZ0J5dGVzICUgNCkgKiA4KTtcclxuICAgICAgICAgICAgd29yZHMubGVuZ3RoID0gTWF0aC5jZWlsKHNpZ0J5dGVzIC8gNCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyB3b3JkIGFycmF5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgY2xvbmUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBjbG9uZSA9IHdvcmRBcnJheS5jbG9uZSgpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBjbG9uZSA9IEJhc2UuY2xvbmUuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgY2xvbmUud29yZHMgPSB0aGlzLndvcmRzLnNsaWNlKDApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSB3b3JkIGFycmF5IGZpbGxlZCB3aXRoIHJhbmRvbSBieXRlcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuQnl0ZXMgVGhlIG51bWJlciBvZiByYW5kb20gYnl0ZXMgdG8gZ2VuZXJhdGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSByYW5kb20gd29yZCBhcnJheS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkucmFuZG9tKDE2KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICByYW5kb206IGZ1bmN0aW9uIChuQnl0ZXMpIHtcclxuICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkJ5dGVzOyBpICs9IDQpIHtcclxuICAgICAgICAgICAgICAgIHdvcmRzLnB1c2goKE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAwMCkgfCAwKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdCh3b3JkcywgbkJ5dGVzKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEVuY29kZXIgbmFtZXNwYWNlLlxyXG4gICAgICovXHJcbiAgICB2YXIgQ19lbmMgPSBDLmVuYyA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGV4IGVuY29kaW5nIHN0cmF0ZWd5LlxyXG4gICAgICovXHJcbiAgICB2YXIgSGV4ID0gQ19lbmMuSGV4ID0ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIGhleCBzdHJpbmcuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgaGV4IHN0cmluZy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIGhleFN0cmluZyA9IENyeXB0b0pTLmVuYy5IZXguc3RyaW5naWZ5KHdvcmRBcnJheSk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XHJcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xyXG4gICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XHJcbiAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcclxuXHJcbiAgICAgICAgICAgIC8vIENvbnZlcnRcclxuICAgICAgICAgICAgdmFyIGhleENoYXJzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGJpdGUgPSAod29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xyXG4gICAgICAgICAgICAgICAgaGV4Q2hhcnMucHVzaCgoYml0ZSA+Pj4gNCkudG9TdHJpbmcoMTYpKTtcclxuICAgICAgICAgICAgICAgIGhleENoYXJzLnB1c2goKGJpdGUgJiAweDBmKS50b1N0cmluZygxNikpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gaGV4Q2hhcnMuam9pbignJyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgYSBoZXggc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBoZXhTdHIgVGhlIGhleCBzdHJpbmcuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkhleC5wYXJzZShoZXhTdHJpbmcpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoaGV4U3RyKSB7XHJcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0XHJcbiAgICAgICAgICAgIHZhciBoZXhTdHJMZW5ndGggPSBoZXhTdHIubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29udmVydFxyXG4gICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZXhTdHJMZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gM10gfD0gcGFyc2VJbnQoaGV4U3RyLnN1YnN0cihpLCAyKSwgMTYpIDw8ICgyNCAtIChpICUgOCkgKiA0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdCh3b3JkcywgaGV4U3RyTGVuZ3RoIC8gMik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExhdGluMSBlbmNvZGluZyBzdHJhdGVneS5cclxuICAgICAqL1xyXG4gICAgdmFyIExhdGluMSA9IENfZW5jLkxhdGluMSA9IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBMYXRpbjEgc3RyaW5nLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIExhdGluMSBzdHJpbmcuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBsYXRpbjFTdHJpbmcgPSBDcnlwdG9KUy5lbmMuTGF0aW4xLnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xyXG4gICAgICAgICAgICAvLyBTaG9ydGN1dHNcclxuICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xyXG4gICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XHJcblxyXG4gICAgICAgICAgICAvLyBDb252ZXJ0XHJcbiAgICAgICAgICAgIHZhciBsYXRpbjFDaGFycyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBiaXRlID0gKHdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcclxuICAgICAgICAgICAgICAgIGxhdGluMUNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShiaXRlKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBsYXRpbjFDaGFycy5qb2luKCcnKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyBhIExhdGluMSBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGxhdGluMVN0ciBUaGUgTGF0aW4xIHN0cmluZy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuTGF0aW4xLnBhcnNlKGxhdGluMVN0cmluZyk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChsYXRpbjFTdHIpIHtcclxuICAgICAgICAgICAgLy8gU2hvcnRjdXRcclxuICAgICAgICAgICAgdmFyIGxhdGluMVN0ckxlbmd0aCA9IGxhdGluMVN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAvLyBDb252ZXJ0XHJcbiAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGluMVN0ckxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAyXSB8PSAobGF0aW4xU3RyLmNoYXJDb2RlQXQoaSkgJiAweGZmKSA8PCAoMjQgLSAoaSAlIDQpICogOCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsIGxhdGluMVN0ckxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVURi04IGVuY29kaW5nIHN0cmF0ZWd5LlxyXG4gICAgICovXHJcbiAgICB2YXIgVXRmOCA9IENfZW5jLlV0ZjggPSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgVVRGLTggc3RyaW5nLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFVURi04IHN0cmluZy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIHV0ZjhTdHJpbmcgPSBDcnlwdG9KUy5lbmMuVXRmOC5zdHJpbmdpZnkod29yZEFycmF5KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKExhdGluMS5zdHJpbmdpZnkod29yZEFycmF5KSkpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBVVEYtOCBkYXRhJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyBhIFVURi04IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXRmOFN0ciBUaGUgVVRGLTggc3RyaW5nLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5VdGY4LnBhcnNlKHV0ZjhTdHJpbmcpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAodXRmOFN0cikge1xyXG4gICAgICAgICAgICByZXR1cm4gTGF0aW4xLnBhcnNlKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCh1dGY4U3RyKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBYnN0cmFjdCBidWZmZXJlZCBibG9jayBhbGdvcml0aG0gdGVtcGxhdGUuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIHByb3BlcnR5IGJsb2NrU2l6ZSBtdXN0IGJlIGltcGxlbWVudGVkIGluIGEgY29uY3JldGUgc3VidHlwZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gX21pbkJ1ZmZlclNpemUgVGhlIG51bWJlciBvZiBibG9ja3MgdGhhdCBzaG91bGQgYmUga2VwdCB1bnByb2Nlc3NlZCBpbiB0aGUgYnVmZmVyLiBEZWZhdWx0OiAwXHJcbiAgICAgKi9cclxuICAgIHZhciBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtID0gQ19saWIuQnVmZmVyZWRCbG9ja0FsZ29yaXRobSA9IEJhc2UuZXh0ZW5kKHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXNldHMgdGhpcyBibG9jayBhbGdvcml0aG0ncyBkYXRhIGJ1ZmZlciB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5yZXNldCgpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIEluaXRpYWwgdmFsdWVzXHJcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgV29yZEFycmF5LmluaXQoKTtcclxuICAgICAgICAgICAgdGhpcy5fbkRhdGFCeXRlcyA9IDA7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBuZXcgZGF0YSB0byB0aGlzIGJsb2NrIGFsZ29yaXRobSdzIGJ1ZmZlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBhcHBlbmQuIFN0cmluZ3MgYXJlIGNvbnZlcnRlZCB0byBhIFdvcmRBcnJheSB1c2luZyBVVEYtOC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fYXBwZW5kKCdkYXRhJyk7XHJcbiAgICAgICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX2FwcGVuZCh3b3JkQXJyYXkpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9hcHBlbmQ6IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIFdvcmRBcnJheSwgZWxzZSBhc3N1bWUgV29yZEFycmF5IGFscmVhZHlcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gVXRmOC5wYXJzZShkYXRhKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQXBwZW5kXHJcbiAgICAgICAgICAgIHRoaXMuX2RhdGEuY29uY2F0KGRhdGEpO1xyXG4gICAgICAgICAgICB0aGlzLl9uRGF0YUJ5dGVzICs9IGRhdGEuc2lnQnl0ZXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvY2Vzc2VzIGF2YWlsYWJsZSBkYXRhIGJsb2Nrcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGludm9rZXMgX2RvUHJvY2Vzc0Jsb2NrKG9mZnNldCksIHdoaWNoIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgYSBjb25jcmV0ZSBzdWJ0eXBlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBkb0ZsdXNoIFdoZXRoZXIgYWxsIGJsb2NrcyBhbmQgcGFydGlhbCBibG9ja3Mgc2hvdWxkIGJlIHByb2Nlc3NlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHByb2Nlc3NlZCBkYXRhLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgcHJvY2Vzc2VkRGF0YSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX3Byb2Nlc3MoKTtcclxuICAgICAgICAgKiAgICAgdmFyIHByb2Nlc3NlZERhdGEgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgX3Byb2Nlc3M6IGZ1bmN0aW9uIChkb0ZsdXNoKSB7XHJcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XHJcbiAgICAgICAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xyXG4gICAgICAgICAgICB2YXIgZGF0YVNpZ0J5dGVzID0gZGF0YS5zaWdCeXRlcztcclxuICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IHRoaXMuYmxvY2tTaXplO1xyXG4gICAgICAgICAgICB2YXIgYmxvY2tTaXplQnl0ZXMgPSBibG9ja1NpemUgKiA0O1xyXG5cclxuICAgICAgICAgICAgLy8gQ291bnQgYmxvY2tzIHJlYWR5XHJcbiAgICAgICAgICAgIHZhciBuQmxvY2tzUmVhZHkgPSBkYXRhU2lnQnl0ZXMgLyBibG9ja1NpemVCeXRlcztcclxuICAgICAgICAgICAgaWYgKGRvRmx1c2gpIHtcclxuICAgICAgICAgICAgICAgIC8vIFJvdW5kIHVwIHRvIGluY2x1ZGUgcGFydGlhbCBibG9ja3NcclxuICAgICAgICAgICAgICAgIG5CbG9ja3NSZWFkeSA9IE1hdGguY2VpbChuQmxvY2tzUmVhZHkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gUm91bmQgZG93biB0byBpbmNsdWRlIG9ubHkgZnVsbCBibG9ja3MsXHJcbiAgICAgICAgICAgICAgICAvLyBsZXNzIHRoZSBudW1iZXIgb2YgYmxvY2tzIHRoYXQgbXVzdCByZW1haW4gaW4gdGhlIGJ1ZmZlclxyXG4gICAgICAgICAgICAgICAgbkJsb2Nrc1JlYWR5ID0gTWF0aC5tYXgoKG5CbG9ja3NSZWFkeSB8IDApIC0gdGhpcy5fbWluQnVmZmVyU2l6ZSwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENvdW50IHdvcmRzIHJlYWR5XHJcbiAgICAgICAgICAgIHZhciBuV29yZHNSZWFkeSA9IG5CbG9ja3NSZWFkeSAqIGJsb2NrU2l6ZTtcclxuXHJcbiAgICAgICAgICAgIC8vIENvdW50IGJ5dGVzIHJlYWR5XHJcbiAgICAgICAgICAgIHZhciBuQnl0ZXNSZWFkeSA9IE1hdGgubWluKG5Xb3Jkc1JlYWR5ICogNCwgZGF0YVNpZ0J5dGVzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgYmxvY2tzXHJcbiAgICAgICAgICAgIGlmIChuV29yZHNSZWFkeSkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgbldvcmRzUmVhZHk7IG9mZnNldCArPSBibG9ja1NpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWFsZ29yaXRobSBsb2dpY1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvUHJvY2Vzc0Jsb2NrKGRhdGFXb3Jkcywgb2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgcHJvY2Vzc2VkIHdvcmRzXHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvY2Vzc2VkV29yZHMgPSBkYXRhV29yZHMuc3BsaWNlKDAsIG5Xb3Jkc1JlYWR5KTtcclxuICAgICAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgLT0gbkJ5dGVzUmVhZHk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFJldHVybiBwcm9jZXNzZWQgd29yZHNcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdChwcm9jZXNzZWRXb3JkcywgbkJ5dGVzUmVhZHkpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgb2JqZWN0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY2xvbmUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBjbG9uZSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uY2xvbmUoKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgY2xvbmUgPSBCYXNlLmNsb25lLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIGNsb25lLl9kYXRhID0gdGhpcy5fZGF0YS5jbG9uZSgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9taW5CdWZmZXJTaXplOiAwXHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFic3RyYWN0IGhhc2hlciB0ZW1wbGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBudW1iZXIgb2YgMzItYml0IHdvcmRzIHRoaXMgaGFzaGVyIG9wZXJhdGVzIG9uLiBEZWZhdWx0OiAxNiAoNTEyIGJpdHMpXHJcbiAgICAgKi9cclxuICAgIHZhciBIYXNoZXIgPSBDX2xpYi5IYXNoZXIgPSBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLmV4dGVuZCh7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNmZzogQmFzZS5leHRlbmQoKSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGhhc2hlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBoYXNoIGNvbXB1dGF0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIgaGFzaGVyID0gQ3J5cHRvSlMuYWxnby5TSEEyNTYuY3JlYXRlKCk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNmZykge1xyXG4gICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcclxuICAgICAgICAgICAgdGhpcy5jZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNldCBpbml0aWFsIHZhbHVlc1xyXG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVzZXRzIHRoaXMgaGFzaGVyIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICBoYXNoZXIucmVzZXQoKTtcclxuICAgICAgICAgKi9cclxuICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBSZXNldCBkYXRhIGJ1ZmZlclxyXG4gICAgICAgICAgICBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0LmNhbGwodGhpcyk7XHJcblxyXG4gICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWhhc2hlciBsb2dpY1xyXG4gICAgICAgICAgICB0aGlzLl9kb1Jlc2V0KCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlcyB0aGlzIGhhc2hlciB3aXRoIGEgbWVzc2FnZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSBUaGUgbWVzc2FnZSB0byBhcHBlbmQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJuIHtIYXNoZXJ9IFRoaXMgaGFzaGVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICBoYXNoZXIudXBkYXRlKCdtZXNzYWdlJyk7XHJcbiAgICAgICAgICogICAgIGhhc2hlci51cGRhdGUod29yZEFycmF5KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XHJcbiAgICAgICAgICAgIC8vIEFwcGVuZFxyXG4gICAgICAgICAgICB0aGlzLl9hcHBlbmQobWVzc2FnZVVwZGF0ZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGhhc2hcclxuICAgICAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2hhaW5hYmxlXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpbmFsaXplcyB0aGUgaGFzaCBjb21wdXRhdGlvbi5cclxuICAgICAgICAgKiBOb3RlIHRoYXQgdGhlIGZpbmFsaXplIG9wZXJhdGlvbiBpcyBlZmZlY3RpdmVseSBhIGRlc3RydWN0aXZlLCByZWFkLW9uY2Ugb3BlcmF0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIChPcHRpb25hbCkgQSBmaW5hbCBtZXNzYWdlIHVwZGF0ZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKCk7XHJcbiAgICAgICAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKCdtZXNzYWdlJyk7XHJcbiAgICAgICAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKHdvcmRBcnJheSk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZmluYWxpemU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XHJcbiAgICAgICAgICAgIC8vIEZpbmFsIG1lc3NhZ2UgdXBkYXRlXHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlVXBkYXRlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBlbmQobWVzc2FnZVVwZGF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtaGFzaGVyIGxvZ2ljXHJcbiAgICAgICAgICAgIHZhciBoYXNoID0gdGhpcy5fZG9GaW5hbGl6ZSgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGhhc2g7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYmxvY2tTaXplOiA1MTIvMzIsXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBzaG9ydGN1dCBmdW5jdGlvbiB0byBhIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoZXIgdG8gY3JlYXRlIGEgaGVscGVyIGZvci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgc2hvcnRjdXQgZnVuY3Rpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICAgIHZhciBTSEEyNTYgPSBDcnlwdG9KUy5saWIuSGFzaGVyLl9jcmVhdGVIZWxwZXIoQ3J5cHRvSlMuYWxnby5TSEEyNTYpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9jcmVhdGVIZWxwZXI6IGZ1bmN0aW9uIChoYXNoZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlLCBjZmcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaGFzaGVyLmluaXQoY2ZnKS5maW5hbGl6ZShtZXNzYWdlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgc2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaGVyIHRvIHVzZSBpbiB0aGlzIEhNQUMgaGVscGVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBzaG9ydGN1dCBmdW5jdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIEhtYWNTSEEyNTYgPSBDcnlwdG9KUy5saWIuSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKENyeXB0b0pTLmFsZ28uU0hBMjU2KTtcclxuICAgICAgICAgKi9cclxuICAgICAgICBfY3JlYXRlSG1hY0hlbHBlcjogZnVuY3Rpb24gKGhhc2hlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UsIGtleSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDX2FsZ28uSE1BQy5pbml0KGhhc2hlciwga2V5KS5maW5hbGl6ZShtZXNzYWdlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFsZ29yaXRobSBuYW1lc3BhY2UuXHJcbiAgICAgKi9cclxuICAgIHZhciBDX2FsZ28gPSBDLmFsZ28gPSB7fTtcclxuXHJcbiAgICByZXR1cm4gQztcclxufShNYXRoKSk7XHJcblxyXG5leHBvcnRzLkNyeXB0b0pTID0gQ3J5cHRvSlM7XHJcbiIsInZhciBDcnlwdG9KUyA9IHJlcXVpcmUoJy4vY29yZScpLkNyeXB0b0pTO1xuXG4vKlxuQ3J5cHRvSlMgdjMuMS4yXG5jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanNcbihjKSAyMDA5LTIwMTMgYnkgSmVmZiBNb3R0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzL3dpa2kvTGljZW5zZVxuKi9cbihmdW5jdGlvbiAoKSB7XG4gICAgLy8gU2hvcnRjdXRzXG4gICAgdmFyIEMgPSBDcnlwdG9KUztcbiAgICB2YXIgQ19saWIgPSBDLmxpYjtcbiAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuICAgIHZhciBDX2VuYyA9IEMuZW5jO1xuXG4gICAgLyoqXG4gICAgICogQmFzZTY0IGVuY29kaW5nIHN0cmF0ZWd5LlxuICAgICAqL1xuICAgIHZhciBCYXNlNjQgPSBDX2VuYy5CYXNlNjQgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBCYXNlNjQgc3RyaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBCYXNlNjQgc3RyaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICB2YXIgYmFzZTY0U3RyaW5nID0gQ3J5cHRvSlMuZW5jLkJhc2U2NC5zdHJpbmdpZnkod29yZEFycmF5KTtcbiAgICAgICAgICovXG4gICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG4gICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG4gICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG4gICAgICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG4gICAgICAgICAgICAvLyBDbGFtcCBleGNlc3MgYml0c1xuICAgICAgICAgICAgd29yZEFycmF5LmNsYW1wKCk7XG5cbiAgICAgICAgICAgIC8vIENvbnZlcnRcbiAgICAgICAgICAgIHZhciBiYXNlNjRDaGFycyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSArPSAzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ5dGUxID0gKHdvcmRzW2kgPj4+IDJdICAgICAgID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICAgICAgICYgMHhmZjtcbiAgICAgICAgICAgICAgICB2YXIgYnl0ZTIgPSAod29yZHNbKGkgKyAxKSA+Pj4gMl0gPj4+ICgyNCAtICgoaSArIDEpICUgNCkgKiA4KSkgJiAweGZmO1xuICAgICAgICAgICAgICAgIHZhciBieXRlMyA9ICh3b3Jkc1soaSArIDIpID4+PiAyXSA+Pj4gKDI0IC0gKChpICsgMikgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cbiAgICAgICAgICAgICAgICB2YXIgdHJpcGxldCA9IChieXRlMSA8PCAxNikgfCAoYnl0ZTIgPDwgOCkgfCBieXRlMztcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyAoaiA8IDQpICYmIChpICsgaiAqIDAuNzUgPCBzaWdCeXRlcyk7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBiYXNlNjRDaGFycy5wdXNoKG1hcC5jaGFyQXQoKHRyaXBsZXQgPj4+ICg2ICogKDMgLSBqKSkpICYgMHgzZikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcbiAgICAgICAgICAgIHZhciBwYWRkaW5nQ2hhciA9IG1hcC5jaGFyQXQoNjQpO1xuICAgICAgICAgICAgaWYgKHBhZGRpbmdDaGFyKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGJhc2U2NENoYXJzLmxlbmd0aCAlIDQpIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZTY0Q2hhcnMucHVzaChwYWRkaW5nQ2hhcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYmFzZTY0Q2hhcnMuam9pbignJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIGEgQmFzZTY0IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlNjRTdHIgVGhlIEJhc2U2NCBzdHJpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuQmFzZTY0LnBhcnNlKGJhc2U2NFN0cmluZyk7XG4gICAgICAgICAqL1xuICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGJhc2U2NFN0cikge1xuICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG4gICAgICAgICAgICB2YXIgYmFzZTY0U3RyTGVuZ3RoID0gYmFzZTY0U3RyLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cbiAgICAgICAgICAgIC8vIElnbm9yZSBwYWRkaW5nXG4gICAgICAgICAgICB2YXIgcGFkZGluZ0NoYXIgPSBtYXAuY2hhckF0KDY0KTtcbiAgICAgICAgICAgIGlmIChwYWRkaW5nQ2hhcikge1xuICAgICAgICAgICAgICAgIHZhciBwYWRkaW5nSW5kZXggPSBiYXNlNjRTdHIuaW5kZXhPZihwYWRkaW5nQ2hhcik7XG4gICAgICAgICAgICAgICAgaWYgKHBhZGRpbmdJbmRleCAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBiYXNlNjRTdHJMZW5ndGggPSBwYWRkaW5nSW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb252ZXJ0XG4gICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBuQnl0ZXMgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXNlNjRTdHJMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpICUgNCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYml0czEgPSBtYXAuaW5kZXhPZihiYXNlNjRTdHIuY2hhckF0KGkgLSAxKSkgPDwgKChpICUgNCkgKiAyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJpdHMyID0gbWFwLmluZGV4T2YoYmFzZTY0U3RyLmNoYXJBdChpKSkgPj4+ICg2IC0gKGkgJSA0KSAqIDIpO1xuICAgICAgICAgICAgICAgICAgICB3b3Jkc1tuQnl0ZXMgPj4+IDJdIHw9IChiaXRzMSB8IGJpdHMyKSA8PCAoMjQgLSAobkJ5dGVzICUgNCkgKiA4KTtcbiAgICAgICAgICAgICAgICAgICAgbkJ5dGVzKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gV29yZEFycmF5LmNyZWF0ZSh3b3JkcywgbkJ5dGVzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfbWFwOiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nXG4gICAgfTtcbn0oKSk7XG4iLCJ2YXIgQ3J5cHRvSlMgPSByZXF1aXJlKCcuL2NvcmUnKS5DcnlwdG9KUztcclxuXHJcbi8qXG5DcnlwdG9KUyB2My4xLjJcbmNvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qc1xuKGMpIDIwMDktMjAxMyBieSBKZWZmIE1vdHQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanMvd2lraS9MaWNlbnNlXG4qL1xuKGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIFNob3J0Y3V0c1xyXG4gICAgdmFyIEMgPSBDcnlwdG9KUztcclxuICAgIHZhciBDX2xpYiA9IEMubGliO1xyXG4gICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlO1xyXG4gICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcclxuICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XHJcbiAgICB2YXIgTUQ1ID0gQ19hbGdvLk1ENTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMga2V5IGRlcml2YXRpb24gZnVuY3Rpb24gaXMgbWVhbnQgdG8gY29uZm9ybSB3aXRoIEVWUF9CeXRlc1RvS2V5LlxyXG4gICAgICogd3d3Lm9wZW5zc2wub3JnL2RvY3MvY3J5cHRvL0VWUF9CeXRlc1RvS2V5Lmh0bWxcclxuICAgICAqL1xyXG4gICAgdmFyIEV2cEtERiA9IENfYWxnby5FdnBLREYgPSBCYXNlLmV4dGVuZCh7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGtleVNpemUgVGhlIGtleSBzaXplIGluIHdvcmRzIHRvIGdlbmVyYXRlLiBEZWZhdWx0OiA0ICgxMjggYml0cylcclxuICAgICAgICAgKiBAcHJvcGVydHkge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoIGFsZ29yaXRobSB0byB1c2UuIERlZmF1bHQ6IE1ENVxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpdGVyYXRpb25zIFRoZSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBwZXJmb3JtLiBEZWZhdWx0OiAxXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCh7XHJcbiAgICAgICAgICAgIGtleVNpemU6IDEyOC8zMixcclxuICAgICAgICAgICAgaGFzaGVyOiBNRDUsXHJcbiAgICAgICAgICAgIGl0ZXJhdGlvbnM6IDFcclxuICAgICAgICB9KSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGUgZGVyaXZhdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgICAgdmFyIGtkZiA9IENyeXB0b0pTLmFsZ28uRXZwS0RGLmNyZWF0ZSgpO1xyXG4gICAgICAgICAqICAgICB2YXIga2RmID0gQ3J5cHRvSlMuYWxnby5FdnBLREYuY3JlYXRlKHsga2V5U2l6ZTogOCB9KTtcclxuICAgICAgICAgKiAgICAgdmFyIGtkZiA9IENyeXB0b0pTLmFsZ28uRXZwS0RGLmNyZWF0ZSh7IGtleVNpemU6IDgsIGl0ZXJhdGlvbnM6IDEwMDAgfSk7XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNmZykge1xyXG4gICAgICAgICAgICB0aGlzLmNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlcml2ZXMgYSBrZXkgZnJvbSBhIHBhc3N3b3JkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXHJcbiAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBzYWx0IEEgc2FsdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRlcml2ZWQga2V5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICAgICB2YXIga2V5ID0ga2RmLmNvbXB1dGUocGFzc3dvcmQsIHNhbHQpO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbXB1dGU6IGZ1bmN0aW9uIChwYXNzd29yZCwgc2FsdCkge1xyXG4gICAgICAgICAgICAvLyBTaG9ydGN1dFxyXG4gICAgICAgICAgICB2YXIgY2ZnID0gdGhpcy5jZmc7XHJcblxyXG4gICAgICAgICAgICAvLyBJbml0IGhhc2hlclxyXG4gICAgICAgICAgICB2YXIgaGFzaGVyID0gY2ZnLmhhc2hlci5jcmVhdGUoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEluaXRpYWwgdmFsdWVzXHJcbiAgICAgICAgICAgIHZhciBkZXJpdmVkS2V5ID0gV29yZEFycmF5LmNyZWF0ZSgpO1xyXG5cclxuICAgICAgICAgICAgLy8gU2hvcnRjdXRzXHJcbiAgICAgICAgICAgIHZhciBkZXJpdmVkS2V5V29yZHMgPSBkZXJpdmVkS2V5LndvcmRzO1xyXG4gICAgICAgICAgICB2YXIga2V5U2l6ZSA9IGNmZy5rZXlTaXplO1xyXG4gICAgICAgICAgICB2YXIgaXRlcmF0aW9ucyA9IGNmZy5pdGVyYXRpb25zO1xyXG5cclxuICAgICAgICAgICAgLy8gR2VuZXJhdGUga2V5XHJcbiAgICAgICAgICAgIHdoaWxlIChkZXJpdmVkS2V5V29yZHMubGVuZ3RoIDwga2V5U2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzaGVyLnVwZGF0ZShibG9jayk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2sgPSBoYXNoZXIudXBkYXRlKHBhc3N3b3JkKS5maW5hbGl6ZShzYWx0KTtcclxuICAgICAgICAgICAgICAgIGhhc2hlci5yZXNldCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEl0ZXJhdGlvbnNcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgaXRlcmF0aW9uczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2sgPSBoYXNoZXIuZmluYWxpemUoYmxvY2spO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc2hlci5yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGRlcml2ZWRLZXkuY29uY2F0KGJsb2NrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZXJpdmVkS2V5LnNpZ0J5dGVzID0ga2V5U2l6ZSAqIDQ7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZGVyaXZlZEtleTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlcml2ZXMgYSBrZXkgZnJvbSBhIHBhc3N3b3JkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxyXG4gICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBzYWx0IEEgc2FsdC5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBjb21wdXRhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkZXJpdmVkIGtleS5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiAgICAgdmFyIGtleSA9IENyeXB0b0pTLkV2cEtERihwYXNzd29yZCwgc2FsdCk7XHJcbiAgICAgKiAgICAgdmFyIGtleSA9IENyeXB0b0pTLkV2cEtERihwYXNzd29yZCwgc2FsdCwgeyBrZXlTaXplOiA4IH0pO1xyXG4gICAgICogICAgIHZhciBrZXkgPSBDcnlwdG9KUy5FdnBLREYocGFzc3dvcmQsIHNhbHQsIHsga2V5U2l6ZTogOCwgaXRlcmF0aW9uczogMTAwMCB9KTtcclxuICAgICAqL1xyXG4gICAgQy5FdnBLREYgPSBmdW5jdGlvbiAocGFzc3dvcmQsIHNhbHQsIGNmZykge1xyXG4gICAgICAgIHJldHVybiBFdnBLREYuY3JlYXRlKGNmZykuY29tcHV0ZShwYXNzd29yZCwgc2FsdCk7XHJcbiAgICB9O1xyXG59KCkpO1xyXG4iLCJ2YXIgQ3J5cHRvSlMgPSByZXF1aXJlKCcuL2NvcmUnKS5DcnlwdG9KUztcblxuLy8gY3JlYXRlIGN1c3RvbSBqc29uIHNlcmlhbGl6YXRpb24gZm9ybWF0XG52YXIgSnNvbkZvcm1hdHRlciA9IHtcblx0c3RyaW5naWZ5OiBmdW5jdGlvbiAoY2lwaGVyUGFyYW1zKSB7XG5cdFx0Ly8gY3JlYXRlIGpzb24gb2JqZWN0IHdpdGggY2lwaGVydGV4dFxuXHRcdHZhciBqc29uT2JqID0ge1xuXHRcdFx0Y3Q6IGNpcGhlclBhcmFtcy5jaXBoZXJ0ZXh0LnRvU3RyaW5nKENyeXB0b0pTLmVuYy5CYXNlNjQpXG5cdFx0fTtcblx0XHRcblx0XHQvLyBvcHRpb25hbGx5IGFkZCBpdiBhbmQgc2FsdFxuXHRcdGlmIChjaXBoZXJQYXJhbXMuaXYpIHtcblx0XHRcdGpzb25PYmouaXYgPSBjaXBoZXJQYXJhbXMuaXYudG9TdHJpbmcoKTtcblx0XHR9XG5cdFx0XG5cdFx0aWYgKGNpcGhlclBhcmFtcy5zYWx0KSB7XG5cdFx0XHRqc29uT2JqLnMgPSBjaXBoZXJQYXJhbXMuc2FsdC50b1N0cmluZygpO1xuXHRcdH1cblxuXHRcdC8vIHN0cmluZ2lmeSBqc29uIG9iamVjdFxuXHRcdHJldHVybiBKU09OLnN0cmluZ2lmeShqc29uT2JqKVxuXHR9LFxuXG5cdHBhcnNlOiBmdW5jdGlvbiAoanNvblN0cikge1xuXHRcdC8vIHBhcnNlIGpzb24gc3RyaW5nXG5cdFx0dmFyIGpzb25PYmogPSBKU09OLnBhcnNlKGpzb25TdHIpO1xuXHRcdFxuXHRcdC8vIGV4dHJhY3QgY2lwaGVydGV4dCBmcm9tIGpzb24gb2JqZWN0LCBhbmQgY3JlYXRlIGNpcGhlciBwYXJhbXMgb2JqZWN0XG5cdFx0dmFyIGNpcGhlclBhcmFtcyA9IENyeXB0b0pTLmxpYi5DaXBoZXJQYXJhbXMuY3JlYXRlKHtcblx0XHRcdGNpcGhlcnRleHQ6IENyeXB0b0pTLmVuYy5CYXNlNjQucGFyc2UoanNvbk9iai5jdClcblx0XHR9KTtcblx0XHRcblx0XHQvLyBvcHRpb25hbGx5IGV4dHJhY3QgaXYgYW5kIHNhbHRcblx0XHRpZiAoanNvbk9iai5pdikge1xuXHRcdFx0Y2lwaGVyUGFyYW1zLml2ID0gQ3J5cHRvSlMuZW5jLkhleC5wYXJzZShqc29uT2JqLml2KTtcblx0XHR9XG4gICAgICAgICAgICBcblx0XHRpZiAoanNvbk9iai5zKSB7XG5cdFx0XHRjaXBoZXJQYXJhbXMuc2FsdCA9IENyeXB0b0pTLmVuYy5IZXgucGFyc2UoanNvbk9iai5zKTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIGNpcGhlclBhcmFtcztcblx0fVxufTtcblxuZXhwb3J0cy5Kc29uRm9ybWF0dGVyID0gSnNvbkZvcm1hdHRlcjsiLCJ2YXIgQ3J5cHRvSlMgPSByZXF1aXJlKCcuL2NvcmUnKS5DcnlwdG9KUztcclxuXHJcbi8qXG5DcnlwdG9KUyB2My4xLjJcbmNvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qc1xuKGMpIDIwMDktMjAxMyBieSBKZWZmIE1vdHQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanMvd2lraS9MaWNlbnNlXG4qL1xuKGZ1bmN0aW9uIChNYXRoKSB7XHJcbiAgICAvLyBTaG9ydGN1dHNcclxuICAgIHZhciBDID0gQ3J5cHRvSlM7XHJcbiAgICB2YXIgQ19saWIgPSBDLmxpYjtcclxuICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XHJcbiAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyO1xyXG4gICAgdmFyIENfYWxnbyA9IEMuYWxnbztcclxuXHJcbiAgICAvLyBDb25zdGFudHMgdGFibGVcclxuICAgIHZhciBUID0gW107XHJcblxyXG4gICAgLy8gQ29tcHV0ZSBjb25zdGFudHNcclxuICAgIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XHJcbiAgICAgICAgICAgIFRbaV0gPSAoTWF0aC5hYnMoTWF0aC5zaW4oaSArIDEpKSAqIDB4MTAwMDAwMDAwKSB8IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfSgpKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1ENSBoYXNoIGFsZ29yaXRobS5cclxuICAgICAqL1xyXG4gICAgdmFyIE1ENSA9IENfYWxnby5NRDUgPSBIYXNoZXIuZXh0ZW5kKHtcclxuICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9oYXNoID0gbmV3IFdvcmRBcnJheS5pbml0KFtcclxuICAgICAgICAgICAgICAgIDB4Njc0NTIzMDEsIDB4ZWZjZGFiODksXHJcbiAgICAgICAgICAgICAgICAweDk4YmFkY2ZlLCAweDEwMzI1NDc2XHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xyXG4gICAgICAgICAgICAvLyBTd2FwIGVuZGlhblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xyXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldF9pID0gb2Zmc2V0ICsgaTtcclxuICAgICAgICAgICAgICAgIHZhciBNX29mZnNldF9pID0gTVtvZmZzZXRfaV07XHJcblxyXG4gICAgICAgICAgICAgICAgTVtvZmZzZXRfaV0gPSAoXHJcbiAgICAgICAgICAgICAgICAgICAgKCgoTV9vZmZzZXRfaSA8PCA4KSAgfCAoTV9vZmZzZXRfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcclxuICAgICAgICAgICAgICAgICAgICAoKChNX29mZnNldF9pIDw8IDI0KSB8IChNX29mZnNldF9pID4+PiA4KSkgICYgMHhmZjAwZmYwMClcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xyXG4gICAgICAgICAgICB2YXIgSCA9IHRoaXMuX2hhc2gud29yZHM7XHJcblxyXG4gICAgICAgICAgICB2YXIgTV9vZmZzZXRfMCAgPSBNW29mZnNldCArIDBdO1xyXG4gICAgICAgICAgICB2YXIgTV9vZmZzZXRfMSAgPSBNW29mZnNldCArIDFdO1xyXG4gICAgICAgICAgICB2YXIgTV9vZmZzZXRfMiAgPSBNW29mZnNldCArIDJdO1xyXG4gICAgICAgICAgICB2YXIgTV9vZmZzZXRfMyAgPSBNW29mZnNldCArIDNdO1xyXG4gICAgICAgICAgICB2YXIgTV9vZmZzZXRfNCAgPSBNW29mZnNldCArIDRdO1xyXG4gICAgICAgICAgICB2YXIgTV9vZmZzZXRfNSAgPSBNW29mZnNldCArIDVdO1xyXG4gICAgICAgICAgICB2YXIgTV9vZmZzZXRfNiAgPSBNW29mZnNldCArIDZdO1xyXG4gICAgICAgICAgICB2YXIgTV9vZmZzZXRfNyAgPSBNW29mZnNldCArIDddO1xyXG4gICAgICAgICAgICB2YXIgTV9vZmZzZXRfOCAgPSBNW29mZnNldCArIDhdO1xyXG4gICAgICAgICAgICB2YXIgTV9vZmZzZXRfOSAgPSBNW29mZnNldCArIDldO1xyXG4gICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTAgPSBNW29mZnNldCArIDEwXTtcclxuICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzExID0gTVtvZmZzZXQgKyAxMV07XHJcbiAgICAgICAgICAgIHZhciBNX29mZnNldF8xMiA9IE1bb2Zmc2V0ICsgMTJdO1xyXG4gICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTMgPSBNW29mZnNldCArIDEzXTtcclxuICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzE0ID0gTVtvZmZzZXQgKyAxNF07XHJcbiAgICAgICAgICAgIHZhciBNX29mZnNldF8xNSA9IE1bb2Zmc2V0ICsgMTVdO1xyXG5cclxuICAgICAgICAgICAgLy8gV29ya2luZyB2YXJpYWxiZXNcclxuICAgICAgICAgICAgdmFyIGEgPSBIWzBdO1xyXG4gICAgICAgICAgICB2YXIgYiA9IEhbMV07XHJcbiAgICAgICAgICAgIHZhciBjID0gSFsyXTtcclxuICAgICAgICAgICAgdmFyIGQgPSBIWzNdO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29tcHV0YXRpb25cclxuICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzAsICA3LCAgVFswXSk7XHJcbiAgICAgICAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF8xLCAgMTIsIFRbMV0pO1xyXG4gICAgICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfMiwgIDE3LCBUWzJdKTtcclxuICAgICAgICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzMsICAyMiwgVFszXSk7XHJcbiAgICAgICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF80LCAgNywgIFRbNF0pO1xyXG4gICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfNSwgIDEyLCBUWzVdKTtcclxuICAgICAgICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzYsICAxNywgVFs2XSk7XHJcbiAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF83LCAgMjIsIFRbN10pO1xyXG4gICAgICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfOCwgIDcsICBUWzhdKTtcclxuICAgICAgICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzksICAxMiwgVFs5XSk7XHJcbiAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF8xMCwgMTcsIFRbMTBdKTtcclxuICAgICAgICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzExLCAyMiwgVFsxMV0pO1xyXG4gICAgICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfMTIsIDcsICBUWzEyXSk7XHJcbiAgICAgICAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF8xMywgMTIsIFRbMTNdKTtcclxuICAgICAgICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE0LCAxNywgVFsxNF0pO1xyXG4gICAgICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTUsIDIyLCBUWzE1XSk7XHJcblxyXG4gICAgICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfMSwgIDUsICBUWzE2XSk7XHJcbiAgICAgICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF82LCAgOSwgIFRbMTddKTtcclxuICAgICAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzExLCAxNCwgVFsxOF0pO1xyXG4gICAgICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfMCwgIDIwLCBUWzE5XSk7XHJcbiAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF81LCAgNSwgIFRbMjBdKTtcclxuICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzEwLCA5LCAgVFsyMV0pO1xyXG4gICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfMTUsIDE0LCBUWzIyXSk7XHJcbiAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF80LCAgMjAsIFRbMjNdKTtcclxuICAgICAgICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzksICA1LCAgVFsyNF0pO1xyXG4gICAgICAgICAgICBkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfMTQsIDksICBUWzI1XSk7XHJcbiAgICAgICAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF8zLCAgMTQsIFRbMjZdKTtcclxuICAgICAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzgsICAyMCwgVFsyN10pO1xyXG4gICAgICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfMTMsIDUsICBUWzI4XSk7XHJcbiAgICAgICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF8yLCAgOSwgIFRbMjldKTtcclxuICAgICAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzcsICAxNCwgVFszMF0pO1xyXG4gICAgICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfMTIsIDIwLCBUWzMxXSk7XHJcblxyXG4gICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfNSwgIDQsICBUWzMyXSk7XHJcbiAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF84LCAgMTEsIFRbMzNdKTtcclxuICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzExLCAxNiwgVFszNF0pO1xyXG4gICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTQsIDIzLCBUWzM1XSk7XHJcbiAgICAgICAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBNX29mZnNldF8xLCAgNCwgIFRbMzZdKTtcclxuICAgICAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzQsICAxMSwgVFszN10pO1xyXG4gICAgICAgICAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfNywgIDE2LCBUWzM4XSk7XHJcbiAgICAgICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF8xMCwgMjMsIFRbMzldKTtcclxuICAgICAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEzLCA0LCAgVFs0MF0pO1xyXG4gICAgICAgICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfMCwgIDExLCBUWzQxXSk7XHJcbiAgICAgICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF8zLCAgMTYsIFRbNDJdKTtcclxuICAgICAgICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzYsICAyMywgVFs0M10pO1xyXG4gICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfOSwgIDQsICBUWzQ0XSk7XHJcbiAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF8xMiwgMTEsIFRbNDVdKTtcclxuICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE1LCAxNiwgVFs0Nl0pO1xyXG4gICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMiwgIDIzLCBUWzQ3XSk7XHJcblxyXG4gICAgICAgICAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfMCwgIDYsICBUWzQ4XSk7XHJcbiAgICAgICAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF83LCAgMTAsIFRbNDldKTtcclxuICAgICAgICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE0LCAxNSwgVFs1MF0pO1xyXG4gICAgICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfNSwgIDIxLCBUWzUxXSk7XHJcbiAgICAgICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF8xMiwgNiwgIFRbNTJdKTtcclxuICAgICAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzMsICAxMCwgVFs1M10pO1xyXG4gICAgICAgICAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTAsIDE1LCBUWzU0XSk7XHJcbiAgICAgICAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF8xLCAgMjEsIFRbNTVdKTtcclxuICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzgsICA2LCAgVFs1Nl0pO1xyXG4gICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTUsIDEwLCBUWzU3XSk7XHJcbiAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF82LCAgMTUsIFRbNThdKTtcclxuICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzEzLCAyMSwgVFs1OV0pO1xyXG4gICAgICAgICAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfNCwgIDYsICBUWzYwXSk7XHJcbiAgICAgICAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF8xMSwgMTAsIFRbNjFdKTtcclxuICAgICAgICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzIsICAxNSwgVFs2Ml0pO1xyXG4gICAgICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfOSwgIDIxLCBUWzYzXSk7XHJcblxyXG4gICAgICAgICAgICAvLyBJbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxyXG4gICAgICAgICAgICBIWzBdID0gKEhbMF0gKyBhKSB8IDA7XHJcbiAgICAgICAgICAgIEhbMV0gPSAoSFsxXSArIGIpIHwgMDtcclxuICAgICAgICAgICAgSFsyXSA9IChIWzJdICsgYykgfCAwO1xyXG4gICAgICAgICAgICBIWzNdID0gKEhbM10gKyBkKSB8IDA7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gU2hvcnRjdXRzXHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcclxuICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XHJcblxyXG4gICAgICAgICAgICB2YXIgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xyXG4gICAgICAgICAgICB2YXIgbkJpdHNMZWZ0ID0gZGF0YS5zaWdCeXRlcyAqIDg7XHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xyXG4gICAgICAgICAgICBkYXRhV29yZHNbbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDgwIDw8ICgyNCAtIG5CaXRzTGVmdCAlIDMyKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBuQml0c1RvdGFsSCA9IE1hdGguZmxvb3IobkJpdHNUb3RhbCAvIDB4MTAwMDAwMDAwKTtcclxuICAgICAgICAgICAgdmFyIG5CaXRzVG90YWxMID0gbkJpdHNUb3RhbDtcclxuICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNV0gPSAoXHJcbiAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsSCA8PCA4KSAgfCAobkJpdHNUb3RhbEggPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XHJcbiAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsSCA8PCAyNCkgfCAobkJpdHNUb3RhbEggPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IChcclxuICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxMIDw8IDgpICB8IChuQml0c1RvdGFsTCA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcclxuICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxMIDw8IDI0KSB8IChuQml0c1RvdGFsTCA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBkYXRhLnNpZ0J5dGVzID0gKGRhdGFXb3Jkcy5sZW5ndGggKyAxKSAqIDQ7XHJcblxyXG4gICAgICAgICAgICAvLyBIYXNoIGZpbmFsIGJsb2Nrc1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBTaG9ydGN1dHNcclxuICAgICAgICAgICAgdmFyIGhhc2ggPSB0aGlzLl9oYXNoO1xyXG4gICAgICAgICAgICB2YXIgSCA9IGhhc2gud29yZHM7XHJcblxyXG4gICAgICAgICAgICAvLyBTd2FwIGVuZGlhblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRcclxuICAgICAgICAgICAgICAgIHZhciBIX2kgPSBIW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgIEhbaV0gPSAoKChIX2kgPDwgOCkgIHwgKEhfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcclxuICAgICAgICAgICAgICAgICAgICAgICAoKChIX2kgPDwgMjQpIHwgKEhfaSA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxyXG4gICAgICAgICAgICByZXR1cm4gaGFzaDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgY2xvbmUgPSBIYXNoZXIuY2xvbmUuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgY2xvbmUuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY2xvbmU7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgZnVuY3Rpb24gRkYoYSwgYiwgYywgZCwgeCwgcywgdCkge1xyXG4gICAgICAgIHZhciBuID0gYSArICgoYiAmIGMpIHwgKH5iICYgZCkpICsgeCArIHQ7XHJcbiAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBHRyhhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XHJcbiAgICAgICAgdmFyIG4gPSBhICsgKChiICYgZCkgfCAoYyAmIH5kKSkgKyB4ICsgdDtcclxuICAgICAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIEhIKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcclxuICAgICAgICB2YXIgbiA9IGEgKyAoYiBeIGMgXiBkKSArIHggKyB0O1xyXG4gICAgICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gSUkoYSwgYiwgYywgZCwgeCwgcywgdCkge1xyXG4gICAgICAgIHZhciBuID0gYSArIChjIF4gKGIgfCB+ZCkpICsgeCArIHQ7XHJcbiAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuTUQ1KCdtZXNzYWdlJyk7XHJcbiAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5NRDUod29yZEFycmF5KTtcclxuICAgICAqL1xyXG4gICAgQy5NRDUgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihNRDUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxyXG4gICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjTUQ1KG1lc3NhZ2UsIGtleSk7XHJcbiAgICAgKi9cclxuICAgIEMuSG1hY01ENSA9IEhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihNRDUpO1xyXG59KE1hdGgpKTtcclxuIiwiLyohXG4gICogUmVxd2VzdCEgQSBnZW5lcmFsIHB1cnBvc2UgWEhSIGNvbm5lY3Rpb24gbWFuYWdlclxuICAqIGxpY2Vuc2UgTUlUIChjKSBEdXN0aW4gRGlheiAyMDE0XG4gICogaHR0cHM6Ly9naXRodWIuY29tL2RlZC9yZXF3ZXN0XG4gICovXG5cbiFmdW5jdGlvbiAobmFtZSwgY29udGV4dCwgZGVmaW5pdGlvbikge1xuICBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKClcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIGRlZmluZShkZWZpbml0aW9uKVxuICBlbHNlIGNvbnRleHRbbmFtZV0gPSBkZWZpbml0aW9uKClcbn0oJ3JlcXdlc3QnLCB0aGlzLCBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHdpbiA9IHdpbmRvd1xuICAgICwgZG9jID0gZG9jdW1lbnRcbiAgICAsIGh0dHBzUmUgPSAvXmh0dHAvXG4gICAgLCBwcm90b2NvbFJlID0gLyheXFx3Kyk6XFwvXFwvL1xuICAgICwgdHdvSHVuZG8gPSAvXigyMFxcZHwxMjIzKSQvIC8vaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDA0Njk3Mi9tc2llLXJldHVybnMtc3RhdHVzLWNvZGUtb2YtMTIyMy1mb3ItYWpheC1yZXF1ZXN0XG4gICAgLCBieVRhZyA9ICdnZXRFbGVtZW50c0J5VGFnTmFtZSdcbiAgICAsIHJlYWR5U3RhdGUgPSAncmVhZHlTdGF0ZSdcbiAgICAsIGNvbnRlbnRUeXBlID0gJ0NvbnRlbnQtVHlwZSdcbiAgICAsIHJlcXVlc3RlZFdpdGggPSAnWC1SZXF1ZXN0ZWQtV2l0aCdcbiAgICAsIGhlYWQgPSBkb2NbYnlUYWddKCdoZWFkJylbMF1cbiAgICAsIHVuaXFpZCA9IDBcbiAgICAsIGNhbGxiYWNrUHJlZml4ID0gJ3JlcXdlc3RfJyArICgrbmV3IERhdGUoKSlcbiAgICAsIGxhc3RWYWx1ZSAvLyBkYXRhIHN0b3JlZCBieSB0aGUgbW9zdCByZWNlbnQgSlNPTlAgY2FsbGJhY2tcbiAgICAsIHhtbEh0dHBSZXF1ZXN0ID0gJ1hNTEh0dHBSZXF1ZXN0J1xuICAgICwgeERvbWFpblJlcXVlc3QgPSAnWERvbWFpblJlcXVlc3QnXG4gICAgLCBub29wID0gZnVuY3Rpb24gKCkge31cblxuICAgICwgaXNBcnJheSA9IHR5cGVvZiBBcnJheS5pc0FycmF5ID09ICdmdW5jdGlvbidcbiAgICAgICAgPyBBcnJheS5pc0FycmF5XG4gICAgICAgIDogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgIHJldHVybiBhIGluc3RhbmNlb2YgQXJyYXlcbiAgICAgICAgICB9XG5cbiAgICAsIGRlZmF1bHRIZWFkZXJzID0ge1xuICAgICAgICAgICdjb250ZW50VHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG4gICAgICAgICwgJ3JlcXVlc3RlZFdpdGgnOiB4bWxIdHRwUmVxdWVzdFxuICAgICAgICAsICdhY2NlcHQnOiB7XG4gICAgICAgICAgICAgICcqJzogICd0ZXh0L2phdmFzY3JpcHQsIHRleHQvaHRtbCwgYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbCwgKi8qJ1xuICAgICAgICAgICAgLCAneG1sJzogICdhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sJ1xuICAgICAgICAgICAgLCAnaHRtbCc6ICd0ZXh0L2h0bWwnXG4gICAgICAgICAgICAsICd0ZXh0JzogJ3RleHQvcGxhaW4nXG4gICAgICAgICAgICAsICdqc29uJzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdCdcbiAgICAgICAgICAgICwgJ2pzJzogICAnYXBwbGljYXRpb24vamF2YXNjcmlwdCwgdGV4dC9qYXZhc2NyaXB0J1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICwgeGhyID0gZnVuY3Rpb24obykge1xuICAgICAgICAvLyBpcyBpdCB4LWRvbWFpblxuICAgICAgICBpZiAob1snY3Jvc3NPcmlnaW4nXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciB4aHIgPSB3aW5beG1sSHR0cFJlcXVlc3RdID8gbmV3IFhNTEh0dHBSZXF1ZXN0KCkgOiBudWxsXG4gICAgICAgICAgaWYgKHhociAmJiAnd2l0aENyZWRlbnRpYWxzJyBpbiB4aHIpIHtcbiAgICAgICAgICAgIHJldHVybiB4aHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHdpblt4RG9tYWluUmVxdWVzdF0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWERvbWFpblJlcXVlc3QoKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBjcm9zcy1vcmlnaW4gcmVxdWVzdHMnKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh3aW5beG1sSHR0cFJlcXVlc3RdKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAsIGdsb2JhbFNldHVwT3B0aW9ucyA9IHtcbiAgICAgICAgZGF0YUZpbHRlcjogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICByZXR1cm4gZGF0YVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgZnVuY3Rpb24gc3VjY2VlZChyKSB7XG4gICAgdmFyIHByb3RvY29sID0gcHJvdG9jb2xSZS5leGVjKHIudXJsKTtcbiAgICBwcm90b2NvbCA9IChwcm90b2NvbCAmJiBwcm90b2NvbFsxXSkgfHwgd2luZG93LmxvY2F0aW9uLnByb3RvY29sO1xuICAgIHJldHVybiBodHRwc1JlLnRlc3QocHJvdG9jb2wpID8gdHdvSHVuZG8udGVzdChyLnJlcXVlc3Quc3RhdHVzKSA6ICEhci5yZXF1ZXN0LnJlc3BvbnNlO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlUmVhZHlTdGF0ZShyLCBzdWNjZXNzLCBlcnJvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyB1c2UgX2Fib3J0ZWQgdG8gbWl0aWdhdGUgYWdhaW5zdCBJRSBlcnIgYzAwYzAyM2ZcbiAgICAgIC8vIChjYW4ndCByZWFkIHByb3BzIG9uIGFib3J0ZWQgcmVxdWVzdCBvYmplY3RzKVxuICAgICAgaWYgKHIuX2Fib3J0ZWQpIHJldHVybiBlcnJvcihyLnJlcXVlc3QpXG4gICAgICBpZiAoci5fdGltZWRPdXQpIHJldHVybiBlcnJvcihyLnJlcXVlc3QsICdSZXF1ZXN0IGlzIGFib3J0ZWQ6IHRpbWVvdXQnKVxuICAgICAgaWYgKHIucmVxdWVzdCAmJiByLnJlcXVlc3RbcmVhZHlTdGF0ZV0gPT0gNCkge1xuICAgICAgICByLnJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gbm9vcFxuICAgICAgICBpZiAoc3VjY2VlZChyKSkgc3VjY2VzcyhyLnJlcXVlc3QpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBlcnJvcihyLnJlcXVlc3QpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0SGVhZGVycyhodHRwLCBvKSB7XG4gICAgdmFyIGhlYWRlcnMgPSBvWydoZWFkZXJzJ10gfHwge31cbiAgICAgICwgaFxuXG4gICAgaGVhZGVyc1snQWNjZXB0J10gPSBoZWFkZXJzWydBY2NlcHQnXVxuICAgICAgfHwgZGVmYXVsdEhlYWRlcnNbJ2FjY2VwdCddW29bJ3R5cGUnXV1cbiAgICAgIHx8IGRlZmF1bHRIZWFkZXJzWydhY2NlcHQnXVsnKiddXG5cbiAgICB2YXIgaXNBRm9ybURhdGEgPSB0eXBlb2YgRm9ybURhdGEgPT09ICdmdW5jdGlvbicgJiYgKG9bJ2RhdGEnXSBpbnN0YW5jZW9mIEZvcm1EYXRhKTtcbiAgICAvLyBicmVha3MgY3Jvc3Mtb3JpZ2luIHJlcXVlc3RzIHdpdGggbGVnYWN5IGJyb3dzZXJzXG4gICAgaWYgKCFvWydjcm9zc09yaWdpbiddICYmICFoZWFkZXJzW3JlcXVlc3RlZFdpdGhdKSBoZWFkZXJzW3JlcXVlc3RlZFdpdGhdID0gZGVmYXVsdEhlYWRlcnNbJ3JlcXVlc3RlZFdpdGgnXVxuICAgIGlmICghaGVhZGVyc1tjb250ZW50VHlwZV0gJiYgIWlzQUZvcm1EYXRhKSBoZWFkZXJzW2NvbnRlbnRUeXBlXSA9IG9bJ2NvbnRlbnRUeXBlJ10gfHwgZGVmYXVsdEhlYWRlcnNbJ2NvbnRlbnRUeXBlJ11cbiAgICBmb3IgKGggaW4gaGVhZGVycylcbiAgICAgIGhlYWRlcnMuaGFzT3duUHJvcGVydHkoaCkgJiYgJ3NldFJlcXVlc3RIZWFkZXInIGluIGh0dHAgJiYgaHR0cC5zZXRSZXF1ZXN0SGVhZGVyKGgsIGhlYWRlcnNbaF0pXG4gIH1cblxuICBmdW5jdGlvbiBzZXRDcmVkZW50aWFscyhodHRwLCBvKSB7XG4gICAgaWYgKHR5cGVvZiBvWyd3aXRoQ3JlZGVudGlhbHMnXSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGh0dHAud2l0aENyZWRlbnRpYWxzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaHR0cC53aXRoQ3JlZGVudGlhbHMgPSAhIW9bJ3dpdGhDcmVkZW50aWFscyddXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuZXJhbENhbGxiYWNrKGRhdGEpIHtcbiAgICBsYXN0VmFsdWUgPSBkYXRhXG4gIH1cblxuICBmdW5jdGlvbiB1cmxhcHBlbmQgKHVybCwgcykge1xuICAgIHJldHVybiB1cmwgKyAoL1xcPy8udGVzdCh1cmwpID8gJyYnIDogJz8nKSArIHNcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUpzb25wKG8sIGZuLCBlcnIsIHVybCkge1xuICAgIHZhciByZXFJZCA9IHVuaXFpZCsrXG4gICAgICAsIGNia2V5ID0gb1snanNvbnBDYWxsYmFjayddIHx8ICdjYWxsYmFjaycgLy8gdGhlICdjYWxsYmFjaycga2V5XG4gICAgICAsIGNidmFsID0gb1snanNvbnBDYWxsYmFja05hbWUnXSB8fCByZXF3ZXN0LmdldGNhbGxiYWNrUHJlZml4KHJlcUlkKVxuICAgICAgLCBjYnJlZyA9IG5ldyBSZWdFeHAoJygoXnxcXFxcP3wmKScgKyBjYmtleSArICcpPShbXiZdKyknKVxuICAgICAgLCBtYXRjaCA9IHVybC5tYXRjaChjYnJlZylcbiAgICAgICwgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpXG4gICAgICAsIGxvYWRlZCA9IDBcbiAgICAgICwgaXNJRTEwID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdNU0lFIDEwLjAnKSAhPT0gLTFcblxuICAgIGlmIChtYXRjaCkge1xuICAgICAgaWYgKG1hdGNoWzNdID09PSAnPycpIHtcbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoY2JyZWcsICckMT0nICsgY2J2YWwpIC8vIHdpbGRjYXJkIGNhbGxiYWNrIGZ1bmMgbmFtZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2J2YWwgPSBtYXRjaFszXSAvLyBwcm92aWRlZCBjYWxsYmFjayBmdW5jIG5hbWVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdXJsID0gdXJsYXBwZW5kKHVybCwgY2JrZXkgKyAnPScgKyBjYnZhbCkgLy8gbm8gY2FsbGJhY2sgZGV0YWlscywgYWRkICdlbVxuICAgIH1cblxuICAgIHdpbltjYnZhbF0gPSBnZW5lcmFsQ2FsbGJhY2tcblxuICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCdcbiAgICBzY3JpcHQuc3JjID0gdXJsXG4gICAgc2NyaXB0LmFzeW5jID0gdHJ1ZVxuICAgIGlmICh0eXBlb2Ygc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSAhPT0gJ3VuZGVmaW5lZCcgJiYgIWlzSUUxMCkge1xuICAgICAgLy8gbmVlZCB0aGlzIGZvciBJRSBkdWUgdG8gb3V0LW9mLW9yZGVyIG9ucmVhZHlzdGF0ZWNoYW5nZSgpLCBiaW5kaW5nIHNjcmlwdFxuICAgICAgLy8gZXhlY3V0aW9uIHRvIGFuIGV2ZW50IGxpc3RlbmVyIGdpdmVzIHVzIGNvbnRyb2wgb3ZlciB3aGVuIHRoZSBzY3JpcHRcbiAgICAgIC8vIGlzIGV4ZWN1dGVkLiBTZWUgaHR0cDovL2phdWJvdXJnLm5ldC8yMDEwLzA3L2xvYWRpbmctc2NyaXB0LWFzLW9uY2xpY2staGFuZGxlci1vZi5odG1sXG4gICAgICBzY3JpcHQuaHRtbEZvciA9IHNjcmlwdC5pZCA9ICdfcmVxd2VzdF8nICsgcmVxSWRcbiAgICB9XG5cbiAgICBzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICgoc2NyaXB0W3JlYWR5U3RhdGVdICYmIHNjcmlwdFtyZWFkeVN0YXRlXSAhPT0gJ2NvbXBsZXRlJyAmJiBzY3JpcHRbcmVhZHlTdGF0ZV0gIT09ICdsb2FkZWQnKSB8fCBsb2FkZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGxcbiAgICAgIHNjcmlwdC5vbmNsaWNrICYmIHNjcmlwdC5vbmNsaWNrKClcbiAgICAgIC8vIENhbGwgdGhlIHVzZXIgY2FsbGJhY2sgd2l0aCB0aGUgbGFzdCB2YWx1ZSBzdG9yZWQgYW5kIGNsZWFuIHVwIHZhbHVlcyBhbmQgc2NyaXB0cy5cbiAgICAgIGZuKGxhc3RWYWx1ZSlcbiAgICAgIGxhc3RWYWx1ZSA9IHVuZGVmaW5lZFxuICAgICAgaGVhZC5yZW1vdmVDaGlsZChzY3JpcHQpXG4gICAgICBsb2FkZWQgPSAxXG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSBzY3JpcHQgdG8gdGhlIERPTSBoZWFkXG4gICAgaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpXG5cbiAgICAvLyBFbmFibGUgSlNPTlAgdGltZW91dFxuICAgIHJldHVybiB7XG4gICAgICBhYm9ydDogZnVuY3Rpb24gKCkge1xuICAgICAgICBzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGxcbiAgICAgICAgZXJyKHt9LCAnUmVxdWVzdCBpcyBhYm9ydGVkOiB0aW1lb3V0Jywge30pXG4gICAgICAgIGxhc3RWYWx1ZSA9IHVuZGVmaW5lZFxuICAgICAgICBoZWFkLnJlbW92ZUNoaWxkKHNjcmlwdClcbiAgICAgICAgbG9hZGVkID0gMVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJlcXVlc3QoZm4sIGVycikge1xuICAgIHZhciBvID0gdGhpcy5vXG4gICAgICAsIG1ldGhvZCA9IChvWydtZXRob2QnXSB8fCAnR0VUJykudG9VcHBlckNhc2UoKVxuICAgICAgLCB1cmwgPSB0eXBlb2YgbyA9PT0gJ3N0cmluZycgPyBvIDogb1sndXJsJ11cbiAgICAgIC8vIGNvbnZlcnQgbm9uLXN0cmluZyBvYmplY3RzIHRvIHF1ZXJ5LXN0cmluZyBmb3JtIHVubGVzcyBvWydwcm9jZXNzRGF0YSddIGlzIGZhbHNlXG4gICAgICAsIGRhdGEgPSAob1sncHJvY2Vzc0RhdGEnXSAhPT0gZmFsc2UgJiYgb1snZGF0YSddICYmIHR5cGVvZiBvWydkYXRhJ10gIT09ICdzdHJpbmcnKVxuICAgICAgICA/IHJlcXdlc3QudG9RdWVyeVN0cmluZyhvWydkYXRhJ10pXG4gICAgICAgIDogKG9bJ2RhdGEnXSB8fCBudWxsKVxuICAgICAgLCBodHRwXG4gICAgICAsIHNlbmRXYWl0ID0gZmFsc2VcblxuICAgIC8vIGlmIHdlJ3JlIHdvcmtpbmcgb24gYSBHRVQgcmVxdWVzdCBhbmQgd2UgaGF2ZSBkYXRhIHRoZW4gd2Ugc2hvdWxkIGFwcGVuZFxuICAgIC8vIHF1ZXJ5IHN0cmluZyB0byBlbmQgb2YgVVJMIGFuZCBub3QgcG9zdCBkYXRhXG4gICAgaWYgKChvWyd0eXBlJ10gPT0gJ2pzb25wJyB8fCBtZXRob2QgPT0gJ0dFVCcpICYmIGRhdGEpIHtcbiAgICAgIHVybCA9IHVybGFwcGVuZCh1cmwsIGRhdGEpXG4gICAgICBkYXRhID0gbnVsbFxuICAgIH1cblxuICAgIGlmIChvWyd0eXBlJ10gPT0gJ2pzb25wJykgcmV0dXJuIGhhbmRsZUpzb25wKG8sIGZuLCBlcnIsIHVybClcblxuICAgIC8vIGdldCB0aGUgeGhyIGZyb20gdGhlIGZhY3RvcnkgaWYgcGFzc2VkXG4gICAgLy8gaWYgdGhlIGZhY3RvcnkgcmV0dXJucyBudWxsLCBmYWxsLWJhY2sgdG8gb3Vyc1xuICAgIGh0dHAgPSAoby54aHIgJiYgby54aHIobykpIHx8IHhocihvKVxuXG4gICAgaHR0cC5vcGVuKG1ldGhvZCwgdXJsLCBvWydhc3luYyddID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZSlcbiAgICBzZXRIZWFkZXJzKGh0dHAsIG8pXG4gICAgc2V0Q3JlZGVudGlhbHMoaHR0cCwgbylcbiAgICBpZiAod2luW3hEb21haW5SZXF1ZXN0XSAmJiBodHRwIGluc3RhbmNlb2Ygd2luW3hEb21haW5SZXF1ZXN0XSkge1xuICAgICAgICBodHRwLm9ubG9hZCA9IGZuXG4gICAgICAgIGh0dHAub25lcnJvciA9IGVyclxuICAgICAgICAvLyBOT1RFOiBzZWVcbiAgICAgICAgLy8gaHR0cDovL3NvY2lhbC5tc2RuLm1pY3Jvc29mdC5jb20vRm9ydW1zL2VuLVVTL2lld2ViZGV2ZWxvcG1lbnQvdGhyZWFkLzMwZWYzYWRkLTc2N2MtNDQzNi1iOGE5LWYxY2ExOWI0ODEyZVxuICAgICAgICBodHRwLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbigpIHt9XG4gICAgICAgIHNlbmRXYWl0ID0gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICBodHRwLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGhhbmRsZVJlYWR5U3RhdGUodGhpcywgZm4sIGVycilcbiAgICB9XG4gICAgb1snYmVmb3JlJ10gJiYgb1snYmVmb3JlJ10oaHR0cClcbiAgICBpZiAoc2VuZFdhaXQpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBodHRwLnNlbmQoZGF0YSlcbiAgICAgIH0sIDIwMClcbiAgICB9IGVsc2Uge1xuICAgICAgaHR0cC5zZW5kKGRhdGEpXG4gICAgfVxuICAgIHJldHVybiBodHRwXG4gIH1cblxuICBmdW5jdGlvbiBSZXF3ZXN0KG8sIGZuKSB7XG4gICAgdGhpcy5vID0gb1xuICAgIHRoaXMuZm4gPSBmblxuXG4gICAgaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIH1cblxuICBmdW5jdGlvbiBzZXRUeXBlKGhlYWRlcikge1xuICAgIC8vIGpzb24sIGphdmFzY3JpcHQsIHRleHQvcGxhaW4sIHRleHQvaHRtbCwgeG1sXG4gICAgaWYgKGhlYWRlci5tYXRjaCgnanNvbicpKSByZXR1cm4gJ2pzb24nXG4gICAgaWYgKGhlYWRlci5tYXRjaCgnamF2YXNjcmlwdCcpKSByZXR1cm4gJ2pzJ1xuICAgIGlmIChoZWFkZXIubWF0Y2goJ3RleHQnKSkgcmV0dXJuICdodG1sJ1xuICAgIGlmIChoZWFkZXIubWF0Y2goJ3htbCcpKSByZXR1cm4gJ3htbCdcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXQobywgZm4pIHtcblxuICAgIHRoaXMudXJsID0gdHlwZW9mIG8gPT0gJ3N0cmluZycgPyBvIDogb1sndXJsJ11cbiAgICB0aGlzLnRpbWVvdXQgPSBudWxsXG5cbiAgICAvLyB3aGV0aGVyIHJlcXVlc3QgaGFzIGJlZW4gZnVsZmlsbGVkIGZvciBwdXJwb3NlXG4gICAgLy8gb2YgdHJhY2tpbmcgdGhlIFByb21pc2VzXG4gICAgdGhpcy5fZnVsZmlsbGVkID0gZmFsc2VcbiAgICAvLyBzdWNjZXNzIGhhbmRsZXJzXG4gICAgdGhpcy5fc3VjY2Vzc0hhbmRsZXIgPSBmdW5jdGlvbigpe31cbiAgICB0aGlzLl9mdWxmaWxsbWVudEhhbmRsZXJzID0gW11cbiAgICAvLyBlcnJvciBoYW5kbGVyc1xuICAgIHRoaXMuX2Vycm9ySGFuZGxlcnMgPSBbXVxuICAgIC8vIGNvbXBsZXRlIChib3RoIHN1Y2Nlc3MgYW5kIGZhaWwpIGhhbmRsZXJzXG4gICAgdGhpcy5fY29tcGxldGVIYW5kbGVycyA9IFtdXG4gICAgdGhpcy5fZXJyZWQgPSBmYWxzZVxuICAgIHRoaXMuX3Jlc3BvbnNlQXJncyA9IHt9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXNcblxuICAgIGZuID0gZm4gfHwgZnVuY3Rpb24gKCkge31cblxuICAgIGlmIChvWyd0aW1lb3V0J10pIHtcbiAgICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB0aW1lZE91dCgpXG4gICAgICB9LCBvWyd0aW1lb3V0J10pXG4gICAgfVxuXG4gICAgaWYgKG9bJ3N1Y2Nlc3MnXSkge1xuICAgICAgdGhpcy5fc3VjY2Vzc0hhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9bJ3N1Y2Nlc3MnXS5hcHBseShvLCBhcmd1bWVudHMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9bJ2Vycm9yJ10pIHtcbiAgICAgIHRoaXMuX2Vycm9ySGFuZGxlcnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9bJ2Vycm9yJ10uYXBwbHkobywgYXJndW1lbnRzKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAob1snY29tcGxldGUnXSkge1xuICAgICAgdGhpcy5fY29tcGxldGVIYW5kbGVycy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb1snY29tcGxldGUnXS5hcHBseShvLCBhcmd1bWVudHMpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlIChyZXNwKSB7XG4gICAgICBvWyd0aW1lb3V0J10gJiYgY2xlYXJUaW1lb3V0KHNlbGYudGltZW91dClcbiAgICAgIHNlbGYudGltZW91dCA9IG51bGxcbiAgICAgIHdoaWxlIChzZWxmLl9jb21wbGV0ZUhhbmRsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc2VsZi5fY29tcGxldGVIYW5kbGVycy5zaGlmdCgpKHJlc3ApXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3VjY2VzcyAocmVzcCkge1xuICAgICAgdmFyIHR5cGUgPSBvWyd0eXBlJ10gfHwgcmVzcCAmJiBzZXRUeXBlKHJlc3AuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtVHlwZScpKSAvLyByZXNwIGNhbiBiZSB1bmRlZmluZWQgaW4gSUVcbiAgICAgIHJlc3AgPSAodHlwZSAhPT0gJ2pzb25wJykgPyBzZWxmLnJlcXVlc3QgOiByZXNwXG4gICAgICAvLyB1c2UgZ2xvYmFsIGRhdGEgZmlsdGVyIG9uIHJlc3BvbnNlIHRleHRcbiAgICAgIHZhciBmaWx0ZXJlZFJlc3BvbnNlID0gZ2xvYmFsU2V0dXBPcHRpb25zLmRhdGFGaWx0ZXIocmVzcC5yZXNwb25zZVRleHQsIHR5cGUpXG4gICAgICAgICwgciA9IGZpbHRlcmVkUmVzcG9uc2VcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3AucmVzcG9uc2VUZXh0ID0gclxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBjYW4ndCBhc3NpZ24gdGhpcyBpbiBJRTw9OCwganVzdCBpZ25vcmVcbiAgICAgIH1cbiAgICAgIGlmIChyKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdqc29uJzpcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzcCA9IHdpbi5KU09OID8gd2luLkpTT04ucGFyc2UocikgOiBldmFsKCcoJyArIHIgKyAnKScpXG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3IocmVzcCwgJ0NvdWxkIG5vdCBwYXJzZSBKU09OIGluIHJlc3BvbnNlJywgZXJyKVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdqcyc6XG4gICAgICAgICAgcmVzcCA9IGV2YWwocilcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgICByZXNwID0gclxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3htbCc6XG4gICAgICAgICAgcmVzcCA9IHJlc3AucmVzcG9uc2VYTUxcbiAgICAgICAgICAgICAgJiYgcmVzcC5yZXNwb25zZVhNTC5wYXJzZUVycm9yIC8vIElFIHRyb2xvbG9cbiAgICAgICAgICAgICAgJiYgcmVzcC5yZXNwb25zZVhNTC5wYXJzZUVycm9yLmVycm9yQ29kZVxuICAgICAgICAgICAgICAmJiByZXNwLnJlc3BvbnNlWE1MLnBhcnNlRXJyb3IucmVhc29uXG4gICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgIDogcmVzcC5yZXNwb25zZVhNTFxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VsZi5fcmVzcG9uc2VBcmdzLnJlc3AgPSByZXNwXG4gICAgICBzZWxmLl9mdWxmaWxsZWQgPSB0cnVlXG4gICAgICBmbihyZXNwKVxuICAgICAgc2VsZi5fc3VjY2Vzc0hhbmRsZXIocmVzcClcbiAgICAgIHdoaWxlIChzZWxmLl9mdWxmaWxsbWVudEhhbmRsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVzcCA9IHNlbGYuX2Z1bGZpbGxtZW50SGFuZGxlcnMuc2hpZnQoKShyZXNwKVxuICAgICAgfVxuXG4gICAgICBjb21wbGV0ZShyZXNwKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRpbWVkT3V0KCkge1xuICAgICAgc2VsZi5fdGltZWRPdXQgPSB0cnVlXG4gICAgICBzZWxmLnJlcXVlc3QuYWJvcnQoKSAgICAgIFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVycm9yKHJlc3AsIG1zZywgdCkge1xuICAgICAgcmVzcCA9IHNlbGYucmVxdWVzdFxuICAgICAgc2VsZi5fcmVzcG9uc2VBcmdzLnJlc3AgPSByZXNwXG4gICAgICBzZWxmLl9yZXNwb25zZUFyZ3MubXNnID0gbXNnXG4gICAgICBzZWxmLl9yZXNwb25zZUFyZ3MudCA9IHRcbiAgICAgIHNlbGYuX2VycmVkID0gdHJ1ZVxuICAgICAgd2hpbGUgKHNlbGYuX2Vycm9ySGFuZGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBzZWxmLl9lcnJvckhhbmRsZXJzLnNoaWZ0KCkocmVzcCwgbXNnLCB0KVxuICAgICAgfVxuICAgICAgY29tcGxldGUocmVzcClcbiAgICB9XG5cbiAgICB0aGlzLnJlcXVlc3QgPSBnZXRSZXF1ZXN0LmNhbGwodGhpcywgc3VjY2VzcywgZXJyb3IpXG4gIH1cblxuICBSZXF3ZXN0LnByb3RvdHlwZSA9IHtcbiAgICBhYm9ydDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fYWJvcnRlZCA9IHRydWVcbiAgICAgIHRoaXMucmVxdWVzdC5hYm9ydCgpXG4gICAgfVxuXG4gICwgcmV0cnk6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGluaXQuY2FsbCh0aGlzLCB0aGlzLm8sIHRoaXMuZm4pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU21hbGwgZGV2aWF0aW9uIGZyb20gdGhlIFByb21pc2VzIEEgQ29tbW9uSnMgc3BlY2lmaWNhdGlvblxuICAgICAqIGh0dHA6Ly93aWtpLmNvbW1vbmpzLm9yZy93aWtpL1Byb21pc2VzL0FcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIGB0aGVuYCB3aWxsIGV4ZWN1dGUgdXBvbiBzdWNjZXNzZnVsIHJlcXVlc3RzXG4gICAgICovXG4gICwgdGhlbjogZnVuY3Rpb24gKHN1Y2Nlc3MsIGZhaWwpIHtcbiAgICAgIHN1Y2Nlc3MgPSBzdWNjZXNzIHx8IGZ1bmN0aW9uICgpIHt9XG4gICAgICBmYWlsID0gZmFpbCB8fCBmdW5jdGlvbiAoKSB7fVxuICAgICAgaWYgKHRoaXMuX2Z1bGZpbGxlZCkge1xuICAgICAgICB0aGlzLl9yZXNwb25zZUFyZ3MucmVzcCA9IHN1Y2Nlc3ModGhpcy5fcmVzcG9uc2VBcmdzLnJlc3ApXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2VycmVkKSB7XG4gICAgICAgIGZhaWwodGhpcy5fcmVzcG9uc2VBcmdzLnJlc3AsIHRoaXMuX3Jlc3BvbnNlQXJncy5tc2csIHRoaXMuX3Jlc3BvbnNlQXJncy50KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVycy5wdXNoKHN1Y2Nlc3MpXG4gICAgICAgIHRoaXMuX2Vycm9ySGFuZGxlcnMucHVzaChmYWlsKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBgYWx3YXlzYCB3aWxsIGV4ZWN1dGUgd2hldGhlciB0aGUgcmVxdWVzdCBzdWNjZWVkcyBvciBmYWlsc1xuICAgICAqL1xuICAsIGFsd2F5czogZnVuY3Rpb24gKGZuKSB7XG4gICAgICBpZiAodGhpcy5fZnVsZmlsbGVkIHx8IHRoaXMuX2VycmVkKSB7XG4gICAgICAgIGZuKHRoaXMuX3Jlc3BvbnNlQXJncy5yZXNwKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY29tcGxldGVIYW5kbGVycy5wdXNoKGZuKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBgZmFpbGAgd2lsbCBleGVjdXRlIHdoZW4gdGhlIHJlcXVlc3QgZmFpbHNcbiAgICAgKi9cbiAgLCBmYWlsOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIGlmICh0aGlzLl9lcnJlZCkge1xuICAgICAgICBmbih0aGlzLl9yZXNwb25zZUFyZ3MucmVzcCwgdGhpcy5fcmVzcG9uc2VBcmdzLm1zZywgdGhpcy5fcmVzcG9uc2VBcmdzLnQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9lcnJvckhhbmRsZXJzLnB1c2goZm4pXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgLCAnY2F0Y2gnOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIHJldHVybiB0aGlzLmZhaWwoZm4pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVxd2VzdChvLCBmbikge1xuICAgIHJldHVybiBuZXcgUmVxd2VzdChvLCBmbilcbiAgfVxuXG4gIC8vIG5vcm1hbGl6ZSBuZXdsaW5lIHZhcmlhbnRzIGFjY29yZGluZyB0byBzcGVjIC0+IENSTEZcbiAgZnVuY3Rpb24gbm9ybWFsaXplKHMpIHtcbiAgICByZXR1cm4gcyA/IHMucmVwbGFjZSgvXFxyP1xcbi9nLCAnXFxyXFxuJykgOiAnJ1xuICB9XG5cbiAgZnVuY3Rpb24gc2VyaWFsKGVsLCBjYikge1xuICAgIHZhciBuID0gZWwubmFtZVxuICAgICAgLCB0ID0gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgICAsIG9wdENiID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAvLyBJRSBnaXZlcyB2YWx1ZT1cIlwiIGV2ZW4gd2hlcmUgdGhlcmUgaXMgbm8gdmFsdWUgYXR0cmlidXRlXG4gICAgICAgICAgLy8gJ3NwZWNpZmllZCcgcmVmOiBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1Db3JlL2NvcmUuaHRtbCNJRC04NjI1MjkyNzNcbiAgICAgICAgICBpZiAobyAmJiAhb1snZGlzYWJsZWQnXSlcbiAgICAgICAgICAgIGNiKG4sIG5vcm1hbGl6ZShvWydhdHRyaWJ1dGVzJ11bJ3ZhbHVlJ10gJiYgb1snYXR0cmlidXRlcyddWyd2YWx1ZSddWydzcGVjaWZpZWQnXSA/IG9bJ3ZhbHVlJ10gOiBvWyd0ZXh0J10pKVxuICAgICAgICB9XG4gICAgICAsIGNoLCByYSwgdmFsLCBpXG5cbiAgICAvLyBkb24ndCBzZXJpYWxpemUgZWxlbWVudHMgdGhhdCBhcmUgZGlzYWJsZWQgb3Igd2l0aG91dCBhIG5hbWVcbiAgICBpZiAoZWwuZGlzYWJsZWQgfHwgIW4pIHJldHVyblxuXG4gICAgc3dpdGNoICh0KSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgaWYgKCEvcmVzZXR8YnV0dG9ufGltYWdlfGZpbGUvaS50ZXN0KGVsLnR5cGUpKSB7XG4gICAgICAgIGNoID0gL2NoZWNrYm94L2kudGVzdChlbC50eXBlKVxuICAgICAgICByYSA9IC9yYWRpby9pLnRlc3QoZWwudHlwZSlcbiAgICAgICAgdmFsID0gZWwudmFsdWVcbiAgICAgICAgLy8gV2ViS2l0IGdpdmVzIHVzIFwiXCIgaW5zdGVhZCBvZiBcIm9uXCIgaWYgYSBjaGVja2JveCBoYXMgbm8gdmFsdWUsIHNvIGNvcnJlY3QgaXQgaGVyZVxuICAgICAgICA7KCEoY2ggfHwgcmEpIHx8IGVsLmNoZWNrZWQpICYmIGNiKG4sIG5vcm1hbGl6ZShjaCAmJiB2YWwgPT09ICcnID8gJ29uJyA6IHZhbCkpXG4gICAgICB9XG4gICAgICBicmVha1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGNiKG4sIG5vcm1hbGl6ZShlbC52YWx1ZSkpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBpZiAoZWwudHlwZS50b0xvd2VyQ2FzZSgpID09PSAnc2VsZWN0LW9uZScpIHtcbiAgICAgICAgb3B0Q2IoZWwuc2VsZWN0ZWRJbmRleCA+PSAwID8gZWwub3B0aW9uc1tlbC5zZWxlY3RlZEluZGV4XSA6IG51bGwpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSAwOyBlbC5sZW5ndGggJiYgaSA8IGVsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZWwub3B0aW9uc1tpXS5zZWxlY3RlZCAmJiBvcHRDYihlbC5vcHRpb25zW2ldKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8vIGNvbGxlY3QgdXAgYWxsIGZvcm0gZWxlbWVudHMgZm91bmQgZnJvbSB0aGUgcGFzc2VkIGFyZ3VtZW50IGVsZW1lbnRzIGFsbFxuICAvLyB0aGUgd2F5IGRvd24gdG8gY2hpbGQgZWxlbWVudHM7IHBhc3MgYSAnPGZvcm0+JyBvciBmb3JtIGZpZWxkcy5cbiAgLy8gY2FsbGVkIHdpdGggJ3RoaXMnPWNhbGxiYWNrIHRvIHVzZSBmb3Igc2VyaWFsKCkgb24gZWFjaCBlbGVtZW50XG4gIGZ1bmN0aW9uIGVhY2hGb3JtRWxlbWVudCgpIHtcbiAgICB2YXIgY2IgPSB0aGlzXG4gICAgICAsIGUsIGlcbiAgICAgICwgc2VyaWFsaXplU3VidGFncyA9IGZ1bmN0aW9uIChlLCB0YWdzKSB7XG4gICAgICAgICAgdmFyIGksIGosIGZhXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRhZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZhID0gZVtieVRhZ10odGFnc1tpXSlcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBmYS5sZW5ndGg7IGorKykgc2VyaWFsKGZhW2pdLCBjYilcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGUgPSBhcmd1bWVudHNbaV1cbiAgICAgIGlmICgvaW5wdXR8c2VsZWN0fHRleHRhcmVhL2kudGVzdChlLnRhZ05hbWUpKSBzZXJpYWwoZSwgY2IpXG4gICAgICBzZXJpYWxpemVTdWJ0YWdzKGUsIFsgJ2lucHV0JywgJ3NlbGVjdCcsICd0ZXh0YXJlYScgXSlcbiAgICB9XG4gIH1cblxuICAvLyBzdGFuZGFyZCBxdWVyeSBzdHJpbmcgc3R5bGUgc2VyaWFsaXphdGlvblxuICBmdW5jdGlvbiBzZXJpYWxpemVRdWVyeVN0cmluZygpIHtcbiAgICByZXR1cm4gcmVxd2VzdC50b1F1ZXJ5U3RyaW5nKHJlcXdlc3Quc2VyaWFsaXplQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKSlcbiAgfVxuXG4gIC8vIHsgJ25hbWUnOiAndmFsdWUnLCAuLi4gfSBzdHlsZSBzZXJpYWxpemF0aW9uXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZUhhc2goKSB7XG4gICAgdmFyIGhhc2ggPSB7fVxuICAgIGVhY2hGb3JtRWxlbWVudC5hcHBseShmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmIChuYW1lIGluIGhhc2gpIHtcbiAgICAgICAgaGFzaFtuYW1lXSAmJiAhaXNBcnJheShoYXNoW25hbWVdKSAmJiAoaGFzaFtuYW1lXSA9IFtoYXNoW25hbWVdXSlcbiAgICAgICAgaGFzaFtuYW1lXS5wdXNoKHZhbHVlKVxuICAgICAgfSBlbHNlIGhhc2hbbmFtZV0gPSB2YWx1ZVxuICAgIH0sIGFyZ3VtZW50cylcbiAgICByZXR1cm4gaGFzaFxuICB9XG5cbiAgLy8gWyB7IG5hbWU6ICduYW1lJywgdmFsdWU6ICd2YWx1ZScgfSwgLi4uIF0gc3R5bGUgc2VyaWFsaXphdGlvblxuICByZXF3ZXN0LnNlcmlhbGl6ZUFycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcnIgPSBbXVxuICAgIGVhY2hGb3JtRWxlbWVudC5hcHBseShmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgIGFyci5wdXNoKHtuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWV9KVxuICAgIH0sIGFyZ3VtZW50cylcbiAgICByZXR1cm4gYXJyXG4gIH1cblxuICByZXF3ZXN0LnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gICAgdmFyIG9wdCwgZm5cbiAgICAgICwgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMClcblxuICAgIG9wdCA9IGFyZ3MucG9wKClcbiAgICBvcHQgJiYgb3B0Lm5vZGVUeXBlICYmIGFyZ3MucHVzaChvcHQpICYmIChvcHQgPSBudWxsKVxuICAgIG9wdCAmJiAob3B0ID0gb3B0LnR5cGUpXG5cbiAgICBpZiAob3B0ID09ICdtYXAnKSBmbiA9IHNlcmlhbGl6ZUhhc2hcbiAgICBlbHNlIGlmIChvcHQgPT0gJ2FycmF5JykgZm4gPSByZXF3ZXN0LnNlcmlhbGl6ZUFycmF5XG4gICAgZWxzZSBmbiA9IHNlcmlhbGl6ZVF1ZXJ5U3RyaW5nXG5cbiAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncylcbiAgfVxuXG4gIHJlcXdlc3QudG9RdWVyeVN0cmluZyA9IGZ1bmN0aW9uIChvLCB0cmFkKSB7XG4gICAgdmFyIHByZWZpeCwgaVxuICAgICAgLCB0cmFkaXRpb25hbCA9IHRyYWQgfHwgZmFsc2VcbiAgICAgICwgcyA9IFtdXG4gICAgICAsIGVuYyA9IGVuY29kZVVSSUNvbXBvbmVudFxuICAgICAgLCBhZGQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgIC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgcmV0dXJuIGl0cyB2YWx1ZVxuICAgICAgICAgIHZhbHVlID0gKCdmdW5jdGlvbicgPT09IHR5cGVvZiB2YWx1ZSkgPyB2YWx1ZSgpIDogKHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlKVxuICAgICAgICAgIHNbcy5sZW5ndGhdID0gZW5jKGtleSkgKyAnPScgKyBlbmModmFsdWUpXG4gICAgICAgIH1cbiAgICAvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuICAgIGlmIChpc0FycmF5KG8pKSB7XG4gICAgICBmb3IgKGkgPSAwOyBvICYmIGkgPCBvLmxlbmd0aDsgaSsrKSBhZGQob1tpXVsnbmFtZSddLCBvW2ldWyd2YWx1ZSddKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuICAgICAgLy8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXG4gICAgICBmb3IgKHByZWZpeCBpbiBvKSB7XG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KHByZWZpeCkpIGJ1aWxkUGFyYW1zKHByZWZpeCwgb1twcmVmaXhdLCB0cmFkaXRpb25hbCwgYWRkKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNwYWNlcyBzaG91bGQgYmUgKyBhY2NvcmRpbmcgdG8gc3BlY1xuICAgIHJldHVybiBzLmpvaW4oJyYnKS5yZXBsYWNlKC8lMjAvZywgJysnKVxuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGRQYXJhbXMocHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQpIHtcbiAgICB2YXIgbmFtZSwgaSwgdlxuICAgICAgLCByYnJhY2tldCA9IC9cXFtcXF0kL1xuXG4gICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgLy8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG4gICAgICBmb3IgKGkgPSAwOyBvYmogJiYgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICB2ID0gb2JqW2ldXG4gICAgICAgIGlmICh0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KHByZWZpeCkpIHtcbiAgICAgICAgICAvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG4gICAgICAgICAgYWRkKHByZWZpeCwgdilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidWlsZFBhcmFtcyhwcmVmaXggKyAnWycgKyAodHlwZW9mIHYgPT09ICdvYmplY3QnID8gaSA6ICcnKSArICddJywgdiwgdHJhZGl0aW9uYWwsIGFkZClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2JqICYmIG9iai50b1N0cmluZygpID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgLy8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuICAgICAgZm9yIChuYW1lIGluIG9iaikge1xuICAgICAgICBidWlsZFBhcmFtcyhwcmVmaXggKyAnWycgKyBuYW1lICsgJ10nLCBvYmpbbmFtZV0sIHRyYWRpdGlvbmFsLCBhZGQpXG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuICAgICAgYWRkKHByZWZpeCwgb2JqKVxuICAgIH1cbiAgfVxuXG4gIHJlcXdlc3QuZ2V0Y2FsbGJhY2tQcmVmaXggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrUHJlZml4XG4gIH1cblxuICAvLyBqUXVlcnkgYW5kIFplcHRvIGNvbXBhdGliaWxpdHksIGRpZmZlcmVuY2VzIGNhbiBiZSByZW1hcHBlZCBoZXJlIHNvIHlvdSBjYW4gY2FsbFxuICAvLyAuYWpheC5jb21wYXQob3B0aW9ucywgY2FsbGJhY2spXG4gIHJlcXdlc3QuY29tcGF0ID0gZnVuY3Rpb24gKG8sIGZuKSB7XG4gICAgaWYgKG8pIHtcbiAgICAgIG9bJ3R5cGUnXSAmJiAob1snbWV0aG9kJ10gPSBvWyd0eXBlJ10pICYmIGRlbGV0ZSBvWyd0eXBlJ11cbiAgICAgIG9bJ2RhdGFUeXBlJ10gJiYgKG9bJ3R5cGUnXSA9IG9bJ2RhdGFUeXBlJ10pXG4gICAgICBvWydqc29ucENhbGxiYWNrJ10gJiYgKG9bJ2pzb25wQ2FsbGJhY2tOYW1lJ10gPSBvWydqc29ucENhbGxiYWNrJ10pICYmIGRlbGV0ZSBvWydqc29ucENhbGxiYWNrJ11cbiAgICAgIG9bJ2pzb25wJ10gJiYgKG9bJ2pzb25wQ2FsbGJhY2snXSA9IG9bJ2pzb25wJ10pXG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVxd2VzdChvLCBmbilcbiAgfVxuXG4gIHJlcXdlc3QuYWpheFNldHVwID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgIGZvciAodmFyIGsgaW4gb3B0aW9ucykge1xuICAgICAgZ2xvYmFsU2V0dXBPcHRpb25zW2tdID0gb3B0aW9uc1trXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXF3ZXN0XG59KTtcbiIsIi8qIVxuICogQG92ZXJ2aWV3IFJTVlAgLSBhIHRpbnkgaW1wbGVtZW50YXRpb24gb2YgUHJvbWlzZXMvQSsuXG4gKiBAY29weXJpZ2h0IENvcHlyaWdodCAoYykgMjAxNCBZZWh1ZGEgS2F0eiwgVG9tIERhbGUsIFN0ZWZhbiBQZW5uZXIgYW5kIGNvbnRyaWJ1dG9yc1xuICogQGxpY2Vuc2UgICBMaWNlbnNlZCB1bmRlciBNSVQgbGljZW5zZVxuICogICAgICAgICAgICBTZWUgaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3RpbGRlaW8vcnN2cC5qcy9tYXN0ZXIvTElDRU5TRVxuICogQHZlcnNpb24gICAzLjAuMThcbiAqL1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgZnVuY3Rpb24gbGliJHJzdnAkdXRpbHMkJG9iamVjdE9yRnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJHJzdnAkdXRpbHMkJGlzRnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJHV0aWxzJCRpc01heWJlVGhlbmFibGUoeCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsO1xuICAgIH1cblxuICAgIHZhciBsaWIkcnN2cCR1dGlscyQkX2lzQXJyYXk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KSB7XG4gICAgICBsaWIkcnN2cCR1dGlscyQkX2lzQXJyYXkgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGliJHJzdnAkdXRpbHMkJF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbiAgICB9XG5cbiAgICB2YXIgbGliJHJzdnAkdXRpbHMkJGlzQXJyYXkgPSBsaWIkcnN2cCR1dGlscyQkX2lzQXJyYXk7XG5cbiAgICB2YXIgbGliJHJzdnAkdXRpbHMkJG5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7IH07XG5cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCR1dGlscyQkRigpIHsgfVxuXG4gICAgdmFyIGxpYiRyc3ZwJHV0aWxzJCRvX2NyZWF0ZSA9IChPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZWNvbmQgYXJndW1lbnQgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgfVxuICAgICAgbGliJHJzdnAkdXRpbHMkJEYucHJvdG90eXBlID0gbztcbiAgICAgIHJldHVybiBuZXcgbGliJHJzdnAkdXRpbHMkJEYoKTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBsaWIkcnN2cCRldmVudHMkJGluZGV4T2YoY2FsbGJhY2tzLCBjYWxsYmFjaykge1xuICAgICAgZm9yICh2YXIgaT0wLCBsPWNhbGxiYWNrcy5sZW5ndGg7IGk8bDsgaSsrKSB7XG4gICAgICAgIGlmIChjYWxsYmFja3NbaV0gPT09IGNhbGxiYWNrKSB7IHJldHVybiBpOyB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCRldmVudHMkJGNhbGxiYWNrc0ZvcihvYmplY3QpIHtcbiAgICAgIHZhciBjYWxsYmFja3MgPSBvYmplY3QuX3Byb21pc2VDYWxsYmFja3M7XG5cbiAgICAgIGlmICghY2FsbGJhY2tzKSB7XG4gICAgICAgIGNhbGxiYWNrcyA9IG9iamVjdC5fcHJvbWlzZUNhbGxiYWNrcyA9IHt9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FsbGJhY2tzO1xuICAgIH1cblxuICAgIHZhciBsaWIkcnN2cCRldmVudHMkJGRlZmF1bHQgPSB7XG5cbiAgICAgIC8qKlxuICAgICAgICBgUlNWUC5FdmVudFRhcmdldC5taXhpbmAgZXh0ZW5kcyBhbiBvYmplY3Qgd2l0aCBFdmVudFRhcmdldCBtZXRob2RzLiBGb3JcbiAgICAgICAgRXhhbXBsZTpcblxuICAgICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICAgIHZhciBvYmplY3QgPSB7fTtcblxuICAgICAgICBSU1ZQLkV2ZW50VGFyZ2V0Lm1peGluKG9iamVjdCk7XG5cbiAgICAgICAgb2JqZWN0Lm9uKCdmaW5pc2hlZCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgLy8gaGFuZGxlIGV2ZW50XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9iamVjdC50cmlnZ2VyKCdmaW5pc2hlZCcsIHsgZGV0YWlsOiB2YWx1ZSB9KTtcbiAgICAgICAgYGBgXG5cbiAgICAgICAgYEV2ZW50VGFyZ2V0Lm1peGluYCBhbHNvIHdvcmtzIHdpdGggcHJvdG90eXBlczpcblxuICAgICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICAgIHZhciBQZXJzb24gPSBmdW5jdGlvbigpIHt9O1xuICAgICAgICBSU1ZQLkV2ZW50VGFyZ2V0Lm1peGluKFBlcnNvbi5wcm90b3R5cGUpO1xuXG4gICAgICAgIHZhciB5ZWh1ZGEgPSBuZXcgUGVyc29uKCk7XG4gICAgICAgIHZhciB0b20gPSBuZXcgUGVyc29uKCk7XG5cbiAgICAgICAgeWVodWRhLm9uKCdwb2tlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnWWVodWRhIHNheXMgT1cnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdG9tLm9uKCdwb2tlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnVG9tIHNheXMgT1cnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgeWVodWRhLnRyaWdnZXIoJ3Bva2UnKTtcbiAgICAgICAgdG9tLnRyaWdnZXIoJ3Bva2UnKTtcbiAgICAgICAgYGBgXG5cbiAgICAgICAgQG1ldGhvZCBtaXhpblxuICAgICAgICBAZm9yIFJTVlAuRXZlbnRUYXJnZXRcbiAgICAgICAgQHByaXZhdGVcbiAgICAgICAgQHBhcmFtIHtPYmplY3R9IG9iamVjdCBvYmplY3QgdG8gZXh0ZW5kIHdpdGggRXZlbnRUYXJnZXQgbWV0aG9kc1xuICAgICAgKi9cbiAgICAgICdtaXhpbic6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBvYmplY3RbJ29uJ10gICAgICA9IHRoaXNbJ29uJ107XG4gICAgICAgIG9iamVjdFsnb2ZmJ10gICAgID0gdGhpc1snb2ZmJ107XG4gICAgICAgIG9iamVjdFsndHJpZ2dlciddID0gdGhpc1sndHJpZ2dlciddO1xuICAgICAgICBvYmplY3QuX3Byb21pc2VDYWxsYmFja3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAgUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWQgd2hlbiBgZXZlbnROYW1lYCBpcyB0cmlnZ2VyZWRcblxuICAgICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICAgIG9iamVjdC5vbignZXZlbnQnLCBmdW5jdGlvbihldmVudEluZm8pe1xuICAgICAgICAgIC8vIGhhbmRsZSB0aGUgZXZlbnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb2JqZWN0LnRyaWdnZXIoJ2V2ZW50Jyk7XG4gICAgICAgIGBgYFxuXG4gICAgICAgIEBtZXRob2Qgb25cbiAgICAgICAgQGZvciBSU1ZQLkV2ZW50VGFyZ2V0XG4gICAgICAgIEBwcml2YXRlXG4gICAgICAgIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIGZvclxuICAgICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLlxuICAgICAgKi9cbiAgICAgICdvbic6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGFsbENhbGxiYWNrcyA9IGxpYiRyc3ZwJGV2ZW50cyQkY2FsbGJhY2tzRm9yKHRoaXMpLCBjYWxsYmFja3M7XG5cbiAgICAgICAgY2FsbGJhY2tzID0gYWxsQ2FsbGJhY2tzW2V2ZW50TmFtZV07XG5cbiAgICAgICAgaWYgKCFjYWxsYmFja3MpIHtcbiAgICAgICAgICBjYWxsYmFja3MgPSBhbGxDYWxsYmFja3NbZXZlbnROYW1lXSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpYiRyc3ZwJGV2ZW50cyQkaW5kZXhPZihjYWxsYmFja3MsIGNhbGxiYWNrKSA9PT0gLTEpIHtcbiAgICAgICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICBZb3UgY2FuIHVzZSBgb2ZmYCB0byBzdG9wIGZpcmluZyBhIHBhcnRpY3VsYXIgY2FsbGJhY2sgZm9yIGFuIGV2ZW50OlxuXG4gICAgICAgIGBgYGphdmFzY3JpcHRcbiAgICAgICAgZnVuY3Rpb24gZG9TdHVmZigpIHsgLy8gZG8gc3R1ZmYhIH1cbiAgICAgICAgb2JqZWN0Lm9uKCdzdHVmZicsIGRvU3R1ZmYpO1xuXG4gICAgICAgIG9iamVjdC50cmlnZ2VyKCdzdHVmZicpOyAvLyBkb1N0dWZmIHdpbGwgYmUgY2FsbGVkXG5cbiAgICAgICAgLy8gVW5yZWdpc3RlciBPTkxZIHRoZSBkb1N0dWZmIGNhbGxiYWNrXG4gICAgICAgIG9iamVjdC5vZmYoJ3N0dWZmJywgZG9TdHVmZik7XG4gICAgICAgIG9iamVjdC50cmlnZ2VyKCdzdHVmZicpOyAvLyBkb1N0dWZmIHdpbGwgTk9UIGJlIGNhbGxlZFxuICAgICAgICBgYGBcblxuICAgICAgICBJZiB5b3UgZG9uJ3QgcGFzcyBhIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYG9mZmAsIEFMTCBjYWxsYmFja3MgZm9yIHRoZVxuICAgICAgICBldmVudCB3aWxsIG5vdCBiZSBleGVjdXRlZCB3aGVuIHRoZSBldmVudCBmaXJlcy4gRm9yIGV4YW1wbGU6XG5cbiAgICAgICAgYGBgamF2YXNjcmlwdFxuICAgICAgICB2YXIgY2FsbGJhY2sxID0gZnVuY3Rpb24oKXt9O1xuICAgICAgICB2YXIgY2FsbGJhY2syID0gZnVuY3Rpb24oKXt9O1xuXG4gICAgICAgIG9iamVjdC5vbignc3R1ZmYnLCBjYWxsYmFjazEpO1xuICAgICAgICBvYmplY3Qub24oJ3N0dWZmJywgY2FsbGJhY2syKTtcblxuICAgICAgICBvYmplY3QudHJpZ2dlcignc3R1ZmYnKTsgLy8gY2FsbGJhY2sxIGFuZCBjYWxsYmFjazIgd2lsbCBiZSBleGVjdXRlZC5cblxuICAgICAgICBvYmplY3Qub2ZmKCdzdHVmZicpO1xuICAgICAgICBvYmplY3QudHJpZ2dlcignc3R1ZmYnKTsgLy8gY2FsbGJhY2sxIGFuZCBjYWxsYmFjazIgd2lsbCBub3QgYmUgZXhlY3V0ZWQhXG4gICAgICAgIGBgYFxuXG4gICAgICAgIEBtZXRob2Qgb2ZmXG4gICAgICAgIEBmb3IgUlNWUC5FdmVudFRhcmdldFxuICAgICAgICBAcHJpdmF0ZVxuICAgICAgICBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lIGV2ZW50IHRvIHN0b3AgbGlzdGVuaW5nIHRvXG4gICAgICAgIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIG9wdGlvbmFsIGFyZ3VtZW50LiBJZiBnaXZlbiwgb25seSB0aGUgZnVuY3Rpb25cbiAgICAgICAgZ2l2ZW4gd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIGV2ZW50J3MgY2FsbGJhY2sgcXVldWUuIElmIG5vIGBjYWxsYmFja2BcbiAgICAgICAgYXJndW1lbnQgaXMgZ2l2ZW4sIGFsbCBjYWxsYmFja3Mgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIGV2ZW50J3MgY2FsbGJhY2tcbiAgICAgICAgcXVldWUuXG4gICAgICAqL1xuICAgICAgJ29mZic6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGFsbENhbGxiYWNrcyA9IGxpYiRyc3ZwJGV2ZW50cyQkY2FsbGJhY2tzRm9yKHRoaXMpLCBjYWxsYmFja3MsIGluZGV4O1xuXG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICBhbGxDYWxsYmFja3NbZXZlbnROYW1lXSA9IFtdO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrcyA9IGFsbENhbGxiYWNrc1tldmVudE5hbWVdO1xuXG4gICAgICAgIGluZGV4ID0gbGliJHJzdnAkZXZlbnRzJCRpbmRleE9mKGNhbGxiYWNrcywgY2FsbGJhY2spO1xuXG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHsgY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7IH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICBVc2UgYHRyaWdnZXJgIHRvIGZpcmUgY3VzdG9tIGV2ZW50cy4gRm9yIGV4YW1wbGU6XG5cbiAgICAgICAgYGBgamF2YXNjcmlwdFxuICAgICAgICBvYmplY3Qub24oJ2ZvbycsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgY29uc29sZS5sb2coJ2ZvbyBldmVudCBoYXBwZW5lZCEnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9iamVjdC50cmlnZ2VyKCdmb28nKTtcbiAgICAgICAgLy8gJ2ZvbyBldmVudCBoYXBwZW5lZCEnIGxvZ2dlZCB0byB0aGUgY29uc29sZVxuICAgICAgICBgYGBcblxuICAgICAgICBZb3UgY2FuIGFsc28gcGFzcyBhIHZhbHVlIGFzIGEgc2Vjb25kIGFyZ3VtZW50IHRvIGB0cmlnZ2VyYCB0aGF0IHdpbGwgYmVcbiAgICAgICAgcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIGFsbCBldmVudCBsaXN0ZW5lcnMgZm9yIHRoZSBldmVudDpcblxuICAgICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICAgIG9iamVjdC5vbignZm9vJywgZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICAgIGNvbnNvbGUubG9nKHZhbHVlLm5hbWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBvYmplY3QudHJpZ2dlcignZm9vJywgeyBuYW1lOiAnYmFyJyB9KTtcbiAgICAgICAgLy8gJ2JhcicgbG9nZ2VkIHRvIHRoZSBjb25zb2xlXG4gICAgICAgIGBgYFxuXG4gICAgICAgIEBtZXRob2QgdHJpZ2dlclxuICAgICAgICBAZm9yIFJTVlAuRXZlbnRUYXJnZXRcbiAgICAgICAgQHByaXZhdGVcbiAgICAgICAgQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZSBuYW1lIG9mIHRoZSBldmVudCB0byBiZSB0cmlnZ2VyZWRcbiAgICAgICAgQHBhcmFtIHtBbnl9IG9wdGlvbnMgb3B0aW9uYWwgdmFsdWUgdG8gYmUgcGFzc2VkIHRvIGFueSBldmVudCBoYW5kbGVycyBmb3JcbiAgICAgICAgdGhlIGdpdmVuIGBldmVudE5hbWVgXG4gICAgICAqL1xuICAgICAgJ3RyaWdnZXInOiBmdW5jdGlvbihldmVudE5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGFsbENhbGxiYWNrcyA9IGxpYiRyc3ZwJGV2ZW50cyQkY2FsbGJhY2tzRm9yKHRoaXMpLCBjYWxsYmFja3MsIGNhbGxiYWNrO1xuXG4gICAgICAgIGlmIChjYWxsYmFja3MgPSBhbGxDYWxsYmFja3NbZXZlbnROYW1lXSkge1xuICAgICAgICAgIC8vIERvbid0IGNhY2hlIHRoZSBjYWxsYmFja3MubGVuZ3RoIHNpbmNlIGl0IG1heSBncm93XG4gICAgICAgICAgZm9yICh2YXIgaT0wOyBpPGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFja3NbaV07XG5cbiAgICAgICAgICAgIGNhbGxiYWNrKG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgbGliJHJzdnAkY29uZmlnJCRjb25maWcgPSB7XG4gICAgICBpbnN0cnVtZW50OiBmYWxzZVxuICAgIH07XG5cbiAgICBsaWIkcnN2cCRldmVudHMkJGRlZmF1bHRbJ21peGluJ10obGliJHJzdnAkY29uZmlnJCRjb25maWcpO1xuXG4gICAgZnVuY3Rpb24gbGliJHJzdnAkY29uZmlnJCRjb25maWd1cmUobmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmIChuYW1lID09PSAnb25lcnJvcicpIHtcbiAgICAgICAgLy8gaGFuZGxlIGZvciBsZWdhY3kgdXNlcnMgdGhhdCBleHBlY3QgdGhlIGFjdHVhbFxuICAgICAgICAvLyBlcnJvciB0byBiZSBwYXNzZWQgdG8gdGhlaXIgZnVuY3Rpb24gYWRkZWQgdmlhXG4gICAgICAgIC8vIGBSU1ZQLmNvbmZpZ3VyZSgnb25lcnJvcicsIHNvbWVGdW5jdGlvbkhlcmUpO2BcbiAgICAgICAgbGliJHJzdnAkY29uZmlnJCRjb25maWdbJ29uJ10oJ2Vycm9yJywgdmFsdWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGxpYiRyc3ZwJGNvbmZpZyQkY29uZmlnW25hbWVdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbGliJHJzdnAkY29uZmlnJCRjb25maWdbbmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxpYiRyc3ZwJGluc3RydW1lbnQkJHF1ZXVlID0gW107XG5cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCRpbnN0cnVtZW50JCRzY2hlZHVsZUZsdXNoKCkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVudHJ5O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpYiRyc3ZwJGluc3RydW1lbnQkJHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZW50cnkgPSBsaWIkcnN2cCRpbnN0cnVtZW50JCRxdWV1ZVtpXTtcblxuICAgICAgICAgIHZhciBwYXlsb2FkID0gZW50cnkucGF5bG9hZDtcblxuICAgICAgICAgIHBheWxvYWQuZ3VpZCA9IHBheWxvYWQua2V5ICsgcGF5bG9hZC5pZDtcbiAgICAgICAgICBwYXlsb2FkLmNoaWxkR3VpZCA9IHBheWxvYWQua2V5ICsgcGF5bG9hZC5jaGlsZElkO1xuICAgICAgICAgIGlmIChwYXlsb2FkLmVycm9yKSB7XG4gICAgICAgICAgICBwYXlsb2FkLnN0YWNrID0gcGF5bG9hZC5lcnJvci5zdGFjaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaWIkcnN2cCRjb25maWckJGNvbmZpZ1sndHJpZ2dlciddKGVudHJ5Lm5hbWUsIGVudHJ5LnBheWxvYWQpO1xuICAgICAgICB9XG4gICAgICAgIGxpYiRyc3ZwJGluc3RydW1lbnQkJHF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICB9LCA1MCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJHJzdnAkaW5zdHJ1bWVudCQkaW5zdHJ1bWVudChldmVudE5hbWUsIHByb21pc2UsIGNoaWxkKSB7XG4gICAgICBpZiAoMSA9PT0gbGliJHJzdnAkaW5zdHJ1bWVudCQkcXVldWUucHVzaCh7XG4gICAgICAgICAgbmFtZTogZXZlbnROYW1lLFxuICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgIGtleTogcHJvbWlzZS5fZ3VpZEtleSxcbiAgICAgICAgICAgIGlkOiAgcHJvbWlzZS5faWQsXG4gICAgICAgICAgICBldmVudE5hbWU6IGV2ZW50TmFtZSxcbiAgICAgICAgICAgIGRldGFpbDogcHJvbWlzZS5fcmVzdWx0LFxuICAgICAgICAgICAgY2hpbGRJZDogY2hpbGQgJiYgY2hpbGQuX2lkLFxuICAgICAgICAgICAgbGFiZWw6IHByb21pc2UuX2xhYmVsLFxuICAgICAgICAgICAgdGltZVN0YW1wOiBsaWIkcnN2cCR1dGlscyQkbm93KCksXG4gICAgICAgICAgICBlcnJvcjogbGliJHJzdnAkY29uZmlnJCRjb25maWdbXCJpbnN0cnVtZW50LXdpdGgtc3RhY2tcIl0gPyBuZXcgRXJyb3IocHJvbWlzZS5fbGFiZWwpIDogbnVsbFxuICAgICAgICAgIH19KSkge1xuICAgICAgICAgICAgbGliJHJzdnAkaW5zdHJ1bWVudCQkc2NoZWR1bGVGbHVzaCgpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB2YXIgbGliJHJzdnAkaW5zdHJ1bWVudCQkZGVmYXVsdCA9IGxpYiRyc3ZwJGluc3RydW1lbnQkJGluc3RydW1lbnQ7XG5cbiAgICBmdW5jdGlvbiAgbGliJHJzdnAkJGludGVybmFsJCR3aXRoT3duUHJvbWlzZSgpIHtcbiAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKCdBIHByb21pc2VzIGNhbGxiYWNrIGNhbm5vdCByZXR1cm4gdGhhdCBzYW1lIHByb21pc2UuJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJHJzdnAkJGludGVybmFsJCRub29wKCkge31cblxuICAgIHZhciBsaWIkcnN2cCQkaW50ZXJuYWwkJFBFTkRJTkcgICA9IHZvaWQgMDtcbiAgICB2YXIgbGliJHJzdnAkJGludGVybmFsJCRGVUxGSUxMRUQgPSAxO1xuICAgIHZhciBsaWIkcnN2cCQkaW50ZXJuYWwkJFJFSkVDVEVEICA9IDI7XG5cbiAgICB2YXIgbGliJHJzdnAkJGludGVybmFsJCRHRVRfVEhFTl9FUlJPUiA9IG5ldyBsaWIkcnN2cCQkaW50ZXJuYWwkJEVycm9yT2JqZWN0KCk7XG5cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCQkaW50ZXJuYWwkJGdldFRoZW4ocHJvbWlzZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbjtcbiAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgbGliJHJzdnAkJGludGVybmFsJCRHRVRfVEhFTl9FUlJPUi5lcnJvciA9IGVycm9yO1xuICAgICAgICByZXR1cm4gbGliJHJzdnAkJGludGVybmFsJCRHRVRfVEhFTl9FUlJPUjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCQkaW50ZXJuYWwkJHRyeVRoZW4odGhlbiwgdmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJCRpbnRlcm5hbCQkaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlLCB0aGVuKSB7XG4gICAgICBsaWIkcnN2cCRjb25maWckJGNvbmZpZy5hc3luYyhmdW5jdGlvbihwcm9taXNlKSB7XG4gICAgICAgIHZhciBzZWFsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGVycm9yID0gbGliJHJzdnAkJGludGVybmFsJCR0cnlUaGVuKHRoZW4sIHRoZW5hYmxlLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGlmIChzZWFsZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgc2VhbGVkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAodGhlbmFibGUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICBsaWIkcnN2cCQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaWIkcnN2cCQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgICAgaWYgKHNlYWxlZCkgeyByZXR1cm47IH1cbiAgICAgICAgICBzZWFsZWQgPSB0cnVlO1xuXG4gICAgICAgICAgbGliJHJzdnAkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgICAgfSwgJ1NldHRsZTogJyArIChwcm9taXNlLl9sYWJlbCB8fCAnIHVua25vd24gcHJvbWlzZScpKTtcblxuICAgICAgICBpZiAoIXNlYWxlZCAmJiBlcnJvcikge1xuICAgICAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICAgICAgbGliJHJzdnAkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9LCBwcm9taXNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCQkaW50ZXJuYWwkJGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlKSB7XG4gICAgICBpZiAodGhlbmFibGUuX3N0YXRlID09PSBsaWIkcnN2cCQkaW50ZXJuYWwkJEZVTEZJTExFRCkge1xuICAgICAgICBsaWIkcnN2cCQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gICAgICB9IGVsc2UgaWYgKHRoZW5hYmxlLl9zdGF0ZSA9PT0gbGliJHJzdnAkJGludGVybmFsJCRSRUpFQ1RFRCkge1xuICAgICAgICB0aGVuYWJsZS5fb25FcnJvciA9IG51bGw7XG4gICAgICAgIGxpYiRyc3ZwJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGliJHJzdnAkJGludGVybmFsJCRzdWJzY3JpYmUodGhlbmFibGUsIHVuZGVmaW5lZCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBpZiAodGhlbmFibGUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICBsaWIkcnN2cCQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaWIkcnN2cCQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgICAgbGliJHJzdnAkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJHJzdnAkJGludGVybmFsJCRoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUpIHtcbiAgICAgIGlmIChtYXliZVRoZW5hYmxlLmNvbnN0cnVjdG9yID09PSBwcm9taXNlLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGxpYiRyc3ZwJCRpbnRlcm5hbCQkaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdGhlbiA9IGxpYiRyc3ZwJCRpbnRlcm5hbCQkZ2V0VGhlbihtYXliZVRoZW5hYmxlKTtcblxuICAgICAgICBpZiAodGhlbiA9PT0gbGliJHJzdnAkJGludGVybmFsJCRHRVRfVEhFTl9FUlJPUikge1xuICAgICAgICAgIGxpYiRyc3ZwJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIGxpYiRyc3ZwJCRpbnRlcm5hbCQkR0VUX1RIRU5fRVJST1IuZXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoZW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGxpYiRyc3ZwJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICAgICAgfSBlbHNlIGlmIChsaWIkcnN2cCR1dGlscyQkaXNGdW5jdGlvbih0aGVuKSkge1xuICAgICAgICAgIGxpYiRyc3ZwJCRpbnRlcm5hbCQkaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpYiRyc3ZwJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSkge1xuICAgICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgICAgIGxpYiRyc3ZwJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGxpYiRyc3ZwJHV0aWxzJCRvYmplY3RPckZ1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICBsaWIkcnN2cCQkaW50ZXJuYWwkJGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGliJHJzdnAkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCQkaW50ZXJuYWwkJHB1Ymxpc2hSZWplY3Rpb24ocHJvbWlzZSkge1xuICAgICAgaWYgKHByb21pc2UuX29uRXJyb3IpIHtcbiAgICAgICAgcHJvbWlzZS5fb25FcnJvcihwcm9taXNlLl9yZXN1bHQpO1xuICAgICAgfVxuXG4gICAgICBsaWIkcnN2cCQkaW50ZXJuYWwkJHB1Ymxpc2gocHJvbWlzZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJHJzdnAkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHZhbHVlKSB7XG4gICAgICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IGxpYiRyc3ZwJCRpbnRlcm5hbCQkUEVORElORykgeyByZXR1cm47IH1cblxuICAgICAgcHJvbWlzZS5fcmVzdWx0ID0gdmFsdWU7XG4gICAgICBwcm9taXNlLl9zdGF0ZSA9IGxpYiRyc3ZwJCRpbnRlcm5hbCQkRlVMRklMTEVEO1xuXG4gICAgICBpZiAocHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlmIChsaWIkcnN2cCRjb25maWckJGNvbmZpZy5pbnN0cnVtZW50KSB7XG4gICAgICAgICAgbGliJHJzdnAkaW5zdHJ1bWVudCQkZGVmYXVsdCgnZnVsZmlsbGVkJywgcHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpYiRyc3ZwJGNvbmZpZyQkY29uZmlnLmFzeW5jKGxpYiRyc3ZwJCRpbnRlcm5hbCQkcHVibGlzaCwgcHJvbWlzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJHJzdnAkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKSB7XG4gICAgICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IGxpYiRyc3ZwJCRpbnRlcm5hbCQkUEVORElORykgeyByZXR1cm47IH1cbiAgICAgIHByb21pc2UuX3N0YXRlID0gbGliJHJzdnAkJGludGVybmFsJCRSRUpFQ1RFRDtcbiAgICAgIHByb21pc2UuX3Jlc3VsdCA9IHJlYXNvbjtcbiAgICAgIGxpYiRyc3ZwJGNvbmZpZyQkY29uZmlnLmFzeW5jKGxpYiRyc3ZwJCRpbnRlcm5hbCQkcHVibGlzaFJlamVjdGlvbiwgcHJvbWlzZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJHJzdnAkJGludGVybmFsJCRzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgICAgIHZhciBzdWJzY3JpYmVycyA9IHBhcmVudC5fc3Vic2NyaWJlcnM7XG4gICAgICB2YXIgbGVuZ3RoID0gc3Vic2NyaWJlcnMubGVuZ3RoO1xuXG4gICAgICBwYXJlbnQuX29uRXJyb3IgPSBudWxsO1xuXG4gICAgICBzdWJzY3JpYmVyc1tsZW5ndGhdID0gY2hpbGQ7XG4gICAgICBzdWJzY3JpYmVyc1tsZW5ndGggKyBsaWIkcnN2cCQkaW50ZXJuYWwkJEZVTEZJTExFRF0gPSBvbkZ1bGZpbGxtZW50O1xuICAgICAgc3Vic2NyaWJlcnNbbGVuZ3RoICsgbGliJHJzdnAkJGludGVybmFsJCRSRUpFQ1RFRF0gID0gb25SZWplY3Rpb247XG5cbiAgICAgIGlmIChsZW5ndGggPT09IDAgJiYgcGFyZW50Ll9zdGF0ZSkge1xuICAgICAgICBsaWIkcnN2cCRjb25maWckJGNvbmZpZy5hc3luYyhsaWIkcnN2cCQkaW50ZXJuYWwkJHB1Ymxpc2gsIHBhcmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJHJzdnAkJGludGVybmFsJCRwdWJsaXNoKHByb21pc2UpIHtcbiAgICAgIHZhciBzdWJzY3JpYmVycyA9IHByb21pc2UuX3N1YnNjcmliZXJzO1xuICAgICAgdmFyIHNldHRsZWQgPSBwcm9taXNlLl9zdGF0ZTtcblxuICAgICAgaWYgKGxpYiRyc3ZwJGNvbmZpZyQkY29uZmlnLmluc3RydW1lbnQpIHtcbiAgICAgICAgbGliJHJzdnAkaW5zdHJ1bWVudCQkZGVmYXVsdChzZXR0bGVkID09PSBsaWIkcnN2cCQkaW50ZXJuYWwkJEZVTEZJTExFRCA/ICdmdWxmaWxsZWQnIDogJ3JlamVjdGVkJywgcHJvbWlzZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdWJzY3JpYmVycy5sZW5ndGggPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgICAgIHZhciBjaGlsZCwgY2FsbGJhY2ssIGRldGFpbCA9IHByb21pc2UuX3Jlc3VsdDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzY3JpYmVycy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICBjaGlsZCA9IHN1YnNjcmliZXJzW2ldO1xuICAgICAgICBjYWxsYmFjayA9IHN1YnNjcmliZXJzW2kgKyBzZXR0bGVkXTtcblxuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICBsaWIkcnN2cCQkaW50ZXJuYWwkJGludm9rZUNhbGxiYWNrKHNldHRsZWQsIGNoaWxkLCBjYWxsYmFjaywgZGV0YWlsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjayhkZXRhaWwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJHJzdnAkJGludGVybmFsJCRFcnJvck9iamVjdCgpIHtcbiAgICAgIHRoaXMuZXJyb3IgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBsaWIkcnN2cCQkaW50ZXJuYWwkJFRSWV9DQVRDSF9FUlJPUiA9IG5ldyBsaWIkcnN2cCQkaW50ZXJuYWwkJEVycm9yT2JqZWN0KCk7XG5cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCQkaW50ZXJuYWwkJHRyeUNhdGNoKGNhbGxiYWNrLCBkZXRhaWwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhkZXRhaWwpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIGxpYiRyc3ZwJCRpbnRlcm5hbCQkVFJZX0NBVENIX0VSUk9SLmVycm9yID0gZTtcbiAgICAgICAgcmV0dXJuIGxpYiRyc3ZwJCRpbnRlcm5hbCQkVFJZX0NBVENIX0VSUk9SO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJCRpbnRlcm5hbCQkaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgcHJvbWlzZSwgY2FsbGJhY2ssIGRldGFpbCkge1xuICAgICAgdmFyIGhhc0NhbGxiYWNrID0gbGliJHJzdnAkdXRpbHMkJGlzRnVuY3Rpb24oY2FsbGJhY2spLFxuICAgICAgICAgIHZhbHVlLCBlcnJvciwgc3VjY2VlZGVkLCBmYWlsZWQ7XG5cbiAgICAgIGlmIChoYXNDYWxsYmFjaykge1xuICAgICAgICB2YWx1ZSA9IGxpYiRyc3ZwJCRpbnRlcm5hbCQkdHJ5Q2F0Y2goY2FsbGJhY2ssIGRldGFpbCk7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBsaWIkcnN2cCQkaW50ZXJuYWwkJFRSWV9DQVRDSF9FUlJPUikge1xuICAgICAgICAgIGZhaWxlZCA9IHRydWU7XG4gICAgICAgICAgZXJyb3IgPSB2YWx1ZS5lcnJvcjtcbiAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3VjY2VlZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgICAgICAgIGxpYiRyc3ZwJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIGxpYiRyc3ZwJCRpbnRlcm5hbCQkd2l0aE93blByb21pc2UoKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gZGV0YWlsO1xuICAgICAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IGxpYiRyc3ZwJCRpbnRlcm5hbCQkUEVORElORykge1xuICAgICAgICAvLyBub29wXG4gICAgICB9IGVsc2UgaWYgKGhhc0NhbGxiYWNrICYmIHN1Y2NlZWRlZCkge1xuICAgICAgICBsaWIkcnN2cCQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChmYWlsZWQpIHtcbiAgICAgICAgbGliJHJzdnAkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBsaWIkcnN2cCQkaW50ZXJuYWwkJEZVTEZJTExFRCkge1xuICAgICAgICBsaWIkcnN2cCQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBsaWIkcnN2cCQkaW50ZXJuYWwkJFJFSkVDVEVEKSB7XG4gICAgICAgIGxpYiRyc3ZwJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCQkaW50ZXJuYWwkJGluaXRpYWxpemVQcm9taXNlKHByb21pc2UsIHJlc29sdmVyKSB7XG4gICAgICB2YXIgcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc29sdmVyKGZ1bmN0aW9uIHJlc29sdmVQcm9taXNlKHZhbHVlKXtcbiAgICAgICAgICBpZiAocmVzb2x2ZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgcmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgIGxpYiRyc3ZwJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIHJlamVjdFByb21pc2UocmVhc29uKSB7XG4gICAgICAgICAgaWYgKHJlc29sdmVkKSB7IHJldHVybjsgfVxuICAgICAgICAgIHJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICBsaWIkcnN2cCQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBsaWIkcnN2cCQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCRlbnVtZXJhdG9yJCRtYWtlU2V0dGxlZFJlc3VsdChzdGF0ZSwgcG9zaXRpb24sIHZhbHVlKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IGxpYiRyc3ZwJCRpbnRlcm5hbCQkRlVMRklMTEVEKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdGU6ICdmdWxmaWxsZWQnLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGF0ZTogJ3JlamVjdGVkJyxcbiAgICAgICAgICByZWFzb246IHZhbHVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJHJzdnAkZW51bWVyYXRvciQkRW51bWVyYXRvcihDb25zdHJ1Y3RvciwgaW5wdXQsIGFib3J0T25SZWplY3QsIGxhYmVsKSB7XG4gICAgICB0aGlzLl9pbnN0YW5jZUNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG4gICAgICB0aGlzLnByb21pc2UgPSBuZXcgQ29uc3RydWN0b3IobGliJHJzdnAkJGludGVybmFsJCRub29wLCBsYWJlbCk7XG4gICAgICB0aGlzLl9hYm9ydE9uUmVqZWN0ID0gYWJvcnRPblJlamVjdDtcblxuICAgICAgaWYgKHRoaXMuX3ZhbGlkYXRlSW5wdXQoaW5wdXQpKSB7XG4gICAgICAgIHRoaXMuX2lucHV0ICAgICA9IGlucHV0O1xuICAgICAgICB0aGlzLmxlbmd0aCAgICAgPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgIHRoaXMuX3JlbWFpbmluZyA9IGlucHV0Lmxlbmd0aDtcblxuICAgICAgICB0aGlzLl9pbml0KCk7XG5cbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgbGliJHJzdnAkJGludGVybmFsJCRmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMubGVuZ3RoIHx8IDA7XG4gICAgICAgICAgdGhpcy5fZW51bWVyYXRlKCk7XG4gICAgICAgICAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgICAgbGliJHJzdnAkJGludGVybmFsJCRmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpYiRyc3ZwJCRpbnRlcm5hbCQkcmVqZWN0KHRoaXMucHJvbWlzZSwgdGhpcy5fdmFsaWRhdGlvbkVycm9yKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsaWIkcnN2cCRlbnVtZXJhdG9yJCRkZWZhdWx0ID0gbGliJHJzdnAkZW51bWVyYXRvciQkRW51bWVyYXRvcjtcblxuICAgIGxpYiRyc3ZwJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl92YWxpZGF0ZUlucHV0ID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgIHJldHVybiBsaWIkcnN2cCR1dGlscyQkaXNBcnJheShpbnB1dCk7XG4gICAgfTtcblxuICAgIGxpYiRyc3ZwJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl92YWxpZGF0aW9uRXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0FycmF5IE1ldGhvZHMgbXVzdCBiZSBwcm92aWRlZCBhbiBBcnJheScpO1xuICAgIH07XG5cbiAgICBsaWIkcnN2cCRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fcmVzdWx0ID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICB9O1xuXG4gICAgbGliJHJzdnAkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX2VudW1lcmF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxlbmd0aCAgPSB0aGlzLmxlbmd0aDtcbiAgICAgIHZhciBwcm9taXNlID0gdGhpcy5wcm9taXNlO1xuICAgICAgdmFyIGlucHV0ICAgPSB0aGlzLl9pbnB1dDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IHByb21pc2UuX3N0YXRlID09PSBsaWIkcnN2cCQkaW50ZXJuYWwkJFBFTkRJTkcgJiYgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX2VhY2hFbnRyeShpbnB1dFtpXSwgaSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxpYiRyc3ZwJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl9lYWNoRW50cnkgPSBmdW5jdGlvbihlbnRyeSwgaSkge1xuICAgICAgdmFyIGMgPSB0aGlzLl9pbnN0YW5jZUNvbnN0cnVjdG9yO1xuICAgICAgaWYgKGxpYiRyc3ZwJHV0aWxzJCRpc01heWJlVGhlbmFibGUoZW50cnkpKSB7XG4gICAgICAgIGlmIChlbnRyeS5jb25zdHJ1Y3RvciA9PT0gYyAmJiBlbnRyeS5fc3RhdGUgIT09IGxpYiRyc3ZwJCRpbnRlcm5hbCQkUEVORElORykge1xuICAgICAgICAgIGVudHJ5Ll9vbkVycm9yID0gbnVsbDtcbiAgICAgICAgICB0aGlzLl9zZXR0bGVkQXQoZW50cnkuX3N0YXRlLCBpLCBlbnRyeS5fcmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl93aWxsU2V0dGxlQXQoYy5yZXNvbHZlKGVudHJ5KSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSB0aGlzLl9tYWtlUmVzdWx0KGxpYiRyc3ZwJCRpbnRlcm5hbCQkRlVMRklMTEVELCBpLCBlbnRyeSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxpYiRyc3ZwJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl9zZXR0bGVkQXQgPSBmdW5jdGlvbihzdGF0ZSwgaSwgdmFsdWUpIHtcbiAgICAgIHZhciBwcm9taXNlID0gdGhpcy5wcm9taXNlO1xuXG4gICAgICBpZiAocHJvbWlzZS5fc3RhdGUgPT09IGxpYiRyc3ZwJCRpbnRlcm5hbCQkUEVORElORykge1xuICAgICAgICB0aGlzLl9yZW1haW5pbmctLTtcblxuICAgICAgICBpZiAodGhpcy5fYWJvcnRPblJlamVjdCAmJiBzdGF0ZSA9PT0gbGliJHJzdnAkJGludGVybmFsJCRSRUpFQ1RFRCkge1xuICAgICAgICAgIGxpYiRyc3ZwJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSB0aGlzLl9tYWtlUmVzdWx0KHN0YXRlLCBpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICBsaWIkcnN2cCQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbGliJHJzdnAkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX21ha2VSZXN1bHQgPSBmdW5jdGlvbihzdGF0ZSwgaSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgbGliJHJzdnAkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX3dpbGxTZXR0bGVBdCA9IGZ1bmN0aW9uKHByb21pc2UsIGkpIHtcbiAgICAgIHZhciBlbnVtZXJhdG9yID0gdGhpcztcblxuICAgICAgbGliJHJzdnAkJGludGVybmFsJCRzdWJzY3JpYmUocHJvbWlzZSwgdW5kZWZpbmVkLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBlbnVtZXJhdG9yLl9zZXR0bGVkQXQobGliJHJzdnAkJGludGVybmFsJCRGVUxGSUxMRUQsIGksIHZhbHVlKTtcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICBlbnVtZXJhdG9yLl9zZXR0bGVkQXQobGliJHJzdnAkJGludGVybmFsJCRSRUpFQ1RFRCwgaSwgcmVhc29uKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbGliJHJzdnAkcHJvbWlzZSRhbGwkJGFsbChlbnRyaWVzLCBsYWJlbCkge1xuICAgICAgcmV0dXJuIG5ldyBsaWIkcnN2cCRlbnVtZXJhdG9yJCRkZWZhdWx0KHRoaXMsIGVudHJpZXMsIHRydWUgLyogYWJvcnQgb24gcmVqZWN0ICovLCBsYWJlbCkucHJvbWlzZTtcbiAgICB9XG4gICAgdmFyIGxpYiRyc3ZwJHByb21pc2UkYWxsJCRkZWZhdWx0ID0gbGliJHJzdnAkcHJvbWlzZSRhbGwkJGFsbDtcbiAgICBmdW5jdGlvbiBsaWIkcnN2cCRwcm9taXNlJHJhY2UkJHJhY2UoZW50cmllcywgbGFiZWwpIHtcbiAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gICAgICB2YXIgcHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3RvcihsaWIkcnN2cCQkaW50ZXJuYWwkJG5vb3AsIGxhYmVsKTtcblxuICAgICAgaWYgKCFsaWIkcnN2cCR1dGlscyQkaXNBcnJheShlbnRyaWVzKSkge1xuICAgICAgICBsaWIkcnN2cCQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGFuIGFycmF5IHRvIHJhY2UuJykpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbmd0aCA9IGVudHJpZXMubGVuZ3RoO1xuXG4gICAgICBmdW5jdGlvbiBvbkZ1bGZpbGxtZW50KHZhbHVlKSB7XG4gICAgICAgIGxpYiRyc3ZwJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uUmVqZWN0aW9uKHJlYXNvbikge1xuICAgICAgICBsaWIkcnN2cCQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgcHJvbWlzZS5fc3RhdGUgPT09IGxpYiRyc3ZwJCRpbnRlcm5hbCQkUEVORElORyAmJiBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGliJHJzdnAkJGludGVybmFsJCRzdWJzY3JpYmUoQ29uc3RydWN0b3IucmVzb2x2ZShlbnRyaWVzW2ldKSwgdW5kZWZpbmVkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICB2YXIgbGliJHJzdnAkcHJvbWlzZSRyYWNlJCRkZWZhdWx0ID0gbGliJHJzdnAkcHJvbWlzZSRyYWNlJCRyYWNlO1xuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJHByb21pc2UkcmVzb2x2ZSQkcmVzb2x2ZShvYmplY3QsIGxhYmVsKSB7XG4gICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICAgICAgaWYgKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QuY29uc3RydWN0b3IgPT09IENvbnN0cnVjdG9yKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKGxpYiRyc3ZwJCRpbnRlcm5hbCQkbm9vcCwgbGFiZWwpO1xuICAgICAgbGliJHJzdnAkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIG9iamVjdCk7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgdmFyIGxpYiRyc3ZwJHByb21pc2UkcmVzb2x2ZSQkZGVmYXVsdCA9IGxpYiRyc3ZwJHByb21pc2UkcmVzb2x2ZSQkcmVzb2x2ZTtcbiAgICBmdW5jdGlvbiBsaWIkcnN2cCRwcm9taXNlJHJlamVjdCQkcmVqZWN0KHJlYXNvbiwgbGFiZWwpIHtcbiAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuICAgICAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3IobGliJHJzdnAkJGludGVybmFsJCRub29wLCBsYWJlbCk7XG4gICAgICBsaWIkcnN2cCQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHZhciBsaWIkcnN2cCRwcm9taXNlJHJlamVjdCQkZGVmYXVsdCA9IGxpYiRyc3ZwJHByb21pc2UkcmVqZWN0JCRyZWplY3Q7XG5cbiAgICB2YXIgbGliJHJzdnAkcHJvbWlzZSQkZ3VpZEtleSA9ICdyc3ZwXycgKyBsaWIkcnN2cCR1dGlscyQkbm93KCkgKyAnLSc7XG4gICAgdmFyIGxpYiRyc3ZwJHByb21pc2UkJGNvdW50ZXIgPSAwO1xuXG4gICAgZnVuY3Rpb24gbGliJHJzdnAkcHJvbWlzZSQkbmVlZHNSZXNvbHZlcigpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYSByZXNvbHZlciBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIHByb21pc2UgY29uc3RydWN0b3InKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCRwcm9taXNlJCRuZWVkc05ldygpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdQcm9taXNlJzogUGxlYXNlIHVzZSB0aGUgJ25ldycgb3BlcmF0b3IsIHRoaXMgb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICBQcm9taXNlIG9iamVjdHMgcmVwcmVzZW50IHRoZSBldmVudHVhbCByZXN1bHQgb2YgYW4gYXN5bmNocm9ub3VzIG9wZXJhdGlvbi4gVGhlXG4gICAgICBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLCB3aGljaFxuICAgICAgcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2XigJlzIGV2ZW50dWFsIHZhbHVlIG9yIHRoZSByZWFzb25cbiAgICAgIHdoeSB0aGUgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkLlxuXG4gICAgICBUZXJtaW5vbG9neVxuICAgICAgLS0tLS0tLS0tLS1cblxuICAgICAgLSBgcHJvbWlzZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHdpdGggYSBgdGhlbmAgbWV0aG9kIHdob3NlIGJlaGF2aW9yIGNvbmZvcm1zIHRvIHRoaXMgc3BlY2lmaWNhdGlvbi5cbiAgICAgIC0gYHRoZW5hYmxlYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gdGhhdCBkZWZpbmVzIGEgYHRoZW5gIG1ldGhvZC5cbiAgICAgIC0gYHZhbHVlYCBpcyBhbnkgbGVnYWwgSmF2YVNjcmlwdCB2YWx1ZSAoaW5jbHVkaW5nIHVuZGVmaW5lZCwgYSB0aGVuYWJsZSwgb3IgYSBwcm9taXNlKS5cbiAgICAgIC0gYGV4Y2VwdGlvbmAgaXMgYSB2YWx1ZSB0aGF0IGlzIHRocm93biB1c2luZyB0aGUgdGhyb3cgc3RhdGVtZW50LlxuICAgICAgLSBgcmVhc29uYCBpcyBhIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoeSBhIHByb21pc2Ugd2FzIHJlamVjdGVkLlxuICAgICAgLSBgc2V0dGxlZGAgdGhlIGZpbmFsIHJlc3Rpbmcgc3RhdGUgb2YgYSBwcm9taXNlLCBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuXG5cbiAgICAgIEEgcHJvbWlzZSBjYW4gYmUgaW4gb25lIG9mIHRocmVlIHN0YXRlczogcGVuZGluZywgZnVsZmlsbGVkLCBvciByZWplY3RlZC5cblxuICAgICAgUHJvbWlzZXMgdGhhdCBhcmUgZnVsZmlsbGVkIGhhdmUgYSBmdWxmaWxsbWVudCB2YWx1ZSBhbmQgYXJlIGluIHRoZSBmdWxmaWxsZWRcbiAgICAgIHN0YXRlLiAgUHJvbWlzZXMgdGhhdCBhcmUgcmVqZWN0ZWQgaGF2ZSBhIHJlamVjdGlvbiByZWFzb24gYW5kIGFyZSBpbiB0aGVcbiAgICAgIHJlamVjdGVkIHN0YXRlLiAgQSBmdWxmaWxsbWVudCB2YWx1ZSBpcyBuZXZlciBhIHRoZW5hYmxlLlxuXG4gICAgICBQcm9taXNlcyBjYW4gYWxzbyBiZSBzYWlkIHRvICpyZXNvbHZlKiBhIHZhbHVlLiAgSWYgdGhpcyB2YWx1ZSBpcyBhbHNvIGFcbiAgICAgIHByb21pc2UsIHRoZW4gdGhlIG9yaWdpbmFsIHByb21pc2UncyBzZXR0bGVkIHN0YXRlIHdpbGwgbWF0Y2ggdGhlIHZhbHVlJ3NcbiAgICAgIHNldHRsZWQgc3RhdGUuICBTbyBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IHJlamVjdHMgd2lsbFxuICAgICAgaXRzZWxmIHJlamVjdCwgYW5kIGEgcHJvbWlzZSB0aGF0ICpyZXNvbHZlcyogYSBwcm9taXNlIHRoYXQgZnVsZmlsbHMgd2lsbFxuICAgICAgaXRzZWxmIGZ1bGZpbGwuXG5cblxuICAgICAgQmFzaWMgVXNhZ2U6XG4gICAgICAtLS0tLS0tLS0tLS1cblxuICAgICAgYGBganNcbiAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIC8vIG9uIHN1Y2Nlc3NcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG5cbiAgICAgICAgLy8gb24gZmFpbHVyZVxuICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgIH0pO1xuXG4gICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAvLyBvbiByZWplY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEFkdmFuY2VkIFVzYWdlOlxuICAgICAgLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgIFByb21pc2VzIHNoaW5lIHdoZW4gYWJzdHJhY3RpbmcgYXdheSBhc3luY2hyb25vdXMgaW50ZXJhY3Rpb25zIHN1Y2ggYXNcbiAgICAgIGBYTUxIdHRwUmVxdWVzdGBzLlxuXG4gICAgICBgYGBqc1xuICAgICAgZnVuY3Rpb24gZ2V0SlNPTih1cmwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCk7XG4gICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGhhbmRsZXI7XG4gICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdqc29uJztcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgICAgICB4aHIuc2VuZCgpO1xuXG4gICAgICAgICAgZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHRoaXMuRE9ORSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5yZXNwb25zZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignZ2V0SlNPTjogYCcgKyB1cmwgKyAnYCBmYWlsZWQgd2l0aCBzdGF0dXM6IFsnICsgdGhpcy5zdGF0dXMgKyAnXScpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBnZXRKU09OKCcvcG9zdHMuanNvbicpLnRoZW4oZnVuY3Rpb24oanNvbikge1xuICAgICAgICAvLyBvbiBmdWxmaWxsbWVudFxuICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgIC8vIG9uIHJlamVjdGlvblxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgVW5saWtlIGNhbGxiYWNrcywgcHJvbWlzZXMgYXJlIGdyZWF0IGNvbXBvc2FibGUgcHJpbWl0aXZlcy5cblxuICAgICAgYGBganNcbiAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgZ2V0SlNPTignL3Bvc3RzJyksXG4gICAgICAgIGdldEpTT04oJy9jb21tZW50cycpXG4gICAgICBdKS50aGVuKGZ1bmN0aW9uKHZhbHVlcyl7XG4gICAgICAgIHZhbHVlc1swXSAvLyA9PiBwb3N0c0pTT05cbiAgICAgICAgdmFsdWVzWzFdIC8vID0+IGNvbW1lbnRzSlNPTlxuXG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBAY2xhc3MgUlNWUC5Qcm9taXNlXG4gICAgICBAcGFyYW0ge2Z1bmN0aW9ufSByZXNvbHZlclxuICAgICAgQHBhcmFtIHtTdHJpbmd9IGxhYmVsIG9wdGlvbmFsIHN0cmluZyBmb3IgbGFiZWxpbmcgdGhlIHByb21pc2UuXG4gICAgICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gICAgICBAY29uc3RydWN0b3JcbiAgICAqL1xuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJHByb21pc2UkJFByb21pc2UocmVzb2x2ZXIsIGxhYmVsKSB7XG4gICAgICB0aGlzLl9pZCA9IGxpYiRyc3ZwJHByb21pc2UkJGNvdW50ZXIrKztcbiAgICAgIHRoaXMuX2xhYmVsID0gbGFiZWw7XG4gICAgICB0aGlzLl9zdGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX3Jlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX3N1YnNjcmliZXJzID0gW107XG5cbiAgICAgIGlmIChsaWIkcnN2cCRjb25maWckJGNvbmZpZy5pbnN0cnVtZW50KSB7XG4gICAgICAgIGxpYiRyc3ZwJGluc3RydW1lbnQkJGRlZmF1bHQoJ2NyZWF0ZWQnLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxpYiRyc3ZwJCRpbnRlcm5hbCQkbm9vcCAhPT0gcmVzb2x2ZXIpIHtcbiAgICAgICAgaWYgKCFsaWIkcnN2cCR1dGlscyQkaXNGdW5jdGlvbihyZXNvbHZlcikpIHtcbiAgICAgICAgICBsaWIkcnN2cCRwcm9taXNlJCRuZWVkc1Jlc29sdmVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgbGliJHJzdnAkcHJvbWlzZSQkUHJvbWlzZSkpIHtcbiAgICAgICAgICBsaWIkcnN2cCRwcm9taXNlJCRuZWVkc05ldygpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGliJHJzdnAkJGludGVybmFsJCRpbml0aWFsaXplUHJvbWlzZSh0aGlzLCByZXNvbHZlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxpYiRyc3ZwJHByb21pc2UkJGRlZmF1bHQgPSBsaWIkcnN2cCRwcm9taXNlJCRQcm9taXNlO1xuXG4gICAgLy8gZGVwcmVjYXRlZFxuICAgIGxpYiRyc3ZwJHByb21pc2UkJFByb21pc2UuY2FzdCA9IGxpYiRyc3ZwJHByb21pc2UkcmVzb2x2ZSQkZGVmYXVsdDtcbiAgICBsaWIkcnN2cCRwcm9taXNlJCRQcm9taXNlLmFsbCA9IGxpYiRyc3ZwJHByb21pc2UkYWxsJCRkZWZhdWx0O1xuICAgIGxpYiRyc3ZwJHByb21pc2UkJFByb21pc2UucmFjZSA9IGxpYiRyc3ZwJHByb21pc2UkcmFjZSQkZGVmYXVsdDtcbiAgICBsaWIkcnN2cCRwcm9taXNlJCRQcm9taXNlLnJlc29sdmUgPSBsaWIkcnN2cCRwcm9taXNlJHJlc29sdmUkJGRlZmF1bHQ7XG4gICAgbGliJHJzdnAkcHJvbWlzZSQkUHJvbWlzZS5yZWplY3QgPSBsaWIkcnN2cCRwcm9taXNlJHJlamVjdCQkZGVmYXVsdDtcblxuICAgIGxpYiRyc3ZwJHByb21pc2UkJFByb21pc2UucHJvdG90eXBlID0ge1xuICAgICAgY29uc3RydWN0b3I6IGxpYiRyc3ZwJHByb21pc2UkJFByb21pc2UsXG5cbiAgICAgIF9ndWlkS2V5OiBsaWIkcnN2cCRwcm9taXNlJCRndWlkS2V5LFxuXG4gICAgICBfb25FcnJvcjogZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICBsaWIkcnN2cCRjb25maWckJGNvbmZpZy5hc3luYyhmdW5jdGlvbihwcm9taXNlKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChwcm9taXNlLl9vbkVycm9yKSB7XG4gICAgICAgICAgICAgIGxpYiRyc3ZwJGNvbmZpZyQkY29uZmlnWyd0cmlnZ2VyJ10oJ2Vycm9yJywgcmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9LFxuXG4gICAgLyoqXG4gICAgICBUaGUgcHJpbWFyeSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhIHByb21pc2UgaXMgdGhyb3VnaCBpdHMgYHRoZW5gIG1ldGhvZCxcbiAgICAgIHdoaWNoIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlXG4gICAgICByZWFzb24gd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24odXNlcil7XG4gICAgICAgIC8vIHVzZXIgaXMgYXZhaWxhYmxlXG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgICAgICAvLyB1c2VyIGlzIHVuYXZhaWxhYmxlLCBhbmQgeW91IGFyZSBnaXZlbiB0aGUgcmVhc29uIHdoeVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQ2hhaW5pbmdcbiAgICAgIC0tLS0tLS0tXG5cbiAgICAgIFRoZSByZXR1cm4gdmFsdWUgb2YgYHRoZW5gIGlzIGl0c2VsZiBhIHByb21pc2UuICBUaGlzIHNlY29uZCwgJ2Rvd25zdHJlYW0nXG4gICAgICBwcm9taXNlIGlzIHJlc29sdmVkIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZmlyc3QgcHJvbWlzZSdzIGZ1bGZpbGxtZW50XG4gICAgICBvciByZWplY3Rpb24gaGFuZGxlciwgb3IgcmVqZWN0ZWQgaWYgdGhlIGhhbmRsZXIgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cblxuICAgICAgYGBganNcbiAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgICByZXR1cm4gdXNlci5uYW1lO1xuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICByZXR1cm4gJ2RlZmF1bHQgbmFtZSc7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICh1c2VyTmFtZSkge1xuICAgICAgICAvLyBJZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHVzZXJOYW1lYCB3aWxsIGJlIHRoZSB1c2VyJ3MgbmFtZSwgb3RoZXJ3aXNlIGl0XG4gICAgICAgIC8vIHdpbGwgYmUgYCdkZWZhdWx0IG5hbWUnYFxuICAgICAgfSk7XG5cbiAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIHVzZXIsIGJ1dCBzdGlsbCB1bmhhcHB5Jyk7XG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgLy8gbmV2ZXIgcmVhY2hlZFxuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAvLyBpZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHJlYXNvbmAgd2lsbCBiZSAnRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknLlxuICAgICAgICAvLyBJZiBgZmluZFVzZXJgIHJlamVjdGVkLCBgcmVhc29uYCB3aWxsIGJlICdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jy5cbiAgICAgIH0pO1xuICAgICAgYGBgXG4gICAgICBJZiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIGRvZXMgbm90IHNwZWNpZnkgYSByZWplY3Rpb24gaGFuZGxlciwgcmVqZWN0aW9uIHJlYXNvbnMgd2lsbCBiZSBwcm9wYWdhdGVkIGZ1cnRoZXIgZG93bnN0cmVhbS5cblxuICAgICAgYGBganNcbiAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgICB0aHJvdyBuZXcgUGVkYWdvZ2ljYWxFeGNlcHRpb24oJ1Vwc3RyZWFtIGVycm9yJyk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBuZXZlciByZWFjaGVkXG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBuZXZlciByZWFjaGVkXG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIC8vIFRoZSBgUGVkZ2Fnb2NpYWxFeGNlcHRpb25gIGlzIHByb3BhZ2F0ZWQgYWxsIHRoZSB3YXkgZG93biB0byBoZXJlXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBBc3NpbWlsYXRpb25cbiAgICAgIC0tLS0tLS0tLS0tLVxuXG4gICAgICBTb21ldGltZXMgdGhlIHZhbHVlIHlvdSB3YW50IHRvIHByb3BhZ2F0ZSB0byBhIGRvd25zdHJlYW0gcHJvbWlzZSBjYW4gb25seSBiZVxuICAgICAgcmV0cmlldmVkIGFzeW5jaHJvbm91c2x5LiBUaGlzIGNhbiBiZSBhY2hpZXZlZCBieSByZXR1cm5pbmcgYSBwcm9taXNlIGluIHRoZVxuICAgICAgZnVsZmlsbG1lbnQgb3IgcmVqZWN0aW9uIGhhbmRsZXIuIFRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCB0aGVuIGJlIHBlbmRpbmdcbiAgICAgIHVudGlsIHRoZSByZXR1cm5lZCBwcm9taXNlIGlzIHNldHRsZWQuIFRoaXMgaXMgY2FsbGVkICphc3NpbWlsYXRpb24qLlxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgICAgIC8vIFRoZSB1c2VyJ3MgY29tbWVudHMgYXJlIG5vdyBhdmFpbGFibGVcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIElmIHRoZSBhc3NpbWxpYXRlZCBwcm9taXNlIHJlamVjdHMsIHRoZW4gdGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIGFsc28gcmVqZWN0LlxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgZnVsZmlsbHMsIHdlJ2xsIGhhdmUgdGhlIHZhbHVlIGhlcmVcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgLy8gSWYgYGZpbmRDb21tZW50c0J5QXV0aG9yYCByZWplY3RzLCB3ZSdsbCBoYXZlIHRoZSByZWFzb24gaGVyZVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgU2ltcGxlIEV4YW1wbGVcbiAgICAgIC0tLS0tLS0tLS0tLS0tXG5cbiAgICAgIFN5bmNocm9ub3VzIEV4YW1wbGVcblxuICAgICAgYGBgamF2YXNjcmlwdFxuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gZmluZFJlc3VsdCgpO1xuICAgICAgICAvLyBzdWNjZXNzXG4gICAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgICAvLyBmYWlsdXJlXG4gICAgICB9XG4gICAgICBgYGBcblxuICAgICAgRXJyYmFjayBFeGFtcGxlXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kUmVzdWx0KGZ1bmN0aW9uKHJlc3VsdCwgZXJyKXtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIC8vIGZhaWx1cmVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBzdWNjZXNzXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIFByb21pc2UgRXhhbXBsZTtcblxuICAgICAgYGBgamF2YXNjcmlwdFxuICAgICAgZmluZFJlc3VsdCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAgICAgLy8gc3VjY2Vzc1xuICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQWR2YW5jZWQgRXhhbXBsZVxuICAgICAgLS0tLS0tLS0tLS0tLS1cblxuICAgICAgU3luY2hyb25vdXMgRXhhbXBsZVxuXG4gICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICB2YXIgYXV0aG9yLCBib29rcztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgYXV0aG9yID0gZmluZEF1dGhvcigpO1xuICAgICAgICBib29rcyAgPSBmaW5kQm9va3NCeUF1dGhvcihhdXRob3IpO1xuICAgICAgICAvLyBzdWNjZXNzXG4gICAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgICAvLyBmYWlsdXJlXG4gICAgICB9XG4gICAgICBgYGBcblxuICAgICAgRXJyYmFjayBFeGFtcGxlXG5cbiAgICAgIGBgYGpzXG5cbiAgICAgIGZ1bmN0aW9uIGZvdW5kQm9va3MoYm9va3MpIHtcblxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBmYWlsdXJlKHJlYXNvbikge1xuXG4gICAgICB9XG5cbiAgICAgIGZpbmRBdXRob3IoZnVuY3Rpb24oYXV0aG9yLCBlcnIpe1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICAgIC8vIGZhaWx1cmVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZmluZEJvb29rc0J5QXV0aG9yKGF1dGhvciwgZnVuY3Rpb24oYm9va3MsIGVycikge1xuICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBmb3VuZEJvb2tzKGJvb2tzKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgZmFpbHVyZShyZWFzb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBzdWNjZXNzXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIFByb21pc2UgRXhhbXBsZTtcblxuICAgICAgYGBgamF2YXNjcmlwdFxuICAgICAgZmluZEF1dGhvcigpLlxuICAgICAgICB0aGVuKGZpbmRCb29rc0J5QXV0aG9yKS5cbiAgICAgICAgdGhlbihmdW5jdGlvbihib29rcyl7XG4gICAgICAgICAgLy8gZm91bmQgYm9va3NcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBAbWV0aG9kIHRoZW5cbiAgICAgIEBwYXJhbSB7RnVuY3Rpb259IG9uRnVsZmlsbGVkXG4gICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGVkXG4gICAgICBAcGFyYW0ge1N0cmluZ30gbGFiZWwgb3B0aW9uYWwgc3RyaW5nIGZvciBsYWJlbGluZyB0aGUgcHJvbWlzZS5cbiAgICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICAgKi9cbiAgICAgIHRoZW46IGZ1bmN0aW9uKG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uLCBsYWJlbCkge1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcztcbiAgICAgICAgdmFyIHN0YXRlID0gcGFyZW50Ll9zdGF0ZTtcblxuICAgICAgICBpZiAoc3RhdGUgPT09IGxpYiRyc3ZwJCRpbnRlcm5hbCQkRlVMRklMTEVEICYmICFvbkZ1bGZpbGxtZW50IHx8IHN0YXRlID09PSBsaWIkcnN2cCQkaW50ZXJuYWwkJFJFSkVDVEVEICYmICFvblJlamVjdGlvbikge1xuICAgICAgICAgIGlmIChsaWIkcnN2cCRjb25maWckJGNvbmZpZy5pbnN0cnVtZW50KSB7XG4gICAgICAgICAgICBsaWIkcnN2cCRpbnN0cnVtZW50JCRkZWZhdWx0KCdjaGFpbmVkJywgdGhpcywgdGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50Ll9vbkVycm9yID0gbnVsbDtcblxuICAgICAgICB2YXIgY2hpbGQgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihsaWIkcnN2cCQkaW50ZXJuYWwkJG5vb3AsIGxhYmVsKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHBhcmVudC5fcmVzdWx0O1xuXG4gICAgICAgIGlmIChsaWIkcnN2cCRjb25maWckJGNvbmZpZy5pbnN0cnVtZW50KSB7XG4gICAgICAgICAgbGliJHJzdnAkaW5zdHJ1bWVudCQkZGVmYXVsdCgnY2hhaW5lZCcsIHBhcmVudCwgY2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzW3N0YXRlIC0gMV07XG4gICAgICAgICAgbGliJHJzdnAkY29uZmlnJCRjb25maWcuYXN5bmMoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGxpYiRyc3ZwJCRpbnRlcm5hbCQkaW52b2tlQ2FsbGJhY2soc3RhdGUsIGNoaWxkLCBjYWxsYmFjaywgcmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaWIkcnN2cCQkaW50ZXJuYWwkJHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9LFxuXG4gICAgLyoqXG4gICAgICBgY2F0Y2hgIGlzIHNpbXBseSBzdWdhciBmb3IgYHRoZW4odW5kZWZpbmVkLCBvblJlamVjdGlvbilgIHdoaWNoIG1ha2VzIGl0IHRoZSBzYW1lXG4gICAgICBhcyB0aGUgY2F0Y2ggYmxvY2sgb2YgYSB0cnkvY2F0Y2ggc3RhdGVtZW50LlxuXG4gICAgICBgYGBqc1xuICAgICAgZnVuY3Rpb24gZmluZEF1dGhvcigpe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkbid0IGZpbmQgdGhhdCBhdXRob3InKTtcbiAgICAgIH1cblxuICAgICAgLy8gc3luY2hyb25vdXNcbiAgICAgIHRyeSB7XG4gICAgICAgIGZpbmRBdXRob3IoKTtcbiAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgICB9XG5cbiAgICAgIC8vIGFzeW5jIHdpdGggcHJvbWlzZXNcbiAgICAgIGZpbmRBdXRob3IoKS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAgICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQG1ldGhvZCBjYXRjaFxuICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3Rpb25cbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBsYWJlbCBvcHRpb25hbCBzdHJpbmcgZm9yIGxhYmVsaW5nIHRoZSBwcm9taXNlLlxuICAgICAgVXNlZnVsIGZvciB0b29saW5nLlxuICAgICAgQHJldHVybiB7UHJvbWlzZX1cbiAgICAqL1xuICAgICAgJ2NhdGNoJzogZnVuY3Rpb24ob25SZWplY3Rpb24sIGxhYmVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24sIGxhYmVsKTtcbiAgICAgIH0sXG5cbiAgICAvKipcbiAgICAgIGBmaW5hbGx5YCB3aWxsIGJlIGludm9rZWQgcmVnYXJkbGVzcyBvZiB0aGUgcHJvbWlzZSdzIGZhdGUganVzdCBhcyBuYXRpdmVcbiAgICAgIHRyeS9jYXRjaC9maW5hbGx5IGJlaGF2ZXNcblxuICAgICAgU3luY2hyb25vdXMgZXhhbXBsZTpcblxuICAgICAgYGBganNcbiAgICAgIGZpbmRBdXRob3IoKSB7XG4gICAgICAgIGlmIChNYXRoLnJhbmRvbSgpID4gMC41KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBdXRob3IoKTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZpbmRBdXRob3IoKTsgLy8gc3VjY2VlZCBvciBmYWlsXG4gICAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBmaW5kT3RoZXJBdXRoZXIoKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIC8vIGFsd2F5cyBydW5zXG4gICAgICAgIC8vIGRvZXNuJ3QgYWZmZWN0IHRoZSByZXR1cm4gdmFsdWVcbiAgICAgIH1cbiAgICAgIGBgYFxuXG4gICAgICBBc3luY2hyb25vdXMgZXhhbXBsZTpcblxuICAgICAgYGBganNcbiAgICAgIGZpbmRBdXRob3IoKS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAgICAgICByZXR1cm4gZmluZE90aGVyQXV0aGVyKCk7XG4gICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vIGF1dGhvciB3YXMgZWl0aGVyIGZvdW5kLCBvciBub3RcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEBtZXRob2QgZmluYWxseVxuICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgIEBwYXJhbSB7U3RyaW5nfSBsYWJlbCBvcHRpb25hbCBzdHJpbmcgZm9yIGxhYmVsaW5nIHRoZSBwcm9taXNlLlxuICAgICAgVXNlZnVsIGZvciB0b29saW5nLlxuICAgICAgQHJldHVybiB7UHJvbWlzZX1cbiAgICAqL1xuICAgICAgJ2ZpbmFsbHknOiBmdW5jdGlvbihjYWxsYmFjaywgbGFiZWwpIHtcbiAgICAgICAgdmFyIGNvbnN0cnVjdG9yID0gdGhpcy5jb25zdHJ1Y3RvcjtcblxuICAgICAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLnJlc29sdmUoY2FsbGJhY2soKSkudGhlbihmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgICByZXR1cm4gY29uc3RydWN0b3IucmVzb2x2ZShjYWxsYmFjaygpKS50aGVuKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aHJvdyByZWFzb247XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGxhYmVsKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbGliJHJzdnAkYWxsJHNldHRsZWQkJEFsbFNldHRsZWQoQ29uc3RydWN0b3IsIGVudHJpZXMsIGxhYmVsKSB7XG4gICAgICB0aGlzLl9zdXBlckNvbnN0cnVjdG9yKENvbnN0cnVjdG9yLCBlbnRyaWVzLCBmYWxzZSAvKiBkb24ndCBhYm9ydCBvbiByZWplY3QgKi8sIGxhYmVsKTtcbiAgICB9XG5cbiAgICBsaWIkcnN2cCRhbGwkc2V0dGxlZCQkQWxsU2V0dGxlZC5wcm90b3R5cGUgPSBsaWIkcnN2cCR1dGlscyQkb19jcmVhdGUobGliJHJzdnAkZW51bWVyYXRvciQkZGVmYXVsdC5wcm90b3R5cGUpO1xuICAgIGxpYiRyc3ZwJGFsbCRzZXR0bGVkJCRBbGxTZXR0bGVkLnByb3RvdHlwZS5fc3VwZXJDb25zdHJ1Y3RvciA9IGxpYiRyc3ZwJGVudW1lcmF0b3IkJGRlZmF1bHQ7XG4gICAgbGliJHJzdnAkYWxsJHNldHRsZWQkJEFsbFNldHRsZWQucHJvdG90eXBlLl9tYWtlUmVzdWx0ID0gbGliJHJzdnAkZW51bWVyYXRvciQkbWFrZVNldHRsZWRSZXN1bHQ7XG4gICAgbGliJHJzdnAkYWxsJHNldHRsZWQkJEFsbFNldHRsZWQucHJvdG90eXBlLl92YWxpZGF0aW9uRXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ2FsbFNldHRsZWQgbXVzdCBiZSBjYWxsZWQgd2l0aCBhbiBhcnJheScpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCRhbGwkc2V0dGxlZCQkYWxsU2V0dGxlZChlbnRyaWVzLCBsYWJlbCkge1xuICAgICAgcmV0dXJuIG5ldyBsaWIkcnN2cCRhbGwkc2V0dGxlZCQkQWxsU2V0dGxlZChsaWIkcnN2cCRwcm9taXNlJCRkZWZhdWx0LCBlbnRyaWVzLCBsYWJlbCkucHJvbWlzZTtcbiAgICB9XG4gICAgdmFyIGxpYiRyc3ZwJGFsbCRzZXR0bGVkJCRkZWZhdWx0ID0gbGliJHJzdnAkYWxsJHNldHRsZWQkJGFsbFNldHRsZWQ7XG4gICAgZnVuY3Rpb24gbGliJHJzdnAkYWxsJCRhbGwoYXJyYXksIGxhYmVsKSB7XG4gICAgICByZXR1cm4gbGliJHJzdnAkcHJvbWlzZSQkZGVmYXVsdC5hbGwoYXJyYXksIGxhYmVsKTtcbiAgICB9XG4gICAgdmFyIGxpYiRyc3ZwJGFsbCQkZGVmYXVsdCA9IGxpYiRyc3ZwJGFsbCQkYWxsO1xuICAgIHZhciBsaWIkcnN2cCRhc2FwJCRsZW4gPSAwO1xuICAgIHZhciBsaWIkcnN2cCRhc2FwJCR0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuICAgIHZhciBsaWIkcnN2cCRhc2FwJCR2ZXJ0eE5leHQ7XG4gICAgZnVuY3Rpb24gbGliJHJzdnAkYXNhcCQkYXNhcChjYWxsYmFjaywgYXJnKSB7XG4gICAgICBsaWIkcnN2cCRhc2FwJCRxdWV1ZVtsaWIkcnN2cCRhc2FwJCRsZW5dID0gY2FsbGJhY2s7XG4gICAgICBsaWIkcnN2cCRhc2FwJCRxdWV1ZVtsaWIkcnN2cCRhc2FwJCRsZW4gKyAxXSA9IGFyZztcbiAgICAgIGxpYiRyc3ZwJGFzYXAkJGxlbiArPSAyO1xuICAgICAgaWYgKGxpYiRyc3ZwJGFzYXAkJGxlbiA9PT0gMikge1xuICAgICAgICAvLyBJZiBsZW4gaXMgMSwgdGhhdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gc2NoZWR1bGUgYW4gYXN5bmMgZmx1c2guXG4gICAgICAgIC8vIElmIGFkZGl0aW9uYWwgY2FsbGJhY2tzIGFyZSBxdWV1ZWQgYmVmb3JlIHRoZSBxdWV1ZSBpcyBmbHVzaGVkLCB0aGV5XG4gICAgICAgIC8vIHdpbGwgYmUgcHJvY2Vzc2VkIGJ5IHRoaXMgZmx1c2ggdGhhdCB3ZSBhcmUgc2NoZWR1bGluZy5cbiAgICAgICAgbGliJHJzdnAkYXNhcCQkc2NoZWR1bGVGbHVzaCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsaWIkcnN2cCRhc2FwJCRkZWZhdWx0ID0gbGliJHJzdnAkYXNhcCQkYXNhcDtcblxuICAgIHZhciBsaWIkcnN2cCRhc2FwJCRicm93c2VyV2luZG93ID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSA/IHdpbmRvdyA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbGliJHJzdnAkYXNhcCQkYnJvd3Nlckdsb2JhbCA9IGxpYiRyc3ZwJGFzYXAkJGJyb3dzZXJXaW5kb3cgfHwge307XG4gICAgdmFyIGxpYiRyc3ZwJGFzYXAkJEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID0gbGliJHJzdnAkYXNhcCQkYnJvd3Nlckdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGxpYiRyc3ZwJGFzYXAkJGJyb3dzZXJHbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbiAgICB2YXIgbGliJHJzdnAkYXNhcCQkaXNOb2RlID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHt9LnRvU3RyaW5nLmNhbGwocHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJztcblxuICAgIC8vIHRlc3QgZm9yIHdlYiB3b3JrZXIgYnV0IG5vdCBpbiBJRTEwXG4gICAgdmFyIGxpYiRyc3ZwJGFzYXAkJGlzV29ya2VyID0gdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgdHlwZW9mIGltcG9ydFNjcmlwdHMgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICB0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnO1xuXG4gICAgLy8gbm9kZVxuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJGFzYXAkJHVzZU5leHRUaWNrKCkge1xuICAgICAgdmFyIG5leHRUaWNrID0gcHJvY2Vzcy5uZXh0VGljaztcbiAgICAgIC8vIG5vZGUgdmVyc2lvbiAwLjEwLnggZGlzcGxheXMgYSBkZXByZWNhdGlvbiB3YXJuaW5nIHdoZW4gbmV4dFRpY2sgaXMgdXNlZCByZWN1cnNpdmVseVxuICAgICAgLy8gc2V0SW1tZWRpYXRlIHNob3VsZCBiZSB1c2VkIGluc3RlYWQgaW5zdGVhZFxuICAgICAgdmFyIHZlcnNpb24gPSBwcm9jZXNzLnZlcnNpb25zLm5vZGUubWF0Y2goL14oPzooXFxkKylcXC4pPyg/OihcXGQrKVxcLik/KFxcKnxcXGQrKSQvKTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZlcnNpb24pICYmIHZlcnNpb25bMV0gPT09ICcwJyAmJiB2ZXJzaW9uWzJdID09PSAnMTAnKSB7XG4gICAgICAgIG5leHRUaWNrID0gc2V0SW1tZWRpYXRlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBuZXh0VGljayhsaWIkcnN2cCRhc2FwJCRmbHVzaCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIHZlcnR4XG4gICAgZnVuY3Rpb24gbGliJHJzdnAkYXNhcCQkdXNlVmVydHhUaW1lcigpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgbGliJHJzdnAkYXNhcCQkdmVydHhOZXh0KGxpYiRyc3ZwJGFzYXAkJGZsdXNoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJHJzdnAkYXNhcCQkdXNlTXV0YXRpb25PYnNlcnZlcigpIHtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHZhciBvYnNlcnZlciA9IG5ldyBsaWIkcnN2cCRhc2FwJCRCcm93c2VyTXV0YXRpb25PYnNlcnZlcihsaWIkcnN2cCRhc2FwJCRmbHVzaCk7XG4gICAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICAgIG9ic2VydmVyLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIG5vZGUuZGF0YSA9IChpdGVyYXRpb25zID0gKytpdGVyYXRpb25zICUgMik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIHdlYiB3b3JrZXJcbiAgICBmdW5jdGlvbiBsaWIkcnN2cCRhc2FwJCR1c2VNZXNzYWdlQ2hhbm5lbCgpIHtcbiAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpYiRyc3ZwJGFzYXAkJGZsdXNoO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJHJzdnAkYXNhcCQkdXNlU2V0VGltZW91dCgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgc2V0VGltZW91dChsaWIkcnN2cCRhc2FwJCRmbHVzaCwgMSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBsaWIkcnN2cCRhc2FwJCRxdWV1ZSA9IG5ldyBBcnJheSgxMDAwKTtcbiAgICBmdW5jdGlvbiBsaWIkcnN2cCRhc2FwJCRmbHVzaCgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGliJHJzdnAkYXNhcCQkbGVuOyBpKz0yKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGxpYiRyc3ZwJGFzYXAkJHF1ZXVlW2ldO1xuICAgICAgICB2YXIgYXJnID0gbGliJHJzdnAkYXNhcCQkcXVldWVbaSsxXTtcblxuICAgICAgICBjYWxsYmFjayhhcmcpO1xuXG4gICAgICAgIGxpYiRyc3ZwJGFzYXAkJHF1ZXVlW2ldID0gdW5kZWZpbmVkO1xuICAgICAgICBsaWIkcnN2cCRhc2FwJCRxdWV1ZVtpKzFdID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBsaWIkcnN2cCRhc2FwJCRsZW4gPSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJGFzYXAkJGF0dGVtcHRWZXJ0ZXgoKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgciA9IHJlcXVpcmU7XG4gICAgICAgIHZhciB2ZXJ0eCA9IHIoJ3ZlcnR4Jyk7XG4gICAgICAgIGxpYiRyc3ZwJGFzYXAkJHZlcnR4TmV4dCA9IHZlcnR4LnJ1bk9uTG9vcCB8fCB2ZXJ0eC5ydW5PbkNvbnRleHQ7XG4gICAgICAgIHJldHVybiBsaWIkcnN2cCRhc2FwJCR1c2VWZXJ0eFRpbWVyKCk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGxpYiRyc3ZwJGFzYXAkJHVzZVNldFRpbWVvdXQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGliJHJzdnAkYXNhcCQkc2NoZWR1bGVGbHVzaDtcbiAgICAvLyBEZWNpZGUgd2hhdCBhc3luYyBtZXRob2QgdG8gdXNlIHRvIHRyaWdnZXJpbmcgcHJvY2Vzc2luZyBvZiBxdWV1ZWQgY2FsbGJhY2tzOlxuICAgIGlmIChsaWIkcnN2cCRhc2FwJCRpc05vZGUpIHtcbiAgICAgIGxpYiRyc3ZwJGFzYXAkJHNjaGVkdWxlRmx1c2ggPSBsaWIkcnN2cCRhc2FwJCR1c2VOZXh0VGljaygpO1xuICAgIH0gZWxzZSBpZiAobGliJHJzdnAkYXNhcCQkQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgIGxpYiRyc3ZwJGFzYXAkJHNjaGVkdWxlRmx1c2ggPSBsaWIkcnN2cCRhc2FwJCR1c2VNdXRhdGlvbk9ic2VydmVyKCk7XG4gICAgfSBlbHNlIGlmIChsaWIkcnN2cCRhc2FwJCRpc1dvcmtlcikge1xuICAgICAgbGliJHJzdnAkYXNhcCQkc2NoZWR1bGVGbHVzaCA9IGxpYiRyc3ZwJGFzYXAkJHVzZU1lc3NhZ2VDaGFubmVsKCk7XG4gICAgfSBlbHNlIGlmIChsaWIkcnN2cCRhc2FwJCRicm93c2VyV2luZG93ID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGxpYiRyc3ZwJGFzYXAkJHNjaGVkdWxlRmx1c2ggPSBsaWIkcnN2cCRhc2FwJCRhdHRlbXB0VmVydGV4KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpYiRyc3ZwJGFzYXAkJHNjaGVkdWxlRmx1c2ggPSBsaWIkcnN2cCRhc2FwJCR1c2VTZXRUaW1lb3V0KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJGRlZmVyJCRkZWZlcihsYWJlbCkge1xuICAgICAgdmFyIGRlZmVycmVkID0geyB9O1xuXG4gICAgICBkZWZlcnJlZFsncHJvbWlzZSddID0gbmV3IGxpYiRyc3ZwJHByb21pc2UkJGRlZmF1bHQoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGRlZmVycmVkWydyZXNvbHZlJ10gPSByZXNvbHZlO1xuICAgICAgICBkZWZlcnJlZFsncmVqZWN0J10gPSByZWplY3Q7XG4gICAgICB9LCBsYWJlbCk7XG5cbiAgICAgIHJldHVybiBkZWZlcnJlZDtcbiAgICB9XG4gICAgdmFyIGxpYiRyc3ZwJGRlZmVyJCRkZWZhdWx0ID0gbGliJHJzdnAkZGVmZXIkJGRlZmVyO1xuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJGZpbHRlciQkZmlsdGVyKHByb21pc2VzLCBmaWx0ZXJGbiwgbGFiZWwpIHtcbiAgICAgIHJldHVybiBsaWIkcnN2cCRwcm9taXNlJCRkZWZhdWx0LmFsbChwcm9taXNlcywgbGFiZWwpLnRoZW4oZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICAgIGlmICghbGliJHJzdnAkdXRpbHMkJGlzRnVuY3Rpb24oZmlsdGVyRm4pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHBhc3MgYSBmdW5jdGlvbiBhcyBmaWx0ZXIncyBzZWNvbmQgYXJndW1lbnQuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG4gICAgICAgIHZhciBmaWx0ZXJlZCA9IG5ldyBBcnJheShsZW5ndGgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBmaWx0ZXJlZFtpXSA9IGZpbHRlckZuKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGliJHJzdnAkcHJvbWlzZSQkZGVmYXVsdC5hbGwoZmlsdGVyZWQsIGxhYmVsKS50aGVuKGZ1bmN0aW9uKGZpbHRlcmVkKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdHMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgICB2YXIgbmV3TGVuZ3RoID0gMDtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChmaWx0ZXJlZFtpXSkge1xuICAgICAgICAgICAgICByZXN1bHRzW25ld0xlbmd0aF0gPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICAgIG5ld0xlbmd0aCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc3VsdHMubGVuZ3RoID0gbmV3TGVuZ3RoO1xuXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBsaWIkcnN2cCRmaWx0ZXIkJGRlZmF1bHQgPSBsaWIkcnN2cCRmaWx0ZXIkJGZpbHRlcjtcblxuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJHByb21pc2UkaGFzaCQkUHJvbWlzZUhhc2goQ29uc3RydWN0b3IsIG9iamVjdCwgbGFiZWwpIHtcbiAgICAgIHRoaXMuX3N1cGVyQ29uc3RydWN0b3IoQ29uc3RydWN0b3IsIG9iamVjdCwgdHJ1ZSwgbGFiZWwpO1xuICAgIH1cblxuICAgIHZhciBsaWIkcnN2cCRwcm9taXNlJGhhc2gkJGRlZmF1bHQgPSBsaWIkcnN2cCRwcm9taXNlJGhhc2gkJFByb21pc2VIYXNoO1xuXG4gICAgbGliJHJzdnAkcHJvbWlzZSRoYXNoJCRQcm9taXNlSGFzaC5wcm90b3R5cGUgPSBsaWIkcnN2cCR1dGlscyQkb19jcmVhdGUobGliJHJzdnAkZW51bWVyYXRvciQkZGVmYXVsdC5wcm90b3R5cGUpO1xuICAgIGxpYiRyc3ZwJHByb21pc2UkaGFzaCQkUHJvbWlzZUhhc2gucHJvdG90eXBlLl9zdXBlckNvbnN0cnVjdG9yID0gbGliJHJzdnAkZW51bWVyYXRvciQkZGVmYXVsdDtcbiAgICBsaWIkcnN2cCRwcm9taXNlJGhhc2gkJFByb21pc2VIYXNoLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fcmVzdWx0ID0ge307XG4gICAgfTtcblxuICAgIGxpYiRyc3ZwJHByb21pc2UkaGFzaCQkUHJvbWlzZUhhc2gucHJvdG90eXBlLl92YWxpZGF0ZUlucHV0ID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgIHJldHVybiBpbnB1dCAmJiB0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnO1xuICAgIH07XG5cbiAgICBsaWIkcnN2cCRwcm9taXNlJGhhc2gkJFByb21pc2VIYXNoLnByb3RvdHlwZS5fdmFsaWRhdGlvbkVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdQcm9taXNlLmhhc2ggbXVzdCBiZSBjYWxsZWQgd2l0aCBhbiBvYmplY3QnKTtcbiAgICB9O1xuXG4gICAgbGliJHJzdnAkcHJvbWlzZSRoYXNoJCRQcm9taXNlSGFzaC5wcm90b3R5cGUuX2VudW1lcmF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHByb21pc2UgPSB0aGlzLnByb21pc2U7XG4gICAgICB2YXIgaW5wdXQgICA9IHRoaXMuX2lucHV0O1xuICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIGlucHV0KSB7XG4gICAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gbGliJHJzdnAkJGludGVybmFsJCRQRU5ESU5HICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpbnB1dCwga2V5KSkge1xuICAgICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICBwb3NpdGlvbjoga2V5LFxuICAgICAgICAgICAgZW50cnk6IGlucHV0W2tleV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbGVuZ3RoID0gcmVzdWx0cy5sZW5ndGg7XG4gICAgICB0aGlzLl9yZW1haW5pbmcgPSBsZW5ndGg7XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgcHJvbWlzZS5fc3RhdGUgPT09IGxpYiRyc3ZwJCRpbnRlcm5hbCQkUEVORElORyAmJiBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0c1tpXTtcbiAgICAgICAgdGhpcy5fZWFjaEVudHJ5KHJlc3VsdC5lbnRyeSwgcmVzdWx0LnBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbGliJHJzdnAkaGFzaCRzZXR0bGVkJCRIYXNoU2V0dGxlZChDb25zdHJ1Y3Rvciwgb2JqZWN0LCBsYWJlbCkge1xuICAgICAgdGhpcy5fc3VwZXJDb25zdHJ1Y3RvcihDb25zdHJ1Y3Rvciwgb2JqZWN0LCBmYWxzZSwgbGFiZWwpO1xuICAgIH1cblxuICAgIGxpYiRyc3ZwJGhhc2gkc2V0dGxlZCQkSGFzaFNldHRsZWQucHJvdG90eXBlID0gbGliJHJzdnAkdXRpbHMkJG9fY3JlYXRlKGxpYiRyc3ZwJHByb21pc2UkaGFzaCQkZGVmYXVsdC5wcm90b3R5cGUpO1xuICAgIGxpYiRyc3ZwJGhhc2gkc2V0dGxlZCQkSGFzaFNldHRsZWQucHJvdG90eXBlLl9zdXBlckNvbnN0cnVjdG9yID0gbGliJHJzdnAkZW51bWVyYXRvciQkZGVmYXVsdDtcbiAgICBsaWIkcnN2cCRoYXNoJHNldHRsZWQkJEhhc2hTZXR0bGVkLnByb3RvdHlwZS5fbWFrZVJlc3VsdCA9IGxpYiRyc3ZwJGVudW1lcmF0b3IkJG1ha2VTZXR0bGVkUmVzdWx0O1xuXG4gICAgbGliJHJzdnAkaGFzaCRzZXR0bGVkJCRIYXNoU2V0dGxlZC5wcm90b3R5cGUuX3ZhbGlkYXRpb25FcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignaGFzaFNldHRsZWQgbXVzdCBiZSBjYWxsZWQgd2l0aCBhbiBvYmplY3QnKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbGliJHJzdnAkaGFzaCRzZXR0bGVkJCRoYXNoU2V0dGxlZChvYmplY3QsIGxhYmVsKSB7XG4gICAgICByZXR1cm4gbmV3IGxpYiRyc3ZwJGhhc2gkc2V0dGxlZCQkSGFzaFNldHRsZWQobGliJHJzdnAkcHJvbWlzZSQkZGVmYXVsdCwgb2JqZWN0LCBsYWJlbCkucHJvbWlzZTtcbiAgICB9XG4gICAgdmFyIGxpYiRyc3ZwJGhhc2gkc2V0dGxlZCQkZGVmYXVsdCA9IGxpYiRyc3ZwJGhhc2gkc2V0dGxlZCQkaGFzaFNldHRsZWQ7XG4gICAgZnVuY3Rpb24gbGliJHJzdnAkaGFzaCQkaGFzaChvYmplY3QsIGxhYmVsKSB7XG4gICAgICByZXR1cm4gbmV3IGxpYiRyc3ZwJHByb21pc2UkaGFzaCQkZGVmYXVsdChsaWIkcnN2cCRwcm9taXNlJCRkZWZhdWx0LCBvYmplY3QsIGxhYmVsKS5wcm9taXNlO1xuICAgIH1cbiAgICB2YXIgbGliJHJzdnAkaGFzaCQkZGVmYXVsdCA9IGxpYiRyc3ZwJGhhc2gkJGhhc2g7XG4gICAgZnVuY3Rpb24gbGliJHJzdnAkbWFwJCRtYXAocHJvbWlzZXMsIG1hcEZuLCBsYWJlbCkge1xuICAgICAgcmV0dXJuIGxpYiRyc3ZwJHByb21pc2UkJGRlZmF1bHQuYWxsKHByb21pc2VzLCBsYWJlbCkudGhlbihmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgICAgaWYgKCFsaWIkcnN2cCR1dGlscyQkaXNGdW5jdGlvbihtYXBGbikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiWW91IG11c3QgcGFzcyBhIGZ1bmN0aW9uIGFzIG1hcCdzIHNlY29uZCBhcmd1bWVudC5cIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcmVzdWx0c1tpXSA9IG1hcEZuKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGliJHJzdnAkcHJvbWlzZSQkZGVmYXVsdC5hbGwocmVzdWx0cywgbGFiZWwpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBsaWIkcnN2cCRtYXAkJGRlZmF1bHQgPSBsaWIkcnN2cCRtYXAkJG1hcDtcblxuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJG5vZGUkJFJlc3VsdCgpIHtcbiAgICAgIHRoaXMudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIGxpYiRyc3ZwJG5vZGUkJEVSUk9SID0gbmV3IGxpYiRyc3ZwJG5vZGUkJFJlc3VsdCgpO1xuICAgIHZhciBsaWIkcnN2cCRub2RlJCRHRVRfVEhFTl9FUlJPUiA9IG5ldyBsaWIkcnN2cCRub2RlJCRSZXN1bHQoKTtcblxuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJG5vZGUkJGdldFRoZW4ob2JqKSB7XG4gICAgICB0cnkge1xuICAgICAgIHJldHVybiBvYmoudGhlbjtcbiAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgbGliJHJzdnAkbm9kZSQkRVJST1IudmFsdWU9IGVycm9yO1xuICAgICAgICByZXR1cm4gbGliJHJzdnAkbm9kZSQkRVJST1I7XG4gICAgICB9XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCRub2RlJCR0cnlBcHBseShmLCBzLCBhKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmLmFwcGx5KHMsIGEpO1xuICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICBsaWIkcnN2cCRub2RlJCRFUlJPUi52YWx1ZSA9IGVycm9yO1xuICAgICAgICByZXR1cm4gbGliJHJzdnAkbm9kZSQkRVJST1I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJHJzdnAkbm9kZSQkbWFrZU9iamVjdChfLCBhcmd1bWVudE5hbWVzKSB7XG4gICAgICB2YXIgb2JqID0ge307XG4gICAgICB2YXIgbmFtZTtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbmd0aCA9IF8ubGVuZ3RoO1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuZ3RoKTtcblxuICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBsZW5ndGg7IHgrKykge1xuICAgICAgICBhcmdzW3hdID0gX1t4XTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ3VtZW50TmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmFtZSA9IGFyZ3VtZW50TmFtZXNbaV07XG4gICAgICAgIG9ialtuYW1lXSA9IGFyZ3NbaSArIDFdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJG5vZGUkJGFycmF5UmVzdWx0KF8pIHtcbiAgICAgIHZhciBsZW5ndGggPSBfLmxlbmd0aDtcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbmd0aCAtIDEpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyZ3NbaSAtIDFdID0gX1tpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJHJzdnAkbm9kZSQkd3JhcFRoZW5hYmxlKHRoZW4sIHByb21pc2UpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRoZW46IGZ1bmN0aW9uKG9uRnVsRmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHRoZW4uY2FsbChwcm9taXNlLCBvbkZ1bEZpbGxtZW50LCBvblJlamVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJHJzdnAkbm9kZSQkZGVub2RlaWZ5KG5vZGVGdW5jLCBvcHRpb25zKSB7XG4gICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGwgKyAxKTtcbiAgICAgICAgdmFyIGFyZztcbiAgICAgICAgdmFyIHByb21pc2VJbnB1dCA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgYXJnID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICAgICAgaWYgKCFwcm9taXNlSW5wdXQpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IGNsZWFuIHRoaXMgdXBcbiAgICAgICAgICAgIHByb21pc2VJbnB1dCA9IGxpYiRyc3ZwJG5vZGUkJG5lZWRzUHJvbWlzZUlucHV0KGFyZyk7XG4gICAgICAgICAgICBpZiAocHJvbWlzZUlucHV0ID09PSBsaWIkcnN2cCRub2RlJCRHRVRfVEhFTl9FUlJPUikge1xuICAgICAgICAgICAgICB2YXIgcCA9IG5ldyBsaWIkcnN2cCRwcm9taXNlJCRkZWZhdWx0KGxpYiRyc3ZwJCRpbnRlcm5hbCQkbm9vcCk7XG4gICAgICAgICAgICAgIGxpYiRyc3ZwJCRpbnRlcm5hbCQkcmVqZWN0KHAsIGxpYiRyc3ZwJG5vZGUkJEdFVF9USEVOX0VSUk9SLnZhbHVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb21pc2VJbnB1dCAmJiBwcm9taXNlSW5wdXQgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgYXJnID0gbGliJHJzdnAkbm9kZSQkd3JhcFRoZW5hYmxlKHByb21pc2VJbnB1dCwgYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IGxpYiRyc3ZwJHByb21pc2UkJGRlZmF1bHQobGliJHJzdnAkJGludGVybmFsJCRub29wKTtcblxuICAgICAgICBhcmdzW2xdID0gZnVuY3Rpb24oZXJyLCB2YWwpIHtcbiAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgbGliJHJzdnAkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgZXJyKTtcbiAgICAgICAgICBlbHNlIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBsaWIkcnN2cCQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsKTtcbiAgICAgICAgICBlbHNlIGlmIChvcHRpb25zID09PSB0cnVlKVxuICAgICAgICAgICAgbGliJHJzdnAkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIGxpYiRyc3ZwJG5vZGUkJGFycmF5UmVzdWx0KGFyZ3VtZW50cykpO1xuICAgICAgICAgIGVsc2UgaWYgKGxpYiRyc3ZwJHV0aWxzJCRpc0FycmF5KG9wdGlvbnMpKVxuICAgICAgICAgICAgbGliJHJzdnAkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIGxpYiRyc3ZwJG5vZGUkJG1ha2VPYmplY3QoYXJndW1lbnRzLCBvcHRpb25zKSk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGliJHJzdnAkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHByb21pc2VJbnB1dCkge1xuICAgICAgICAgIHJldHVybiBsaWIkcnN2cCRub2RlJCRoYW5kbGVQcm9taXNlSW5wdXQocHJvbWlzZSwgYXJncywgbm9kZUZ1bmMsIHNlbGYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBsaWIkcnN2cCRub2RlJCRoYW5kbGVWYWx1ZUlucHV0KHByb21pc2UsIGFyZ3MsIG5vZGVGdW5jLCBzZWxmKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZm4uX19wcm90b19fID0gbm9kZUZ1bmM7XG5cbiAgICAgIHJldHVybiBmbjtcbiAgICB9XG5cbiAgICB2YXIgbGliJHJzdnAkbm9kZSQkZGVmYXVsdCA9IGxpYiRyc3ZwJG5vZGUkJGRlbm9kZWlmeTtcblxuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJG5vZGUkJGhhbmRsZVZhbHVlSW5wdXQocHJvbWlzZSwgYXJncywgbm9kZUZ1bmMsIHNlbGYpIHtcbiAgICAgIHZhciByZXN1bHQgPSBsaWIkcnN2cCRub2RlJCR0cnlBcHBseShub2RlRnVuYywgc2VsZiwgYXJncyk7XG4gICAgICBpZiAocmVzdWx0ID09PSBsaWIkcnN2cCRub2RlJCRFUlJPUikge1xuICAgICAgICBsaWIkcnN2cCQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCByZXN1bHQudmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJHJzdnAkbm9kZSQkaGFuZGxlUHJvbWlzZUlucHV0KHByb21pc2UsIGFyZ3MsIG5vZGVGdW5jLCBzZWxmKXtcbiAgICAgIHJldHVybiBsaWIkcnN2cCRwcm9taXNlJCRkZWZhdWx0LmFsbChhcmdzKS50aGVuKGZ1bmN0aW9uKGFyZ3Mpe1xuICAgICAgICB2YXIgcmVzdWx0ID0gbGliJHJzdnAkbm9kZSQkdHJ5QXBwbHkobm9kZUZ1bmMsIHNlbGYsIGFyZ3MpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBsaWIkcnN2cCRub2RlJCRFUlJPUikge1xuICAgICAgICAgIGxpYiRyc3ZwJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlc3VsdC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkcnN2cCRub2RlJCRuZWVkc1Byb21pc2VJbnB1dChhcmcpIHtcbiAgICAgIGlmIChhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKGFyZy5jb25zdHJ1Y3RvciA9PT0gbGliJHJzdnAkcHJvbWlzZSQkZGVmYXVsdCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBsaWIkcnN2cCRub2RlJCRnZXRUaGVuKGFyZyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbGliJHJzdnAkcmFjZSQkcmFjZShhcnJheSwgbGFiZWwpIHtcbiAgICAgIHJldHVybiBsaWIkcnN2cCRwcm9taXNlJCRkZWZhdWx0LnJhY2UoYXJyYXksIGxhYmVsKTtcbiAgICB9XG4gICAgdmFyIGxpYiRyc3ZwJHJhY2UkJGRlZmF1bHQgPSBsaWIkcnN2cCRyYWNlJCRyYWNlO1xuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJHJlamVjdCQkcmVqZWN0KHJlYXNvbiwgbGFiZWwpIHtcbiAgICAgIHJldHVybiBsaWIkcnN2cCRwcm9taXNlJCRkZWZhdWx0LnJlamVjdChyZWFzb24sIGxhYmVsKTtcbiAgICB9XG4gICAgdmFyIGxpYiRyc3ZwJHJlamVjdCQkZGVmYXVsdCA9IGxpYiRyc3ZwJHJlamVjdCQkcmVqZWN0O1xuICAgIGZ1bmN0aW9uIGxpYiRyc3ZwJHJlc29sdmUkJHJlc29sdmUodmFsdWUsIGxhYmVsKSB7XG4gICAgICByZXR1cm4gbGliJHJzdnAkcHJvbWlzZSQkZGVmYXVsdC5yZXNvbHZlKHZhbHVlLCBsYWJlbCk7XG4gICAgfVxuICAgIHZhciBsaWIkcnN2cCRyZXNvbHZlJCRkZWZhdWx0ID0gbGliJHJzdnAkcmVzb2x2ZSQkcmVzb2x2ZTtcbiAgICBmdW5jdGlvbiBsaWIkcnN2cCRyZXRocm93JCRyZXRocm93KHJlYXNvbikge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgdGhyb3cgcmVhc29uO1xuICAgICAgfSk7XG4gICAgICB0aHJvdyByZWFzb247XG4gICAgfVxuICAgIHZhciBsaWIkcnN2cCRyZXRocm93JCRkZWZhdWx0ID0gbGliJHJzdnAkcmV0aHJvdyQkcmV0aHJvdztcblxuICAgIC8vIGRlZmF1bHQgYXN5bmMgaXMgYXNhcDtcbiAgICBsaWIkcnN2cCRjb25maWckJGNvbmZpZy5hc3luYyA9IGxpYiRyc3ZwJGFzYXAkJGRlZmF1bHQ7XG4gICAgdmFyIGxpYiRyc3ZwJCRjYXN0ID0gbGliJHJzdnAkcmVzb2x2ZSQkZGVmYXVsdDtcbiAgICBmdW5jdGlvbiBsaWIkcnN2cCQkYXN5bmMoY2FsbGJhY2ssIGFyZykge1xuICAgICAgbGliJHJzdnAkY29uZmlnJCRjb25maWcuYXN5bmMoY2FsbGJhY2ssIGFyZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJHJzdnAkJG9uKCkge1xuICAgICAgbGliJHJzdnAkY29uZmlnJCRjb25maWdbJ29uJ10uYXBwbHkobGliJHJzdnAkY29uZmlnJCRjb25maWcsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJHJzdnAkJG9mZigpIHtcbiAgICAgIGxpYiRyc3ZwJGNvbmZpZyQkY29uZmlnWydvZmYnXS5hcHBseShsaWIkcnN2cCRjb25maWckJGNvbmZpZywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvLyBTZXQgdXAgaW5zdHJ1bWVudGF0aW9uIHRocm91Z2ggYHdpbmRvdy5fX1BST01JU0VfSU5UUlVNRU5UQVRJT05fX2BcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvd1snX19QUk9NSVNFX0lOU1RSVU1FTlRBVElPTl9fJ10gPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgbGliJHJzdnAkJGNhbGxiYWNrcyA9IHdpbmRvd1snX19QUk9NSVNFX0lOU1RSVU1FTlRBVElPTl9fJ107XG4gICAgICBsaWIkcnN2cCRjb25maWckJGNvbmZpZ3VyZSgnaW5zdHJ1bWVudCcsIHRydWUpO1xuICAgICAgZm9yICh2YXIgbGliJHJzdnAkJGV2ZW50TmFtZSBpbiBsaWIkcnN2cCQkY2FsbGJhY2tzKSB7XG4gICAgICAgIGlmIChsaWIkcnN2cCQkY2FsbGJhY2tzLmhhc093blByb3BlcnR5KGxpYiRyc3ZwJCRldmVudE5hbWUpKSB7XG4gICAgICAgICAgbGliJHJzdnAkJG9uKGxpYiRyc3ZwJCRldmVudE5hbWUsIGxpYiRyc3ZwJCRjYWxsYmFja3NbbGliJHJzdnAkJGV2ZW50TmFtZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxpYiRyc3ZwJHVtZCQkUlNWUCA9IHtcbiAgICAgICdyYWNlJzogbGliJHJzdnAkcmFjZSQkZGVmYXVsdCxcbiAgICAgICdQcm9taXNlJzogbGliJHJzdnAkcHJvbWlzZSQkZGVmYXVsdCxcbiAgICAgICdhbGxTZXR0bGVkJzogbGliJHJzdnAkYWxsJHNldHRsZWQkJGRlZmF1bHQsXG4gICAgICAnaGFzaCc6IGxpYiRyc3ZwJGhhc2gkJGRlZmF1bHQsXG4gICAgICAnaGFzaFNldHRsZWQnOiBsaWIkcnN2cCRoYXNoJHNldHRsZWQkJGRlZmF1bHQsXG4gICAgICAnZGVub2RlaWZ5JzogbGliJHJzdnAkbm9kZSQkZGVmYXVsdCxcbiAgICAgICdvbic6IGxpYiRyc3ZwJCRvbixcbiAgICAgICdvZmYnOiBsaWIkcnN2cCQkb2ZmLFxuICAgICAgJ21hcCc6IGxpYiRyc3ZwJG1hcCQkZGVmYXVsdCxcbiAgICAgICdmaWx0ZXInOiBsaWIkcnN2cCRmaWx0ZXIkJGRlZmF1bHQsXG4gICAgICAncmVzb2x2ZSc6IGxpYiRyc3ZwJHJlc29sdmUkJGRlZmF1bHQsXG4gICAgICAncmVqZWN0JzogbGliJHJzdnAkcmVqZWN0JCRkZWZhdWx0LFxuICAgICAgJ2FsbCc6IGxpYiRyc3ZwJGFsbCQkZGVmYXVsdCxcbiAgICAgICdyZXRocm93JzogbGliJHJzdnAkcmV0aHJvdyQkZGVmYXVsdCxcbiAgICAgICdkZWZlcic6IGxpYiRyc3ZwJGRlZmVyJCRkZWZhdWx0LFxuICAgICAgJ0V2ZW50VGFyZ2V0JzogbGliJHJzdnAkZXZlbnRzJCRkZWZhdWx0LFxuICAgICAgJ2NvbmZpZ3VyZSc6IGxpYiRyc3ZwJGNvbmZpZyQkY29uZmlndXJlLFxuICAgICAgJ2FzeW5jJzogbGliJHJzdnAkJGFzeW5jXG4gICAgfTtcblxuICAgIC8qIGdsb2JhbCBkZWZpbmU6dHJ1ZSBtb2R1bGU6dHJ1ZSB3aW5kb3c6IHRydWUgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmVbJ2FtZCddKSB7XG4gICAgICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBsaWIkcnN2cCR1bWQkJFJTVlA7IH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlWydleHBvcnRzJ10pIHtcbiAgICAgIG1vZHVsZVsnZXhwb3J0cyddID0gbGliJHJzdnAkdW1kJCRSU1ZQO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzWydSU1ZQJ10gPSBsaWIkcnN2cCR1bWQkJFJTVlA7XG4gICAgfVxufSkuY2FsbCh0aGlzKTtcblxuIiwiLy8gICAgIFVuZGVyc2NvcmUuanMgMS44LjNcbi8vICAgICBodHRwOi8vdW5kZXJzY29yZWpzLm9yZ1xuLy8gICAgIChjKSAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbi8vICAgICBVbmRlcnNjb3JlIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLy8gQmFzZWxpbmUgc2V0dXBcbiAgLy8gLS0tLS0tLS0tLS0tLS1cblxuICAvLyBFc3RhYmxpc2ggdGhlIHJvb3Qgb2JqZWN0LCBgd2luZG93YCBpbiB0aGUgYnJvd3Nlciwgb3IgYGV4cG9ydHNgIG9uIHRoZSBzZXJ2ZXIuXG4gIHZhciByb290ID0gdGhpcztcblxuICAvLyBTYXZlIHRoZSBwcmV2aW91cyB2YWx1ZSBvZiB0aGUgYF9gIHZhcmlhYmxlLlxuICB2YXIgcHJldmlvdXNVbmRlcnNjb3JlID0gcm9vdC5fO1xuXG4gIC8vIFNhdmUgYnl0ZXMgaW4gdGhlIG1pbmlmaWVkIChidXQgbm90IGd6aXBwZWQpIHZlcnNpb246XG4gIHZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLCBPYmpQcm90byA9IE9iamVjdC5wcm90b3R5cGUsIEZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuICAvLyBDcmVhdGUgcXVpY2sgcmVmZXJlbmNlIHZhcmlhYmxlcyBmb3Igc3BlZWQgYWNjZXNzIHRvIGNvcmUgcHJvdG90eXBlcy5cbiAgdmFyXG4gICAgcHVzaCAgICAgICAgICAgICA9IEFycmF5UHJvdG8ucHVzaCxcbiAgICBzbGljZSAgICAgICAgICAgID0gQXJyYXlQcm90by5zbGljZSxcbiAgICB0b1N0cmluZyAgICAgICAgID0gT2JqUHJvdG8udG9TdHJpbmcsXG4gICAgaGFzT3duUHJvcGVydHkgICA9IE9ialByb3RvLmhhc093blByb3BlcnR5O1xuXG4gIC8vIEFsbCAqKkVDTUFTY3JpcHQgNSoqIG5hdGl2ZSBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbnMgdGhhdCB3ZSBob3BlIHRvIHVzZVxuICAvLyBhcmUgZGVjbGFyZWQgaGVyZS5cbiAgdmFyXG4gICAgbmF0aXZlSXNBcnJheSAgICAgID0gQXJyYXkuaXNBcnJheSxcbiAgICBuYXRpdmVLZXlzICAgICAgICAgPSBPYmplY3Qua2V5cyxcbiAgICBuYXRpdmVCaW5kICAgICAgICAgPSBGdW5jUHJvdG8uYmluZCxcbiAgICBuYXRpdmVDcmVhdGUgICAgICAgPSBPYmplY3QuY3JlYXRlO1xuXG4gIC8vIE5ha2VkIGZ1bmN0aW9uIHJlZmVyZW5jZSBmb3Igc3Vycm9nYXRlLXByb3RvdHlwZS1zd2FwcGluZy5cbiAgdmFyIEN0b3IgPSBmdW5jdGlvbigpe307XG5cbiAgLy8gQ3JlYXRlIGEgc2FmZSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciB1c2UgYmVsb3cuXG4gIHZhciBfID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIF8pIHJldHVybiBvYmo7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIF8pKSByZXR1cm4gbmV3IF8ob2JqKTtcbiAgICB0aGlzLl93cmFwcGVkID0gb2JqO1xuICB9O1xuXG4gIC8vIEV4cG9ydCB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yICoqTm9kZS5qcyoqLCB3aXRoXG4gIC8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZvciB0aGUgb2xkIGByZXF1aXJlKClgIEFQSS4gSWYgd2UncmUgaW5cbiAgLy8gdGhlIGJyb3dzZXIsIGFkZCBgX2AgYXMgYSBnbG9iYWwgb2JqZWN0LlxuICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfO1xuICAgIH1cbiAgICBleHBvcnRzLl8gPSBfO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuXyA9IF87XG4gIH1cblxuICAvLyBDdXJyZW50IHZlcnNpb24uXG4gIF8uVkVSU0lPTiA9ICcxLjguMyc7XG5cbiAgLy8gSW50ZXJuYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGVmZmljaWVudCAoZm9yIGN1cnJlbnQgZW5naW5lcykgdmVyc2lvblxuICAvLyBvZiB0aGUgcGFzc2VkLWluIGNhbGxiYWNrLCB0byBiZSByZXBlYXRlZGx5IGFwcGxpZWQgaW4gb3RoZXIgVW5kZXJzY29yZVxuICAvLyBmdW5jdGlvbnMuXG4gIHZhciBvcHRpbWl6ZUNiID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCwgYXJnQ291bnQpIHtcbiAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSByZXR1cm4gZnVuYztcbiAgICBzd2l0Y2ggKGFyZ0NvdW50ID09IG51bGwgPyAzIDogYXJnQ291bnQpIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUpO1xuICAgICAgfTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBvdGhlcik7XG4gICAgICB9O1xuICAgICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQSBtb3N0bHktaW50ZXJuYWwgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgY2FsbGJhY2tzIHRoYXQgY2FuIGJlIGFwcGxpZWRcbiAgLy8gdG8gZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiwgcmV0dXJuaW5nIHRoZSBkZXNpcmVkIHJlc3VsdCDigJQgZWl0aGVyXG4gIC8vIGlkZW50aXR5LCBhbiBhcmJpdHJhcnkgY2FsbGJhY2ssIGEgcHJvcGVydHkgbWF0Y2hlciwgb3IgYSBwcm9wZXJ0eSBhY2Nlc3Nvci5cbiAgdmFyIGNiID0gZnVuY3Rpb24odmFsdWUsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBfLmlkZW50aXR5O1xuICAgIGlmIChfLmlzRnVuY3Rpb24odmFsdWUpKSByZXR1cm4gb3B0aW1pemVDYih2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpO1xuICAgIGlmIChfLmlzT2JqZWN0KHZhbHVlKSkgcmV0dXJuIF8ubWF0Y2hlcih2YWx1ZSk7XG4gICAgcmV0dXJuIF8ucHJvcGVydHkodmFsdWUpO1xuICB9O1xuICBfLml0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gY2IodmFsdWUsIGNvbnRleHQsIEluZmluaXR5KTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYXNzaWduZXIgZnVuY3Rpb25zLlxuICB2YXIgY3JlYXRlQXNzaWduZXIgPSBmdW5jdGlvbihrZXlzRnVuYywgdW5kZWZpbmVkT25seSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCA8IDIgfHwgb2JqID09IG51bGwpIHJldHVybiBvYmo7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdLFxuICAgICAgICAgICAga2V5cyA9IGtleXNGdW5jKHNvdXJjZSksXG4gICAgICAgICAgICBsID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKCF1bmRlZmluZWRPbmx5IHx8IG9ialtrZXldID09PSB2b2lkIDApIG9ialtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSBhbm90aGVyLlxuICB2YXIgYmFzZUNyZWF0ZSA9IGZ1bmN0aW9uKHByb3RvdHlwZSkge1xuICAgIGlmICghXy5pc09iamVjdChwcm90b3R5cGUpKSByZXR1cm4ge307XG4gICAgaWYgKG5hdGl2ZUNyZWF0ZSkgcmV0dXJuIG5hdGl2ZUNyZWF0ZShwcm90b3R5cGUpO1xuICAgIEN0b3IucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgIHZhciByZXN1bHQgPSBuZXcgQ3RvcjtcbiAgICBDdG9yLnByb3RvdHlwZSA9IG51bGw7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgcHJvcGVydHkgPSBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09IG51bGwgPyB2b2lkIDAgOiBvYmpba2V5XTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEhlbHBlciBmb3IgY29sbGVjdGlvbiBtZXRob2RzIHRvIGRldGVybWluZSB3aGV0aGVyIGEgY29sbGVjdGlvblxuICAvLyBzaG91bGQgYmUgaXRlcmF0ZWQgYXMgYW4gYXJyYXkgb3IgYXMgYW4gb2JqZWN0XG4gIC8vIFJlbGF0ZWQ6IGh0dHA6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvbGVuZ3RoXG4gIC8vIEF2b2lkcyBhIHZlcnkgbmFzdHkgaU9TIDggSklUIGJ1ZyBvbiBBUk0tNjQuICMyMDk0XG4gIHZhciBNQVhfQVJSQVlfSU5ERVggPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuICB2YXIgZ2V0TGVuZ3RoID0gcHJvcGVydHkoJ2xlbmd0aCcpO1xuICB2YXIgaXNBcnJheUxpa2UgPSBmdW5jdGlvbihjb2xsZWN0aW9uKSB7XG4gICAgdmFyIGxlbmd0aCA9IGdldExlbmd0aChjb2xsZWN0aW9uKTtcbiAgICByZXR1cm4gdHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyAmJiBsZW5ndGggPj0gMCAmJiBsZW5ndGggPD0gTUFYX0FSUkFZX0lOREVYO1xuICB9O1xuXG4gIC8vIENvbGxlY3Rpb24gRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gVGhlIGNvcm5lcnN0b25lLCBhbiBgZWFjaGAgaW1wbGVtZW50YXRpb24sIGFrYSBgZm9yRWFjaGAuXG4gIC8vIEhhbmRsZXMgcmF3IG9iamVjdHMgaW4gYWRkaXRpb24gdG8gYXJyYXktbGlrZXMuIFRyZWF0cyBhbGxcbiAgLy8gc3BhcnNlIGFycmF5LWxpa2VzIGFzIGlmIHRoZXkgd2VyZSBkZW5zZS5cbiAgXy5lYWNoID0gXy5mb3JFYWNoID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGksIGxlbmd0aDtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtpXSwgaSwgb2JqKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlcmF0ZWUob2JqW2tleXNbaV1dLCBrZXlzW2ldLCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0ZWUgdG8gZWFjaCBlbGVtZW50LlxuICBfLm1hcCA9IF8uY29sbGVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0cyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIHJlc3VsdHNbaW5kZXhdID0gaXRlcmF0ZWUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDcmVhdGUgYSByZWR1Y2luZyBmdW5jdGlvbiBpdGVyYXRpbmcgbGVmdCBvciByaWdodC5cbiAgZnVuY3Rpb24gY3JlYXRlUmVkdWNlKGRpcikge1xuICAgIC8vIE9wdGltaXplZCBpdGVyYXRvciBmdW5jdGlvbiBhcyB1c2luZyBhcmd1bWVudHMubGVuZ3RoXG4gICAgLy8gaW4gdGhlIG1haW4gZnVuY3Rpb24gd2lsbCBkZW9wdGltaXplIHRoZSwgc2VlICMxOTkxLlxuICAgIGZ1bmN0aW9uIGl0ZXJhdG9yKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGtleXMsIGluZGV4LCBsZW5ndGgpIHtcbiAgICAgIGZvciAoOyBpbmRleCA+PSAwICYmIGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSBkaXIpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgICAgbWVtbyA9IGl0ZXJhdGVlKG1lbW8sIG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBtZW1vLCBjb250ZXh0KSB7XG4gICAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQsIDQpO1xuICAgICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aCxcbiAgICAgICAgICBpbmRleCA9IGRpciA+IDAgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgIC8vIERldGVybWluZSB0aGUgaW5pdGlhbCB2YWx1ZSBpZiBub25lIGlzIHByb3ZpZGVkLlxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgICAgIG1lbW8gPSBvYmpba2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXhdO1xuICAgICAgICBpbmRleCArPSBkaXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0b3Iob2JqLCBpdGVyYXRlZSwgbWVtbywga2V5cywgaW5kZXgsIGxlbmd0aCk7XG4gICAgfTtcbiAgfVxuXG4gIC8vICoqUmVkdWNlKiogYnVpbGRzIHVwIGEgc2luZ2xlIHJlc3VsdCBmcm9tIGEgbGlzdCBvZiB2YWx1ZXMsIGFrYSBgaW5qZWN0YCxcbiAgLy8gb3IgYGZvbGRsYC5cbiAgXy5yZWR1Y2UgPSBfLmZvbGRsID0gXy5pbmplY3QgPSBjcmVhdGVSZWR1Y2UoMSk7XG5cbiAgLy8gVGhlIHJpZ2h0LWFzc29jaWF0aXZlIHZlcnNpb24gb2YgcmVkdWNlLCBhbHNvIGtub3duIGFzIGBmb2xkcmAuXG4gIF8ucmVkdWNlUmlnaHQgPSBfLmZvbGRyID0gY3JlYXRlUmVkdWNlKC0xKTtcblxuICAvLyBSZXR1cm4gdGhlIGZpcnN0IHZhbHVlIHdoaWNoIHBhc3NlcyBhIHRydXRoIHRlc3QuIEFsaWFzZWQgYXMgYGRldGVjdGAuXG4gIF8uZmluZCA9IF8uZGV0ZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIga2V5O1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopKSB7XG4gICAgICBrZXkgPSBfLmZpbmRJbmRleChvYmosIHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IF8uZmluZEtleShvYmosIHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgfVxuICAgIGlmIChrZXkgIT09IHZvaWQgMCAmJiBrZXkgIT09IC0xKSByZXR1cm4gb2JqW2tleV07XG4gIH07XG5cbiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBwYXNzIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgc2VsZWN0YC5cbiAgXy5maWx0ZXIgPSBfLnNlbGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGxpc3QpKSByZXN1bHRzLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGZvciB3aGljaCBhIHRydXRoIHRlc3QgZmFpbHMuXG4gIF8ucmVqZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm5lZ2F0ZShjYihwcmVkaWNhdGUpKSwgY29udGV4dCk7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgYWxsIG9mIHRoZSBlbGVtZW50cyBtYXRjaCBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYGFsbGAuXG4gIF8uZXZlcnkgPSBfLmFsbCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgaWYgKCFwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiBhdCBsZWFzdCBvbmUgZWxlbWVudCBpbiB0aGUgb2JqZWN0IG1hdGNoZXMgYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbnlgLlxuICBfLnNvbWUgPSBfLmFueSA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgaWYgKHByZWRpY2F0ZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaikpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBhcnJheSBvciBvYmplY3QgY29udGFpbnMgYSBnaXZlbiBpdGVtICh1c2luZyBgPT09YCkuXG4gIC8vIEFsaWFzZWQgYXMgYGluY2x1ZGVzYCBhbmQgYGluY2x1ZGVgLlxuICBfLmNvbnRhaW5zID0gXy5pbmNsdWRlcyA9IF8uaW5jbHVkZSA9IGZ1bmN0aW9uKG9iaiwgaXRlbSwgZnJvbUluZGV4LCBndWFyZCkge1xuICAgIGlmICghaXNBcnJheUxpa2Uob2JqKSkgb2JqID0gXy52YWx1ZXMob2JqKTtcbiAgICBpZiAodHlwZW9mIGZyb21JbmRleCAhPSAnbnVtYmVyJyB8fCBndWFyZCkgZnJvbUluZGV4ID0gMDtcbiAgICByZXR1cm4gXy5pbmRleE9mKG9iaiwgaXRlbSwgZnJvbUluZGV4KSA+PSAwO1xuICB9O1xuXG4gIC8vIEludm9rZSBhIG1ldGhvZCAod2l0aCBhcmd1bWVudHMpIG9uIGV2ZXJ5IGl0ZW0gaW4gYSBjb2xsZWN0aW9uLlxuICBfLmludm9rZSA9IGZ1bmN0aW9uKG9iaiwgbWV0aG9kKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGlzRnVuYyA9IF8uaXNGdW5jdGlvbihtZXRob2QpO1xuICAgIHJldHVybiBfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzRnVuYyA/IG1ldGhvZCA6IHZhbHVlW21ldGhvZF07XG4gICAgICByZXR1cm4gZnVuYyA9PSBudWxsID8gZnVuYyA6IGZ1bmMuYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYG1hcGA6IGZldGNoaW5nIGEgcHJvcGVydHkuXG4gIF8ucGx1Y2sgPSBmdW5jdGlvbihvYmosIGtleSkge1xuICAgIHJldHVybiBfLm1hcChvYmosIF8ucHJvcGVydHkoa2V5KSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgZmlsdGVyYDogc2VsZWN0aW5nIG9ubHkgb2JqZWN0c1xuICAvLyBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLndoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbHRlcihvYmosIF8ubWF0Y2hlcihhdHRycykpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbmRgOiBnZXR0aW5nIHRoZSBmaXJzdCBvYmplY3RcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5maW5kV2hlcmUgPSBmdW5jdGlvbihvYmosIGF0dHJzKSB7XG4gICAgcmV0dXJuIF8uZmluZChvYmosIF8ubWF0Y2hlcihhdHRycykpO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbWF4aW11bSBlbGVtZW50IChvciBlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbiAgXy5tYXggPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IC1JbmZpbml0eSwgbGFzdENvbXB1dGVkID0gLUluZmluaXR5LFxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgJiYgb2JqICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgaWYgKHZhbHVlID4gcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPiBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IC1JbmZpbml0eSAmJiByZXN1bHQgPT09IC1JbmZpbml0eSkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1pbmltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWluID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSBJbmZpbml0eSwgbGFzdENvbXB1dGVkID0gSW5maW5pdHksXG4gICAgICAgIHZhbHVlLCBjb21wdXRlZDtcbiAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCAmJiBvYmogIT0gbnVsbCkge1xuICAgICAgb2JqID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gb2JqW2ldO1xuICAgICAgICBpZiAodmFsdWUgPCByZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgbGlzdCk7XG4gICAgICAgIGlmIChjb21wdXRlZCA8IGxhc3RDb21wdXRlZCB8fCBjb21wdXRlZCA9PT0gSW5maW5pdHkgJiYgcmVzdWx0ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBTaHVmZmxlIGEgY29sbGVjdGlvbiwgdXNpbmcgdGhlIG1vZGVybiB2ZXJzaW9uIG9mIHRoZVxuICAvLyBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVy4oCTWWF0ZXNfc2h1ZmZsZSkuXG4gIF8uc2h1ZmZsZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBzZXQgPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0gc2V0Lmxlbmd0aDtcbiAgICB2YXIgc2h1ZmZsZWQgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMCwgcmFuZDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHJhbmQgPSBfLnJhbmRvbSgwLCBpbmRleCk7XG4gICAgICBpZiAocmFuZCAhPT0gaW5kZXgpIHNodWZmbGVkW2luZGV4XSA9IHNodWZmbGVkW3JhbmRdO1xuICAgICAgc2h1ZmZsZWRbcmFuZF0gPSBzZXRbaW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gc2h1ZmZsZWQ7XG4gIH07XG5cbiAgLy8gU2FtcGxlICoqbioqIHJhbmRvbSB2YWx1ZXMgZnJvbSBhIGNvbGxlY3Rpb24uXG4gIC8vIElmICoqbioqIGlzIG5vdCBzcGVjaWZpZWQsIHJldHVybnMgYSBzaW5nbGUgcmFuZG9tIGVsZW1lbnQuXG4gIC8vIFRoZSBpbnRlcm5hbCBgZ3VhcmRgIGFyZ3VtZW50IGFsbG93cyBpdCB0byB3b3JrIHdpdGggYG1hcGAuXG4gIF8uc2FtcGxlID0gZnVuY3Rpb24ob2JqLCBuLCBndWFyZCkge1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHtcbiAgICAgIGlmICghaXNBcnJheUxpa2Uob2JqKSkgb2JqID0gXy52YWx1ZXMob2JqKTtcbiAgICAgIHJldHVybiBvYmpbXy5yYW5kb20ob2JqLmxlbmd0aCAtIDEpXTtcbiAgICB9XG4gICAgcmV0dXJuIF8uc2h1ZmZsZShvYmopLnNsaWNlKDAsIE1hdGgubWF4KDAsIG4pKTtcbiAgfTtcblxuICAvLyBTb3J0IHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24gcHJvZHVjZWQgYnkgYW4gaXRlcmF0ZWUuXG4gIF8uc29ydEJ5ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHJldHVybiBfLnBsdWNrKF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgY3JpdGVyaWE6IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgbGlzdClcbiAgICAgIH07XG4gICAgfSkuc29ydChmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgdmFyIGEgPSBsZWZ0LmNyaXRlcmlhO1xuICAgICAgdmFyIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICAgIGlmIChhICE9PSBiKSB7XG4gICAgICAgIGlmIChhID4gYiB8fCBhID09PSB2b2lkIDApIHJldHVybiAxO1xuICAgICAgICBpZiAoYSA8IGIgfHwgYiA9PT0gdm9pZCAwKSByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVmdC5pbmRleCAtIHJpZ2h0LmluZGV4O1xuICAgIH0pLCAndmFsdWUnKTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiB1c2VkIGZvciBhZ2dyZWdhdGUgXCJncm91cCBieVwiIG9wZXJhdGlvbnMuXG4gIHZhciBncm91cCA9IGZ1bmN0aW9uKGJlaGF2aW9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHZhciBrZXkgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIG9iaik7XG4gICAgICAgIGJlaGF2aW9yKHJlc3VsdCwgdmFsdWUsIGtleSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBHcm91cHMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbi4gUGFzcyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlXG4gIC8vIHRvIGdyb3VwIGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY3JpdGVyaW9uLlxuICBfLmdyb3VwQnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICBpZiAoXy5oYXMocmVzdWx0LCBrZXkpKSByZXN1bHRba2V5XS5wdXNoKHZhbHVlKTsgZWxzZSByZXN1bHRba2V5XSA9IFt2YWx1ZV07XG4gIH0pO1xuXG4gIC8vIEluZGV4ZXMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbiwgc2ltaWxhciB0byBgZ3JvdXBCeWAsIGJ1dCBmb3JcbiAgLy8gd2hlbiB5b3Uga25vdyB0aGF0IHlvdXIgaW5kZXggdmFsdWVzIHdpbGwgYmUgdW5pcXVlLlxuICBfLmluZGV4QnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICB9KTtcblxuICAvLyBDb3VudHMgaW5zdGFuY2VzIG9mIGFuIG9iamVjdCB0aGF0IGdyb3VwIGJ5IGEgY2VydGFpbiBjcml0ZXJpb24uIFBhc3NcbiAgLy8gZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZSB0byBjb3VudCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gIC8vIGNyaXRlcmlvbi5cbiAgXy5jb3VudEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKF8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0rKzsgZWxzZSByZXN1bHRba2V5XSA9IDE7XG4gIH0pO1xuXG4gIC8vIFNhZmVseSBjcmVhdGUgYSByZWFsLCBsaXZlIGFycmF5IGZyb20gYW55dGhpbmcgaXRlcmFibGUuXG4gIF8udG9BcnJheSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghb2JqKSByZXR1cm4gW107XG4gICAgaWYgKF8uaXNBcnJheShvYmopKSByZXR1cm4gc2xpY2UuY2FsbChvYmopO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopKSByZXR1cm4gXy5tYXAob2JqLCBfLmlkZW50aXR5KTtcbiAgICByZXR1cm4gXy52YWx1ZXMob2JqKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiBhbiBvYmplY3QuXG4gIF8uc2l6ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIDA7XG4gICAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iaikgPyBvYmoubGVuZ3RoIDogXy5rZXlzKG9iaikubGVuZ3RoO1xuICB9O1xuXG4gIC8vIFNwbGl0IGEgY29sbGVjdGlvbiBpbnRvIHR3byBhcnJheXM6IG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgc2F0aXNmeSB0aGUgZ2l2ZW5cbiAgLy8gcHJlZGljYXRlLCBhbmQgb25lIHdob3NlIGVsZW1lbnRzIGFsbCBkbyBub3Qgc2F0aXNmeSB0aGUgcHJlZGljYXRlLlxuICBfLnBhcnRpdGlvbiA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIgcGFzcyA9IFtdLCBmYWlsID0gW107XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqKSB7XG4gICAgICAocHJlZGljYXRlKHZhbHVlLCBrZXksIG9iaikgPyBwYXNzIDogZmFpbCkucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtwYXNzLCBmYWlsXTtcbiAgfTtcblxuICAvLyBBcnJheSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gR2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYGhlYWRgIGFuZCBgdGFrZWAuIFRoZSAqKmd1YXJkKiogY2hlY2tcbiAgLy8gYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLlxuICBfLmZpcnN0ID0gXy5oZWFkID0gXy50YWtlID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkgcmV0dXJuIGFycmF5WzBdO1xuICAgIHJldHVybiBfLmluaXRpYWwoYXJyYXksIGFycmF5Lmxlbmd0aCAtIG4pO1xuICB9O1xuXG4gIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGxhc3QgZW50cnkgb2YgdGhlIGFycmF5LiBFc3BlY2lhbGx5IHVzZWZ1bCBvblxuICAvLyB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiBhbGwgdGhlIHZhbHVlcyBpblxuICAvLyB0aGUgYXJyYXksIGV4Y2x1ZGluZyB0aGUgbGFzdCBOLlxuICBfLmluaXRpYWwgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgMCwgTWF0aC5tYXgoMCwgYXJyYXkubGVuZ3RoIC0gKG4gPT0gbnVsbCB8fCBndWFyZCA/IDEgOiBuKSkpO1xuICB9O1xuXG4gIC8vIEdldCB0aGUgbGFzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBsYXN0IE5cbiAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS5cbiAgXy5sYXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBfLnJlc3QoYXJyYXksIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIG4pKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBmaXJzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYHRhaWxgIGFuZCBgZHJvcGAuXG4gIC8vIEVzcGVjaWFsbHkgdXNlZnVsIG9uIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nIGFuICoqbioqIHdpbGwgcmV0dXJuXG4gIC8vIHRoZSByZXN0IE4gdmFsdWVzIGluIHRoZSBhcnJheS5cbiAgXy5yZXN0ID0gXy50YWlsID0gXy5kcm9wID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIG4gPT0gbnVsbCB8fCBndWFyZCA/IDEgOiBuKTtcbiAgfTtcblxuICAvLyBUcmltIG91dCBhbGwgZmFsc3kgdmFsdWVzIGZyb20gYW4gYXJyYXkuXG4gIF8uY29tcGFjdCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBfLmlkZW50aXR5KTtcbiAgfTtcblxuICAvLyBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiBhIHJlY3Vyc2l2ZSBgZmxhdHRlbmAgZnVuY3Rpb24uXG4gIHZhciBmbGF0dGVuID0gZnVuY3Rpb24oaW5wdXQsIHNoYWxsb3csIHN0cmljdCwgc3RhcnRJbmRleCkge1xuICAgIHZhciBvdXRwdXQgPSBbXSwgaWR4ID0gMDtcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleCB8fCAwLCBsZW5ndGggPSBnZXRMZW5ndGgoaW5wdXQpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IGlucHV0W2ldO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJiAoXy5pc0FycmF5KHZhbHVlKSB8fCBfLmlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICAgICAgLy9mbGF0dGVuIGN1cnJlbnQgbGV2ZWwgb2YgYXJyYXkgb3IgYXJndW1lbnRzIG9iamVjdFxuICAgICAgICBpZiAoIXNoYWxsb3cpIHZhbHVlID0gZmxhdHRlbih2YWx1ZSwgc2hhbGxvdywgc3RyaWN0KTtcbiAgICAgICAgdmFyIGogPSAwLCBsZW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIG91dHB1dC5sZW5ndGggKz0gbGVuO1xuICAgICAgICB3aGlsZSAoaiA8IGxlbikge1xuICAgICAgICAgIG91dHB1dFtpZHgrK10gPSB2YWx1ZVtqKytdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFzdHJpY3QpIHtcbiAgICAgICAgb3V0cHV0W2lkeCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xuXG4gIC8vIEZsYXR0ZW4gb3V0IGFuIGFycmF5LCBlaXRoZXIgcmVjdXJzaXZlbHkgKGJ5IGRlZmF1bHQpLCBvciBqdXN0IG9uZSBsZXZlbC5cbiAgXy5mbGF0dGVuID0gZnVuY3Rpb24oYXJyYXksIHNoYWxsb3cpIHtcbiAgICByZXR1cm4gZmxhdHRlbihhcnJheSwgc2hhbGxvdywgZmFsc2UpO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHZlcnNpb24gb2YgdGhlIGFycmF5IHRoYXQgZG9lcyBub3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIHZhbHVlKHMpLlxuICBfLndpdGhvdXQgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmRpZmZlcmVuY2UoYXJyYXksIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgdGhlIGFycmF5LiBJZiB0aGUgYXJyYXkgaGFzIGFscmVhZHlcbiAgLy8gYmVlbiBzb3J0ZWQsIHlvdSBoYXZlIHRoZSBvcHRpb24gb2YgdXNpbmcgYSBmYXN0ZXIgYWxnb3JpdGhtLlxuICAvLyBBbGlhc2VkIGFzIGB1bmlxdWVgLlxuICBfLnVuaXEgPSBfLnVuaXF1ZSA9IGZ1bmN0aW9uKGFycmF5LCBpc1NvcnRlZCwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpZiAoIV8uaXNCb29sZWFuKGlzU29ydGVkKSkge1xuICAgICAgY29udGV4dCA9IGl0ZXJhdGVlO1xuICAgICAgaXRlcmF0ZWUgPSBpc1NvcnRlZDtcbiAgICAgIGlzU29ydGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpdGVyYXRlZSAhPSBudWxsKSBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIHNlZW4gPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpXSxcbiAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUsIGksIGFycmF5KSA6IHZhbHVlO1xuICAgICAgaWYgKGlzU29ydGVkKSB7XG4gICAgICAgIGlmICghaSB8fCBzZWVuICE9PSBjb21wdXRlZCkgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICBzZWVuID0gY29tcHV0ZWQ7XG4gICAgICB9IGVsc2UgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIGlmICghXy5jb250YWlucyhzZWVuLCBjb21wdXRlZCkpIHtcbiAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghXy5jb250YWlucyhyZXN1bHQsIHZhbHVlKSkge1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSB1bmlvbjogZWFjaCBkaXN0aW5jdCBlbGVtZW50IGZyb20gYWxsIG9mXG4gIC8vIHRoZSBwYXNzZWQtaW4gYXJyYXlzLlxuICBfLnVuaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8udW5pcShmbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSkpO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyBldmVyeSBpdGVtIHNoYXJlZCBiZXR3ZWVuIGFsbCB0aGVcbiAgLy8gcGFzc2VkLWluIGFycmF5cy5cbiAgXy5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBhcnJheVtpXTtcbiAgICAgIGlmIChfLmNvbnRhaW5zKHJlc3VsdCwgaXRlbSkpIGNvbnRpbnVlO1xuICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBhcmdzTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKCFfLmNvbnRhaW5zKGFyZ3VtZW50c1tqXSwgaXRlbSkpIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGogPT09IGFyZ3NMZW5ndGgpIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFRha2UgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBvbmUgYXJyYXkgYW5kIGEgbnVtYmVyIG9mIG90aGVyIGFycmF5cy5cbiAgLy8gT25seSB0aGUgZWxlbWVudHMgcHJlc2VudCBpbiBqdXN0IHRoZSBmaXJzdCBhcnJheSB3aWxsIHJlbWFpbi5cbiAgXy5kaWZmZXJlbmNlID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdCA9IGZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlLCB0cnVlLCAxKTtcbiAgICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgIHJldHVybiAhXy5jb250YWlucyhyZXN0LCB2YWx1ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gWmlwIHRvZ2V0aGVyIG11bHRpcGxlIGxpc3RzIGludG8gYSBzaW5nbGUgYXJyYXkgLS0gZWxlbWVudHMgdGhhdCBzaGFyZVxuICAvLyBhbiBpbmRleCBnbyB0b2dldGhlci5cbiAgXy56aXAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXy51bnppcChhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIENvbXBsZW1lbnQgb2YgXy56aXAuIFVuemlwIGFjY2VwdHMgYW4gYXJyYXkgb2YgYXJyYXlzIGFuZCBncm91cHNcbiAgLy8gZWFjaCBhcnJheSdzIGVsZW1lbnRzIG9uIHNoYXJlZCBpbmRpY2VzXG4gIF8udW56aXAgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSAmJiBfLm1heChhcnJheSwgZ2V0TGVuZ3RoKS5sZW5ndGggfHwgMDtcbiAgICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBfLnBsdWNrKGFycmF5LCBpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gQ29udmVydHMgbGlzdHMgaW50byBvYmplY3RzLiBQYXNzIGVpdGhlciBhIHNpbmdsZSBhcnJheSBvZiBgW2tleSwgdmFsdWVdYFxuICAvLyBwYWlycywgb3IgdHdvIHBhcmFsbGVsIGFycmF5cyBvZiB0aGUgc2FtZSBsZW5ndGggLS0gb25lIG9mIGtleXMsIGFuZCBvbmUgb2ZcbiAgLy8gdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICBfLm9iamVjdCA9IGZ1bmN0aW9uKGxpc3QsIHZhbHVlcykge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGxpc3QpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgcmVzdWx0W2xpc3RbaV1dID0gdmFsdWVzW2ldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2xpc3RbaV1bMF1dID0gbGlzdFtpXVsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBHZW5lcmF0b3IgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBmaW5kSW5kZXggYW5kIGZpbmRMYXN0SW5kZXggZnVuY3Rpb25zXG4gIGZ1bmN0aW9uIGNyZWF0ZVByZWRpY2F0ZUluZGV4RmluZGVyKGRpcikge1xuICAgIHJldHVybiBmdW5jdGlvbihhcnJheSwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgICAgdmFyIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7XG4gICAgICB2YXIgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGluZGV4IG9uIGFuIGFycmF5LWxpa2UgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdFxuICBfLmZpbmRJbmRleCA9IGNyZWF0ZVByZWRpY2F0ZUluZGV4RmluZGVyKDEpO1xuICBfLmZpbmRMYXN0SW5kZXggPSBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcigtMSk7XG5cbiAgLy8gVXNlIGEgY29tcGFyYXRvciBmdW5jdGlvbiB0byBmaWd1cmUgb3V0IHRoZSBzbWFsbGVzdCBpbmRleCBhdCB3aGljaFxuICAvLyBhbiBvYmplY3Qgc2hvdWxkIGJlIGluc2VydGVkIHNvIGFzIHRvIG1haW50YWluIG9yZGVyLiBVc2VzIGJpbmFyeSBzZWFyY2guXG4gIF8uc29ydGVkSW5kZXggPSBmdW5jdGlvbihhcnJheSwgb2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQsIDEpO1xuICAgIHZhciB2YWx1ZSA9IGl0ZXJhdGVlKG9iaik7XG4gICAgdmFyIGxvdyA9IDAsIGhpZ2ggPSBnZXRMZW5ndGgoYXJyYXkpO1xuICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICB2YXIgbWlkID0gTWF0aC5mbG9vcigobG93ICsgaGlnaCkgLyAyKTtcbiAgICAgIGlmIChpdGVyYXRlZShhcnJheVttaWRdKSA8IHZhbHVlKSBsb3cgPSBtaWQgKyAxOyBlbHNlIGhpZ2ggPSBtaWQ7XG4gICAgfVxuICAgIHJldHVybiBsb3c7XG4gIH07XG5cbiAgLy8gR2VuZXJhdG9yIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgaW5kZXhPZiBhbmQgbGFzdEluZGV4T2YgZnVuY3Rpb25zXG4gIGZ1bmN0aW9uIGNyZWF0ZUluZGV4RmluZGVyKGRpciwgcHJlZGljYXRlRmluZCwgc29ydGVkSW5kZXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGlkeCkge1xuICAgICAgdmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpO1xuICAgICAgaWYgKHR5cGVvZiBpZHggPT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGRpciA+IDApIHtcbiAgICAgICAgICAgIGkgPSBpZHggPj0gMCA/IGlkeCA6IE1hdGgubWF4KGlkeCArIGxlbmd0aCwgaSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZW5ndGggPSBpZHggPj0gMCA/IE1hdGgubWluKGlkeCArIDEsIGxlbmd0aCkgOiBpZHggKyBsZW5ndGggKyAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNvcnRlZEluZGV4ICYmIGlkeCAmJiBsZW5ndGgpIHtcbiAgICAgICAgaWR4ID0gc29ydGVkSW5kZXgoYXJyYXksIGl0ZW0pO1xuICAgICAgICByZXR1cm4gYXJyYXlbaWR4XSA9PT0gaXRlbSA/IGlkeCA6IC0xO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW0gIT09IGl0ZW0pIHtcbiAgICAgICAgaWR4ID0gcHJlZGljYXRlRmluZChzbGljZS5jYWxsKGFycmF5LCBpLCBsZW5ndGgpLCBfLmlzTmFOKTtcbiAgICAgICAgcmV0dXJuIGlkeCA+PSAwID8gaWR4ICsgaSA6IC0xO1xuICAgICAgfVxuICAgICAgZm9yIChpZHggPSBkaXIgPiAwID8gaSA6IGxlbmd0aCAtIDE7IGlkeCA+PSAwICYmIGlkeCA8IGxlbmd0aDsgaWR4ICs9IGRpcikge1xuICAgICAgICBpZiAoYXJyYXlbaWR4XSA9PT0gaXRlbSkgcmV0dXJuIGlkeDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICB9XG5cbiAgLy8gUmV0dXJuIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhbiBpdGVtIGluIGFuIGFycmF5LFxuICAvLyBvciAtMSBpZiB0aGUgaXRlbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIGFycmF5LlxuICAvLyBJZiB0aGUgYXJyYXkgaXMgbGFyZ2UgYW5kIGFscmVhZHkgaW4gc29ydCBvcmRlciwgcGFzcyBgdHJ1ZWBcbiAgLy8gZm9yICoqaXNTb3J0ZWQqKiB0byB1c2UgYmluYXJ5IHNlYXJjaC5cbiAgXy5pbmRleE9mID0gY3JlYXRlSW5kZXhGaW5kZXIoMSwgXy5maW5kSW5kZXgsIF8uc29ydGVkSW5kZXgpO1xuICBfLmxhc3RJbmRleE9mID0gY3JlYXRlSW5kZXhGaW5kZXIoLTEsIF8uZmluZExhc3RJbmRleCk7XG5cbiAgLy8gR2VuZXJhdGUgYW4gaW50ZWdlciBBcnJheSBjb250YWluaW5nIGFuIGFyaXRobWV0aWMgcHJvZ3Jlc3Npb24uIEEgcG9ydCBvZlxuICAvLyB0aGUgbmF0aXZlIFB5dGhvbiBgcmFuZ2UoKWAgZnVuY3Rpb24uIFNlZVxuICAvLyBbdGhlIFB5dGhvbiBkb2N1bWVudGF0aW9uXShodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvZnVuY3Rpb25zLmh0bWwjcmFuZ2UpLlxuICBfLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICBpZiAoc3RvcCA9PSBudWxsKSB7XG4gICAgICBzdG9wID0gc3RhcnQgfHwgMDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgc3RlcCA9IHN0ZXAgfHwgMTtcblxuICAgIHZhciBsZW5ndGggPSBNYXRoLm1heChNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSwgMCk7XG4gICAgdmFyIHJhbmdlID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyssIHN0YXJ0ICs9IHN0ZXApIHtcbiAgICAgIHJhbmdlW2lkeF0gPSBzdGFydDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG5cbiAgLy8gRnVuY3Rpb24gKGFoZW0pIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gZXhlY3V0ZSBhIGZ1bmN0aW9uIGFzIGEgY29uc3RydWN0b3JcbiAgLy8gb3IgYSBub3JtYWwgZnVuY3Rpb24gd2l0aCB0aGUgcHJvdmlkZWQgYXJndW1lbnRzXG4gIHZhciBleGVjdXRlQm91bmQgPSBmdW5jdGlvbihzb3VyY2VGdW5jLCBib3VuZEZ1bmMsIGNvbnRleHQsIGNhbGxpbmdDb250ZXh0LCBhcmdzKSB7XG4gICAgaWYgKCEoY2FsbGluZ0NvbnRleHQgaW5zdGFuY2VvZiBib3VuZEZ1bmMpKSByZXR1cm4gc291cmNlRnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB2YXIgc2VsZiA9IGJhc2VDcmVhdGUoc291cmNlRnVuYy5wcm90b3R5cGUpO1xuICAgIHZhciByZXN1bHQgPSBzb3VyY2VGdW5jLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIGlmIChfLmlzT2JqZWN0KHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgZnVuY3Rpb24gYm91bmQgdG8gYSBnaXZlbiBvYmplY3QgKGFzc2lnbmluZyBgdGhpc2AsIGFuZCBhcmd1bWVudHMsXG4gIC8vIG9wdGlvbmFsbHkpLiBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgRnVuY3Rpb24uYmluZGAgaWZcbiAgLy8gYXZhaWxhYmxlLlxuICBfLmJpbmQgPSBmdW5jdGlvbihmdW5jLCBjb250ZXh0KSB7XG4gICAgaWYgKG5hdGl2ZUJpbmQgJiYgZnVuYy5iaW5kID09PSBuYXRpdmVCaW5kKSByZXR1cm4gbmF0aXZlQmluZC5hcHBseShmdW5jLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIGlmICghXy5pc0Z1bmN0aW9uKGZ1bmMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdCaW5kIG11c3QgYmUgY2FsbGVkIG9uIGEgZnVuY3Rpb24nKTtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICB2YXIgYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIGNvbnRleHQsIHRoaXMsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9O1xuXG4gIC8vIFBhcnRpYWxseSBhcHBseSBhIGZ1bmN0aW9uIGJ5IGNyZWF0aW5nIGEgdmVyc2lvbiB0aGF0IGhhcyBoYWQgc29tZSBvZiBpdHNcbiAgLy8gYXJndW1lbnRzIHByZS1maWxsZWQsIHdpdGhvdXQgY2hhbmdpbmcgaXRzIGR5bmFtaWMgYHRoaXNgIGNvbnRleHQuIF8gYWN0c1xuICAvLyBhcyBhIHBsYWNlaG9sZGVyLCBhbGxvd2luZyBhbnkgY29tYmluYXRpb24gb2YgYXJndW1lbnRzIHRvIGJlIHByZS1maWxsZWQuXG4gIF8ucGFydGlhbCA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICB2YXIgYm91bmRBcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHZhciBib3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvc2l0aW9uID0gMCwgbGVuZ3RoID0gYm91bmRBcmdzLmxlbmd0aDtcbiAgICAgIHZhciBhcmdzID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJnc1tpXSA9IGJvdW5kQXJnc1tpXSA9PT0gXyA/IGFyZ3VtZW50c1twb3NpdGlvbisrXSA6IGJvdW5kQXJnc1tpXTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChwb3NpdGlvbiA8IGFyZ3VtZW50cy5sZW5ndGgpIGFyZ3MucHVzaChhcmd1bWVudHNbcG9zaXRpb24rK10pO1xuICAgICAgcmV0dXJuIGV4ZWN1dGVCb3VuZChmdW5jLCBib3VuZCwgdGhpcywgdGhpcywgYXJncyk7XG4gICAgfTtcbiAgICByZXR1cm4gYm91bmQ7XG4gIH07XG5cbiAgLy8gQmluZCBhIG51bWJlciBvZiBhbiBvYmplY3QncyBtZXRob2RzIHRvIHRoYXQgb2JqZWN0LiBSZW1haW5pbmcgYXJndW1lbnRzXG4gIC8vIGFyZSB0aGUgbWV0aG9kIG5hbWVzIHRvIGJlIGJvdW5kLiBVc2VmdWwgZm9yIGVuc3VyaW5nIHRoYXQgYWxsIGNhbGxiYWNrc1xuICAvLyBkZWZpbmVkIG9uIGFuIG9iamVjdCBiZWxvbmcgdG8gaXQuXG4gIF8uYmluZEFsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBpLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLCBrZXk7XG4gICAgaWYgKGxlbmd0aCA8PSAxKSB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBbGwgbXVzdCBiZSBwYXNzZWQgZnVuY3Rpb24gbmFtZXMnKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIG9ialtrZXldID0gXy5iaW5kKG9ialtrZXldLCBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIE1lbW9pemUgYW4gZXhwZW5zaXZlIGZ1bmN0aW9uIGJ5IHN0b3JpbmcgaXRzIHJlc3VsdHMuXG4gIF8ubWVtb2l6ZSA9IGZ1bmN0aW9uKGZ1bmMsIGhhc2hlcikge1xuICAgIHZhciBtZW1vaXplID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICB2YXIgY2FjaGUgPSBtZW1vaXplLmNhY2hlO1xuICAgICAgdmFyIGFkZHJlc3MgPSAnJyArIChoYXNoZXIgPyBoYXNoZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGtleSk7XG4gICAgICBpZiAoIV8uaGFzKGNhY2hlLCBhZGRyZXNzKSkgY2FjaGVbYWRkcmVzc10gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gY2FjaGVbYWRkcmVzc107XG4gICAgfTtcbiAgICBtZW1vaXplLmNhY2hlID0ge307XG4gICAgcmV0dXJuIG1lbW9pemU7XG4gIH07XG5cbiAgLy8gRGVsYXlzIGEgZnVuY3Rpb24gZm9yIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCBhbmQgdGhlbiBjYWxsc1xuICAvLyBpdCB3aXRoIHRoZSBhcmd1bWVudHMgc3VwcGxpZWQuXG4gIF8uZGVsYXkgPSBmdW5jdGlvbihmdW5jLCB3YWl0KSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0sIHdhaXQpO1xuICB9O1xuXG4gIC8vIERlZmVycyBhIGZ1bmN0aW9uLCBzY2hlZHVsaW5nIGl0IHRvIHJ1biBhZnRlciB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhc1xuICAvLyBjbGVhcmVkLlxuICBfLmRlZmVyID0gXy5wYXJ0aWFsKF8uZGVsYXksIF8sIDEpO1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIG9ubHkgYmUgdHJpZ2dlcmVkIGF0IG1vc3Qgb25jZVxuICAvLyBkdXJpbmcgYSBnaXZlbiB3aW5kb3cgb2YgdGltZS4gTm9ybWFsbHksIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gd2lsbCBydW5cbiAgLy8gYXMgbXVjaCBhcyBpdCBjYW4sIHdpdGhvdXQgZXZlciBnb2luZyBtb3JlIHRoYW4gb25jZSBwZXIgYHdhaXRgIGR1cmF0aW9uO1xuICAvLyBidXQgaWYgeW91J2QgbGlrZSB0byBkaXNhYmxlIHRoZSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmcgZWRnZSwgcGFzc1xuICAvLyBge2xlYWRpbmc6IGZhbHNlfWAuIFRvIGRpc2FibGUgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlLCBkaXR0by5cbiAgXy50aHJvdHRsZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgY29udGV4dCwgYXJncywgcmVzdWx0O1xuICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXMgPSAwO1xuICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IF8ubm93KCk7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBub3cgPSBfLm5vdygpO1xuICAgICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSBwcmV2aW91cyA9IG5vdztcbiAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdFxuICAvLyBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXG4gIC8vIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuICAvLyBsZWFkaW5nIGVkZ2UsIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLlxuICBfLmRlYm91bmNlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xuXG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGFzdCA9IF8ubm93KCkgLSB0aW1lc3RhbXA7XG5cbiAgICAgIGlmIChsYXN0IDwgd2FpdCAmJiBsYXN0ID49IDApIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdGltZXN0YW1wID0gXy5ub3coKTtcbiAgICAgIHZhciBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xuICAgICAgaWYgKCF0aW1lb3V0KSB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgICBpZiAoY2FsbE5vdykge1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBmdW5jdGlvbiBwYXNzZWQgYXMgYW4gYXJndW1lbnQgdG8gdGhlIHNlY29uZCxcbiAgLy8gYWxsb3dpbmcgeW91IHRvIGFkanVzdCBhcmd1bWVudHMsIHJ1biBjb2RlIGJlZm9yZSBhbmQgYWZ0ZXIsIGFuZFxuICAvLyBjb25kaXRpb25hbGx5IGV4ZWN1dGUgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxuICBfLndyYXAgPSBmdW5jdGlvbihmdW5jLCB3cmFwcGVyKSB7XG4gICAgcmV0dXJuIF8ucGFydGlhbCh3cmFwcGVyLCBmdW5jKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgbmVnYXRlZCB2ZXJzaW9uIG9mIHRoZSBwYXNzZWQtaW4gcHJlZGljYXRlLlxuICBfLm5lZ2F0ZSA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgYSBsaXN0IG9mIGZ1bmN0aW9ucywgZWFjaFxuICAvLyBjb25zdW1pbmcgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gdGhhdCBmb2xsb3dzLlxuICBfLmNvbXBvc2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgc3RhcnQgPSBhcmdzLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGkgPSBzdGFydDtcbiAgICAgIHZhciByZXN1bHQgPSBhcmdzW3N0YXJ0XS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgd2hpbGUgKGktLSkgcmVzdWx0ID0gYXJnc1tpXS5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIG9uIGFuZCBhZnRlciB0aGUgTnRoIGNhbGwuXG4gIF8uYWZ0ZXIgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzIDwgMSkge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIHVwIHRvIChidXQgbm90IGluY2x1ZGluZykgdGhlIE50aCBjYWxsLlxuICBfLmJlZm9yZSA9IGZ1bmN0aW9uKHRpbWVzLCBmdW5jKSB7XG4gICAgdmFyIG1lbW87XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKC0tdGltZXMgPiAwKSB7XG4gICAgICAgIG1lbW8gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICBpZiAodGltZXMgPD0gMSkgZnVuYyA9IG51bGw7XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYXQgbW9zdCBvbmUgdGltZSwgbm8gbWF0dGVyIGhvd1xuICAvLyBvZnRlbiB5b3UgY2FsbCBpdC4gVXNlZnVsIGZvciBsYXp5IGluaXRpYWxpemF0aW9uLlxuICBfLm9uY2UgPSBfLnBhcnRpYWwoXy5iZWZvcmUsIDIpO1xuXG4gIC8vIE9iamVjdCBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEtleXMgaW4gSUUgPCA5IHRoYXQgd29uJ3QgYmUgaXRlcmF0ZWQgYnkgYGZvciBrZXkgaW4gLi4uYCBhbmQgdGh1cyBtaXNzZWQuXG4gIHZhciBoYXNFbnVtQnVnID0gIXt0b1N0cmluZzogbnVsbH0ucHJvcGVydHlJc0VudW1lcmFibGUoJ3RvU3RyaW5nJyk7XG4gIHZhciBub25FbnVtZXJhYmxlUHJvcHMgPSBbJ3ZhbHVlT2YnLCAnaXNQcm90b3R5cGVPZicsICd0b1N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJ2hhc093blByb3BlcnR5JywgJ3RvTG9jYWxlU3RyaW5nJ107XG5cbiAgZnVuY3Rpb24gY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpIHtcbiAgICB2YXIgbm9uRW51bUlkeCA9IG5vbkVudW1lcmFibGVQcm9wcy5sZW5ndGg7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gb2JqLmNvbnN0cnVjdG9yO1xuICAgIHZhciBwcm90byA9IChfLmlzRnVuY3Rpb24oY29uc3RydWN0b3IpICYmIGNvbnN0cnVjdG9yLnByb3RvdHlwZSkgfHwgT2JqUHJvdG87XG5cbiAgICAvLyBDb25zdHJ1Y3RvciBpcyBhIHNwZWNpYWwgY2FzZS5cbiAgICB2YXIgcHJvcCA9ICdjb25zdHJ1Y3Rvcic7XG4gICAgaWYgKF8uaGFzKG9iaiwgcHJvcCkgJiYgIV8uY29udGFpbnMoa2V5cywgcHJvcCkpIGtleXMucHVzaChwcm9wKTtcblxuICAgIHdoaWxlIChub25FbnVtSWR4LS0pIHtcbiAgICAgIHByb3AgPSBub25FbnVtZXJhYmxlUHJvcHNbbm9uRW51bUlkeF07XG4gICAgICBpZiAocHJvcCBpbiBvYmogJiYgb2JqW3Byb3BdICE9PSBwcm90b1twcm9wXSAmJiAhXy5jb250YWlucyhrZXlzLCBwcm9wKSkge1xuICAgICAgICBrZXlzLnB1c2gocHJvcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0cmlldmUgdGhlIG5hbWVzIG9mIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzLlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgT2JqZWN0LmtleXNgXG4gIF8ua2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgaWYgKG5hdGl2ZUtleXMpIHJldHVybiBuYXRpdmVLZXlzKG9iaik7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgICAvLyBBaGVtLCBJRSA8IDkuXG4gICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSBhbGwgdGhlIHByb3BlcnR5IG5hbWVzIG9mIGFuIG9iamVjdC5cbiAgXy5hbGxLZXlzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBbXTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICAgIC8vIEFoZW0sIElFIDwgOS5cbiAgICBpZiAoaGFzRW51bUJ1ZykgY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpO1xuICAgIHJldHVybiBrZXlzO1xuICB9O1xuXG4gIC8vIFJldHJpZXZlIHRoZSB2YWx1ZXMgb2YgYW4gb2JqZWN0J3MgcHJvcGVydGllcy5cbiAgXy52YWx1ZXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgdmFsdWVzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZXNbaV0gPSBvYmpba2V5c1tpXV07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0ZWUgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBvYmplY3RcbiAgLy8gSW4gY29udHJhc3QgdG8gXy5tYXAgaXQgcmV0dXJucyBhbiBvYmplY3RcbiAgXy5tYXBPYmplY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAgXy5rZXlzKG9iaiksXG4gICAgICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0cyA9IHt9LFxuICAgICAgICAgIGN1cnJlbnRLZXk7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGN1cnJlbnRLZXkgPSBrZXlzW2luZGV4XTtcbiAgICAgICAgcmVzdWx0c1tjdXJyZW50S2V5XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIENvbnZlcnQgYW4gb2JqZWN0IGludG8gYSBsaXN0IG9mIGBba2V5LCB2YWx1ZV1gIHBhaXJzLlxuICBfLnBhaXJzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHBhaXJzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBwYWlyc1tpXSA9IFtrZXlzW2ldLCBvYmpba2V5c1tpXV1dO1xuICAgIH1cbiAgICByZXR1cm4gcGFpcnM7XG4gIH07XG5cbiAgLy8gSW52ZXJ0IHRoZSBrZXlzIGFuZCB2YWx1ZXMgb2YgYW4gb2JqZWN0LiBUaGUgdmFsdWVzIG11c3QgYmUgc2VyaWFsaXphYmxlLlxuICBfLmludmVydCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRbb2JqW2tleXNbaV1dXSA9IGtleXNbaV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgc29ydGVkIGxpc3Qgb2YgdGhlIGZ1bmN0aW9uIG5hbWVzIGF2YWlsYWJsZSBvbiB0aGUgb2JqZWN0LlxuICAvLyBBbGlhc2VkIGFzIGBtZXRob2RzYFxuICBfLmZ1bmN0aW9ucyA9IF8ubWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24ob2JqW2tleV0pKSBuYW1lcy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lcy5zb3J0KCk7XG4gIH07XG5cbiAgLy8gRXh0ZW5kIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBwcm9wZXJ0aWVzIGluIHBhc3NlZC1pbiBvYmplY3QocykuXG4gIF8uZXh0ZW5kID0gY3JlYXRlQXNzaWduZXIoXy5hbGxLZXlzKTtcblxuICAvLyBBc3NpZ25zIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBvd24gcHJvcGVydGllcyBpbiB0aGUgcGFzc2VkLWluIG9iamVjdChzKVxuICAvLyAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnbilcbiAgXy5leHRlbmRPd24gPSBfLmFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKF8ua2V5cyk7XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3Qga2V5IG9uIGFuIG9iamVjdCB0aGF0IHBhc3NlcyBhIHByZWRpY2F0ZSB0ZXN0XG4gIF8uZmluZEtleSA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopLCBrZXk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAocHJlZGljYXRlKG9ialtrZXldLCBrZXksIG9iaikpIHJldHVybiBrZXk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCBvbmx5IGNvbnRhaW5pbmcgdGhlIHdoaXRlbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ucGljayA9IGZ1bmN0aW9uKG9iamVjdCwgb2l0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9LCBvYmogPSBvYmplY3QsIGl0ZXJhdGVlLCBrZXlzO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKG9pdGVyYXRlZSkpIHtcbiAgICAgIGtleXMgPSBfLmFsbEtleXMob2JqKTtcbiAgICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihvaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gZmxhdHRlbihhcmd1bWVudHMsIGZhbHNlLCBmYWxzZSwgMSk7XG4gICAgICBpdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikgeyByZXR1cm4ga2V5IGluIG9iajsgfTtcbiAgICAgIG9iaiA9IE9iamVjdChvYmopO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgIGlmIChpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmopKSByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgd2l0aG91dCB0aGUgYmxhY2tsaXN0ZWQgcHJvcGVydGllcy5cbiAgXy5vbWl0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGlmIChfLmlzRnVuY3Rpb24oaXRlcmF0ZWUpKSB7XG4gICAgICBpdGVyYXRlZSA9IF8ubmVnYXRlKGl0ZXJhdGVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBfLm1hcChmbGF0dGVuKGFyZ3VtZW50cywgZmFsc2UsIGZhbHNlLCAxKSwgU3RyaW5nKTtcbiAgICAgIGl0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICByZXR1cm4gIV8uY29udGFpbnMoa2V5cywga2V5KTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBfLnBpY2sob2JqLCBpdGVyYXRlZSwgY29udGV4dCk7XG4gIH07XG5cbiAgLy8gRmlsbCBpbiBhIGdpdmVuIG9iamVjdCB3aXRoIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgXy5kZWZhdWx0cyA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cywgdHJ1ZSk7XG5cbiAgLy8gQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoZSBnaXZlbiBwcm90b3R5cGUgb2JqZWN0LlxuICAvLyBJZiBhZGRpdGlvbmFsIHByb3BlcnRpZXMgYXJlIHByb3ZpZGVkIHRoZW4gdGhleSB3aWxsIGJlIGFkZGVkIHRvIHRoZVxuICAvLyBjcmVhdGVkIG9iamVjdC5cbiAgXy5jcmVhdGUgPSBmdW5jdGlvbihwcm90b3R5cGUsIHByb3BzKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VDcmVhdGUocHJvdG90eXBlKTtcbiAgICBpZiAocHJvcHMpIF8uZXh0ZW5kT3duKHJlc3VsdCwgcHJvcHMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgKHNoYWxsb3ctY2xvbmVkKSBkdXBsaWNhdGUgb2YgYW4gb2JqZWN0LlxuICBfLmNsb25lID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG4gICAgcmV0dXJuIF8uaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiBfLmV4dGVuZCh7fSwgb2JqKTtcbiAgfTtcblxuICAvLyBJbnZva2VzIGludGVyY2VwdG9yIHdpdGggdGhlIG9iaiwgYW5kIHRoZW4gcmV0dXJucyBvYmouXG4gIC8vIFRoZSBwcmltYXJ5IHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluLCBpblxuICAvLyBvcmRlciB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gaW50ZXJtZWRpYXRlIHJlc3VsdHMgd2l0aGluIHRoZSBjaGFpbi5cbiAgXy50YXAgPSBmdW5jdGlvbihvYmosIGludGVyY2VwdG9yKSB7XG4gICAgaW50ZXJjZXB0b3Iob2JqKTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybnMgd2hldGhlciBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gc2V0IG9mIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLmlzTWF0Y2ggPSBmdW5jdGlvbihvYmplY3QsIGF0dHJzKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMoYXR0cnMpLCBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHJldHVybiAhbGVuZ3RoO1xuICAgIHZhciBvYmogPSBPYmplY3Qob2JqZWN0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChhdHRyc1trZXldICE9PSBvYmpba2V5XSB8fCAhKGtleSBpbiBvYmopKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG5cbiAgLy8gSW50ZXJuYWwgcmVjdXJzaXZlIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIGBpc0VxdWFsYC5cbiAgdmFyIGVxID0gZnVuY3Rpb24oYSwgYiwgYVN0YWNrLCBiU3RhY2spIHtcbiAgICAvLyBJZGVudGljYWwgb2JqZWN0cyBhcmUgZXF1YWwuIGAwID09PSAtMGAsIGJ1dCB0aGV5IGFyZW4ndCBpZGVudGljYWwuXG4gICAgLy8gU2VlIHRoZSBbSGFybW9ueSBgZWdhbGAgcHJvcG9zYWxdKGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6ZWdhbCkuXG4gICAgaWYgKGEgPT09IGIpIHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09PSAxIC8gYjtcbiAgICAvLyBBIHN0cmljdCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGBudWxsID09IHVuZGVmaW5lZGAuXG4gICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBhID09PSBiO1xuICAgIC8vIFVud3JhcCBhbnkgd3JhcHBlZCBvYmplY3RzLlxuICAgIGlmIChhIGluc3RhbmNlb2YgXykgYSA9IGEuX3dyYXBwZWQ7XG4gICAgaWYgKGIgaW5zdGFuY2VvZiBfKSBiID0gYi5fd3JhcHBlZDtcbiAgICAvLyBDb21wYXJlIGBbW0NsYXNzXV1gIG5hbWVzLlxuICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpO1xuICAgIGlmIChjbGFzc05hbWUgIT09IHRvU3RyaW5nLmNhbGwoYikpIHJldHVybiBmYWxzZTtcbiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgLy8gU3RyaW5ncywgbnVtYmVycywgcmVndWxhciBleHByZXNzaW9ucywgZGF0ZXMsIGFuZCBib29sZWFucyBhcmUgY29tcGFyZWQgYnkgdmFsdWUuXG4gICAgICBjYXNlICdbb2JqZWN0IFJlZ0V4cF0nOlxuICAgICAgLy8gUmVnRXhwcyBhcmUgY29lcmNlZCB0byBzdHJpbmdzIGZvciBjb21wYXJpc29uIChOb3RlOiAnJyArIC9hL2kgPT09ICcvYS9pJylcbiAgICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XG4gICAgICAgIC8vIFByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHdyYXBwZXJzIGFyZSBlcXVpdmFsZW50OyB0aHVzLCBgXCI1XCJgIGlzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gYG5ldyBTdHJpbmcoXCI1XCIpYC5cbiAgICAgICAgcmV0dXJuICcnICsgYSA9PT0gJycgKyBiO1xuICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzpcbiAgICAgICAgLy8gYE5hTmBzIGFyZSBlcXVpdmFsZW50LCBidXQgbm9uLXJlZmxleGl2ZS5cbiAgICAgICAgLy8gT2JqZWN0KE5hTikgaXMgZXF1aXZhbGVudCB0byBOYU5cbiAgICAgICAgaWYgKCthICE9PSArYSkgcmV0dXJuICtiICE9PSArYjtcbiAgICAgICAgLy8gQW4gYGVnYWxgIGNvbXBhcmlzb24gaXMgcGVyZm9ybWVkIGZvciBvdGhlciBudW1lcmljIHZhbHVlcy5cbiAgICAgICAgcmV0dXJuICthID09PSAwID8gMSAvICthID09PSAxIC8gYiA6ICthID09PSArYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOlxuICAgICAgY2FzZSAnW29iamVjdCBCb29sZWFuXSc6XG4gICAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtZXJpYyBwcmltaXRpdmUgdmFsdWVzLiBEYXRlcyBhcmUgY29tcGFyZWQgYnkgdGhlaXJcbiAgICAgICAgLy8gbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zLiBOb3RlIHRoYXQgaW52YWxpZCBkYXRlcyB3aXRoIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9uc1xuICAgICAgICAvLyBvZiBgTmFOYCBhcmUgbm90IGVxdWl2YWxlbnQuXG4gICAgICAgIHJldHVybiArYSA9PT0gK2I7XG4gICAgfVxuXG4gICAgdmFyIGFyZUFycmF5cyA9IGNsYXNzTmFtZSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICBpZiAoIWFyZUFycmF5cykge1xuICAgICAgaWYgKHR5cGVvZiBhICE9ICdvYmplY3QnIHx8IHR5cGVvZiBiICE9ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIC8vIE9iamVjdHMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1aXZhbGVudCwgYnV0IGBPYmplY3RgcyBvciBgQXJyYXlgc1xuICAgICAgLy8gZnJvbSBkaWZmZXJlbnQgZnJhbWVzIGFyZS5cbiAgICAgIHZhciBhQ3RvciA9IGEuY29uc3RydWN0b3IsIGJDdG9yID0gYi5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmIChhQ3RvciAhPT0gYkN0b3IgJiYgIShfLmlzRnVuY3Rpb24oYUN0b3IpICYmIGFDdG9yIGluc3RhbmNlb2YgYUN0b3IgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmlzRnVuY3Rpb24oYkN0b3IpICYmIGJDdG9yIGluc3RhbmNlb2YgYkN0b3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICYmICgnY29uc3RydWN0b3InIGluIGEgJiYgJ2NvbnN0cnVjdG9yJyBpbiBiKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEFzc3VtZSBlcXVhbGl0eSBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWNcbiAgICAvLyBzdHJ1Y3R1cmVzIGlzIGFkYXB0ZWQgZnJvbSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLCBhYnN0cmFjdCBvcGVyYXRpb24gYEpPYC5cblxuICAgIC8vIEluaXRpYWxpemluZyBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAvLyBJdCdzIGRvbmUgaGVyZSBzaW5jZSB3ZSBvbmx5IG5lZWQgdGhlbSBmb3Igb2JqZWN0cyBhbmQgYXJyYXlzIGNvbXBhcmlzb24uXG4gICAgYVN0YWNrID0gYVN0YWNrIHx8IFtdO1xuICAgIGJTdGFjayA9IGJTdGFjayB8fCBbXTtcbiAgICB2YXIgbGVuZ3RoID0gYVN0YWNrLmxlbmd0aDtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIC8vIExpbmVhciBzZWFyY2guIFBlcmZvcm1hbmNlIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZlxuICAgICAgLy8gdW5pcXVlIG5lc3RlZCBzdHJ1Y3R1cmVzLlxuICAgICAgaWYgKGFTdGFja1tsZW5ndGhdID09PSBhKSByZXR1cm4gYlN0YWNrW2xlbmd0aF0gPT09IGI7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSBmaXJzdCBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIGFTdGFjay5wdXNoKGEpO1xuICAgIGJTdGFjay5wdXNoKGIpO1xuXG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgaWYgKGFyZUFycmF5cykge1xuICAgICAgLy8gQ29tcGFyZSBhcnJheSBsZW5ndGhzIHRvIGRldGVybWluZSBpZiBhIGRlZXAgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkuXG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICAvLyBEZWVwIGNvbXBhcmUgdGhlIGNvbnRlbnRzLCBpZ25vcmluZyBub24tbnVtZXJpYyBwcm9wZXJ0aWVzLlxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmICghZXEoYVtsZW5ndGhdLCBiW2xlbmd0aF0sIGFTdGFjaywgYlN0YWNrKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWVwIGNvbXBhcmUgb2JqZWN0cy5cbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKGEpLCBrZXk7XG4gICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IGJvdGggb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzIGJlZm9yZSBjb21wYXJpbmcgZGVlcCBlcXVhbGl0eS5cbiAgICAgIGlmIChfLmtleXMoYikubGVuZ3RoICE9PSBsZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAvLyBEZWVwIGNvbXBhcmUgZWFjaCBtZW1iZXJcbiAgICAgICAga2V5ID0ga2V5c1tsZW5ndGhdO1xuICAgICAgICBpZiAoIShfLmhhcyhiLCBrZXkpICYmIGVxKGFba2V5XSwgYltrZXldLCBhU3RhY2ssIGJTdGFjaykpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJlbW92ZSB0aGUgZmlyc3Qgb2JqZWN0IGZyb20gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIGFTdGFjay5wb3AoKTtcbiAgICBiU3RhY2sucG9wKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gUGVyZm9ybSBhIGRlZXAgY29tcGFyaXNvbiB0byBjaGVjayBpZiB0d28gb2JqZWN0cyBhcmUgZXF1YWwuXG4gIF8uaXNFcXVhbCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gZXEoYSwgYik7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiBhcnJheSwgc3RyaW5nLCBvciBvYmplY3QgZW1wdHk/XG4gIC8vIEFuIFwiZW1wdHlcIiBvYmplY3QgaGFzIG5vIGVudW1lcmFibGUgb3duLXByb3BlcnRpZXMuXG4gIF8uaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikgJiYgKF8uaXNBcnJheShvYmopIHx8IF8uaXNTdHJpbmcob2JqKSB8fCBfLmlzQXJndW1lbnRzKG9iaikpKSByZXR1cm4gb2JqLmxlbmd0aCA9PT0gMDtcbiAgICByZXR1cm4gXy5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBET00gZWxlbWVudD9cbiAgXy5pc0VsZW1lbnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PT0gMSk7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhbiBhcnJheT9cbiAgLy8gRGVsZWdhdGVzIHRvIEVDTUE1J3MgbmF0aXZlIEFycmF5LmlzQXJyYXlcbiAgXy5pc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgYW4gb2JqZWN0P1xuICBfLmlzT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2Ygb2JqO1xuICAgIHJldHVybiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGUgPT09ICdvYmplY3QnICYmICEhb2JqO1xuICB9O1xuXG4gIC8vIEFkZCBzb21lIGlzVHlwZSBtZXRob2RzOiBpc0FyZ3VtZW50cywgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGlzTnVtYmVyLCBpc0RhdGUsIGlzUmVnRXhwLCBpc0Vycm9yLlxuICBfLmVhY2goWydBcmd1bWVudHMnLCAnRnVuY3Rpb24nLCAnU3RyaW5nJywgJ051bWJlcicsICdEYXRlJywgJ1JlZ0V4cCcsICdFcnJvciddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgX1snaXMnICsgbmFtZV0gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0ICcgKyBuYW1lICsgJ10nO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIERlZmluZSBhIGZhbGxiYWNrIHZlcnNpb24gb2YgdGhlIG1ldGhvZCBpbiBicm93c2VycyAoYWhlbSwgSUUgPCA5KSwgd2hlcmVcbiAgLy8gdGhlcmUgaXNuJ3QgYW55IGluc3BlY3RhYmxlIFwiQXJndW1lbnRzXCIgdHlwZS5cbiAgaWYgKCFfLmlzQXJndW1lbnRzKGFyZ3VtZW50cykpIHtcbiAgICBfLmlzQXJndW1lbnRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gXy5oYXMob2JqLCAnY2FsbGVlJyk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIE9wdGltaXplIGBpc0Z1bmN0aW9uYCBpZiBhcHByb3ByaWF0ZS4gV29yayBhcm91bmQgc29tZSB0eXBlb2YgYnVncyBpbiBvbGQgdjgsXG4gIC8vIElFIDExICgjMTYyMSksIGFuZCBpbiBTYWZhcmkgOCAoIzE5MjkpLlxuICBpZiAodHlwZW9mIC8uLyAhPSAnZnVuY3Rpb24nICYmIHR5cGVvZiBJbnQ4QXJyYXkgIT0gJ29iamVjdCcpIHtcbiAgICBfLmlzRnVuY3Rpb24gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09ICdmdW5jdGlvbicgfHwgZmFsc2U7XG4gICAgfTtcbiAgfVxuXG4gIC8vIElzIGEgZ2l2ZW4gb2JqZWN0IGEgZmluaXRlIG51bWJlcj9cbiAgXy5pc0Zpbml0ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBpc0Zpbml0ZShvYmopICYmICFpc05hTihwYXJzZUZsb2F0KG9iaikpO1xuICB9O1xuXG4gIC8vIElzIHRoZSBnaXZlbiB2YWx1ZSBgTmFOYD8gKE5hTiBpcyB0aGUgb25seSBudW1iZXIgd2hpY2ggZG9lcyBub3QgZXF1YWwgaXRzZWxmKS5cbiAgXy5pc05hTiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBfLmlzTnVtYmVyKG9iaikgJiYgb2JqICE9PSArb2JqO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBib29sZWFuP1xuICBfLmlzQm9vbGVhbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHRydWUgfHwgb2JqID09PSBmYWxzZSB8fCB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEJvb2xlYW5dJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGVxdWFsIHRvIG51bGw/XG4gIF8uaXNOdWxsID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIHVuZGVmaW5lZD9cbiAgXy5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcbiAgfTtcblxuICAvLyBTaG9ydGN1dCBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHByb3BlcnR5IGRpcmVjdGx5XG4gIC8vIG9uIGl0c2VsZiAoaW4gb3RoZXIgd29yZHMsIG5vdCBvbiBhIHByb3RvdHlwZSkuXG4gIF8uaGFzID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG4gIH07XG5cbiAgLy8gVXRpbGl0eSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBSdW4gVW5kZXJzY29yZS5qcyBpbiAqbm9Db25mbGljdCogbW9kZSwgcmV0dXJuaW5nIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzXG4gIC8vIHByZXZpb3VzIG93bmVyLiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcm9vdC5fID0gcHJldmlvdXNVbmRlcnNjb3JlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEtlZXAgdGhlIGlkZW50aXR5IGZ1bmN0aW9uIGFyb3VuZCBmb3IgZGVmYXVsdCBpdGVyYXRlZXMuXG4gIF8uaWRlbnRpdHkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvLyBQcmVkaWNhdGUtZ2VuZXJhdGluZyBmdW5jdGlvbnMuIE9mdGVuIHVzZWZ1bCBvdXRzaWRlIG9mIFVuZGVyc2NvcmUuXG4gIF8uY29uc3RhbnQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICB9O1xuXG4gIF8ubm9vcCA9IGZ1bmN0aW9uKCl7fTtcblxuICBfLnByb3BlcnR5ID0gcHJvcGVydHk7XG5cbiAgLy8gR2VuZXJhdGVzIGEgZnVuY3Rpb24gZm9yIGEgZ2l2ZW4gb2JqZWN0IHRoYXQgcmV0dXJucyBhIGdpdmVuIHByb3BlcnR5LlxuICBfLnByb3BlcnR5T2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09IG51bGwgPyBmdW5jdGlvbigpe30gOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBwcmVkaWNhdGUgZm9yIGNoZWNraW5nIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZlxuICAvLyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5tYXRjaGVyID0gXy5tYXRjaGVzID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgICBhdHRycyA9IF8uZXh0ZW5kT3duKHt9LCBhdHRycyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIF8uaXNNYXRjaChvYmosIGF0dHJzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJ1biBhIGZ1bmN0aW9uICoqbioqIHRpbWVzLlxuICBfLnRpbWVzID0gZnVuY3Rpb24obiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgYWNjdW0gPSBBcnJheShNYXRoLm1heCgwLCBuKSk7XG4gICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykgYWNjdW1baV0gPSBpdGVyYXRlZShpKTtcbiAgICByZXR1cm4gYWNjdW07XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBtaW4gYW5kIG1heCAoaW5jbHVzaXZlKS5cbiAgXy5yYW5kb20gPSBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgIGlmIChtYXggPT0gbnVsbCkge1xuICAgICAgbWF4ID0gbWluO1xuICAgICAgbWluID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIG1pbiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSk7XG4gIH07XG5cbiAgLy8gQSAocG9zc2libHkgZmFzdGVyKSB3YXkgdG8gZ2V0IHRoZSBjdXJyZW50IHRpbWVzdGFtcCBhcyBhbiBpbnRlZ2VyLlxuICBfLm5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfTtcblxuICAgLy8gTGlzdCBvZiBIVE1MIGVudGl0aWVzIGZvciBlc2NhcGluZy5cbiAgdmFyIGVzY2FwZU1hcCA9IHtcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmI3gyNzsnLFxuICAgICdgJzogJyYjeDYwOydcbiAgfTtcbiAgdmFyIHVuZXNjYXBlTWFwID0gXy5pbnZlcnQoZXNjYXBlTWFwKTtcblxuICAvLyBGdW5jdGlvbnMgZm9yIGVzY2FwaW5nIGFuZCB1bmVzY2FwaW5nIHN0cmluZ3MgdG8vZnJvbSBIVE1MIGludGVycG9sYXRpb24uXG4gIHZhciBjcmVhdGVFc2NhcGVyID0gZnVuY3Rpb24obWFwKSB7XG4gICAgdmFyIGVzY2FwZXIgPSBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgcmV0dXJuIG1hcFttYXRjaF07XG4gICAgfTtcbiAgICAvLyBSZWdleGVzIGZvciBpZGVudGlmeWluZyBhIGtleSB0aGF0IG5lZWRzIHRvIGJlIGVzY2FwZWRcbiAgICB2YXIgc291cmNlID0gJyg/OicgKyBfLmtleXMobWFwKS5qb2luKCd8JykgKyAnKSc7XG4gICAgdmFyIHRlc3RSZWdleHAgPSBSZWdFeHAoc291cmNlKTtcbiAgICB2YXIgcmVwbGFjZVJlZ2V4cCA9IFJlZ0V4cChzb3VyY2UsICdnJyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gc3RyaW5nID09IG51bGwgPyAnJyA6ICcnICsgc3RyaW5nO1xuICAgICAgcmV0dXJuIHRlc3RSZWdleHAudGVzdChzdHJpbmcpID8gc3RyaW5nLnJlcGxhY2UocmVwbGFjZVJlZ2V4cCwgZXNjYXBlcikgOiBzdHJpbmc7XG4gICAgfTtcbiAgfTtcbiAgXy5lc2NhcGUgPSBjcmVhdGVFc2NhcGVyKGVzY2FwZU1hcCk7XG4gIF8udW5lc2NhcGUgPSBjcmVhdGVFc2NhcGVyKHVuZXNjYXBlTWFwKTtcblxuICAvLyBJZiB0aGUgdmFsdWUgb2YgdGhlIG5hbWVkIGBwcm9wZXJ0eWAgaXMgYSBmdW5jdGlvbiB0aGVuIGludm9rZSBpdCB3aXRoIHRoZVxuICAvLyBgb2JqZWN0YCBhcyBjb250ZXh0OyBvdGhlcndpc2UsIHJldHVybiBpdC5cbiAgXy5yZXN1bHQgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5LCBmYWxsYmFjaykge1xuICAgIHZhciB2YWx1ZSA9IG9iamVjdCA9PSBudWxsID8gdm9pZCAwIDogb2JqZWN0W3Byb3BlcnR5XTtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgdmFsdWUgPSBmYWxsYmFjaztcbiAgICB9XG4gICAgcmV0dXJuIF8uaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZS5jYWxsKG9iamVjdCkgOiB2YWx1ZTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpbnRlZ2VyIGlkICh1bmlxdWUgd2l0aGluIHRoZSBlbnRpcmUgY2xpZW50IHNlc3Npb24pLlxuICAvLyBVc2VmdWwgZm9yIHRlbXBvcmFyeSBET00gaWRzLlxuICB2YXIgaWRDb3VudGVyID0gMDtcbiAgXy51bmlxdWVJZCA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHZhciBpZCA9ICsraWRDb3VudGVyICsgJyc7XG4gICAgcmV0dXJuIHByZWZpeCA/IHByZWZpeCArIGlkIDogaWQ7XG4gIH07XG5cbiAgLy8gQnkgZGVmYXVsdCwgVW5kZXJzY29yZSB1c2VzIEVSQi1zdHlsZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLCBjaGFuZ2UgdGhlXG4gIC8vIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAgXy50ZW1wbGF0ZVNldHRpbmdzID0ge1xuICAgIGV2YWx1YXRlICAgIDogLzwlKFtcXHNcXFNdKz8pJT4vZyxcbiAgICBpbnRlcnBvbGF0ZSA6IC88JT0oW1xcc1xcU10rPyklPi9nLFxuICAgIGVzY2FwZSAgICAgIDogLzwlLShbXFxzXFxTXSs/KSU+L2dcbiAgfTtcblxuICAvLyBXaGVuIGN1c3RvbWl6aW5nIGB0ZW1wbGF0ZVNldHRpbmdzYCwgaWYgeW91IGRvbid0IHdhbnQgdG8gZGVmaW5lIGFuXG4gIC8vIGludGVycG9sYXRpb24sIGV2YWx1YXRpb24gb3IgZXNjYXBpbmcgcmVnZXgsIHdlIG5lZWQgb25lIHRoYXQgaXNcbiAgLy8gZ3VhcmFudGVlZCBub3QgdG8gbWF0Y2guXG4gIHZhciBub01hdGNoID0gLyguKV4vO1xuXG4gIC8vIENlcnRhaW4gY2hhcmFjdGVycyBuZWVkIHRvIGJlIGVzY2FwZWQgc28gdGhhdCB0aGV5IGNhbiBiZSBwdXQgaW50byBhXG4gIC8vIHN0cmluZyBsaXRlcmFsLlxuICB2YXIgZXNjYXBlcyA9IHtcbiAgICBcIidcIjogICAgICBcIidcIixcbiAgICAnXFxcXCc6ICAgICAnXFxcXCcsXG4gICAgJ1xccic6ICAgICAncicsXG4gICAgJ1xcbic6ICAgICAnbicsXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xuICB9O1xuXG4gIHZhciBlc2NhcGVyID0gL1xcXFx8J3xcXHJ8XFxufFxcdTIwMjh8XFx1MjAyOS9nO1xuXG4gIHZhciBlc2NhcGVDaGFyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gJ1xcXFwnICsgZXNjYXBlc1ttYXRjaF07XG4gIH07XG5cbiAgLy8gSmF2YVNjcmlwdCBtaWNyby10ZW1wbGF0aW5nLCBzaW1pbGFyIHRvIEpvaG4gUmVzaWcncyBpbXBsZW1lbnRhdGlvbi5cbiAgLy8gVW5kZXJzY29yZSB0ZW1wbGF0aW5nIGhhbmRsZXMgYXJiaXRyYXJ5IGRlbGltaXRlcnMsIHByZXNlcnZlcyB3aGl0ZXNwYWNlLFxuICAvLyBhbmQgY29ycmVjdGx5IGVzY2FwZXMgcXVvdGVzIHdpdGhpbiBpbnRlcnBvbGF0ZWQgY29kZS5cbiAgLy8gTkI6IGBvbGRTZXR0aW5nc2Agb25seSBleGlzdHMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICBfLnRlbXBsYXRlID0gZnVuY3Rpb24odGV4dCwgc2V0dGluZ3MsIG9sZFNldHRpbmdzKSB7XG4gICAgaWYgKCFzZXR0aW5ncyAmJiBvbGRTZXR0aW5ncykgc2V0dGluZ3MgPSBvbGRTZXR0aW5ncztcbiAgICBzZXR0aW5ncyA9IF8uZGVmYXVsdHMoe30sIHNldHRpbmdzLCBfLnRlbXBsYXRlU2V0dGluZ3MpO1xuXG4gICAgLy8gQ29tYmluZSBkZWxpbWl0ZXJzIGludG8gb25lIHJlZ3VsYXIgZXhwcmVzc2lvbiB2aWEgYWx0ZXJuYXRpb24uXG4gICAgdmFyIG1hdGNoZXIgPSBSZWdFeHAoW1xuICAgICAgKHNldHRpbmdzLmVzY2FwZSB8fCBub01hdGNoKS5zb3VyY2UsXG4gICAgICAoc2V0dGluZ3MuaW50ZXJwb2xhdGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmV2YWx1YXRlIHx8IG5vTWF0Y2gpLnNvdXJjZVxuICAgIF0uam9pbignfCcpICsgJ3wkJywgJ2cnKTtcblxuICAgIC8vIENvbXBpbGUgdGhlIHRlbXBsYXRlIHNvdXJjZSwgZXNjYXBpbmcgc3RyaW5nIGxpdGVyYWxzIGFwcHJvcHJpYXRlbHkuXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgc291cmNlID0gXCJfX3ArPSdcIjtcbiAgICB0ZXh0LnJlcGxhY2UobWF0Y2hlciwgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZSwgaW50ZXJwb2xhdGUsIGV2YWx1YXRlLCBvZmZzZXQpIHtcbiAgICAgIHNvdXJjZSArPSB0ZXh0LnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UoZXNjYXBlciwgZXNjYXBlQ2hhcik7XG4gICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgICAgaWYgKGVzY2FwZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGVzY2FwZSArIFwiKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXFxuJ1wiO1xuICAgICAgfSBlbHNlIGlmIChpbnRlcnBvbGF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGludGVycG9sYXRlICsgXCIpKT09bnVsbD8nJzpfX3QpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoZXZhbHVhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlICsgXCJcXG5fX3ArPSdcIjtcbiAgICAgIH1cblxuICAgICAgLy8gQWRvYmUgVk1zIG5lZWQgdGhlIG1hdGNoIHJldHVybmVkIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3Qgb2ZmZXN0LlxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAvLyBJZiBhIHZhcmlhYmxlIGlzIG5vdCBzcGVjaWZpZWQsIHBsYWNlIGRhdGEgdmFsdWVzIGluIGxvY2FsIHNjb3BlLlxuICAgIGlmICghc2V0dGluZ3MudmFyaWFibGUpIHNvdXJjZSA9ICd3aXRoKG9ianx8e30pe1xcbicgKyBzb3VyY2UgKyAnfVxcbic7XG5cbiAgICBzb3VyY2UgPSBcInZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixcIiArXG4gICAgICBcInByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XFxuXCIgK1xuICAgICAgc291cmNlICsgJ3JldHVybiBfX3A7XFxuJztcblxuICAgIHRyeSB7XG4gICAgICB2YXIgcmVuZGVyID0gbmV3IEZ1bmN0aW9uKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonLCAnXycsIHNvdXJjZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZS5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIHZhciB0ZW1wbGF0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiByZW5kZXIuY2FsbCh0aGlzLCBkYXRhLCBfKTtcbiAgICB9O1xuXG4gICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgc291cmNlIGFzIGEgY29udmVuaWVuY2UgZm9yIHByZWNvbXBpbGF0aW9uLlxuICAgIHZhciBhcmd1bWVudCA9IHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonO1xuICAgIHRlbXBsYXRlLnNvdXJjZSA9ICdmdW5jdGlvbignICsgYXJndW1lbnQgKyAnKXtcXG4nICsgc291cmNlICsgJ30nO1xuXG4gICAgcmV0dXJuIHRlbXBsYXRlO1xuICB9O1xuXG4gIC8vIEFkZCBhIFwiY2hhaW5cIiBmdW5jdGlvbi4gU3RhcnQgY2hhaW5pbmcgYSB3cmFwcGVkIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBfLmNoYWluID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGluc3RhbmNlID0gXyhvYmopO1xuICAgIGluc3RhbmNlLl9jaGFpbiA9IHRydWU7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xuXG4gIC8vIE9PUFxuICAvLyAtLS0tLS0tLS0tLS0tLS1cbiAgLy8gSWYgVW5kZXJzY29yZSBpcyBjYWxsZWQgYXMgYSBmdW5jdGlvbiwgaXQgcmV0dXJucyBhIHdyYXBwZWQgb2JqZWN0IHRoYXRcbiAgLy8gY2FuIGJlIHVzZWQgT08tc3R5bGUuIFRoaXMgd3JhcHBlciBob2xkcyBhbHRlcmVkIHZlcnNpb25zIG9mIGFsbCB0aGVcbiAgLy8gdW5kZXJzY29yZSBmdW5jdGlvbnMuIFdyYXBwZWQgb2JqZWN0cyBtYXkgYmUgY2hhaW5lZC5cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29udGludWUgY2hhaW5pbmcgaW50ZXJtZWRpYXRlIHJlc3VsdHMuXG4gIHZhciByZXN1bHQgPSBmdW5jdGlvbihpbnN0YW5jZSwgb2JqKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLl9jaGFpbiA/IF8ob2JqKS5jaGFpbigpIDogb2JqO1xuICB9O1xuXG4gIC8vIEFkZCB5b3VyIG93biBjdXN0b20gZnVuY3Rpb25zIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5taXhpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIF8uZWFjaChfLmZ1bmN0aW9ucyhvYmopLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IF9bbmFtZV0gPSBvYmpbbmFtZV07XG4gICAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IFt0aGlzLl93cmFwcGVkXTtcbiAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIGZ1bmMuYXBwbHkoXywgYXJncykpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBBZGQgYWxsIG9mIHRoZSBVbmRlcnNjb3JlIGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlciBvYmplY3QuXG4gIF8ubWl4aW4oXyk7XG5cbiAgLy8gQWRkIGFsbCBtdXRhdG9yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsncG9wJywgJ3B1c2gnLCAncmV2ZXJzZScsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9iaiA9IHRoaXMuX3dyYXBwZWQ7XG4gICAgICBtZXRob2QuYXBwbHkob2JqLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKChuYW1lID09PSAnc2hpZnQnIHx8IG5hbWUgPT09ICdzcGxpY2UnKSAmJiBvYmoubGVuZ3RoID09PSAwKSBkZWxldGUgb2JqWzBdO1xuICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLCBvYmopO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIEFkZCBhbGwgYWNjZXNzb3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICBfLmVhY2goWydjb25jYXQnLCAnam9pbicsICdzbGljZSddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByZXN1bHQodGhpcywgbWV0aG9kLmFwcGx5KHRoaXMuX3dyYXBwZWQsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIEV4dHJhY3RzIHRoZSByZXN1bHQgZnJvbSBhIHdyYXBwZWQgYW5kIGNoYWluZWQgb2JqZWN0LlxuICBfLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl93cmFwcGVkO1xuICB9O1xuXG4gIC8vIFByb3ZpZGUgdW53cmFwcGluZyBwcm94eSBmb3Igc29tZSBtZXRob2RzIHVzZWQgaW4gZW5naW5lIG9wZXJhdGlvbnNcbiAgLy8gc3VjaCBhcyBhcml0aG1ldGljIGFuZCBKU09OIHN0cmluZ2lmaWNhdGlvbi5cbiAgXy5wcm90b3R5cGUudmFsdWVPZiA9IF8ucHJvdG90eXBlLnRvSlNPTiA9IF8ucHJvdG90eXBlLnZhbHVlO1xuXG4gIF8ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICcnICsgdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxuICAvLyBBTUQgcmVnaXN0cmF0aW9uIGhhcHBlbnMgYXQgdGhlIGVuZCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIEFNRCBsb2FkZXJzXG4gIC8vIHRoYXQgbWF5IG5vdCBlbmZvcmNlIG5leHQtdHVybiBzZW1hbnRpY3Mgb24gbW9kdWxlcy4gRXZlbiB0aG91Z2ggZ2VuZXJhbFxuICAvLyBwcmFjdGljZSBmb3IgQU1EIHJlZ2lzdHJhdGlvbiBpcyB0byBiZSBhbm9ueW1vdXMsIHVuZGVyc2NvcmUgcmVnaXN0ZXJzXG4gIC8vIGFzIGEgbmFtZWQgbW9kdWxlIGJlY2F1c2UsIGxpa2UgalF1ZXJ5LCBpdCBpcyBhIGJhc2UgbGlicmFyeSB0aGF0IGlzXG4gIC8vIHBvcHVsYXIgZW5vdWdoIHRvIGJlIGJ1bmRsZWQgaW4gYSB0aGlyZCBwYXJ0eSBsaWIsIGJ1dCBub3QgYmUgcGFydCBvZlxuICAvLyBhbiBBTUQgbG9hZCByZXF1ZXN0LiBUaG9zZSBjYXNlcyBjb3VsZCBnZW5lcmF0ZSBhbiBlcnJvciB3aGVuIGFuXG4gIC8vIGFub255bW91cyBkZWZpbmUoKSBpcyBjYWxsZWQgb3V0c2lkZSBvZiBhIGxvYWRlciByZXF1ZXN0LlxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKCd1bmRlcnNjb3JlJywgW10sIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF87XG4gICAgfSk7XG4gIH1cbn0uY2FsbCh0aGlzKSk7XG4iLCJcbnZhciBybmc7XG5cbmlmIChnbG9iYWwuY3J5cHRvICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgLy8gV0hBVFdHIGNyeXB0by1iYXNlZCBSTkcgLSBodHRwOi8vd2lraS53aGF0d2cub3JnL3dpa2kvQ3J5cHRvXG4gIC8vIE1vZGVyYXRlbHkgZmFzdCwgaGlnaCBxdWFsaXR5XG4gIHZhciBfcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7XG4gIHJuZyA9IGZ1bmN0aW9uIHdoYXR3Z1JORygpIHtcbiAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKF9ybmRzOCk7XG4gICAgcmV0dXJuIF9ybmRzODtcbiAgfTtcbn1cblxuaWYgKCFybmcpIHtcbiAgLy8gTWF0aC5yYW5kb20oKS1iYXNlZCAoUk5HKVxuICAvL1xuICAvLyBJZiBhbGwgZWxzZSBmYWlscywgdXNlIE1hdGgucmFuZG9tKCkuICBJdCdzIGZhc3QsIGJ1dCBpcyBvZiB1bnNwZWNpZmllZFxuICAvLyBxdWFsaXR5LlxuICB2YXIgIF9ybmRzID0gbmV3IEFycmF5KDE2KTtcbiAgcm5nID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIHI7IGkgPCAxNjsgaSsrKSB7XG4gICAgICBpZiAoKGkgJiAweDAzKSA9PT0gMCkgciA9IE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAwMDtcbiAgICAgIF9ybmRzW2ldID0gciA+Pj4gKChpICYgMHgwMykgPDwgMykgJiAweGZmO1xuICAgIH1cblxuICAgIHJldHVybiBfcm5kcztcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBybmc7XG5cbiIsIi8vICAgICB1dWlkLmpzXG4vL1xuLy8gICAgIENvcHlyaWdodCAoYykgMjAxMC0yMDEyIFJvYmVydCBLaWVmZmVyXG4vLyAgICAgTUlUIExpY2Vuc2UgLSBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cbi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuICBXZSBmZWF0dXJlXG4vLyBkZXRlY3QgdG8gZGV0ZXJtaW5lIHRoZSBiZXN0IFJORyBzb3VyY2UsIG5vcm1hbGl6aW5nIHRvIGEgZnVuY3Rpb24gdGhhdFxuLy8gcmV0dXJucyAxMjgtYml0cyBvZiByYW5kb21uZXNzLCBzaW5jZSB0aGF0J3Mgd2hhdCdzIHVzdWFsbHkgcmVxdWlyZWRcbnZhciBfcm5nID0gcmVxdWlyZSgnLi9ybmcnKTtcblxuLy8gTWFwcyBmb3IgbnVtYmVyIDwtPiBoZXggc3RyaW5nIGNvbnZlcnNpb25cbnZhciBfYnl0ZVRvSGV4ID0gW107XG52YXIgX2hleFRvQnl0ZSA9IHt9O1xuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICBfYnl0ZVRvSGV4W2ldID0gKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKTtcbiAgX2hleFRvQnl0ZVtfYnl0ZVRvSGV4W2ldXSA9IGk7XG59XG5cbi8vICoqYHBhcnNlKClgIC0gUGFyc2UgYSBVVUlEIGludG8gaXQncyBjb21wb25lbnQgYnl0ZXMqKlxuZnVuY3Rpb24gcGFyc2UocywgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSAoYnVmICYmIG9mZnNldCkgfHwgMCwgaWkgPSAwO1xuXG4gIGJ1ZiA9IGJ1ZiB8fCBbXTtcbiAgcy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1swLTlhLWZdezJ9L2csIGZ1bmN0aW9uKG9jdCkge1xuICAgIGlmIChpaSA8IDE2KSB7IC8vIERvbid0IG92ZXJmbG93IVxuICAgICAgYnVmW2kgKyBpaSsrXSA9IF9oZXhUb0J5dGVbb2N0XTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFplcm8gb3V0IHJlbWFpbmluZyBieXRlcyBpZiBzdHJpbmcgd2FzIHNob3J0XG4gIHdoaWxlIChpaSA8IDE2KSB7XG4gICAgYnVmW2kgKyBpaSsrXSA9IDA7XG4gIH1cblxuICByZXR1cm4gYnVmO1xufVxuXG4vLyAqKmB1bnBhcnNlKClgIC0gQ29udmVydCBVVUlEIGJ5dGUgYXJyYXkgKGFsYSBwYXJzZSgpKSBpbnRvIGEgc3RyaW5nKipcbmZ1bmN0aW9uIHVucGFyc2UoYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBvZmZzZXQgfHwgMCwgYnRoID0gX2J5dGVUb0hleDtcbiAgcmV0dXJuICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArXG4gICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICtcbiAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG4gICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICtcbiAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArXG4gICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV07XG59XG5cbi8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcbi8vXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svVVVJRC5qc1xuLy8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcblxuLy8gcmFuZG9tICMncyB3ZSBuZWVkIHRvIGluaXQgbm9kZSBhbmQgY2xvY2tzZXFcbnZhciBfc2VlZEJ5dGVzID0gX3JuZygpO1xuXG4vLyBQZXIgNC41LCBjcmVhdGUgYW5kIDQ4LWJpdCBub2RlIGlkLCAoNDcgcmFuZG9tIGJpdHMgKyBtdWx0aWNhc3QgYml0ID0gMSlcbnZhciBfbm9kZUlkID0gW1xuICBfc2VlZEJ5dGVzWzBdIHwgMHgwMSxcbiAgX3NlZWRCeXRlc1sxXSwgX3NlZWRCeXRlc1syXSwgX3NlZWRCeXRlc1szXSwgX3NlZWRCeXRlc1s0XSwgX3NlZWRCeXRlc1s1XVxuXTtcblxuLy8gUGVyIDQuMi4yLCByYW5kb21pemUgKDE0IGJpdCkgY2xvY2tzZXFcbnZhciBfY2xvY2tzZXEgPSAoX3NlZWRCeXRlc1s2XSA8PCA4IHwgX3NlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG5cbi8vIFByZXZpb3VzIHV1aWQgY3JlYXRpb24gdGltZVxudmFyIF9sYXN0TVNlY3MgPSAwLCBfbGFzdE5TZWNzID0gMDtcblxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9icm9vZmEvbm9kZS11dWlkIGZvciBBUEkgZGV0YWlsc1xuZnVuY3Rpb24gdjEob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG4gIHZhciBiID0gYnVmIHx8IFtdO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBjbG9ja3NlcSA9IG9wdGlvbnMuY2xvY2tzZXEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2xvY2tzZXEgOiBfY2xvY2tzZXE7XG5cbiAgLy8gVVVJRCB0aW1lc3RhbXBzIGFyZSAxMDAgbmFuby1zZWNvbmQgdW5pdHMgc2luY2UgdGhlIEdyZWdvcmlhbiBlcG9jaCxcbiAgLy8gKDE1ODItMTAtMTUgMDA6MDApLiAgSlNOdW1iZXJzIGFyZW4ndCBwcmVjaXNlIGVub3VnaCBmb3IgdGhpcywgc29cbiAgLy8gdGltZSBpcyBoYW5kbGVkIGludGVybmFsbHkgYXMgJ21zZWNzJyAoaW50ZWdlciBtaWxsaXNlY29uZHMpIGFuZCAnbnNlY3MnXG4gIC8vICgxMDAtbmFub3NlY29uZHMgb2Zmc2V0IGZyb20gbXNlY3MpIHNpbmNlIHVuaXggZXBvY2gsIDE5NzAtMDEtMDEgMDA6MDAuXG4gIHZhciBtc2VjcyA9IG9wdGlvbnMubXNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubXNlY3MgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAvLyBQZXIgNC4yLjEuMiwgdXNlIGNvdW50IG9mIHV1aWQncyBnZW5lcmF0ZWQgZHVyaW5nIHRoZSBjdXJyZW50IGNsb2NrXG4gIC8vIGN5Y2xlIHRvIHNpbXVsYXRlIGhpZ2hlciByZXNvbHV0aW9uIGNsb2NrXG4gIHZhciBuc2VjcyA9IG9wdGlvbnMubnNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubnNlY3MgOiBfbGFzdE5TZWNzICsgMTtcblxuICAvLyBUaW1lIHNpbmNlIGxhc3QgdXVpZCBjcmVhdGlvbiAoaW4gbXNlY3MpXG4gIHZhciBkdCA9IChtc2VjcyAtIF9sYXN0TVNlY3MpICsgKG5zZWNzIC0gX2xhc3ROU2VjcykvMTAwMDA7XG5cbiAgLy8gUGVyIDQuMi4xLjIsIEJ1bXAgY2xvY2tzZXEgb24gY2xvY2sgcmVncmVzc2lvblxuICBpZiAoZHQgPCAwICYmIG9wdGlvbnMuY2xvY2tzZXEgPT09IHVuZGVmaW5lZCkge1xuICAgIGNsb2Nrc2VxID0gY2xvY2tzZXEgKyAxICYgMHgzZmZmO1xuICB9XG5cbiAgLy8gUmVzZXQgbnNlY3MgaWYgY2xvY2sgcmVncmVzc2VzIChuZXcgY2xvY2tzZXEpIG9yIHdlJ3ZlIG1vdmVkIG9udG8gYSBuZXdcbiAgLy8gdGltZSBpbnRlcnZhbFxuICBpZiAoKGR0IDwgMCB8fCBtc2VjcyA+IF9sYXN0TVNlY3MpICYmIG9wdGlvbnMubnNlY3MgPT09IHVuZGVmaW5lZCkge1xuICAgIG5zZWNzID0gMDtcbiAgfVxuXG4gIC8vIFBlciA0LjIuMS4yIFRocm93IGVycm9yIGlmIHRvbyBtYW55IHV1aWRzIGFyZSByZXF1ZXN0ZWRcbiAgaWYgKG5zZWNzID49IDEwMDAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1dWlkLnYxKCk6IENhblxcJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjJyk7XG4gIH1cblxuICBfbGFzdE1TZWNzID0gbXNlY3M7XG4gIF9sYXN0TlNlY3MgPSBuc2VjcztcbiAgX2Nsb2Nrc2VxID0gY2xvY2tzZXE7XG5cbiAgLy8gUGVyIDQuMS40IC0gQ29udmVydCBmcm9tIHVuaXggZXBvY2ggdG8gR3JlZ29yaWFuIGVwb2NoXG4gIG1zZWNzICs9IDEyMjE5MjkyODAwMDAwO1xuXG4gIC8vIGB0aW1lX2xvd2BcbiAgdmFyIHRsID0gKChtc2VjcyAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5zZWNzKSAlIDB4MTAwMDAwMDAwO1xuICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gMTYgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsICYgMHhmZjtcblxuICAvLyBgdGltZV9taWRgXG4gIHZhciB0bWggPSAobXNlY3MgLyAweDEwMDAwMDAwMCAqIDEwMDAwKSAmIDB4ZmZmZmZmZjtcbiAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdG1oICYgMHhmZjtcblxuICAvLyBgdGltZV9oaWdoX2FuZF92ZXJzaW9uYFxuICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMTYgJiAweGZmO1xuXG4gIC8vIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYCAoUGVyIDQuMi4yIC0gaW5jbHVkZSB2YXJpYW50KVxuICBiW2krK10gPSBjbG9ja3NlcSA+Pj4gOCB8IDB4ODA7XG5cbiAgLy8gYGNsb2NrX3NlcV9sb3dgXG4gIGJbaSsrXSA9IGNsb2Nrc2VxICYgMHhmZjtcblxuICAvLyBgbm9kZWBcbiAgdmFyIG5vZGUgPSBvcHRpb25zLm5vZGUgfHwgX25vZGVJZDtcbiAgZm9yICh2YXIgbiA9IDA7IG4gPCA2OyBuKyspIHtcbiAgICBiW2kgKyBuXSA9IG5vZGVbbl07XG4gIH1cblxuICByZXR1cm4gYnVmID8gYnVmIDogdW5wYXJzZShiKTtcbn1cblxuLy8gKipgdjQoKWAgLSBHZW5lcmF0ZSByYW5kb20gVVVJRCoqXG5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYnJvb2ZhL25vZGUtdXVpZCBmb3IgQVBJIGRldGFpbHNcbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIC8vIERlcHJlY2F0ZWQgLSAnZm9ybWF0JyBhcmd1bWVudCwgYXMgc3VwcG9ydGVkIGluIHYxLjJcbiAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG5cbiAgaWYgKHR5cGVvZihvcHRpb25zKSA9PSAnc3RyaW5nJykge1xuICAgIGJ1ZiA9IG9wdGlvbnMgPT0gJ2JpbmFyeScgPyBuZXcgQXJyYXkoMTYpIDogbnVsbDtcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBfcm5nKSgpO1xuXG4gIC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcbiAgcm5kc1s2XSA9IChybmRzWzZdICYgMHgwZikgfCAweDQwO1xuICBybmRzWzhdID0gKHJuZHNbOF0gJiAweDNmKSB8IDB4ODA7XG5cbiAgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG4gIGlmIChidWYpIHtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgMTY7IGlpKyspIHtcbiAgICAgIGJ1ZltpICsgaWldID0gcm5kc1tpaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZiB8fCB1bnBhcnNlKHJuZHMpO1xufVxuXG4vLyBFeHBvcnQgcHVibGljIEFQSVxudmFyIHV1aWQgPSB2NDtcbnV1aWQudjEgPSB2MTtcbnV1aWQudjQgPSB2NDtcbnV1aWQucGFyc2UgPSBwYXJzZTtcbnV1aWQudW5wYXJzZSA9IHVucGFyc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gdXVpZDtcbiIsIid1c2Ugc3RyaWN0JztcclxudmFyIENvbnN0YW50cyA9IHt9O1xyXG5Db25zdGFudHMuRGVmYXVsdFRha2VJdGVtc0NvdW50ID0gNTA7XHJcbkNvbnN0YW50cy5FeHBhbmRFeHByZXNzaW9uTmFtZSA9ICdFeHBhbmQnO1xyXG5Db25zdGFudHMuUmV0dXJuQXNGaWVsZE5hbWUgPSAnUmV0dXJuQXMnO1xyXG5Db25zdGFudHMuRmllbGRzRXhwcmVzc2lvbk5hbWUgPSAnRmllbGRzJztcclxuQ29uc3RhbnRzLlNpbmdsZUZpZWxkRXhwcmVzc2lvbk5hbWUgPSAnU2luZ2xlRmllbGQnO1xyXG5Db25zdGFudHMuU29ydEV4cHJlc3Npb25OYW1lID0gJ1NvcnQnO1xyXG5Db25zdGFudHMuRmlsdGVyRXhwcmVzc2lvbk5hbWUgPSAnRmlsdGVyJztcclxuQ29uc3RhbnRzLlNraXBFeHByZXNzaW9uTmFtZSA9ICdTa2lwJztcclxuQ29uc3RhbnRzLlRha2VFeHByZXNzaW9uTmFtZSA9ICdUYWtlJztcclxuQ29uc3RhbnRzLlBhcmVudFJlbGF0aW9uRmllbGROYW1lID0gJ1BhcmVudFJlbGF0aW9uRmllbGQnO1xyXG5Db25zdGFudHMuSWRGaWVsZE5hbWVDbGllbnQgPSAnSWQnO1xyXG5Db25zdGFudHMuVGFyZ2V0VHlwZU5hbWVGaWVsZE5hbWUgPSAnVGFyZ2V0VHlwZU5hbWUnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb25zdGFudHM7IiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgQ29uc3RhbnRzID0gcmVxdWlyZSgnLi9Db25zdGFudHMnKTtcclxuXHJcbi8qKlxyXG4gKiBBIGNsYXNzIHRoYXQgaXMgdXNlZCB0byBnZXQgYWxsIHJlcXVpcmVkIGluZm9ybWF0aW9uIGluIG9yZGVyIHRvIHByb2Nlc3MgYSBzZXQgb2YgcmVsYXRpb25zLlxyXG4gKiBAcGFyYW0gcGFyZW50IC0gQW4gRXhlY3V0aW9uTm9kZSBpbnN0YW5jZSB1c2VkIHRvIHN1cHBseSB0aGUgdHJlZSBsaWtlIGRhdGEgc3RydWN0dXJlLlxyXG4gKiBAcGFyYW0gcmVsYXRpb25Ob2RlIC0gVGhlIHJlbGF0aW9uIG5vZGUgdXNlZCB0byBjcmVhdGVkIHRoZSBFeGVjdXRpb25Ob2RlIGluc3RhbmNlIChFeGVjdXRpb25Ob2RlIGluc3RhbmNlIHNob3VsZCBjb250YWluIG9uZSBvciBtYW55IHJlbGF0aW9uc1xyXG4gKiBpZiB0aGV5IGNhbiBiZSBjb21iaW5lZCBmb3IgYmF0Y2ggZXhlY3V0aW9uKS5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG52YXIgRXhlY3V0aW9uTm9kZSA9IGZ1bmN0aW9uIChwYXJlbnQsIHJlbGF0aW9uTm9kZSkge1xyXG4gICAgdmFyIHBhcmVudFBhdGggPSAnJztcclxuICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICBwYXJlbnRQYXRoID0gcGFyZW50LnBhdGg7XHJcbiAgICB9XHJcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudFBhdGg7XHJcbiAgICB0aGlzLnJlbGF0aW9ucyA9IFtyZWxhdGlvbk5vZGUucGF0aF07XHJcbiAgICB0aGlzLm5hbWUgPSByZWxhdGlvbk5vZGUucGF0aDtcclxuICAgIHRoaXMudGFyZ2V0VHlwZU5hbWUgPSByZWxhdGlvbk5vZGUudGFyZ2V0VHlwZU5hbWU7XHJcbiAgICB0aGlzLmNhbkFkZE90aGVyUmVsYXRpb25zID0gIXJlbGF0aW9uTm9kZS5maWx0ZXJFeHByZXNzaW9uICYmICFyZWxhdGlvbk5vZGUuc29ydEV4cHJlc3Npb24gJiYgIXJlbGF0aW9uTm9kZS50YWtlICYmICFyZWxhdGlvbk5vZGUuc2tpcDtcclxuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcclxuICAgIHZhciBwYXRoID0gJyc7XHJcbiAgICBpZiAocGFyZW50UGF0aCkge1xyXG4gICAgICAgIHBhdGggKz0gcGFyZW50UGF0aCArICcuJztcclxuICAgIH1cclxuICAgIHBhdGggKz0gcmVsYXRpb25Ob2RlLnRhcmdldFR5cGVOYW1lO1xyXG4gICAgdGhpcy5wYXRoID0gcGF0aDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbnNlcnRzIGEgUmVsYXRpb25Ob2RlIHRvIGFuIEV4ZWN1dGlvbk5vZGUuXHJcbiAqIEBwYXJhbSByZWxhdGlvbiAtIEEgUmVsYXRpb24gaW5zdGFuY2UuXHJcbiAqL1xyXG5FeGVjdXRpb25Ob2RlLnByb3RvdHlwZS5pbnNlcnRSZWxhdGlvbk5vZGUgPSBmdW5jdGlvbiAocmVsYXRpb24pIHtcclxuICAgIHRoaXMucmVsYXRpb25zLnB1c2gocmVsYXRpb24ucGF0aCk7XHJcbn07XHJcblxyXG4vKipcclxuICogSW5zZXJ0cyBhIGNoaWxkIG5vZGUgKHdoaWNoIHJlbGF0aW9ucykgZGVwZW5kcyBmcm9tIHBhcmVudCBub2RlIHJlc3VsdC5cclxuICogQHBhcmFtIGNoaWxkIC0gRXhlY3V0aW9uTm9kZSBpbnN0YW5jZSByZXByZXNlbnRpbmcgY2hpbGQgbm9kZS5cclxuICovXHJcbkV4ZWN1dGlvbk5vZGUucHJvdG90eXBlLmluc2VydENoaWxkcmVuTm9kZSA9IGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkLm5hbWUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEhlbHBlciBtZXRob2QgdGhhdCBjaGVja3MgaWYgc29tZSByZWxhdGlvbnMgY291bGQgYmUgY29tYmluZWQgKGZvciBleGFtcGxlIGhhdmUgc2FtZSBUYXJnZXRUeXBlKS5cclxuICogQHBhcmFtIHJlbGF0aW9uXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuRXhlY3V0aW9uTm9kZS5wcm90b3R5cGUuY2FuQ29tYmluZVdpdGhSZWxhdGlvbiA9IGZ1bmN0aW9uIChyZWxhdGlvbikge1xyXG4gICAgaWYgKCF0aGlzLmNhbkFkZE90aGVyUmVsYXRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLnRhcmdldFR5cGVOYW1lID09PSByZWxhdGlvbi50YXJnZXRUeXBlTmFtZSAmJiAhcmVsYXRpb24uZmlsdGVyRXhwcmVzc2lvbiAmJiAhcmVsYXRpb24uc29ydEV4cHJlc3Npb24gJiYgIXJlbGF0aW9uLnRha2UgJiYgIXJlbGF0aW9uLnNraXA7XHJcbn07XHJcblxyXG4vKiogRXhlY3V0aW9uVHJlZVxyXG4gKiBDbGFzcyB0aGF0IGFsbG93cyB0aGUgY3JlYXRpb24gb2YgYW4gZXhlY3V0aW9uIHRyZWUgZnJvbSBhIHJlbGF0aW9uVHJlZS4gVXNlZCB0byBwcm9jZXNzIGFsbCBxdWVyaWVzIChtYXN0ZXIgYW5kIGNoaWxkKSBpbiBhIGNvcnJlY3Qgb3JkZXIuXHJcbiAqIEBwYXJhbSByZWxhdGlvblRyZWUgLSBBbiBpbnN0YW5jZSBvZiByZWxhdGlvbiB0cmVlLlxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBFeGVjdXRpb25UcmVlID0gZnVuY3Rpb24gKHJlbGF0aW9uVHJlZSkge1xyXG4gICAgdGhpcy5fcmVsYXRpb25UcmVlID0gcmVsYXRpb25UcmVlO1xyXG4gICAgdGhpcy5fbWFwID0ge307XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyBleGVjdXRpb24gbm9kZSB0byB0aGUgRXhlY3V0aW9uVHJlZS5cclxuICogQHBhcmFtIGV4ZWN1dGlvbk5vZGVcclxuICovXHJcbkV4ZWN1dGlvblRyZWUucHJvdG90eXBlLmFkZEV4ZWN1dGlvbk5vZGUgPSBmdW5jdGlvbiAoZXhlY3V0aW9uTm9kZSkge1xyXG4gICAgdGhpcy5fbWFwW2V4ZWN1dGlvbk5vZGUubmFtZV0gPSBleGVjdXRpb25Ob2RlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEZpbmRzIHRoZSBFeGVjdXRpb25Ob2RlIHdoaWNoIGNvbnRhaW5zIHRoZSByZXF1ZXN0ZWQgcmVsYXRpb24uXHJcbiAqIEBwYXJhbSByZWxhdGlvbiAtIEEgUmVsYXRpb24gaW5zdGFuY2UuXHJcbiAqIEByZXR1cm5zIHsqfVxyXG4gKi9cclxuRXhlY3V0aW9uVHJlZS5wcm90b3R5cGUuZ2V0RXhlY3V0aW9uTm9kZU9mUmVsYXRpb24gPSBmdW5jdGlvbiAocmVsYXRpb24pIHtcclxuICAgIGZvciAodmFyIGV4ZWNOb2RlIGluIHRoaXMuX21hcCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9tYXAuaGFzT3duUHJvcGVydHkoZXhlY05vZGUpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXBbZXhlY05vZGVdLnJlbGF0aW9ucy5pbmRleE9mKHJlbGF0aW9uKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFwW2V4ZWNOb2RlXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEZpbmRzIGEgUmVsYXRpb25Ob2RlIHdpdGhpbiB0aGUgUmVsYXRpb25UcmVlLlxyXG4gKiBAcGFyYW0gcmVsYXRpb24gLSBTdHJpbmcgdGhhdCByZXByZXNlbnRzIHRoZSByZWxhdGlvbiB3aXRoaW4gdGhlIFJlbGF0aW9uVHJlZSAoZm9yIGV4YW1wbGU6IEFjdGl2aXRpZXMuTGlrZXMuUm9sZSkuXHJcbiAqIEByZXR1cm5zIHsqfVxyXG4gKi9cclxuRXhlY3V0aW9uVHJlZS5wcm90b3R5cGUuZ2V0UmVsYXRpb25Ob2RlID0gZnVuY3Rpb24gKHJlbGF0aW9uKSB7XHJcbiAgICBpZiAocmVsYXRpb24pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVsYXRpb25UcmVlW3JlbGF0aW9uXSB8fCBudWxsO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufTtcclxuXHJcbkV4ZWN1dGlvblRyZWUucHJvdG90eXBlLmdldFJvb3RSZWxhdGlvbk5vZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcmVsYXRpb25UcmVlW3RoaXMuX3JlbGF0aW9uVHJlZS4kcm9vdF0gfHwgbnVsbDtcclxufTtcclxuLyoqXHJcbiAqIEJ1aWxkcyB0aGUgRXhlY3V0aW9uVHJlZSBmcm9tIGEgUmVsYXRpb25UcmVlLlxyXG4gKi9cclxuRXhlY3V0aW9uVHJlZS5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAvL2J1aWxkIGJlZ2lubmluZyBmcm9tIHRoZSByb290XHJcbiAgICB2YXIgcmVsYXRpb25Sb290ID0gdGhpcy5nZXRSZWxhdGlvbk5vZGUodGhpcy5fcmVsYXRpb25UcmVlLiRyb290KTtcclxuICAgIC8vU2V0dXAgdGhlIHJvb3Qgb2YgdGhlIGV4ZWN1dGlvbiB0cmVlLlxyXG4gICAgdmFyIHJvb3RFeGVjdXRpb25Ob2RlID0gbmV3IEV4ZWN1dGlvbk5vZGUobnVsbCwgcmVsYXRpb25Sb290KTsvL25vIHBhcmVudCBub2RlXHJcbiAgICB0aGlzLmFkZEV4ZWN1dGlvbk5vZGUocm9vdEV4ZWN1dGlvbk5vZGUpO1xyXG4gICAgdGhpcy5idWlsZEludGVybmFsKHJlbGF0aW9uUm9vdCk7XHJcbn07XHJcblxyXG4vKipcclxuICogVHJhdmVyc2UgdGhlIHJlbGF0aW9uIHRyZWUgYW5kIGJ1aWxkIHRoZSBleGVjdXRpb24gdHJlZS5cclxuICogQHBhcmFtIHJlbGF0aW9uUm9vdCAtIFRoZSByb290IG5vZGUgb2YgdGhlIFJlbGF0aW9uVHJlZS5cclxuICovXHJcbkV4ZWN1dGlvblRyZWUucHJvdG90eXBlLmJ1aWxkSW50ZXJuYWwgPSBmdW5jdGlvbiAocmVsYXRpb25Sb290KSB7XHJcbiAgICByZWxhdGlvblJvb3QuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICB2YXIgY2hpbGRSZWxhdGlvbk5vZGUgPSB0aGlzLmdldFJlbGF0aW9uTm9kZShjaGlsZCk7XHJcbiAgICAgICAgdGhpcy5pbnNlcnRSZWxhdGlvbk5vZGVJbkV4ZWN1dGlvblRyZWUoY2hpbGRSZWxhdGlvbk5vZGUpO1xyXG4gICAgICAgIHRoaXMuYnVpbGRJbnRlcm5hbChjaGlsZFJlbGF0aW9uTm9kZSk7XHJcbiAgICB9LCB0aGlzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbnNlcnRzIGEgcmVsYXRpb24gbm9kZSB3aXRoaW4gdGhlIGV4ZWN1dGlvbiB0cmVlIChiYXNlZCBvbiBpdHMgZGVwZW5kZW5jaWVzKS5cclxuICogQHBhcmFtIHJlbGF0aW9uIC0gVGhlIHJlbGF0aW9uIHRoYXQgd2lsbCBiZSBpbnNlcnRlZC5cclxuICovXHJcbkV4ZWN1dGlvblRyZWUucHJvdG90eXBlLmluc2VydFJlbGF0aW9uTm9kZUluRXhlY3V0aW9uVHJlZSA9IGZ1bmN0aW9uIChyZWxhdGlvbikge1xyXG4gICAgdmFyIHJvb3RFeGVjdXRpb25Ob2RlID0gdGhpcy5nZXRFeGVjdXRpb25Ob2RlT2ZSZWxhdGlvbihyZWxhdGlvbi5wYXJlbnQpO1xyXG4gICAgdmFyIGNoaWxkVG9Db21iaW5lID0gdGhpcy50cnlHZXRDaGlsZE5vZGVUb0NvbWJpbmUocm9vdEV4ZWN1dGlvbk5vZGUsIHJlbGF0aW9uKTtcclxuICAgIGlmIChjaGlsZFRvQ29tYmluZSkgey8vaWYgdGhlcmUgaXMgYSBjaGlsZCB0aGF0IHdlIGNvbWJpbmUgdGhlIHJlbGF0aW9uXHJcbiAgICAgICAgY2hpbGRUb0NvbWJpbmUuaW5zZXJ0UmVsYXRpb25Ob2RlKHJlbGF0aW9uKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIG5ld0V4ZWN1dGlvbk5vZGUgPSBuZXcgRXhlY3V0aW9uTm9kZShyb290RXhlY3V0aW9uTm9kZSwgcmVsYXRpb24pOy8vY3JlYXRlIGEgc2VwYXJhdGUgZXhlY3V0aW9uIG5vZGUgdGhhdCB3aWxsIGhvc3QgdGhlIHJlbGF0aW9uXHJcbiAgICAgICAgcm9vdEV4ZWN1dGlvbk5vZGUuaW5zZXJ0Q2hpbGRyZW5Ob2RlKG5ld0V4ZWN1dGlvbk5vZGUpO1xyXG4gICAgICAgIHRoaXMuYWRkRXhlY3V0aW9uTm9kZShuZXdFeGVjdXRpb25Ob2RlKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBUcmllcyB0byBmaW5kIGFuIEV4ZWN1dGlvbk5vZGUgd2hpY2ggY291bGQgYmUgY29tYmluZWQgd2l0aCBhIHJlbGF0aW9uLlxyXG4gKiBAcGFyYW0gcm9vdEV4ZWN1dGlvbk5vZGUgLSBUaGUgcm9vdCBub2RlIG9mIHRoZSBFeGVjdXRpb25UcmVlLlxyXG4gKiBAcGFyYW0gcmVsYXRpb24gLSBSZWxhdGlvbiB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIEV4ZWN1dGlvblRyZWUuXHJcbiAqIEByZXR1cm5zIHsqfVxyXG4gKi9cclxuRXhlY3V0aW9uVHJlZS5wcm90b3R5cGUudHJ5R2V0Q2hpbGROb2RlVG9Db21iaW5lID0gZnVuY3Rpb24gKHJvb3RFeGVjdXRpb25Ob2RlLCByZWxhdGlvbikge1xyXG4gICAgaWYgKHJvb3RFeGVjdXRpb25Ob2RlLmNhbkNvbWJpbmVXaXRoUmVsYXRpb24ocmVsYXRpb24pKSB7XHJcbiAgICAgICAgcmV0dXJuIHJvb3RFeGVjdXRpb25Ob2RlO1xyXG4gICAgfVxyXG4gICAgdmFyIGNoaWxkcmVuID0gcm9vdEV4ZWN1dGlvbk5vZGUuY2hpbGRyZW47XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5fbWFwW2NoaWxkcmVuW2ldXTtcclxuICAgICAgICB2YXIgY2hpbGRUb0NvbWJpbmUgPSB0aGlzLnRyeUdldENoaWxkTm9kZVRvQ29tYmluZShjaGlsZCwgcmVsYXRpb24pO1xyXG4gICAgICAgIGlmIChjaGlsZFRvQ29tYmluZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY2hpbGRUb0NvbWJpbmU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgZmlsdGVyIGV4cHJlc3Npb24gZnJvbSBhbGwgcmVsYXRpb25zIGluc2lkZSBhbiBFeGVjdXRpb25Ob2RlLlxyXG4gKiBAcGFyYW0gZXhlY3V0aW9uTm9kZSAtIFRoZSBFeGVjdXRpb25Ob2RlIGluc3RhbmNlLlxyXG4gKiBAcmV0dXJucyB7e319XHJcbiAqL1xyXG5FeGVjdXRpb25UcmVlLnByb3RvdHlwZS5nZXRGaWx0ZXJGcm9tRXhlY3V0aW9uTm9kZSA9IGZ1bmN0aW9uIChleGVjdXRpb25Ob2RlLCBpbmNsdWRlQXJyYXlzKSB7XHJcbiAgICB2YXIgZmlsdGVyID0ge307XHJcbiAgICB2YXIgc3ViUmVsYXRpb25zRmlsdGVyID0gW107XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4ZWN1dGlvbk5vZGUucmVsYXRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGlubmVyRmlsdGVyID0gdGhpcy5nZXRGaWx0ZXJGcm9tU2luZ2xlUmVsYXRpb24odGhpcy5fcmVsYXRpb25UcmVlW2V4ZWN1dGlvbk5vZGUucmVsYXRpb25zW2ldXSwgaW5jbHVkZUFycmF5cyk7XHJcbiAgICAgICAgaWYgKGlubmVyRmlsdGVyKSB7XHJcbiAgICAgICAgICAgIHN1YlJlbGF0aW9uc0ZpbHRlci5wdXNoKGlubmVyRmlsdGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHN1YlJlbGF0aW9uc0ZpbHRlci5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgZmlsdGVyLiRvciA9IHN1YlJlbGF0aW9uc0ZpbHRlcjtcclxuICAgIH0gZWxzZSBpZiAoc3ViUmVsYXRpb25zRmlsdGVyLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBmaWx0ZXIgPSBzdWJSZWxhdGlvbnNGaWx0ZXJbMF07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZpbHRlciA9IG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmlsdGVyO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgZmlsdGVyIGV4cHJlc3Npb24gZnJvbSBhIHNpbmdsZSByZWxhdGlvbi4gVHJhdmVyc2UgdGhlIHJlbGF0aW9uIHRyZWUgaW4gb3JkZXIgdG8gZ2V0IHRoZSBcIklkXCJzIGZyb20gdGhlIHJlc3VsdCBvZiBwYXJlbnQgcmVsYXRpb25cclxuICogYWxvbmcgd2l0aCB1c2VyIGRlZmluZWQgZmlsdGVycy5cclxuICogQHBhcmFtIHJlbGF0aW9uIC0gQSBSZWxhdGlvbiBpbnN0YW5jZS5cclxuICogQHJldHVybnMgeyp9XHJcbiAqL1xyXG5FeGVjdXRpb25UcmVlLnByb3RvdHlwZS5nZXRGaWx0ZXJGcm9tU2luZ2xlUmVsYXRpb24gPSBmdW5jdGlvbiAocmVsYXRpb24sIGluY2x1ZGVBcnJheXMpIHtcclxuICAgIHZhciB1c2VyRGVmaW5lZEZpbHRlciA9IHJlbGF0aW9uLmZpbHRlckV4cHJlc3Npb247XHJcbiAgICB2YXIgcGFyZW50UmVsYXRpb25GaWx0ZXIgPSB7fTtcclxuICAgIHZhciBwYXJlbnRSZWxhdGlvbklkcyA9IHRoaXMuZ2V0UmVsYXRpb25GaWVsZFZhbHVlcyhyZWxhdGlvbiwgaW5jbHVkZUFycmF5cyk7XHJcbiAgICB2YXIgcGFyZW50UmVsYXRpb25GaWVsZE5hbWUgPSAocmVsYXRpb24uaXNJbnZlcnRlZFJlbGF0aW9uID8gcmVsYXRpb24ucmVsYXRpb25GaWVsZCA6IENvbnN0YW50cy5JZEZpZWxkTmFtZUNsaWVudCk7XHJcblxyXG4gICAgaWYgKHBhcmVudFJlbGF0aW9uSWRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBwYXJlbnRSZWxhdGlvbkZpbHRlcltwYXJlbnRSZWxhdGlvbkZpZWxkTmFtZV0gPSB7JyRpbic6IHBhcmVudFJlbGF0aW9uSWRzfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHVzZXJEZWZpbmVkRmlsdGVyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB2YXIgZmlsdGVycyA9IFtdO1xyXG4gICAgICAgIGZpbHRlcnMucHVzaChwYXJlbnRSZWxhdGlvbkZpbHRlcik7XHJcbiAgICAgICAgZmlsdGVycy5wdXNoKHVzZXJEZWZpbmVkRmlsdGVyKTtcclxuICAgICAgICByZXR1cm4geyckYW5kJzogZmlsdGVyc307XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBwYXJlbnRSZWxhdGlvbkZpbHRlcjtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgcmVsYXRpb24gZmllbGQgdmFsdWVzIG9mIHBhcmVudCByZWxhdGlvbiBpbiBvcmRlciB0byBjb25zdHJ1Y3QgYSBwcm9wZXIgZmlsdGVyICh0byBjcmVhdGUgYSByZWxhdGlvbikuXHJcbiAqIEBwYXJhbSByZWxhdGlvbiAtIEEgcmVsYXRpb24gaW5zdGFuY2Ugd2hpY2ggd2lsbCBnZXQgdGhlIGZpbHRlci5cclxuICogQHBhcmFtIGluY2x1ZGVBcnJheXMgLSBXaGV0aGVyIHRvIGluY2x1ZGUgYXJyYXkgdmFsdXMgb2YgdGhlIHBhcmVudCBpdGVtcyB3aGVuIGNhbGN1bGF0aW5nIHRoZSBpdGVtcyB0aGF0IHdpbGwgYmUgZXhwYW5kZWQgb24gdGhlIGN1cnJlbnQgbGV2ZWwuXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gLSBBbiBhcnJheSBvZiByZWxhdGlvbiBmaWVsZCB2YWx1ZXMuXHJcbiAqL1xyXG5FeGVjdXRpb25UcmVlLnByb3RvdHlwZS5nZXRSZWxhdGlvbkZpZWxkVmFsdWVzID0gZnVuY3Rpb24gKHJlbGF0aW9uLCBpbmNsdWRlQXJyYXlzKSB7XHJcbiAgICB2YXIgcGFyZW50UmVsYXRpb25JZHMgPSBbXTtcclxuICAgIHZhciBwYXJlbnRSZWxhdGlvbiA9IHRoaXMuX3JlbGF0aW9uVHJlZVtyZWxhdGlvbi5wYXJlbnRdO1xyXG4gICAgLy8gcGFyZW50UmVsYXRpb25SZXN1bHQgYWN0dWFsbHkgaXMgYW4gQWN0aXZpdHkgb3IgQXJyYXkgb2YgQWN0aXZpdGllc1xyXG4gICAgdmFyIHBhcmVudFJlbGF0aW9uUmVzdWx0ID0gQXJyYXkuaXNBcnJheShwYXJlbnRSZWxhdGlvbi5yZXN1bHQpID8gcGFyZW50UmVsYXRpb24ucmVzdWx0IDogW3BhcmVudFJlbGF0aW9uLnJlc3VsdF07XHJcbiAgICBpZiAocmVsYXRpb24uaXNJbnZlcnRlZFJlbGF0aW9uKSB7XHJcbiAgICAgICAgZm9yICh2YXIgcCA9IDA7IHAgPCBwYXJlbnRSZWxhdGlvblJlc3VsdC5sZW5ndGg7IHArKykge1xyXG4gICAgICAgICAgICBwYXJlbnRSZWxhdGlvbklkcy5wdXNoKHBhcmVudFJlbGF0aW9uUmVzdWx0W3BdW3JlbGF0aW9uLnBhcmVudFJlbGF0aW9uRmllbGRdKTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIGFsbCBjb21tZW50cyBhcmUgcmVsYXRlZCB0byBleHBhbmQgb2YgdHlwZSBjb250ZW50IHR5cGUgQWN0aXZpdGllcyBleHBhbmQ6IHtcIkxpa2VzXCI6IHRydWV9XHJcbiAgICAgICAgaWYgKHBhcmVudFJlbGF0aW9uICYmIHBhcmVudFJlbGF0aW9uLnJlc3VsdCkge1xyXG4gICAgICAgICAgICByZWxhdGlvbi5wYXJlbnRSZWxhdGlvbklkcyA9IHJlbGF0aW9uLnBhcmVudFJlbGF0aW9uSWRzIHx8IHt9O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudFJlbGF0aW9uUmVzdWx0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpdGVtRnJvbVBhcmVudFJlbGF0aW9uIGlzIHNpbmdsZSBBY3Rpdml0eVxyXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1Gcm9tUGFyZW50UmVsYXRpb24gPSBwYXJlbnRSZWxhdGlvblJlc3VsdFtpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBwYXJlbnRSZWxhdGlvbkZpZWxkVmFsdWUgaXMgQWN0aXZpdHkuTGlrZXNcclxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRSZWxhdGlvbkZpZWxkVmFsdWUgPSBpdGVtRnJvbVBhcmVudFJlbGF0aW9uW3JlbGF0aW9uLnJlbGF0aW9uRmllbGRdO1xyXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyZW50UmVsYXRpb25GaWVsZFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbGF0aW9uLmhhc0FycmF5VmFsdWVzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZUFycmF5cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBhcmVudFJlbGF0aW9uRmllbGRWYWx1ZS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXRlbVRvRXhwYW5kSWQgaXMgY3VycmVudCB2YWx1ZSBpbiBBY3Rpdml0eS5MaWtlcyBhcnJheSBvciBqdXN0IGEgc2luZ2xlIFwiSWRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1Ub0V4cGFuZElkID0gcGFyZW50UmVsYXRpb25GaWVsZFZhbHVlW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXRlbVRvRXhwYW5kSWQgIT09IHVuZGVmaW5lZCAmJiBpdGVtVG9FeHBhbmRJZCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFJlbGF0aW9uSWRzLnB1c2goaXRlbVRvRXhwYW5kSWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHNldCBhbnkgdmFsdWUganVzdCB0byBjcmVhdGUgYSBtYXAgb2YgSWRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRpb24ucGFyZW50UmVsYXRpb25JZHNbaXRlbVRvRXhwYW5kSWRdID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYocGFyZW50UmVsYXRpb25GaWVsZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgcGFyZW50UmVsYXRpb25GaWVsZFZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFJlbGF0aW9uSWRzLnB1c2gocGFyZW50UmVsYXRpb25GaWVsZFZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRpb24ucGFyZW50UmVsYXRpb25JZHNbcGFyZW50UmVsYXRpb25GaWVsZFZhbHVlXSA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwYXJlbnRSZWxhdGlvbklkcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRXhlY3V0aW9uVHJlZTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG5mdW5jdGlvbiBFeHBhbmRFcnJvcihtZXNzYWdlKSB7XHJcbiAgICB0aGlzLm5hbWUgPSAnRXhwYW5kRXJyb3InO1xyXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcclxuICAgIHRoaXMuc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrO1xyXG59XHJcbkV4cGFuZEVycm9yLnByb3RvdHlwZSA9IG5ldyBFcnJvcjtcclxubW9kdWxlLmV4cG9ydHMgPSBFeHBhbmRFcnJvcjsiLCIndXNlIHN0cmljdCc7XHJcbnZhciBhc3luYyA9IHJlcXVpcmUoJ2FzeW5jJyk7XHJcbnZhciBSZWxhdGlvblRyZWVCdWlsZGVyID0gcmVxdWlyZSgnLi9SZWxhdGlvblRyZWVCdWlsZGVyJyk7XHJcbnZhciBFeGVjdXRpb25UcmVlID0gcmVxdWlyZSgnLi9FeGVjdXRpb25UcmVlJyk7XHJcbnZhciBDb25zdGFudHMgPSByZXF1aXJlKCcuL0NvbnN0YW50cycpO1xyXG52YXIgRXhwYW5kRXJyb3IgPSByZXF1aXJlKCcuL0V4cGFuZEVycm9yJyk7XHJcblxyXG5mdW5jdGlvbiBQcm9jZXNzb3Iob3B0aW9ucykge1xyXG4gICAgdGhpcy5fZXhlY3V0aW9uTm9kZUZ1bmN0aW9uID0gb3B0aW9ucy5leGVjdXRpb25Ob2RlRnVuY3Rpb247XHJcbiAgICB0aGlzLl9tZXRhZGF0YVByb3ZpZGVyRnVuY3Rpb24gPSBvcHRpb25zLm1ldGFkYXRhUHJvdmlkZXJGdW5jdGlvbjtcclxufVxyXG5cclxuUHJvY2Vzc29yLnByb3RvdHlwZS5fZ2V0RXhlY3V0aW9uVHJlZVJvb3QgPSBmdW5jdGlvbiAoZXhlY3V0aW9uVHJlZSkge1xyXG4gICAgdmFyIGV4ZWN1dGlvblRyZWVSb290ID0gbnVsbDtcclxuICAgIGZvciAodmFyIGV4Tm9kZSBpbiBleGVjdXRpb25UcmVlKSB7XHJcbiAgICAgICAgaWYgKGV4ZWN1dGlvblRyZWUuaGFzT3duUHJvcGVydHkoZXhOb2RlKSkge1xyXG4gICAgICAgICAgICBpZiAoZXhlY3V0aW9uVHJlZVtleE5vZGVdLnBhcmVudCA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgIGV4ZWN1dGlvblRyZWVSb290ID0gZXhlY3V0aW9uVHJlZVtleE5vZGVdO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXhlY3V0aW9uVHJlZVJvb3Q7XHJcbn07XHJcblxyXG5Qcm9jZXNzb3IucHJvdG90eXBlLl9jcmVhdGVFeGVjdXRlTm9kZUV4ZWN1dG9yID0gZnVuY3Rpb24gKHJlbGF0aW9uc1RyZWUsIGV4ZWN1dGlvblRyZWUsIGV4ZWN1dGlvbk5vZGUsIGV4cGFuZENvbnRleHQpIHtcclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgIHZhciByZWxhdGlvbnNUcmVlTWFwID0gcmVsYXRpb25zVHJlZS5tYXA7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGRvbmUpIHtcclxuICAgICAgICB2YXIgcmVsYXRpb25Ob2RlID0gZXhlY3V0aW9uVHJlZS5nZXRSZWxhdGlvbk5vZGUoZXhlY3V0aW9uTm9kZS5yZWxhdGlvbnNbMF0pOy8vZ2V0IHRoZSByZWxhdGlvbiBub2RlIGZvciB0aGUgb25seSByZWxhdGlvbiBvZiB0aGUgZXhlY3V0aW9uIG5vZGUuXHJcbiAgICAgICAgdmFyIHBhcmVudFJlbGF0aW9uTm9kZSA9IGV4ZWN1dGlvblRyZWUuZ2V0UmVsYXRpb25Ob2RlKHJlbGF0aW9uTm9kZS5wYXJlbnQpO1xyXG4gICAgICAgIHZhciBpbmNsdWRlQXJyYXlzID0gIShwYXJlbnRSZWxhdGlvbk5vZGUucGFyZW50ICYmIHBhcmVudFJlbGF0aW9uTm9kZS5oYXNBcnJheVZhbHVlcyk7IC8vb25seSBleHBhbmQgYXJyYXkgZmllbGRzIGlmIHRoZSBwYXJlbnQgcmVsYXRpb24gaXMgbm90IGFuIGFycmF5LiBUaGlzIG1lYW5zIHRoYXQgaWYgd2UgaGF2ZSBleHBhbmRlZCBhIExpa2VzIChtdWx0aXBsZSB0byBVc2VycyksIHdlIHdvbid0IGV4cGFuZCBhbnkgYXJyYXkgcmVsYXRpb25zIHRoYXQgYXJlIG5lc3RlZCBpbiBpdCBzdWNoIGFzIHRoZSBVc2VyQ29tbWVudHMgKG11bHRpcGxlIHJlbGF0aW9uIHRvIENvbW1lbnRzKS5cclxuICAgICAgICB2YXIgZmlsdGVyID0gZXhlY3V0aW9uVHJlZS5nZXRGaWx0ZXJGcm9tRXhlY3V0aW9uTm9kZShleGVjdXRpb25Ob2RlLCBpbmNsdWRlQXJyYXlzKTtcclxuXHJcbiAgICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IHJlbGF0aW9uc1RyZWUudmFsaWRhdGVTaW5nbGVSZWxhdGlvbihyZWxhdGlvbk5vZGUpO1xyXG4gICAgICAgIGlmIChlcnJvck1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRvbmUobmV3IEV4cGFuZEVycm9yKGVycm9yTWVzc2FnZSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBzdWNoIG9wdGlvbnMgZXhlY3V0aW9uTm9kZSBzaG91bGQgaGF2ZSBvbmx5IG9uZSByZWxhdGlvbi5cclxuICAgICAgICB2YXIgbm9kZSA9IHt9O1xyXG4gICAgICAgIG5vZGUuc2VsZWN0ID0gcmVsYXRpb25Ob2RlLmZpZWxkc0V4cHJlc3Npb247XHJcbiAgICAgICAgbm9kZS5zb3J0ID0gcmVsYXRpb25Ob2RlLnNvcnRFeHByZXNzaW9uO1xyXG4gICAgICAgIG5vZGUuc2tpcCA9IHJlbGF0aW9uTm9kZS5za2lwO1xyXG4gICAgICAgIG5vZGUudGFrZSA9IHJlbGF0aW9uTm9kZS50YWtlO1xyXG4gICAgICAgIG5vZGUuZmlsdGVyID0gZmlsdGVyO1xyXG4gICAgICAgIG5vZGUudGFyZ2V0VHlwZU5hbWUgPSByZWxhdGlvbk5vZGUudGFyZ2V0VHlwZU5hbWU7XHJcblxyXG4gICAgICAgIHNlbGYuX2V4ZWN1dGlvbk5vZGVGdW5jdGlvbi5jYWxsKG51bGwsIG5vZGUsIGV4cGFuZENvbnRleHQsIGZ1bmN0aW9uIG9uUHJvY2Vzc0V4ZWN1dGlvbk5vZGUoZXJyLCByZXN1bHQpIHtcclxuICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbmUoZXJyKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleGVjdXRpb25Ob2RlLnJlbGF0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkUmVsYXRpb24gPSByZWxhdGlvbnNUcmVlTWFwW2V4ZWN1dGlvbk5vZGUucmVsYXRpb25zW2ldXTtcclxuICAgICAgICAgICAgICAgIGNoaWxkUmVsYXRpb24ucmVzdWx0ID0gc2VsZi5fZXh0cmFjdFJlc3VsdEZvclJlbGF0aW9uKHJlbGF0aW9uc1RyZWVNYXBbZXhlY3V0aW9uTm9kZS5yZWxhdGlvbnNbaV1dLCByZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGV4ZWN1dGlvbk5vZGUucmVzdWx0ID0gY2hpbGRSZWxhdGlvbi5yZXN1bHQ7XHJcbiAgICAgICAgICAgIHZhciBhcnIgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBleGVjdXRpb25Ob2RlLmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXhlY3V0aW9uVHJlZU1hcCA9IGV4ZWN1dGlvblRyZWUuX21hcDtcclxuICAgICAgICAgICAgICAgIGFyci5wdXNoKHNlbGYuX2NyZWF0ZUV4ZWN1dGVOb2RlRXhlY3V0b3IocmVsYXRpb25zVHJlZSwgZXhlY3V0aW9uVHJlZSwgZXhlY3V0aW9uVHJlZU1hcFtleGVjdXRpb25Ob2RlLmNoaWxkcmVuW2pdXSwgZXhwYW5kQ29udGV4dCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFzeW5jLnBhcmFsbGVsKGFyciwgZG9uZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG59O1xyXG5cclxuUHJvY2Vzc29yLnByb3RvdHlwZS5fZ2V0U2luZ2xlUmVzdWx0ID0gZnVuY3Rpb24gKHJlbGF0aW9uc1RyZWUsIHJlbGF0aW9uLCBzaW5nbGVPYmplY3QpIHtcclxuICAgIGlmICghc2luZ2xlT2JqZWN0KSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNoaWxkUmVsYXRpb247XHJcbiAgICB2YXIgY2hpbGRJdGVtO1xyXG5cclxuICAgIC8vIGlmIHJlbGF0aW9uIGhhcyBzaW5nbGVGaWVsZE5hbWUgb3B0aW9uIHdlIGp1c3QgcmVwbGFjZSB0aGUgcGFyZW50IGlkIHdpdGggYSBzaW5nbGUgdmFsdWVcclxuICAgIGlmIChyZWxhdGlvbi5zaW5nbGVGaWVsZE5hbWUpIHtcclxuICAgICAgICBpZiAocmVsYXRpb24uY2hpbGRyZW4gJiYgcmVsYXRpb24uY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBjaGlsZFJlbGF0aW9uID0gcmVsYXRpb25zVHJlZVtyZWxhdGlvbi5jaGlsZHJlblswXV07XHJcbiAgICAgICAgICAgIGNoaWxkSXRlbSA9IHRoaXMuX2dldE9iamVjdEJ5SWRGcm9tQXJyYXkoY2hpbGRSZWxhdGlvbi5yZXN1bHQsIHNpbmdsZU9iamVjdFtyZWxhdGlvbi5zaW5nbGVGaWVsZE5hbWVdKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFNpbmdsZVJlc3VsdChyZWxhdGlvbnNUcmVlLCBjaGlsZFJlbGF0aW9uLCBjaGlsZEl0ZW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2luZ2xlT2JqZWN0W3JlbGF0aW9uLnNpbmdsZUZpZWxkTmFtZV07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgdmFyIHBhc3NlZFByb3BlcnRpZXMgPSB7fTtcclxuXHJcbiAgICBpZiAocmVsYXRpb24uY2hpbGRyZW4gJiYgcmVsYXRpb24uY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVsYXRpb24uY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgY2hpbGRSZWxhdGlvbiA9IHJlbGF0aW9uc1RyZWVbcmVsYXRpb24uY2hpbGRyZW5bal1dO1xyXG4gICAgICAgICAgICB2YXIgY2hpbGRSZWxhdGlvbkZpZWxkID0gY2hpbGRSZWxhdGlvbi5yZWxhdGlvbkZpZWxkO1xyXG4gICAgICAgICAgICB2YXIgdXNlckRlZmluZWRSZWxOYW1lID0gY2hpbGRSZWxhdGlvbi51c2VyRGVmaW5lZE5hbWU7XHJcbiAgICAgICAgICAgIGlmICghY2hpbGRSZWxhdGlvbi5pc0ludmVydGVkUmVsYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHBhc3NlZFByb3BlcnRpZXNbY2hpbGRSZWxhdGlvbkZpZWxkXSA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBpbm5lclJlbGF0aW9uUmVzdWx0ID0gY2hpbGRSZWxhdGlvbi5yZXN1bHQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoY2hpbGRSZWxhdGlvbi5pc0ludmVydGVkUmVsYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgaW5uZXJSZWxhdGlvblJlc3VsdC5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZFNpbmdsZVJlc3VsdFRvUGFyZW50QXJyYXkocmVsYXRpb25zVHJlZSwgY2hpbGRSZWxhdGlvbiwgaW5uZXJSZWxhdGlvblJlc3VsdFtrXSwgcmVzdWx0LCB1c2VyRGVmaW5lZFJlbE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0W3VzZXJEZWZpbmVkUmVsTmFtZV0gPSBjaGlsZFJlbGF0aW9uLmlzQXJyYXkoKSA/IFtdIDogbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc2luZ2xlT2JqZWN0W2NoaWxkUmVsYXRpb25GaWVsZF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzaW5nbGVPYmplY3RbY2hpbGRSZWxhdGlvbkZpZWxkXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkUmVsYXRpb24uc29ydEV4cHJlc3Npb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgc29ydGluZyB3ZSByZXBsYWNlIGl0ZW1zIHVzaW5nIG9yZGVyIG9mIHRoZSBxdWVyeSByZXN1bHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgaW5uZXJSZWxhdGlvblJlc3VsdC5sZW5ndGg7IHArKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaW5nbGVPYmplY3RbY2hpbGRSZWxhdGlvbkZpZWxkXS5pbmRleE9mKGlubmVyUmVsYXRpb25SZXN1bHRbcF0uSWQpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRJdGVtID0gaW5uZXJSZWxhdGlvblJlc3VsdFtwXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkU2luZ2xlUmVzdWx0VG9QYXJlbnRBcnJheShyZWxhdGlvbnNUcmVlLCBjaGlsZFJlbGF0aW9uLCBjaGlsZEl0ZW0sIHJlc3VsdCwgdXNlckRlZmluZWRSZWxOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBqdXN0IHJlcGxhY2UgaXRlbXMgZ2V0dGluZyB0aGVtIGJ5IGlkIHdoaWNoIHdlIGhhdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2luZ2xlT2JqZWN0W2NoaWxkUmVsYXRpb25GaWVsZF0ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZEl0ZW0gPSB0aGlzLl9nZXRPYmplY3RCeUlkRnJvbUFycmF5KGlubmVyUmVsYXRpb25SZXN1bHQsIHNpbmdsZU9iamVjdFtjaGlsZFJlbGF0aW9uRmllbGRdW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRTaW5nbGVSZXN1bHRUb1BhcmVudEFycmF5KHJlbGF0aW9uc1RyZWUsIGNoaWxkUmVsYXRpb24sIGNoaWxkSXRlbSwgcmVzdWx0LCB1c2VyRGVmaW5lZFJlbE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRJdGVtID0gdGhpcy5fZ2V0T2JqZWN0QnlJZEZyb21BcnJheShpbm5lclJlbGF0aW9uUmVzdWx0LCBzaW5nbGVPYmplY3RbY2hpbGRSZWxhdGlvbkZpZWxkXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFt1c2VyRGVmaW5lZFJlbE5hbWVdID0gdGhpcy5fZ2V0U2luZ2xlUmVzdWx0KHJlbGF0aW9uc1RyZWUsIGNoaWxkUmVsYXRpb24sIGNoaWxkSXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGFkZCBhbGwgb3RoZXIgZmllbGRzIHRvIHRoZSByZXN1bHQgKGV4Y2VwdCB0aGUgcmVsYXRpb24gZmllbGRzIHdoaWNoIHdlIGhhdmUgYWxyZWFkeSByZXBsYWNlZCkuXHJcbiAgICBmb3IgKHZhciBwcm9wIGluIHNpbmdsZU9iamVjdCkge1xyXG4gICAgICAgIHZhciBwcm9wZXJ0eVNob3VsZEJlQWRkZWRUb1Jlc3VsdCA9IHNpbmdsZU9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiAhcGFzc2VkUHJvcGVydGllc1twcm9wXSAmJlxyXG4gICAgICAgICAgICB0aGlzLl9maWVsZEV4aXN0SW5GaWVsZHNFeHByZXNzaW9uKHByb3AsIHJlbGF0aW9uLm9yaWdpbmFsRmllbGRzRXhwcmVzc2lvbik7XHJcbiAgICAgICAgaWYgKHByb3BlcnR5U2hvdWxkQmVBZGRlZFRvUmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdFtwcm9wXSA9IHNpbmdsZU9iamVjdFtwcm9wXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcblByb2Nlc3Nvci5wcm90b3R5cGUuX2FkZFNpbmdsZVJlc3VsdFRvUGFyZW50QXJyYXkgPSBmdW5jdGlvbiAocmVsYXRpb25zVHJlZSwgY2hpbGRSZWxhdGlvbiwgY2hpbGRJdGVtLCByZXN1bHQsIHVzZXJEZWZpbmVkUmVsTmFtZSkge1xyXG4gICAgdmFyIHNpbmdsZVJlc3VsdCA9IHRoaXMuX2dldFNpbmdsZVJlc3VsdChyZWxhdGlvbnNUcmVlLCBjaGlsZFJlbGF0aW9uLCBjaGlsZEl0ZW0pO1xyXG4gICAgcmVzdWx0W3VzZXJEZWZpbmVkUmVsTmFtZV0gPSByZXN1bHRbdXNlckRlZmluZWRSZWxOYW1lXSB8fCBbXTtcclxuICAgIGlmIChzaW5nbGVSZXN1bHQpIHtcclxuICAgICAgICByZXN1bHRbdXNlckRlZmluZWRSZWxOYW1lXS5wdXNoKHNpbmdsZVJlc3VsdCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGEgZmllbGQgd2lsbCBiZSByZXR1cm5lZCB2aWEgZ2l2ZW4gZmllbGRzIGV4cHJlc3Npb24uXHJcbiAqIEBwYXJhbSBmaWVsZCAtIFRoZSBuYW1lIG9mIHRoZSBmaWVsZC5cclxuICogQHBhcmFtIGZpZWxkc0V4cHJlc3Npb24gLSBUaGUgRmllbGRzIGV4cHJlc3Npb24gd2hpY2ggaXMgY2hlY2tlZC5cclxuICogQHJldHVybnMgeyp9XHJcbiAqL1xyXG5Qcm9jZXNzb3IucHJvdG90eXBlLl9maWVsZEV4aXN0SW5GaWVsZHNFeHByZXNzaW9uID0gZnVuY3Rpb24gKGZpZWxkLCBmaWVsZHNFeHByZXNzaW9uKSB7XHJcbiAgICBpZiAoZmllbGRzRXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkIHx8IE9iamVjdC5rZXlzKGZpZWxkc0V4cHJlc3Npb24pLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChmaWVsZCA9PT0gQ29uc3RhbnRzLklkRmllbGROYW1lQ2xpZW50KSB7XHJcbiAgICAgICAgaWYgKGZpZWxkc0V4cHJlc3Npb25bZmllbGRdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmaWVsZHNFeHByZXNzaW9uW2ZpZWxkXTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaXNFeGNsdXNpdmUgPSBSZWxhdGlvblRyZWVCdWlsZGVyLmdldElzRmllbGRzRXhwcmVzc2lvbkV4Y2x1c2l2ZShmaWVsZHNFeHByZXNzaW9uKTtcclxuXHJcbiAgICBpZiAoaXNFeGNsdXNpdmUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc0V4Y2x1c2l2ZSkge1xyXG4gICAgICAgIHJldHVybiAhZmllbGRzRXhwcmVzc2lvbi5oYXNPd25Qcm9wZXJ0eShmaWVsZCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmaWVsZHNFeHByZXNzaW9uLmhhc093blByb3BlcnR5KGZpZWxkKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBFeHRyYWN0cyB0aGUgcmVzdWx0IGZvciBhIHNpbmdsZSByZWxhdGlvbiAoaW4gY2FzZXMgd2hlbiBFeGVjdXRpb25Ob2RlIGNvbnRhaW5zIG1vcmUgdGhhbiBvbmUgcmVsYXRpb25zKS5cclxuICogQHBhcmFtIHJlbGF0aW9uIC0gVGhlIHJlbGF0aW9uIG9iamVjdC5cclxuICogQHBhcmFtIHF1ZXJ5UmVzdWx0IC0gUmVzdWx0IG9mIHRoZSBjb21iaW5lZCBxdWVyeS5cclxuICogQHJldHVybnMge0FycmF5fVxyXG4gKi9cclxuUHJvY2Vzc29yLnByb3RvdHlwZS5fZXh0cmFjdFJlc3VsdEZvclJlbGF0aW9uID0gZnVuY3Rpb24gKHJlbGF0aW9uLCBxdWVyeVJlc3VsdCkge1xyXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWVyeVJlc3VsdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChyZWxhdGlvbi5wYXJlbnRSZWxhdGlvbklkcykge1xyXG4gICAgICAgICAgICBpZiAocmVsYXRpb24ucGFyZW50UmVsYXRpb25JZHMuaGFzT3duUHJvcGVydHkocXVlcnlSZXN1bHRbaV0uSWQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChxdWVyeVJlc3VsdFtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlbGF0aW9uLmlzSW52ZXJ0ZWRSZWxhdGlvbikge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChxdWVyeVJlc3VsdFtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIGFuIG9iamVjdCB3aXRoIGEgZ2l2ZW4gSWQgZnJvbSBBcnJheS5cclxuICogQHBhcmFtIGFycmF5XHJcbiAqIEBwYXJhbSBpZFxyXG4gKiBAcmV0dXJucyB7Kn1cclxuICovXHJcblByb2Nlc3Nvci5wcm90b3R5cGUuX2dldE9iamVjdEJ5SWRGcm9tQXJyYXkgPSBmdW5jdGlvbiAoYXJyYXksIGlkKSB7XHJcbiAgICBpZiAoYXJyYXkpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChhcnJheVtpXS5JZCA9PT0gaWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheVtpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIGV4cGFuZEV4cHJlc3Npb25cclxuICogQHBhcmFtIG1haW5UeXBlTmFtZVxyXG4gKiBAcGFyYW0gaXNBcnJheVxyXG4gKiBAcGFyYW0gZmllbGRzRXhwcmVzc2lvblxyXG4gKiBAcGFyYW0gbWF4VGFrZVZhbHVlXHJcbiAqIEBwYXJhbSBwcmVwYXJlQ29udGV4dFxyXG4gKiBAcGFyYW0gZG9uZVxyXG4gKi9cclxuUHJvY2Vzc29yLnByb3RvdHlwZS5wcmVwYXJlID0gZnVuY3Rpb24gKGV4cGFuZEV4cHJlc3Npb24sIG1haW5UeXBlTmFtZSwgaXNBcnJheSwgZmllbGRzRXhwcmVzc2lvbiwgbWF4VGFrZVZhbHVlLCBwcmVwYXJlQ29udGV4dCwgZG9uZSkge1xyXG4gICAgdmFyIHJ0YiA9IG5ldyBSZWxhdGlvblRyZWVCdWlsZGVyKGV4cGFuZEV4cHJlc3Npb24sIG1haW5UeXBlTmFtZSwgaXNBcnJheSwgZmllbGRzRXhwcmVzc2lvbiwgbWF4VGFrZVZhbHVlLCB0aGlzLl9tZXRhZGF0YVByb3ZpZGVyRnVuY3Rpb24sIHByZXBhcmVDb250ZXh0KTtcclxuICAgIHJ0Yi5idWlsZChmdW5jdGlvbiAoZXJyLCBtYXApIHtcclxuICAgICAgICB2YXIgbWFpblF1ZXJ5RmllbGRzRXhwcmVzc2lvbjtcclxuICAgICAgICBpZiAobWFwKSB7XHJcbiAgICAgICAgICAgIG1haW5RdWVyeUZpZWxkc0V4cHJlc3Npb24gPSBtYXBbbWFwLiRyb290XS5maWVsZHNFeHByZXNzaW9uO1xyXG4gICAgICAgICAgICB2YXIgcHJlcGFyZVJlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgIHJlbGF0aW9uc1RyZWU6IHJ0YixcclxuICAgICAgICAgICAgICAgIG1haW5RdWVyeUZpZWxkc0V4cHJlc3Npb246IG1haW5RdWVyeUZpZWxkc0V4cHJlc3Npb25cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBkb25lKGVyciwgcHJlcGFyZVJlc3VsdCk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSByZWxhdGlvbnNUcmVlXHJcbiAqIEBwYXJhbSBtYWluUXVlcnlSZXN1bHRcclxuICogQHBhcmFtIGV4cGFuZENvbnRleHRcclxuICogQHBhcmFtIGRvbmVcclxuICovXHJcblByb2Nlc3Nvci5wcm90b3R5cGUuZXhwYW5kID0gZnVuY3Rpb24gKHJlbGF0aW9uc1RyZWUsIG1haW5RdWVyeVJlc3VsdCwgZXhwYW5kQ29udGV4dCwgZG9uZSkge1xyXG4gICAgdmFyIHJlbGF0aW9uc1RyZWVNYXAgPSByZWxhdGlvbnNUcmVlLm1hcDtcclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgIHZhciBleGVjdXRpb25UcmVlID0gbmV3IEV4ZWN1dGlvblRyZWUocmVsYXRpb25zVHJlZU1hcCk7XHJcbiAgICBleGVjdXRpb25UcmVlLmJ1aWxkKCk7XHJcbiAgICByZWxhdGlvbnNUcmVlTWFwW3JlbGF0aW9uc1RyZWVNYXAuJHJvb3RdLnJlc3VsdCA9IG1haW5RdWVyeVJlc3VsdDtcclxuICAgIHZhciBleGVjdXRpb25UcmVlTWFwID0gZXhlY3V0aW9uVHJlZS5fbWFwO1xyXG5cclxuICAgIHZhciBleGVjdXRpb25UcmVlUm9vdCA9IHRoaXMuX2dldEV4ZWN1dGlvblRyZWVSb290KGV4ZWN1dGlvblRyZWVNYXApO1xyXG5cclxuICAgIHZhciBtYXhRdWVyaWVzQ291bnQgPSAyMDtcclxuICAgIGlmIChPYmplY3Qua2V5cyhleGVjdXRpb25UcmVlTWFwKS5sZW5ndGggPiBtYXhRdWVyaWVzQ291bnQpIHtcclxuICAgICAgICBkb25lKG5ldyBFeHBhbmRFcnJvcignRXhwYW5kIGV4cHJlc3Npb24gcmVzdWx0cyBpbiBtb3JlIHRoYW4gJyArIG1heFF1ZXJpZXNDb3VudCArICcgaW5uZXIgcXVlcmllcyEnKSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGV4ZWN1dGlvblRyZWVSb290KSB7XHJcbiAgICAgICAgdmFyIGV4ZWNGdW5jcyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhlY3V0aW9uVHJlZVJvb3QuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZXhlY0Z1bmNzLnB1c2godGhpcy5fY3JlYXRlRXhlY3V0ZU5vZGVFeGVjdXRvcihyZWxhdGlvbnNUcmVlLCBleGVjdXRpb25UcmVlLCBleGVjdXRpb25UcmVlTWFwW2V4ZWN1dGlvblRyZWVSb290LmNoaWxkcmVuW2ldXSwgZXhwYW5kQ29udGV4dCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBleGVjRnVuY3MgYXJlIGZ1bmN0aW9ucyBjcmVhdGVkIGZvciBldmVyeSBzaW5nbGUgZXhlY3V0aW9uIG5vdGVcclxuICAgICAgICAvLyB3ZSBleGVjdXRlIHRoZW0gaW4gYXN5bmMsIHNpbmNlIHRoZSByZXN1bHQgb2YgdGhlIHBhcmVudCByZWxhdGlvbiBpcyB1c2VkIHRvIGdldCBjb3JyZWN0IGZpbHRlci5cclxuICAgICAgICBhc3luYy5zZXJpZXMoZXhlY0Z1bmNzLCBmdW5jdGlvbiBvblByb2Nlc3NFeGVjdXRpb25UcmVlKGVycikge1xyXG4gICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBkb25lKGVycik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHJvb3RSZWxhdGlvbiA9IHJlbGF0aW9uc1RyZWVNYXBbcmVsYXRpb25zVHJlZU1hcC4kcm9vdF07XHJcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtYWluUXVlcnlSZXN1bHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYWluUXVlcnlSZXN1bHQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpbmdsZVJlc3VsdCA9IHNlbGYuX2dldFNpbmdsZVJlc3VsdChyZWxhdGlvbnNUcmVlTWFwLCByb290UmVsYXRpb24sIG1haW5RdWVyeVJlc3VsdFtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaW5nbGVSZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHNpbmdsZVJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IHNlbGYuX2dldFNpbmdsZVJlc3VsdChyZWxhdGlvbnNUcmVlTWFwLCByb290UmVsYXRpb24sIG1haW5RdWVyeVJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkb25lKG51bGwsIG91dHB1dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufTtcclxuXHJcblByb2Nlc3Nvci5Db25zdGFudHMgPSBDb25zdGFudHM7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFByb2Nlc3NvcjtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgQ29uc3RhbnRzID0gcmVxdWlyZSgnLi9Db25zdGFudHMnKTtcclxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XHJcbnZhciBFeHBhbmRFcnJvciA9IHJlcXVpcmUoJy4vRXhwYW5kRXJyb3InKTtcclxuXHJcbmZ1bmN0aW9uIFJlbGF0aW9uTm9kZShvcHRpb25zKSB7XHJcbiAgICB0aGlzLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xyXG4gICAgdGhpcy5yZWxhdGlvbkZpZWxkID0gb3B0aW9ucy5yZWxhdGlvbkZpZWxkO1xyXG4gICAgdGhpcy5wYXRoID0gb3B0aW9ucy5wYXRoIHx8IG9wdGlvbnMucGFyZW50ICsgJy4nICsgb3B0aW9ucy5yZWxhdGlvbkZpZWxkO1xyXG4gICAgdGhpcy5maWVsZHNFeHByZXNzaW9uID0gb3B0aW9ucy5maWVsZHNFeHByZXNzaW9uIHx8IHt9O1xyXG4gICAgdGhpcy50YXJnZXRUeXBlTmFtZSA9IG9wdGlvbnMudGFyZ2V0VHlwZU5hbWU7XHJcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XHJcbiAgICB0aGlzLmlzSW52ZXJ0ZWRSZWxhdGlvbiA9IG9wdGlvbnMuaXNJbnZlcnRlZFJlbGF0aW9uO1xyXG4gICAgdGhpcy5pc0FycmF5Um9vdCA9IG9wdGlvbnMuaXNBcnJheVJvb3Q7IC8vdXNlZCBmb3IgdmFsaWRhdGlvbiBvZiBjYXNlcyB3aGVyZSB2YXJpb3VzIGV4cGFuZCBmZWF0dXJlcyBhcmUgZGlzYWJsZWQgZm9yIGEgR2V0QWxsIHNjZW5hcmlvLlxyXG4gICAgdGhpcy5oYXNBcnJheVZhbHVlcyA9IGZhbHNlOy8vc2V0IHdoZW4gd2UgaGF2ZSBleGVjdXRlZCB0aGUgcXVlcnkuIFVzZWQgaW4gdmFsaWRhdGlvbiBzY2VuYXJpb3Mgd2hlcmUgd2UgZG8gbm90IGhhdmUgbWV0YWRhdGEgYWJvdXQgd2hldGhlciB0aGUgcmVsYXRpb24gaXMgYW4gYXJyYXkgb3Igbm90LlxyXG5cclxuICAgIHZhciBleHBhbmRFeHByZXNzaW9uID0gb3B0aW9ucy5leHBhbmRFeHByZXNzaW9uIHx8IHt9O1xyXG5cclxuICAgIHRoaXMucGFyZW50UmVsYXRpb25GaWVsZCA9IGV4cGFuZEV4cHJlc3Npb25bQ29uc3RhbnRzLlBhcmVudFJlbGF0aW9uRmllbGROYW1lXSB8fCBDb25zdGFudHMuSWRGaWVsZE5hbWVDbGllbnQ7XHJcbiAgICB2YXIgcmVsYXRpb25GaWVsZCA9IHRoaXMuaXNJbnZlcnRlZFJlbGF0aW9uID8gdGhpcy5wYXRoIDogdGhpcy5yZWxhdGlvbkZpZWxkOyAvL2ludmVydGVkIHJlbGF0aW9ucyBhcHBlYXIgd2l0aCB0aGUgZnVsbCBwYXRoIC0gQ29udGVudFR5cGUuRmllbGQgLSBpbiB0aGUgcmVzdWx0IHdoZW4gZXhwYW5kaW5nLlxyXG4gICAgdGhpcy51c2VyRGVmaW5lZE5hbWUgPSBleHBhbmRFeHByZXNzaW9uW0NvbnN0YW50cy5SZXR1cm5Bc0ZpZWxkTmFtZV0gfHwgcmVsYXRpb25GaWVsZDtcclxuICAgIF8uZXh0ZW5kKHRoaXMuZmllbGRzRXhwcmVzc2lvbiwgZXhwYW5kRXhwcmVzc2lvbltDb25zdGFudHMuRmllbGRzRXhwcmVzc2lvbk5hbWVdKTtcclxuICAgIHRoaXMub3JpZ2luYWxGaWVsZHNFeHByZXNzaW9uID0ge307XHJcbiAgICBfLmV4dGVuZCh0aGlzLm9yaWdpbmFsRmllbGRzRXhwcmVzc2lvbiwgdGhpcy5maWVsZHNFeHByZXNzaW9uKTtcclxuICAgIHRoaXMuc2luZ2xlRmllbGROYW1lID0gZXhwYW5kRXhwcmVzc2lvbltDb25zdGFudHMuU2luZ2xlRmllbGRFeHByZXNzaW9uTmFtZV07XHJcbiAgICB0aGlzLmZpbHRlckV4cHJlc3Npb24gPSBleHBhbmRFeHByZXNzaW9uW0NvbnN0YW50cy5GaWx0ZXJFeHByZXNzaW9uTmFtZV07XHJcbiAgICB0aGlzLnNvcnRFeHByZXNzaW9uID0gZXhwYW5kRXhwcmVzc2lvbltDb25zdGFudHMuU29ydEV4cHJlc3Npb25OYW1lXTtcclxuICAgIHRoaXMuc2tpcCA9IGV4cGFuZEV4cHJlc3Npb25bQ29uc3RhbnRzLlNraXBFeHByZXNzaW9uTmFtZV07XHJcbiAgICB0aGlzLnRha2UgPSB0aGlzLl9nZXRUYWtlTGltaXQoZXhwYW5kRXhwcmVzc2lvbltDb25zdGFudHMuVGFrZUV4cHJlc3Npb25OYW1lXSwgb3B0aW9ucy5tYXhUYWtlVmFsdWUpO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIHRha2UgbGltaXQgZGVwZW5kaW5nIG9uIHRoZSBhcHBsaWNhdGlvbiBhbmQgdGhlIHRha2UgdmFsdWUgdGhhdCB0aGUgdXNlciBoYXMgcHJvdmlkZWQuXHJcbiAqIEBwYXJhbSBjbGllbnRUYWtlVmFsdWVcclxuICogQHBhcmFtIG1heFRha2VWYWx1ZVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuUmVsYXRpb25Ob2RlLnByb3RvdHlwZS5fZ2V0VGFrZUxpbWl0ID0gZnVuY3Rpb24gKGNsaWVudFRha2VWYWx1ZSwgbWF4VGFrZVZhbHVlKSB7XHJcbiAgICBtYXhUYWtlVmFsdWUgPSBtYXhUYWtlVmFsdWUgfHwgQ29uc3RhbnRzLkRlZmF1bHRUYWtlSXRlbXNDb3VudDtcclxuICAgIGlmIChjbGllbnRUYWtlVmFsdWUpIHtcclxuICAgICAgICBpZiAoY2xpZW50VGFrZVZhbHVlID4gbWF4VGFrZVZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFeHBhbmRFcnJvcignVGhlIG1heGltdW0gYWxsb3dlZCB0YWtlIHZhbHVlIHdoZW4gZXhwYW5kaW5nIHJlbGF0aW9ucyBpcyAnICsgbWF4VGFrZVZhbHVlICsgJyEnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNsaWVudFRha2VWYWx1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG1heFRha2VWYWx1ZTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBBbnlvbmUgdXNpbmcgdGhlIGJzLWV4cGFuZC1wcm9jZXNzb3IgbW9kdWxlIGNhbiBzZXQgd2hldGhlciB0aGUgcmVsYXRpb24gaXMgYSBtdWx0aXBsZSByZWxhdGlvbiBpbiB0aGUgcHJlcGFyZSBwaGFzZS5cclxuICogVGhpcyB3aWxsIGFsbG93IGZvciBjZXJ0YWluIHJlc3RyaWN0aW9ucyB0byBiZSBlbmZvcmNlZCBkaXJlY3RseSBvbiB0aGUgcHJlcGFyZSBwaGFzZSBpbnN0ZWFkIG9mIHRoZSBleGVjdXRpb24gcGhhc2UuXHJcbiAqL1xyXG5SZWxhdGlvbk5vZGUucHJvdG90eXBlLnNldElzQXJyYXlGcm9tTWV0YWRhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmlzQXJyYXlGcm9tTWV0YWRhdGEgPSB0cnVlO1xyXG59O1xyXG5cclxuUmVsYXRpb25Ob2RlLnByb3RvdHlwZS5pc0FycmF5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gV2UgY2FuIGZpbmQgb3V0IGlmIGEgcmVsYXRpb24gaXMgYW4gYXJyYXkgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcclxuICAgIC8vIEZyb20gbWV0YWRhdGEgaW4gdGhlIEFQSSBTZXJ2ZXIuXHJcbiAgICAvLyBBbGwgaW52ZXJ0ZWQgcmVsYXRpb25zIGFyZSBhcnJheS5cclxuICAgIC8vIE9uY2UgdmFsdWVzIGhhdmUgYmVlbiByZWNlaXZlZCB3ZSBjYW4gZmluZCBvdXQuIFRoaXMgaXMgdXNlZCBmb3Igc2NlbmFyaW9zIHdoZXJlIHdlIGRvIG5vdCBoYXZlIG1ldGFkYXRhIGFib3V0IHRoZSByZWxhdGlvbiAob2ZmbGluZSBzdG9yYWdlIGluIFNESykuXHJcbiAgICByZXR1cm4gdGhpcy5pc0FycmF5RnJvbU1ldGFkYXRhIHx8IHRoaXMuaXNJbnZlcnRlZFJlbGF0aW9uIHx8IHRoaXMuaGFzQXJyYXlWYWx1ZXM7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlbGF0aW9uTm9kZTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgUmVsYXRpb25Ob2RlID0gcmVxdWlyZSgnLi9SZWxhdGlvbk5vZGUnKTtcclxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XHJcbnZhciBDb25zdGFudHMgPSByZXF1aXJlKCcuL0NvbnN0YW50cycpO1xyXG52YXIgRXhwYW5kRXJyb3IgPSByZXF1aXJlKCcuL0V4cGFuZEVycm9yJyk7XHJcblxyXG4vL3ZhciByZWxhdGlvbkZpZWxkUHJvcGVydHlOYW1lID0gQ29uc3RhbnRzLlJlbGF0aW9uRXhwcmVzc2lvbk5hbWU7XHJcblxyXG52YXIgcG9zc2libGVFeHBhbmRPcHRpb25zID0gW1xyXG4gICAgQ29uc3RhbnRzLkV4cGFuZEV4cHJlc3Npb25OYW1lLFxyXG4gICAgQ29uc3RhbnRzLlJldHVybkFzRmllbGROYW1lLFxyXG4gICAgQ29uc3RhbnRzLkZpZWxkc0V4cHJlc3Npb25OYW1lLFxyXG4gICAgQ29uc3RhbnRzLlNpbmdsZUZpZWxkRXhwcmVzc2lvbk5hbWUsXHJcbiAgICBDb25zdGFudHMuU29ydEV4cHJlc3Npb25OYW1lLFxyXG4gICAgQ29uc3RhbnRzLkZpbHRlckV4cHJlc3Npb25OYW1lLFxyXG4gICAgQ29uc3RhbnRzLlNraXBFeHByZXNzaW9uTmFtZSxcclxuICAgIENvbnN0YW50cy5UYWtlRXhwcmVzc2lvbk5hbWUsXHJcbiAgICBDb25zdGFudHMuUGFyZW50UmVsYXRpb25GaWVsZE5hbWUsXHJcbiAgICBDb25zdGFudHMuVGFyZ2V0VHlwZU5hbWVGaWVsZE5hbWVcclxuXTtcclxuXHJcblxyXG4vKipcclxuICogQSBjbGFzcyB1c2VkIHRvIHBhcnNlIEV4cGFuZCBleHByZXNzaW9uIGFuZCBidWlsZCBhIGNvcnJlc3BvbmRpbmcgcmVsYXRpb24gdHJlZS5cclxuICogSW4gYSBwcm9jZXNzIG9mIGNyZWF0aW5nIHRoZSByZWxhdGlvbiB0cmVlIGFyZSBwZXJmb3JtZWQgc2V2ZXJhbCBjaGVja3MgaW4gb3JkZXIgdG8gZm9yY2Ugc29tZSBsaW1pdGF0aW9ucyAtXHJcbiAqIDUwIGl0ZW1zIGJvdGggZm9yIG1hc3RlciBhbmQgY2hpbGQgcXVlcmllcyBhbmQgZW50aXJlIGFtb3VudCBvZiBhbGwgcXVlcmllcyBsaW1pdGVkIHRvIDIwLlxyXG4gKiBDaGVja3MgaWYgdGhlIHJlbGF0aW9uIGZpZWxkIGdpdmVuIGJ5IHRoZSBjdXN0b21lciBpcyB2YWxpZCAoZm9yIGV4YW1wbGU6IHVzZXIgZ2l2ZXMgXCJMaWtlXCIgd2hpbGUgdGhlIHJlbGF0aW9uIGZpZWxkIGlzIFwiTGlrZXNcIikuXHJcbiAqIENoZWNrcyBmb3IgcG9zc2libGUgZXhwYW5kIG9wdGlvbnMuXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIFJlbGF0aW9uVHJlZUJ1aWxkZXIgPSBmdW5jdGlvbiAoZXhwYW5kRXhwcmVzc2lvbiwgbWFpblR5cGVOYW1lLCBpc0FycmF5LCBmaWVsZHNFeHByZXNzaW9uLCBtYXhUYWtlVmFsdWUsIG1ldGFkYXRhUHJvdmlkZXJGdW5jdGlvbiwgY29udGV4dCkge1xyXG4gICAgdGhpcy5tYXhUYWtlVmFsdWUgPSBtYXhUYWtlVmFsdWU7XHJcbiAgICB0aGlzLl9tZXRhZGF0YVByb3ZpZGVyRnVuY3Rpb24gPSBtZXRhZGF0YVByb3ZpZGVyRnVuY3Rpb247XHJcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgdGhpcy5leHBhbmRFeHByZXNzaW9uID0gdGhpcy5wcm9jZXNzRXhwYW5kRXhwcmVzc2lvbihleHBhbmRFeHByZXNzaW9uKTtcclxuICAgIC8vIG1hcmsgdGhlIG1haW4gcXVlcnkgaW4gb3JkZXIgdG8gYXZvaWQgc29tZSBkdXBsaWNhdGlvbiBpc3N1ZXMuXHJcbiAgICB0aGlzLm1hcCA9IHt9O1xyXG4gICAgdGhpcy5tYXBbbWFpblR5cGVOYW1lXSA9IG5ldyBSZWxhdGlvbk5vZGUoe1xyXG4gICAgICAgIHRhcmdldFR5cGVOYW1lOiBtYWluVHlwZU5hbWUsXHJcbiAgICAgICAgaXNBcnJheVJvb3Q6IGlzQXJyYXksXHJcbiAgICAgICAgZmllbGRzRXhwcmVzc2lvbjogZmllbGRzRXhwcmVzc2lvbixcclxuICAgICAgICB2YWxpZGF0ZWQ6IHRydWUsXHJcbiAgICAgICAgcGF0aDogbWFpblR5cGVOYW1lLFxyXG4gICAgICAgIG1heFRha2VWYWx1ZTogbWF4VGFrZVZhbHVlXHJcbiAgICB9KTtcclxuICAgIHRoaXMubWFwW21haW5UeXBlTmFtZV0ub3JpZ2luYWxGaWVsZHNFeHByZXNzaW9uID0ge307XHJcbiAgICBfLmV4dGVuZCh0aGlzLm1hcFttYWluVHlwZU5hbWVdLm9yaWdpbmFsRmllbGRzRXhwcmVzc2lvbiwgZmllbGRzRXhwcmVzc2lvbik7XHJcbiAgICB0aGlzLm1hcC4kcm9vdCA9IG1haW5UeXBlTmFtZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGZ1bGx5IHF1YWxpZmllZCBleHBhbmQgZXhwcmVzc2lvbiBmcm9tIHNob3J0aGFuZCB1c2FnZXM6XHJcbiAqIHtcIkxpa2VzXCI6IHRydWV9IC0+IHtcIkxpa2VzXCI6IHtcIlJldHVybkFzXCI6IFwiTGlrZXNcIn19XHJcbiAqIHtcIkxpa2VzXCI6IFwiTGlrZXNFeHBhbmRlZFwifSAtPiB7XCJMaWtlc1wiOiB7XCJSZXR1cm5Bc1wiOiBcIkxpa2VzRXhwYW5kZWRcIn19XHJcbiAqIEBwYXJhbSBleHBhbmRFeHByZXNzaW9uXHJcbiAqIEByZXR1cm5zIHsqfVxyXG4gKi9cclxuUmVsYXRpb25UcmVlQnVpbGRlci5wcm90b3R5cGUucHJvY2Vzc0V4cGFuZEV4cHJlc3Npb24gPSBmdW5jdGlvbiAoZXhwYW5kRXhwcmVzc2lvbikge1xyXG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gZXhwYW5kRXhwcmVzc2lvbikge1xyXG4gICAgICAgIGlmIChleHBhbmRFeHByZXNzaW9uLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4cGFuZEV4cHJlc3Npb25bcHJvcGVydHldID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgICAgIGV4cGFuZEV4cHJlc3Npb25bcHJvcGVydHldID0ge307XHJcbiAgICAgICAgICAgICAgICBleHBhbmRFeHByZXNzaW9uW3Byb3BlcnR5XVtDb25zdGFudHMuUmV0dXJuQXNGaWVsZE5hbWVdID0gcHJvcGVydHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHBhbmRFeHByZXNzaW9uW3Byb3BlcnR5XSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZWxhdGlvbkZpZWxkID0gZXhwYW5kRXhwcmVzc2lvbltwcm9wZXJ0eV07XHJcbiAgICAgICAgICAgICAgICBleHBhbmRFeHByZXNzaW9uW3Byb3BlcnR5XSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgZXhwYW5kRXhwcmVzc2lvbltwcm9wZXJ0eV1bQ29uc3RhbnRzLlJldHVybkFzRmllbGROYW1lXSA9IHJlbGF0aW9uRmllbGQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXhwYW5kRXhwcmVzc2lvbjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBCdWlsZHMgdGhlIHJlbGF0aW9uIHRyZWUuXHJcbiAqIEBwYXJhbSBkb25lXHJcbiAqL1xyXG5SZWxhdGlvblRyZWVCdWlsZGVyLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChkb25lKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuYnVpbGRNYXBJbnRlcm5hbCh0aGlzLmV4cGFuZEV4cHJlc3Npb24sIHRoaXMubWFwLiRyb290KTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICByZXR1cm4gZG9uZShlKTtcclxuICAgIH1cclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgIHJlcXVpcmUoJ2FzeW5jJykuc2VyaWVzKFtcclxuICAgICAgICB0aGlzLmNvbmZpZ3VyZVJlbGF0aW9uVHJlZS5iaW5kKHRoaXMpLFxyXG4gICAgICAgIHRoaXMudmFsaWRhdGVSZWxhdGlvblRyZWUuYmluZCh0aGlzKVxyXG4gICAgXSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgIGRvbmUoZXJyLCBzZWxmLm1hcCk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVsYXRpb25OYW1lIC0gQSBwYXRoIHRvIHRoZSBleHRlcm5hbCByZWxhdGlvbiBjb2xsZWN0aW9uIChDb21tZW50cy5BY3Rpdml0eUlkKVxyXG4gKiBAcGFyYW0gZXhwYW5kRXhwcmVzc2lvbiAtIFRoZSBleHBhbmQgZXhwcmVzc2lvbiB0aGF0IGNvbnRhaW5zIGFsbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcmVsYXRpb25cclxuICogQHBhcmFtIHJvb3ROYW1lIC0gTmFtZSBvZiB0aGUgcGFyZW50IHJlbGF0aW9uLlxyXG4gKiBAcmV0dXJucyB7UmVsYXRpb25Ob2RlfVxyXG4gKi9cclxuUmVsYXRpb25UcmVlQnVpbGRlci5wcm90b3R5cGUuY3JlYXRlSW52ZXJ0ZWRSZWxhdGlvbiA9IGZ1bmN0aW9uIChyZWxhdGlvbk5hbWUsIGV4cGFuZEV4cHJlc3Npb24sIHJvb3ROYW1lKSB7XHJcbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xyXG4gICAgdmFyIHJlbGF0aW9uTmFtZVBhcnRzID0gcmVsYXRpb25OYW1lLnNwbGl0KCcuJyk7XHJcbiAgICBvcHRpb25zLnBhcmVudCA9IHJvb3ROYW1lO1xyXG4gICAgb3B0aW9ucy5yZWxhdGlvbkZpZWxkID0gcmVsYXRpb25OYW1lUGFydHNbMV07XHJcbiAgICBvcHRpb25zLmlzSW52ZXJ0ZWRSZWxhdGlvbiA9IHRydWU7XHJcbiAgICBvcHRpb25zLnRhcmdldFR5cGVOYW1lID0gcmVsYXRpb25OYW1lUGFydHNbMF07XHJcbiAgICBvcHRpb25zLmV4cGFuZEV4cHJlc3Npb24gPSBleHBhbmRFeHByZXNzaW9uO1xyXG4gICAgb3B0aW9ucy5wYXRoID0gcmVsYXRpb25OYW1lO1xyXG4gICAgb3B0aW9ucy5tYXhUYWtlVmFsdWUgPSB0aGlzLm1heFRha2VWYWx1ZTtcclxuICAgIG9wdGlvbnMudmFsaWRhdGVkID0gZmFsc2U7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBSZWxhdGlvbk5vZGUob3B0aW9ucyk7XHJcbn07XHJcblxyXG4vKipcclxuICogQW4gaW50ZXJuYWwgbWV0aG9kIHdoaWNoIHBhcnNlcyB0aGUgZXhwYW5kIGV4cHJlc3Npb24gYW5kIHByb2R1Y2VzIGEgYmFzaWMgcmVsYXRpb24gdHJlZSAob25seSBuYW1lcyBhbmQgcGFyZW50IHJlbGF0aW9ucykuXHJcbiAqIEBwYXJhbSBleHBhbmRFeHByZXNzaW9uIC0gVGhlIGV4cGFuZCBleHByZXNzaW9uIHdoaWNoIHdpbGwgYmUgcHJvY2Vzc2VkLlxyXG4gKiBAcGFyYW0gcm9vdE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcm9vdCByZWxhdGlvbiAobWFzdGVyIHF1ZXJ5KSB1c3VhbGx5IHRoZSBuYW1lIG9mIHRoZSByZXF1ZXN0ZWQgY29udGVudCB0eXBlIChBY3Rpdml0aWVzKS5cclxuICovXHJcblJlbGF0aW9uVHJlZUJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkTWFwSW50ZXJuYWwgPSBmdW5jdGlvbiAoZXhwYW5kRXhwcmVzc2lvbiwgcm9vdE5hbWUpIHtcclxuICAgIGZvciAodmFyIHJlbGF0aW9uTmFtZSBpbiBleHBhbmRFeHByZXNzaW9uKSB7XHJcbiAgICAgICAgaWYgKGV4cGFuZEV4cHJlc3Npb24uaGFzT3duUHJvcGVydHkocmVsYXRpb25OYW1lKSkge1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudEV4cHJlc3Npb24gPSBleHBhbmRFeHByZXNzaW9uW3JlbGF0aW9uTmFtZV07XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBvcHRpb24gaW4gY3VycmVudEV4cHJlc3Npb24pIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RXhwcmVzc2lvbi5oYXNPd25Qcm9wZXJ0eShvcHRpb24pICYmIHBvc3NpYmxlRXhwYW5kT3B0aW9ucy5pbmRleE9mKG9wdGlvbikgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4cGFuZEVycm9yKCdcXFwiJyArIG9wdGlvbiArICdcXFwiJyArICcgaXMgbm90IGEgdmFsaWQgb3B0aW9uIGZvciBFeHBhbmQgZXhwcmVzc2lvbicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocmVsYXRpb25OYW1lLmluZGV4T2YoJy4nKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW52ZXJ0ZWRSZWxhdGlvbiA9IHRoaXMuY3JlYXRlSW52ZXJ0ZWRSZWxhdGlvbihyZWxhdGlvbk5hbWUsIGN1cnJlbnRFeHByZXNzaW9uLCByb290TmFtZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcFtpbnZlcnRlZFJlbGF0aW9uLnBhdGhdID0gaW52ZXJ0ZWRSZWxhdGlvbjtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFwW2ludmVydGVkUmVsYXRpb24ucGFyZW50XS5jaGlsZHJlbi5wdXNoKGludmVydGVkUmVsYXRpb24ucGF0aCk7XHJcbiAgICAgICAgICAgICAgICAvLyBhZGRzIGEgZmllbGQgZXhwcmVzc2lvbiBpbiB0aGUgb3JpZ2luYWwgZmllbGRzIGV4cHJlc3Npb24gaW4gb3JkZXIgdG8gZ2V0IHRoZSByZXN1bHQgZm9yIHRoYXQgZmllbGRcclxuICAgICAgICAgICAgICAgIFJlbGF0aW9uVHJlZUJ1aWxkZXIuYWRkRmllbGRUb0ZpZWxkc0V4cHJlc3Npb24odGhpcy5tYXBbaW52ZXJ0ZWRSZWxhdGlvbi5wYXJlbnRdLm9yaWdpbmFsRmllbGRzRXhwcmVzc2lvbiwgaW52ZXJ0ZWRSZWxhdGlvbi51c2VyRGVmaW5lZE5hbWUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChleHBhbmRFeHByZXNzaW9uW3JlbGF0aW9uTmFtZV1bQ29uc3RhbnRzLkV4cGFuZEV4cHJlc3Npb25OYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9jZXNzZWRFeHBhbmRFeHByZXNzaW9uID0gdGhpcy5wcm9jZXNzRXhwYW5kRXhwcmVzc2lvbihleHBhbmRFeHByZXNzaW9uW3JlbGF0aW9uTmFtZV1bQ29uc3RhbnRzLkV4cGFuZEV4cHJlc3Npb25OYW1lXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZE1hcEludGVybmFsKHByb2Nlc3NlZEV4cGFuZEV4cHJlc3Npb24sIGludmVydGVkUmVsYXRpb24ucGF0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5yZWxhdGlvbkZpZWxkID0gcmVsYXRpb25OYW1lO1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wYXJlbnQgPSByb290TmFtZTtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZXhwYW5kRXhwcmVzc2lvbiA9IGN1cnJlbnRFeHByZXNzaW9uO1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5tYXhUYWtlVmFsdWUgPSB0aGlzLm1heFRha2VWYWx1ZTtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMudGFyZ2V0VHlwZU5hbWUgPSBjdXJyZW50RXhwcmVzc2lvbltDb25zdGFudHMuVGFyZ2V0VHlwZU5hbWVGaWVsZE5hbWVdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlbGF0aW9uTm9kZSA9IG5ldyBSZWxhdGlvbk5vZGUob3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IHRoaXMubWFwW29wdGlvbnMucGFyZW50XTtcclxuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuY2hpbGRyZW4ucHVzaChyZWxhdGlvbk5vZGUucGF0aCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcFtyZWxhdGlvbk5vZGUucGF0aF0gPSByZWxhdGlvbk5vZGU7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRFeHByZXNzaW9uLmhhc093blByb3BlcnR5KENvbnN0YW50cy5FeHBhbmRFeHByZXNzaW9uTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGN1cnJlbnRFeHByZXNzaW9uW0NvbnN0YW50cy5FeHBhbmRFeHByZXNzaW9uTmFtZV0pID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkTWFwSW50ZXJuYWwodGhpcy5wcm9jZXNzRXhwYW5kRXhwcmVzc2lvbihjdXJyZW50RXhwcmVzc2lvbi5FeHBhbmQpLCByZWxhdGlvbk5vZGUucGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4cGFuZEVycm9yKHJlbGF0aW9uTm9kZS5wYXRoICsgJy5FeHBhbmQgbXVzdCBiZSBhIHZhbGlkIGV4cGFuZCBleHByZXNzaW9uIScpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGFkZGl0aW9uYWwgbWV0YWRhdGEgd2hpY2ggaXMgbmVjZXNzYXJ5IHRvIGV4ZWN1dGUgYSBxdWVyeS5cclxuICogTmFtZSBvZiB0aGUgY29udGVudCB0eXBlIG9mIHRoZSBjaGlsZCByZWxhdGlvbiBnZXQgdmlhIHJlbGF0aW9uIGZpZWxkLlxyXG4gKiBAcGFyYW0gZG9uZVxyXG4gKi9cclxuUmVsYXRpb25UcmVlQnVpbGRlci5wcm90b3R5cGUuY29uZmlndXJlUmVsYXRpb25UcmVlID0gZnVuY3Rpb24gKGRvbmUpIHtcclxuICAgIGlmICh0aGlzLl9tZXRhZGF0YVByb3ZpZGVyRnVuY3Rpb24pIHtcclxuICAgICAgICB2YXIgcmVsYXRpb25OYW1lcyA9IFtdO1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgZm9yICh2YXIgcmVsIGluIHRoaXMubWFwKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShyZWwpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXBbcmVsXS5wYXJlbnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWxhdGlvbk5hbWVzLnB1c2godGhpcy5tYXBbcmVsXS5yZWxhdGlvbkZpZWxkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fbWV0YWRhdGFQcm92aWRlckZ1bmN0aW9uKHJlbGF0aW9uTmFtZXMsIHRoaXMubWFwLCB0aGlzLmNvbnRleHQsIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xyXG4gICAgICAgICAgICBkb25lKGVycik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBkb25lKCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogUGVyZm9ybXMgc2V2ZXJhbCBjaGVja3MgbGlrZTpcclxuICogVmFsaWRpdHkgb2YgdGhlIHJlbGF0aW9uIGZpZWxkLlxyXG4gKiBUbyBub3QgdXNlIGZpbHRlciBvciBzb3J0aW5nIGV4cHJlc3Npb24gd2l0aGluIGEgXCJHZXRCeUZpbHRlclwiIHNjZW5hcmlvLlxyXG4gKiBEb2VzIG5vdCBhbGxvdyB0byBuZXN0IChleHBhbmQgbXVsdGlwbGUgcmVsYXRpb24gZmllbGQpIGFmdGVyIGEgbXVsdGlwbGUgcmVsYXRpb24uXHJcbiAqIERvZXMgbm90IGFsbG93IHRvIHVzZSBib3RoIFwiRmllbGRzXCIgYW5kIFwiU2luZ2xlRmllbGRcIiBvcHRpb25zLlxyXG4gKiBAcGFyYW0gZG9uZVxyXG4gKiBAcmV0dXJucyB7Kn1cclxuICovXHJcblJlbGF0aW9uVHJlZUJ1aWxkZXIucHJvdG90eXBlLnZhbGlkYXRlUmVsYXRpb25UcmVlID0gZnVuY3Rpb24gKGRvbmUpIHtcclxuICAgIHZhciBlcnJvck1lc3NhZ2UgPSAnJztcclxuICAgIHZhciBFT0wgPSAnXFxyXFxuJztcclxuICAgIGZvciAodmFyIHJlbGF0aW9uUGF0aCBpbiB0aGlzLm1hcCkge1xyXG4gICAgICAgIGlmIChyZWxhdGlvblBhdGggIT09ICckcm9vdCcgJiYgdGhpcy5tYXAuaGFzT3duUHJvcGVydHkocmVsYXRpb25QYXRoKSkge1xyXG4gICAgICAgICAgICB2YXIgcmVsYXRpb24gPSB0aGlzLm1hcFtyZWxhdGlvblBhdGhdO1xyXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gdGhpcy52YWxpZGF0ZVNpbmdsZVJlbGF0aW9uKHJlbGF0aW9uKTtcclxuICAgICAgICAgICAgdGhpcy5jb25maWd1cmVGaWVsZHNFeHByZXNzaW9uc0ZvclJlbGF0aW9uKHJlbGF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoZXJyb3JNZXNzYWdlICE9PSAnJykge1xyXG4gICAgICAgIHZhciBmaW5hbEVycm9yTWVzc2FnZSA9IGVycm9yTWVzc2FnZS5zdWJzdHIoMCwgZXJyb3JNZXNzYWdlLmxhc3RJbmRleE9mKEVPTCkpO1xyXG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFeHBhbmRFcnJvcihmaW5hbEVycm9yTWVzc2FnZSk7XHJcbiAgICAgICAgcmV0dXJuIGRvbmUoZXJyb3IpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBkb25lKCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkIHJlbGF0aW9uIGZpZWxkcyB0byBwYXJlbnQgcmVsYXRpb24gZmllbGRzIGV4cHJlc3Npb24gaWYgbmVlZGVkIChvdGhlcndpc2UgcmVsYXRpb24gY2Fubm90IGJlIGVzdGFibGlzaGVkKS5cclxuICogQHBhcmFtIHJlbGF0aW9uIC0gQSByZWxhdGlvbiB3aGljaCB3aWxsIGJlIGNvbmZpZ3VyZWQuXHJcbiAqL1xyXG5SZWxhdGlvblRyZWVCdWlsZGVyLnByb3RvdHlwZS5jb25maWd1cmVGaWVsZHNFeHByZXNzaW9uc0ZvclJlbGF0aW9uID0gZnVuY3Rpb24gKHJlbGF0aW9uKSB7XHJcbiAgICBpZiAocmVsYXRpb24ucGFyZW50KSB7XHJcbiAgICAgICAgdmFyIHBhcmVudFJlbGF0aW9uRmllbGRzRXhwcmVzc2lvbiA9IHRoaXMubWFwW3JlbGF0aW9uLnBhcmVudF0uZmllbGRzRXhwcmVzc2lvbjtcclxuICAgICAgICBpZiAocmVsYXRpb24uaXNJbnZlcnRlZFJlbGF0aW9uKSB7XHJcbiAgICAgICAgICAgIFJlbGF0aW9uVHJlZUJ1aWxkZXIuYWRkRmllbGRUb0ZpZWxkc0V4cHJlc3Npb24ocGFyZW50UmVsYXRpb25GaWVsZHNFeHByZXNzaW9uLCByZWxhdGlvbi5wYXJlbnRSZWxhdGlvbkZpZWxkKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBSZWxhdGlvblRyZWVCdWlsZGVyLmFkZEZpZWxkVG9GaWVsZHNFeHByZXNzaW9uKHBhcmVudFJlbGF0aW9uRmllbGRzRXhwcmVzc2lvbiwgcmVsYXRpb24ucmVsYXRpb25GaWVsZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHJlbGF0aW9uLmlzSW52ZXJ0ZWRSZWxhdGlvbikge1xyXG4gICAgICAgIFJlbGF0aW9uVHJlZUJ1aWxkZXIuYWRkRmllbGRUb0ZpZWxkc0V4cHJlc3Npb24ocmVsYXRpb24uZmllbGRzRXhwcmVzc2lvbiwgcmVsYXRpb24ucmVsYXRpb25GaWVsZCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIFJlbGF0aW9uVHJlZUJ1aWxkZXIuYWRkRmllbGRUb0ZpZWxkc0V4cHJlc3Npb24ocmVsYXRpb24uZmllbGRzRXhwcmVzc2lvbiwgQ29uc3RhbnRzLklkRmllbGROYW1lQ2xpZW50KTtcclxuICAgIH1cclxuICAgIFJlbGF0aW9uVHJlZUJ1aWxkZXIuYWRqdXN0UGFyZW50UmVsYXRpb25GaWVsZHNFeHByZXNzaW9uKHRoaXMubWFwW3JlbGF0aW9uLnBhcmVudF0sIHJlbGF0aW9uKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBWYWxpZGF0ZXMgYSBzaW5nbGUgcmVsYXRpb24gZm9yIGFsbCBidWlsZC1pbiBsaW1pdGF0aW9ucy5cclxuICogQHBhcmFtIHJlbGF0aW9uIC0gQSByZWxhdGlvbiB3aGljaCB3aWxsIGJlIHZhbGlkYXRlZC5cclxuICogQHJldHVybnMge3N0cmluZ30gLSBSZXR1cm5zIGFuIGVycm9yIG1lc3NhZ2Ugd2l0aCBhbGwgZXJyb3JzIG9yIGVtcHR5IHN0cmluZyBpZiB0aGVyZSBpcyBubyBlcnJvcnMuXHJcbiAqL1xyXG5SZWxhdGlvblRyZWVCdWlsZGVyLnByb3RvdHlwZS52YWxpZGF0ZVNpbmdsZVJlbGF0aW9uID0gZnVuY3Rpb24gKHJlbGF0aW9uKSB7XHJcbiAgICB2YXIgZXJyb3JNZXNzYWdlID0gJyc7XHJcbiAgICB2YXIgRU9MID0gJ1xcclxcbic7XHJcbiAgICB2YXIgaXNHZXRCeUZpbHRlclF1ZXJ5ID0gdGhpcy5tYXBbdGhpcy5tYXAuJHJvb3RdLmlzQXJyYXlSb290O1xyXG5cclxuICAgIGlmIChyZWxhdGlvbi5wYXRoID09PSByZWxhdGlvbi5wYXJlbnQpIHtcclxuICAgICAgICBlcnJvck1lc3NhZ2UgKz0gcmVsYXRpb24ucGF0aCArICcgaGFzIHNhbWUgcGFyZW50IHdoaWNoIHdpbGwgY2F1c2UgYW4gaW5maW5pdGUgbG9vcC4nICsgRU9MO1xyXG4gICAgICAgIHJldHVybiBlcnJvck1lc3NhZ2U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHJlbGF0aW9uLmlzQXJyYXkoKSkge1xyXG4gICAgICAgIHZhciBtdWx0aXBsZVF1ZXJpZXNDb3VudCA9IHRoaXMuZ2V0UGFyZW50TXVsdGlwbGVSZWxhdGlvbnNDb3VudChyZWxhdGlvbik7XHJcbiAgICAgICAgaWYgKG11bHRpcGxlUXVlcmllc0NvdW50ID4gMCkge1xyXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gJ0V4cGFuZCBleHByZXNzaW9uIGhhcyBtdWx0aXBsZSByZWxhdGlvbiBcXFwiJyArIHJlbGF0aW9uLnBhdGggKyAnXFxcIiBpbnNpZGUgYSBtdWx0aXBsZSByZWxhdGlvbi4nO1xyXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gRU9MO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMubWFwW3JlbGF0aW9uLnBhcmVudF0gPT09IHRoaXMubWFwW3RoaXMubWFwLiRyb290XSAmJlxyXG4gICAgICAgICAgICBpc0dldEJ5RmlsdGVyUXVlcnkgJiZcclxuICAgICAgICAgICAgKHJlbGF0aW9uLmZpbHRlckV4cHJlc3Npb24gfHwgcmVsYXRpb24uc29ydEV4cHJlc3Npb24pKSB7XHJcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPSAnRmlsdGVyIGFuZCBTb3J0IGV4cHJlc3Npb25zIGFyZSBub3QgYWxsb3dlZCB3aXRoIEdldEJ5RmlsdGVyIHNjZW5hcmlvLic7XHJcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPSBFT0w7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaXNHZXRCeUZpbHRlclF1ZXJ5ICYmIHJlbGF0aW9uLmlzSW52ZXJ0ZWRSZWxhdGlvbikge1xyXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gJ0V4cGFuZGluZyBhbiBleHRlcm5hbCBjb250ZW50IHR5cGUgaXMgbm90IGFsbG93ZWQgd2l0aCBHZXRCeUZpbHRlciBzY2VuYXJpby4nO1xyXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gRU9MO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghcmVsYXRpb24udGFyZ2V0VHlwZU5hbWUpIHtcclxuICAgICAgICBlcnJvck1lc3NhZ2UgKz0gJ0V4cGFuZGluZyByZWxhdGlvbiBcXFwiJyArIHJlbGF0aW9uLnJlbGF0aW9uRmllbGQgKyAnXFxcIiBoYXMgbm8gdGFyZ2V0IHR5cGUgbmFtZSBzcGVjaWZpZWQuIFlvdSBzaG91bGQgdXNlIFxcXCJUYXJnZXRUeXBlTmFtZVxcXCIgdG8gc3BlY2lmeSBpdC4nO1xyXG4gICAgICAgIGVycm9yTWVzc2FnZSArPSBFT0w7XHJcbiAgICB9XHJcbiAgICBpZiAocmVsYXRpb24uZmllbGRzRXhwcmVzc2lvbiAmJiBPYmplY3Qua2V5cyhyZWxhdGlvbi5maWVsZHNFeHByZXNzaW9uKS5sZW5ndGggJiYgcmVsYXRpb24uc2luZ2xlRmllbGROYW1lKSB7XHJcbiAgICAgICAgZXJyb3JNZXNzYWdlICs9IHJlbGF0aW9uLnBhdGggKyAnICc7XHJcbiAgICAgICAgZXJyb3JNZXNzYWdlICs9ICdleHBhbmQgZXhwcmVzc2lvbiBjb250YWlucyBib3RoIFxcXCJGaWVsZHNcXFwiIGFuZCBcXFwiU2luZ2xlRmllbGRcXFwiIGV4cHJlc3Npb25zLic7XHJcbiAgICAgICAgZXJyb3JNZXNzYWdlICs9IEVPTDtcclxuICAgIH1cclxuICAgIGlmIChyZWxhdGlvbi5zaW5nbGVGaWVsZE5hbWUpIHtcclxuICAgICAgICBpZiAocmVsYXRpb24uY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgaWYgKHJlbGF0aW9uLmNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPSByZWxhdGlvbi5wYXRoICsgJyBoYXMgbXVsdGlwbGUgZXhwYW5kIGV4cHJlc3Npb25zIHdpdGggYSBzaW5nbGUgZmllbGQgb3B0aW9uLicgKyBFT0w7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJlbGF0aW9uLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiB0aGlzLm1hcFtyZWxhdGlvbi5jaGlsZHJlblswXV0ucmVsYXRpb25GaWVsZCAhPT0gcmVsYXRpb24uc2luZ2xlRmllbGROYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gJ0V4cGFuZCBleHByZXNzaW9uICcgKyByZWxhdGlvbi5wYXRoO1xyXG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9ICcgc2luZ2xlIGZpZWxkIFxcXCInICsgcmVsYXRpb24uc2luZ2xlRmllbGROYW1lICsgJ1xcXCInO1xyXG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9ICcgZG9lcyBub3QgbWF0Y2ggY2hpbGQgcmVsYXRpb24gZmllbGQgXFxcIicgKyB0aGlzLm1hcFtyZWxhdGlvbi5jaGlsZHJlblswXV0ucmVsYXRpb25GaWVsZCArICdcXFwiLic7XHJcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gRU9MO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBlcnJvck1lc3NhZ2U7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgY291bnQgb2YgcGFyZW50IG11bHRpcGxlIHJlbGF0aW9ucy5cclxuICogQHBhcmFtIHJlbGF0aW9uIC0gU3RhcnRpbmcgcmVsYXRpb24uXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IC0gY291bnQgb2YgYWxsIHBhcmVudCBtdWx0aXBsZSByZWxhdGlvbnNcclxuICovXHJcblJlbGF0aW9uVHJlZUJ1aWxkZXIucHJvdG90eXBlLmdldFBhcmVudE11bHRpcGxlUmVsYXRpb25zQ291bnQgPSBmdW5jdGlvbiAocmVsYXRpb24pIHtcclxuICAgIHZhciByZXN1bHQgPSAwO1xyXG4gICAgdmFyIHJlbGF0aW9uRm9yTG9vcCA9IHJlbGF0aW9uO1xyXG4gICAgd2hpbGUgKHJlbGF0aW9uRm9yTG9vcC5wYXJlbnQpIHtcclxuICAgICAgICB2YXIgcGFyZW50UmVsYXRpb24gPSB0aGlzLm1hcFtyZWxhdGlvbkZvckxvb3AucGFyZW50XTtcclxuICAgICAgICBpZiAocGFyZW50UmVsYXRpb24uaXNBcnJheSgpICYmIHBhcmVudFJlbGF0aW9uLnBhcmVudCkge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVsYXRpb25Gb3JMb29wID0gcGFyZW50UmVsYXRpb247XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBBZGp1c3RzIGZpZWxkcyBleHByZXNzaW9uIG9mIHRoZSBwYXJlbnQgcmVsYXRpb24gYmFzZWQgb24gcGFnaW5nIHNldHRpbmcgb2YgYSByZWxhdGlvbiAoc2tpcCwgdGFrZSkuXHJcbiAqIEluIHRoYXQgY2FzZSB3ZSBwdXQgYSBcIiRzbGljZVwiIG9wdGlvbiB3aXRoaW4gdGhlIHBhcmVudCByZWxhdGlvbiBmaWVsZHMgZXhwcmVzc2lvbi5cclxuICogQHBhcmFtIHBhcmVudFJlbGF0aW9uXHJcbiAqIEBwYXJhbSByZWxhdGlvblxyXG4gKi9cclxuUmVsYXRpb25UcmVlQnVpbGRlci5hZGp1c3RQYXJlbnRSZWxhdGlvbkZpZWxkc0V4cHJlc3Npb24gPSBmdW5jdGlvbiAocGFyZW50UmVsYXRpb24sIHJlbGF0aW9uKSB7XHJcbiAgICBpZiAoIXJlbGF0aW9uLmlzSW52ZXJ0ZWRSZWxhdGlvbiAmJiByZWxhdGlvbi50YWtlICYmIHR5cGVvZiByZWxhdGlvbi50YWtlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIC8vIHdoZW4gcmVsYXRpb24gaGFzIGZpbHRlciBvciBzb3J0aW5nIHNraXAgYW5kIHRha2Ugc2hvdWxkIG5vdCBiZSB0cmFuc2ZlcnJlZCB0byB0aGUgcGFyZW50IHJlbGF0aW9uIGFzICRzbGljZS5cclxuICAgICAgICB2YXIgc2hvdWxkVHJhbnNmZXJQYWdpbmdUb1BhcmVudFJlbGF0aW9uID0gcmVsYXRpb24uaXNBcnJheSgpICYmICFyZWxhdGlvbi5maWx0ZXJFeHByZXNzaW9uICYmICFyZWxhdGlvbi5zb3J0RXhwcmVzc2lvbiAmJiBwYXJlbnRSZWxhdGlvbjtcclxuICAgICAgICBpZiAoc2hvdWxkVHJhbnNmZXJQYWdpbmdUb1BhcmVudFJlbGF0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnRSZWxhdGlvbi5maWVsZHNFeHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudFJlbGF0aW9uLmZpZWxkc0V4cHJlc3Npb24gPSB7fTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHJlbGF0aW9uLnNraXAgJiYgdHlwZW9mIHJlbGF0aW9uLnNraXAgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRSZWxhdGlvbi5maWVsZHNFeHByZXNzaW9uW3JlbGF0aW9uLnJlbGF0aW9uRmllbGRdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICckc2xpY2UnOiBbcmVsYXRpb24uc2tpcCwgcmVsYXRpb24udGFrZV1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRSZWxhdGlvbi5maWVsZHNFeHByZXNzaW9uW3JlbGF0aW9uLnJlbGF0aW9uRmllbGRdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICckc2xpY2UnOiByZWxhdGlvbi50YWtlXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlbGF0aW9uLnRha2UgPSBudWxsO1xyXG4gICAgICAgICAgICByZWxhdGlvbi5za2lwID0gbnVsbDtcclxuICAgICAgICAgICAgcmVsYXRpb24ubW92ZWRTa2lwVGFrZUFzU2xpY2UgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGZpZWxkIHRvIHBhcmVudCByZWxhdGlvbiBmaWVsZHMgZXhwcmVzc2lvbi4gRm9yIGV4YW1wbGUgaWYgdGhlIHJlbGF0aW9uIGZpZWxkIGlzIGV4Y2x1ZGVkIGZyb20gdGhlIG1hc3RlciByZXF1ZXN0LlxyXG4gKiBAcGFyYW0gZmllbGRzRXhwcmVzc2lvbiAtIEZpZWxkcyBleHByZXNzaW9uIG9mIHRoZSBwYXJlbnQgcmVsYXRpb24uXHJcbiAqIEBwYXJhbSByZWxhdGlvbkZpZWxkIC0gTmFtZSBvZiB0aGUgZmllbGQgd2hpY2ggc2hvdWxkIGJlIHJldHVybmVkLlxyXG4gKi9cclxuUmVsYXRpb25UcmVlQnVpbGRlci5hZGRGaWVsZFRvRmllbGRzRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChmaWVsZHNFeHByZXNzaW9uLCByZWxhdGlvbkZpZWxkKSB7XHJcbiAgICBpZiAoZmllbGRzRXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkIHx8IE9iamVjdC5rZXlzKGZpZWxkc0V4cHJlc3Npb24pLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBpc0V4Y2x1c2l2ZSA9IFJlbGF0aW9uVHJlZUJ1aWxkZXIuZ2V0SXNGaWVsZHNFeHByZXNzaW9uRXhjbHVzaXZlKGZpZWxkc0V4cHJlc3Npb24pO1xyXG5cclxuICAgIGlmIChpc0V4Y2x1c2l2ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc0V4Y2x1c2l2ZSkge1xyXG4gICAgICAgIGRlbGV0ZSBmaWVsZHNFeHByZXNzaW9uW3JlbGF0aW9uRmllbGRdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBmaWVsZHNFeHByZXNzaW9uW3JlbGF0aW9uRmllbGRdID0gMTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIGlmIHRoZSBmaWVsZHMgZXhwcmVzc2lvbiBpcyBleGNsdXNpdmUgKFwiRmllbGROYW1lXCIgOiAwKVxyXG4gKiBAcGFyYW0gZmllbGRzRXhwcmVzc2lvbiAtIEZpZWxkcyBleHByZXNzaW9uIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Kn1cclxuICovXHJcblJlbGF0aW9uVHJlZUJ1aWxkZXIuZ2V0SXNGaWVsZHNFeHByZXNzaW9uRXhjbHVzaXZlID0gZnVuY3Rpb24gKGZpZWxkc0V4cHJlc3Npb24pIHtcclxuICAgIHZhciBpc0V4Y2x1c2l2ZTtcclxuICAgIGZvciAodmFyIGZpZWxkTmFtZSBpbiBmaWVsZHNFeHByZXNzaW9uKSB7XHJcbiAgICAgICAgaWYgKGZpZWxkTmFtZSAhPT0gQ29uc3RhbnRzLklkRmllbGROYW1lQ2xpZW50ICYmIGZpZWxkc0V4cHJlc3Npb24uaGFzT3duUHJvcGVydHkoZmllbGROYW1lKSkge1xyXG4gICAgICAgICAgICBpZiAoaXNFeGNsdXNpdmUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkc0V4cHJlc3Npb25bZmllbGROYW1lXSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzRXhjbHVzaXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWVsZHNFeHByZXNzaW9uW2ZpZWxkTmFtZV0gPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpZWxkc0V4cHJlc3Npb25bZmllbGROYW1lXSA9PT0gMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0V4Y2x1c2l2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXNFeGNsdXNpdmU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlbGF0aW9uVHJlZUJ1aWxkZXI7XHJcbiIsIi8qIVxyXG4gKiBhc3luY1xyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2FvbGFuL2FzeW5jXHJcbiAqXHJcbiAqIENvcHlyaWdodCAyMDEwLTIwMTQgQ2FvbGFuIE1jTWFob25cclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKmpzaGludCBvbmV2YXI6IGZhbHNlLCBpbmRlbnQ6NCAqL1xyXG4vKmdsb2JhbCBzZXRJbW1lZGlhdGU6IGZhbHNlLCBzZXRUaW1lb3V0OiBmYWxzZSwgY29uc29sZTogZmFsc2UgKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgYXN5bmMgPSB7fTtcclxuXHJcbiAgICAvLyBnbG9iYWwgb24gdGhlIHNlcnZlciwgd2luZG93IGluIHRoZSBicm93c2VyXHJcbiAgICB2YXIgcm9vdCwgcHJldmlvdXNfYXN5bmM7XHJcblxyXG4gICAgcm9vdCA9IHRoaXM7XHJcbiAgICBpZiAocm9vdCAhPSBudWxsKSB7XHJcbiAgICAgIHByZXZpb3VzX2FzeW5jID0gcm9vdC5hc3luYztcclxuICAgIH1cclxuXHJcbiAgICBhc3luYy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJvb3QuYXN5bmMgPSBwcmV2aW91c19hc3luYztcclxuICAgICAgICByZXR1cm4gYXN5bmM7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIG9ubHlfb25jZShmbikge1xyXG4gICAgICAgIHZhciBjYWxsZWQgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmIChjYWxsZWQpIHRocm93IG5ldyBFcnJvcihcIkNhbGxiYWNrIHdhcyBhbHJlYWR5IGNhbGxlZC5cIik7XHJcbiAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGZuLmFwcGx5KHJvb3QsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vLy8gY3Jvc3MtYnJvd3NlciBjb21wYXRpYmxpdHkgZnVuY3Rpb25zIC8vLy9cclxuXHJcbiAgICB2YXIgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcclxuXHJcbiAgICB2YXIgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcclxuICAgIH07XHJcblxyXG4gICAgdmFyIF9lYWNoID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IpIHtcclxuICAgICAgICBpZiAoYXJyLmZvckVhY2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFyci5mb3JFYWNoKGl0ZXJhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgaXRlcmF0b3IoYXJyW2ldLCBpLCBhcnIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdmFyIF9tYXAgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvcikge1xyXG4gICAgICAgIGlmIChhcnIubWFwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcnIubWFwKGl0ZXJhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcclxuICAgICAgICBfZWFjaChhcnIsIGZ1bmN0aW9uICh4LCBpLCBhKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChpdGVyYXRvcih4LCBpLCBhKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBfcmVkdWNlID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIG1lbW8pIHtcclxuICAgICAgICBpZiAoYXJyLnJlZHVjZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXJyLnJlZHVjZShpdGVyYXRvciwgbWVtbyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9lYWNoKGFyciwgZnVuY3Rpb24gKHgsIGksIGEpIHtcclxuICAgICAgICAgICAgbWVtbyA9IGl0ZXJhdG9yKG1lbW8sIHgsIGksIGEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBtZW1vO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgX2tleXMgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIga2V5cyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaykpIHtcclxuICAgICAgICAgICAgICAgIGtleXMucHVzaChrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ga2V5cztcclxuICAgIH07XHJcblxyXG4gICAgLy8vLyBleHBvcnRlZCBhc3luYyBtb2R1bGUgZnVuY3Rpb25zIC8vLy9cclxuXHJcbiAgICAvLy8vIG5leHRUaWNrIGltcGxlbWVudGF0aW9uIHdpdGggYnJvd3Nlci1jb21wYXRpYmxlIGZhbGxiYWNrIC8vLy9cclxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHwgIShwcm9jZXNzLm5leHRUaWNrKSkge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGFzeW5jLm5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBub3QgYSBkaXJlY3QgYWxpYXMgZm9yIElFMTAgY29tcGF0aWJpbGl0eVxyXG4gICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKGZuKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlID0gYXN5bmMubmV4dFRpY2s7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhc3luYy5uZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZSA9IGFzeW5jLm5leHRUaWNrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFzeW5jLm5leHRUaWNrID0gcHJvY2Vzcy5uZXh0VGljaztcclxuICAgICAgICBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgICAgICAgLy8gbm90IGEgZGlyZWN0IGFsaWFzIGZvciBJRTEwIGNvbXBhdGliaWxpdHlcclxuICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoZm4pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlID0gYXN5bmMubmV4dFRpY2s7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jLmVhY2ggPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcclxuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xyXG4gICAgICAgIGlmICghYXJyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvbXBsZXRlZCA9IDA7XHJcbiAgICAgICAgX2VhY2goYXJyLCBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICBpdGVyYXRvcih4LCBvbmx5X29uY2UoZG9uZSkgKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBmdW5jdGlvbiBkb25lKGVycikge1xyXG4gICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgIGNvbXBsZXRlZCArPSAxO1xyXG4gICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPj0gYXJyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgYXN5bmMuZm9yRWFjaCA9IGFzeW5jLmVhY2g7XHJcblxyXG4gICAgYXN5bmMuZWFjaFNlcmllcyA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XHJcbiAgICAgICAgaWYgKCFhcnIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29tcGxldGVkID0gMDtcclxuICAgICAgICB2YXIgaXRlcmF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaXRlcmF0b3IoYXJyW2NvbXBsZXRlZF0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWQgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkID49IGFyci5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaXRlcmF0ZSgpO1xyXG4gICAgfTtcclxuICAgIGFzeW5jLmZvckVhY2hTZXJpZXMgPSBhc3luYy5lYWNoU2VyaWVzO1xyXG5cclxuICAgIGFzeW5jLmVhY2hMaW1pdCA9IGZ1bmN0aW9uIChhcnIsIGxpbWl0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgZm4gPSBfZWFjaExpbWl0KGxpbWl0KTtcclxuICAgICAgICBmbi5hcHBseShudWxsLCBbYXJyLCBpdGVyYXRvciwgY2FsbGJhY2tdKTtcclxuICAgIH07XHJcbiAgICBhc3luYy5mb3JFYWNoTGltaXQgPSBhc3luYy5lYWNoTGltaXQ7XHJcblxyXG4gICAgdmFyIF9lYWNoTGltaXQgPSBmdW5jdGlvbiAobGltaXQpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xyXG4gICAgICAgICAgICBpZiAoIWFyci5sZW5ndGggfHwgbGltaXQgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNvbXBsZXRlZCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBzdGFydGVkID0gMDtcclxuICAgICAgICAgICAgdmFyIHJ1bm5pbmcgPSAwO1xyXG5cclxuICAgICAgICAgICAgKGZ1bmN0aW9uIHJlcGxlbmlzaCAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkID49IGFyci5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAocnVubmluZyA8IGxpbWl0ICYmIHN0YXJ0ZWQgPCBhcnIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRlZCArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHJ1bm5pbmcgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvcihhcnJbc3RhcnRlZCAtIDFdLCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVkICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydW5uaW5nIC09IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkID49IGFyci5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGVuaXNoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkoKTtcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgdmFyIGRvUGFyYWxsZWwgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBbYXN5bmMuZWFjaF0uY29uY2F0KGFyZ3MpKTtcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIHZhciBkb1BhcmFsbGVsTGltaXQgPSBmdW5jdGlvbihsaW1pdCwgZm4pIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBbX2VhY2hMaW1pdChsaW1pdCldLmNvbmNhdChhcmdzKSk7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICB2YXIgZG9TZXJpZXMgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBbYXN5bmMuZWFjaFNlcmllc10uY29uY2F0KGFyZ3MpKTtcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgdmFyIF9hc3luY01hcCA9IGZ1bmN0aW9uIChlYWNoZm4sIGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgYXJyID0gX21hcChhcnIsIGZ1bmN0aW9uICh4LCBpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7aW5kZXg6IGksIHZhbHVlOiB4fTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgaXRlcmF0b3IoeC52YWx1ZSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcclxuICAgICAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVyYXRvcih4LnZhbHVlLCBmdW5jdGlvbiAoZXJyLCB2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1t4LmluZGV4XSA9IHY7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgYXN5bmMubWFwID0gZG9QYXJhbGxlbChfYXN5bmNNYXApO1xyXG4gICAgYXN5bmMubWFwU2VyaWVzID0gZG9TZXJpZXMoX2FzeW5jTWFwKTtcclxuICAgIGFzeW5jLm1hcExpbWl0ID0gZnVuY3Rpb24gKGFyciwgbGltaXQsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybiBfbWFwTGltaXQobGltaXQpKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIF9tYXBMaW1pdCA9IGZ1bmN0aW9uKGxpbWl0KSB7XHJcbiAgICAgICAgcmV0dXJuIGRvUGFyYWxsZWxMaW1pdChsaW1pdCwgX2FzeW5jTWFwKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gcmVkdWNlIG9ubHkgaGFzIGEgc2VyaWVzIHZlcnNpb24sIGFzIGRvaW5nIHJlZHVjZSBpbiBwYXJhbGxlbCB3b24ndFxyXG4gICAgLy8gd29yayBpbiBtYW55IHNpdHVhdGlvbnMuXHJcbiAgICBhc3luYy5yZWR1Y2UgPSBmdW5jdGlvbiAoYXJyLCBtZW1vLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcclxuICAgICAgICBhc3luYy5lYWNoU2VyaWVzKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGl0ZXJhdG9yKG1lbW8sIHgsIGZ1bmN0aW9uIChlcnIsIHYpIHtcclxuICAgICAgICAgICAgICAgIG1lbW8gPSB2O1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIG1lbW8pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vIGluamVjdCBhbGlhc1xyXG4gICAgYXN5bmMuaW5qZWN0ID0gYXN5bmMucmVkdWNlO1xyXG4gICAgLy8gZm9sZGwgYWxpYXNcclxuICAgIGFzeW5jLmZvbGRsID0gYXN5bmMucmVkdWNlO1xyXG5cclxuICAgIGFzeW5jLnJlZHVjZVJpZ2h0ID0gZnVuY3Rpb24gKGFyciwgbWVtbywgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIHJldmVyc2VkID0gX21hcChhcnIsIGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgIH0pLnJldmVyc2UoKTtcclxuICAgICAgICBhc3luYy5yZWR1Y2UocmV2ZXJzZWQsIG1lbW8sIGl0ZXJhdG9yLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgLy8gZm9sZHIgYWxpYXNcclxuICAgIGFzeW5jLmZvbGRyID0gYXN5bmMucmVkdWNlUmlnaHQ7XHJcblxyXG4gICAgdmFyIF9maWx0ZXIgPSBmdW5jdGlvbiAoZWFjaGZuLCBhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciByZXN1bHRzID0gW107XHJcbiAgICAgICAgYXJyID0gX21hcChhcnIsIGZ1bmN0aW9uICh4LCBpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7aW5kZXg6IGksIHZhbHVlOiB4fTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgaXRlcmF0b3IoeC52YWx1ZSwgZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgIGlmICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhfbWFwKHJlc3VsdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xyXG4gICAgICAgICAgICB9KSwgZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB4LnZhbHVlO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgYXN5bmMuZmlsdGVyID0gZG9QYXJhbGxlbChfZmlsdGVyKTtcclxuICAgIGFzeW5jLmZpbHRlclNlcmllcyA9IGRvU2VyaWVzKF9maWx0ZXIpO1xyXG4gICAgLy8gc2VsZWN0IGFsaWFzXHJcbiAgICBhc3luYy5zZWxlY3QgPSBhc3luYy5maWx0ZXI7XHJcbiAgICBhc3luYy5zZWxlY3RTZXJpZXMgPSBhc3luYy5maWx0ZXJTZXJpZXM7XHJcblxyXG4gICAgdmFyIF9yZWplY3QgPSBmdW5jdGlvbiAoZWFjaGZuLCBhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciByZXN1bHRzID0gW107XHJcbiAgICAgICAgYXJyID0gX21hcChhcnIsIGZ1bmN0aW9uICh4LCBpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7aW5kZXg6IGksIHZhbHVlOiB4fTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgaXRlcmF0b3IoeC52YWx1ZSwgZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2soX21hcChyZXN1bHRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcclxuICAgICAgICAgICAgfSksIGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geC52YWx1ZTtcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIGFzeW5jLnJlamVjdCA9IGRvUGFyYWxsZWwoX3JlamVjdCk7XHJcbiAgICBhc3luYy5yZWplY3RTZXJpZXMgPSBkb1NlcmllcyhfcmVqZWN0KTtcclxuXHJcbiAgICB2YXIgX2RldGVjdCA9IGZ1bmN0aW9uIChlYWNoZm4sIGFyciwgaXRlcmF0b3IsIG1haW5fY2FsbGJhY2spIHtcclxuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgaXRlcmF0b3IoeCwgZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2soeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICBtYWluX2NhbGxiYWNrKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgYXN5bmMuZGV0ZWN0ID0gZG9QYXJhbGxlbChfZGV0ZWN0KTtcclxuICAgIGFzeW5jLmRldGVjdFNlcmllcyA9IGRvU2VyaWVzKF9kZXRlY3QpO1xyXG5cclxuICAgIGFzeW5jLnNvbWUgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgbWFpbl9jYWxsYmFjaykge1xyXG4gICAgICAgIGFzeW5jLmVhY2goYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgaXRlcmF0b3IoeCwgZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgIGlmICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgIG1haW5fY2FsbGJhY2soZmFsc2UpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vIGFueSBhbGlhc1xyXG4gICAgYXN5bmMuYW55ID0gYXN5bmMuc29tZTtcclxuXHJcbiAgICBhc3luYy5ldmVyeSA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBtYWluX2NhbGxiYWNrKSB7XHJcbiAgICAgICAgYXN5bmMuZWFjaChhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBpdGVyYXRvcih4LCBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayhmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICBtYWluX2NhbGxiYWNrKHRydWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vIGFsbCBhbGlhc1xyXG4gICAgYXN5bmMuYWxsID0gYXN5bmMuZXZlcnk7XHJcblxyXG4gICAgYXN5bmMuc29ydEJ5ID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgYXN5bmMubWFwKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uIChlcnIsIGNyaXRlcmlhKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHt2YWx1ZTogeCwgY3JpdGVyaWE6IGNyaXRlcmlhfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlc3VsdHMpIHtcclxuICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWEsIGIgPSByaWdodC5jcml0ZXJpYTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDA7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgX21hcChyZXN1bHRzLnNvcnQoZm4pLCBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4LnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGFzeW5jLmF1dG8gPSBmdW5jdGlvbiAodGFza3MsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcclxuICAgICAgICB2YXIga2V5cyA9IF9rZXlzKHRhc2tzKTtcclxuICAgICAgICB2YXIgcmVtYWluaW5nVGFza3MgPSBrZXlzLmxlbmd0aFxyXG4gICAgICAgIGlmICghcmVtYWluaW5nVGFza3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcmVzdWx0cyA9IHt9O1xyXG5cclxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gW107XHJcbiAgICAgICAgdmFyIGFkZExpc3RlbmVyID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgICAgIGxpc3RlbmVycy51bnNoaWZ0KGZuKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciByZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tpXSA9PT0gZm4pIHtcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHRhc2tDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmVtYWluaW5nVGFza3MtLVxyXG4gICAgICAgICAgICBfZWFjaChsaXN0ZW5lcnMuc2xpY2UoMCksIGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgICAgICAgICAgZm4oKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgYWRkTGlzdGVuZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXJlbWFpbmluZ1Rhc2tzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGhlQ2FsbGJhY2sgPSBjYWxsYmFjaztcclxuICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgZmluYWwgY2FsbGJhY2sgZnJvbSBjYWxsaW5nIGl0c2VsZiBpZiBpdCBlcnJvcnNcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XHJcblxyXG4gICAgICAgICAgICAgICAgdGhlQ2FsbGJhY2sobnVsbCwgcmVzdWx0cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgX2VhY2goa2V5cywgZnVuY3Rpb24gKGspIHtcclxuICAgICAgICAgICAgdmFyIHRhc2sgPSBfaXNBcnJheSh0YXNrc1trXSkgPyB0YXNrc1trXTogW3Rhc2tzW2tdXTtcclxuICAgICAgICAgICAgdmFyIHRhc2tDYWxsYmFjayA9IGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNhZmVSZXN1bHRzID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgX2VhY2goX2tleXMocmVzdWx0cyksIGZ1bmN0aW9uKHJrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2FmZVJlc3VsdHNbcmtleV0gPSByZXN1bHRzW3JrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHNhZmVSZXN1bHRzW2tdID0gYXJncztcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHNhZmVSZXN1bHRzKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzdG9wIHN1YnNlcXVlbnQgZXJyb3JzIGhpdHRpbmcgY2FsbGJhY2sgbXVsdGlwbGUgdGltZXNcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1trXSA9IGFyZ3M7XHJcbiAgICAgICAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKHRhc2tDb21wbGV0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciByZXF1aXJlcyA9IHRhc2suc2xpY2UoMCwgTWF0aC5hYnModGFzay5sZW5ndGggLSAxKSkgfHwgW107XHJcbiAgICAgICAgICAgIHZhciByZWFkeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfcmVkdWNlKHJlcXVpcmVzLCBmdW5jdGlvbiAoYSwgeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoYSAmJiByZXN1bHRzLmhhc093blByb3BlcnR5KHgpKTtcclxuICAgICAgICAgICAgICAgIH0sIHRydWUpICYmICFyZXN1bHRzLmhhc093blByb3BlcnR5KGspO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAocmVhZHkoKSkge1xyXG4gICAgICAgICAgICAgICAgdGFza1t0YXNrLmxlbmd0aCAtIDFdKHRhc2tDYWxsYmFjaywgcmVzdWx0cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlYWR5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrW3Rhc2subGVuZ3RoIC0gMV0odGFza0NhbGxiYWNrLCByZXN1bHRzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgYWRkTGlzdGVuZXIobGlzdGVuZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGFzeW5jLnJldHJ5ID0gZnVuY3Rpb24odGltZXMsIHRhc2ssIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIERFRkFVTFRfVElNRVMgPSA1O1xyXG4gICAgICAgIHZhciBhdHRlbXB0cyA9IFtdO1xyXG4gICAgICAgIC8vIFVzZSBkZWZhdWx0cyBpZiB0aW1lcyBub3QgcGFzc2VkXHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aW1lcyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBjYWxsYmFjayA9IHRhc2s7XHJcbiAgICAgICAgICAgIHRhc2sgPSB0aW1lcztcclxuICAgICAgICAgICAgdGltZXMgPSBERUZBVUxUX1RJTUVTO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBNYWtlIHN1cmUgdGltZXMgaXMgYSBudW1iZXJcclxuICAgICAgICB0aW1lcyA9IHBhcnNlSW50KHRpbWVzLCAxMCkgfHwgREVGQVVMVF9USU1FUztcclxuICAgICAgICB2YXIgd3JhcHBlZFRhc2sgPSBmdW5jdGlvbih3cmFwcGVkQ2FsbGJhY2ssIHdyYXBwZWRSZXN1bHRzKSB7XHJcbiAgICAgICAgICAgIHZhciByZXRyeUF0dGVtcHQgPSBmdW5jdGlvbih0YXNrLCBmaW5hbEF0dGVtcHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihzZXJpZXNDYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhc2soZnVuY3Rpb24oZXJyLCByZXN1bHQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNDYWxsYmFjayghZXJyIHx8IGZpbmFsQXR0ZW1wdCwge2VycjogZXJyLCByZXN1bHQ6IHJlc3VsdH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIHdyYXBwZWRSZXN1bHRzKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHdoaWxlICh0aW1lcykge1xyXG4gICAgICAgICAgICAgICAgYXR0ZW1wdHMucHVzaChyZXRyeUF0dGVtcHQodGFzaywgISh0aW1lcy09MSkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhc3luYy5zZXJpZXMoYXR0ZW1wdHMsIGZ1bmN0aW9uKGRvbmUsIGRhdGEpe1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgICh3cmFwcGVkQ2FsbGJhY2sgfHwgY2FsbGJhY2spKGRhdGEuZXJyLCBkYXRhLnJlc3VsdCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiBhIGNhbGxiYWNrIGlzIHBhc3NlZCwgcnVuIHRoaXMgYXMgYSBjb250cm9sbCBmbG93XHJcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrID8gd3JhcHBlZFRhc2soKSA6IHdyYXBwZWRUYXNrXHJcbiAgICB9O1xyXG5cclxuICAgIGFzeW5jLndhdGVyZmFsbCA9IGZ1bmN0aW9uICh0YXNrcywgY2FsbGJhY2spIHtcclxuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xyXG4gICAgICAgIGlmICghX2lzQXJyYXkodGFza3MpKSB7XHJcbiAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCB0byB3YXRlcmZhbGwgbXVzdCBiZSBhbiBhcnJheSBvZiBmdW5jdGlvbnMnKTtcclxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRhc2tzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHdyYXBJdGVyYXRvciA9IGZ1bmN0aW9uIChpdGVyYXRvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2god3JhcEl0ZXJhdG9yKG5leHQpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChjYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmFwcGx5KG51bGwsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgd3JhcEl0ZXJhdG9yKGFzeW5jLml0ZXJhdG9yKHRhc2tzKSkoKTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIF9wYXJhbGxlbCA9IGZ1bmN0aW9uKGVhY2hmbiwgdGFza3MsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcclxuICAgICAgICBpZiAoX2lzQXJyYXkodGFza3MpKSB7XHJcbiAgICAgICAgICAgIGVhY2hmbi5tYXAodGFza3MsIGZ1bmN0aW9uIChmbiwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIGlmIChmbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGZuKGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChudWxsLCBlcnIsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBjYWxsYmFjayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHt9O1xyXG4gICAgICAgICAgICBlYWNoZm4uZWFjaChfa2V5cyh0YXNrcyksIGZ1bmN0aW9uIChrLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgdGFza3Nba10oZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1trXSA9IGFyZ3M7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGFzeW5jLnBhcmFsbGVsID0gZnVuY3Rpb24gKHRhc2tzLCBjYWxsYmFjaykge1xyXG4gICAgICAgIF9wYXJhbGxlbCh7IG1hcDogYXN5bmMubWFwLCBlYWNoOiBhc3luYy5lYWNoIH0sIHRhc2tzLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG5cclxuICAgIGFzeW5jLnBhcmFsbGVsTGltaXQgPSBmdW5jdGlvbih0YXNrcywgbGltaXQsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgX3BhcmFsbGVsKHsgbWFwOiBfbWFwTGltaXQobGltaXQpLCBlYWNoOiBfZWFjaExpbWl0KGxpbWl0KSB9LCB0YXNrcywgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuXHJcbiAgICBhc3luYy5zZXJpZXMgPSBmdW5jdGlvbiAodGFza3MsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcclxuICAgICAgICBpZiAoX2lzQXJyYXkodGFza3MpKSB7XHJcbiAgICAgICAgICAgIGFzeW5jLm1hcFNlcmllcyh0YXNrcywgZnVuY3Rpb24gKGZuLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGZuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm4oZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKG51bGwsIGVyciwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIGNhbGxiYWNrKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0ge307XHJcbiAgICAgICAgICAgIGFzeW5jLmVhY2hTZXJpZXMoX2tleXModGFza3MpLCBmdW5jdGlvbiAoaywgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHRhc2tzW2tdKGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNba10gPSBhcmdzO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHRzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBhc3luYy5pdGVyYXRvciA9IGZ1bmN0aW9uICh0YXNrcykge1xyXG4gICAgICAgIHZhciBtYWtlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICAgICAgdmFyIGZuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhc2tzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhc2tzW2luZGV4XS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLm5leHQoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZm4ubmV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoaW5kZXggPCB0YXNrcy5sZW5ndGggLSAxKSA/IG1ha2VDYWxsYmFjayhpbmRleCArIDEpOiBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gZm47XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gbWFrZUNhbGxiYWNrKDApO1xyXG4gICAgfTtcclxuXHJcbiAgICBhc3luYy5hcHBseSA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkoXHJcbiAgICAgICAgICAgICAgICBudWxsLCBhcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBfY29uY2F0ID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBmbiwgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgciA9IFtdO1xyXG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYikge1xyXG4gICAgICAgICAgICBmbih4LCBmdW5jdGlvbiAoZXJyLCB5KSB7XHJcbiAgICAgICAgICAgICAgICByID0gci5jb25jYXQoeSB8fCBbXSk7XHJcbiAgICAgICAgICAgICAgICBjYihlcnIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgYXN5bmMuY29uY2F0ID0gZG9QYXJhbGxlbChfY29uY2F0KTtcclxuICAgIGFzeW5jLmNvbmNhdFNlcmllcyA9IGRvU2VyaWVzKF9jb25jYXQpO1xyXG5cclxuICAgIGFzeW5jLndoaWxzdCA9IGZ1bmN0aW9uICh0ZXN0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAodGVzdCgpKSB7XHJcbiAgICAgICAgICAgIGl0ZXJhdG9yKGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFzeW5jLndoaWxzdCh0ZXN0LCBpdGVyYXRvciwgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBhc3luYy5kb1doaWxzdCA9IGZ1bmN0aW9uIChpdGVyYXRvciwgdGVzdCwgY2FsbGJhY2spIHtcclxuICAgICAgICBpdGVyYXRvcihmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuICAgICAgICAgICAgaWYgKHRlc3QuYXBwbHkobnVsbCwgYXJncykpIHtcclxuICAgICAgICAgICAgICAgIGFzeW5jLmRvV2hpbHN0KGl0ZXJhdG9yLCB0ZXN0LCBjYWxsYmFjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGFzeW5jLnVudGlsID0gZnVuY3Rpb24gKHRlc3QsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGlmICghdGVzdCgpKSB7XHJcbiAgICAgICAgICAgIGl0ZXJhdG9yKGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFzeW5jLnVudGlsKHRlc3QsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGFzeW5jLmRvVW50aWwgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIHRlc3QsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaXRlcmF0b3IoZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcbiAgICAgICAgICAgIGlmICghdGVzdC5hcHBseShudWxsLCBhcmdzKSkge1xyXG4gICAgICAgICAgICAgICAgYXN5bmMuZG9VbnRpbChpdGVyYXRvciwgdGVzdCwgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBhc3luYy5xdWV1ZSA9IGZ1bmN0aW9uICh3b3JrZXIsIGNvbmN1cnJlbmN5KSB7XHJcbiAgICAgICAgaWYgKGNvbmN1cnJlbmN5ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY29uY3VycmVuY3kgPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBfaW5zZXJ0KHEsIGRhdGEsIHBvcywgY2FsbGJhY2spIHtcclxuICAgICAgICAgIGlmICghcS5zdGFydGVkKXtcclxuICAgICAgICAgICAgcS5zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICghX2lzQXJyYXkoZGF0YSkpIHtcclxuICAgICAgICAgICAgICBkYXRhID0gW2RhdGFdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYoZGF0YS5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICAgLy8gY2FsbCBkcmFpbiBpbW1lZGlhdGVseSBpZiB0aGVyZSBhcmUgbm8gdGFza3NcclxuICAgICAgICAgICAgIHJldHVybiBhc3luYy5zZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgaWYgKHEuZHJhaW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgcS5kcmFpbigpO1xyXG4gICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgX2VhY2goZGF0YSwgZnVuY3Rpb24odGFzaykge1xyXG4gICAgICAgICAgICAgIHZhciBpdGVtID0ge1xyXG4gICAgICAgICAgICAgICAgICBkYXRhOiB0YXNrLFxyXG4gICAgICAgICAgICAgICAgICBjYWxsYmFjazogdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gY2FsbGJhY2sgOiBudWxsXHJcbiAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKHBvcykge1xyXG4gICAgICAgICAgICAgICAgcS50YXNrcy51bnNoaWZ0KGl0ZW0pO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBxLnRhc2tzLnB1c2goaXRlbSk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBpZiAocS5zYXR1cmF0ZWQgJiYgcS50YXNrcy5sZW5ndGggPT09IHEuY29uY3VycmVuY3kpIHtcclxuICAgICAgICAgICAgICAgICAgcS5zYXR1cmF0ZWQoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKHEucHJvY2Vzcyk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB3b3JrZXJzID0gMDtcclxuICAgICAgICB2YXIgcSA9IHtcclxuICAgICAgICAgICAgdGFza3M6IFtdLFxyXG4gICAgICAgICAgICBjb25jdXJyZW5jeTogY29uY3VycmVuY3ksXHJcbiAgICAgICAgICAgIHNhdHVyYXRlZDogbnVsbCxcclxuICAgICAgICAgICAgZW1wdHk6IG51bGwsXHJcbiAgICAgICAgICAgIGRyYWluOiBudWxsLFxyXG4gICAgICAgICAgICBzdGFydGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgcGF1c2VkOiBmYWxzZSxcclxuICAgICAgICAgICAgcHVzaDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgX2luc2VydChxLCBkYXRhLCBmYWxzZSwgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBraWxsOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgcS5kcmFpbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgcS50YXNrcyA9IFtdO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB1bnNoaWZ0OiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICBfaW5zZXJ0KHEsIGRhdGEsIHRydWUsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFxLnBhdXNlZCAmJiB3b3JrZXJzIDwgcS5jb25jdXJyZW5jeSAmJiBxLnRhc2tzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXNrID0gcS50YXNrcy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChxLmVtcHR5ICYmIHEudGFza3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHEuZW1wdHkoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgd29ya2VycyArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrZXJzIC09IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXNrLmNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrLmNhbGxiYWNrLmFwcGx5KHRhc2ssIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHEuZHJhaW4gJiYgcS50YXNrcy5sZW5ndGggKyB3b3JrZXJzID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxLmRyYWluKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcS5wcm9jZXNzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2IgPSBvbmx5X29uY2UobmV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd29ya2VyKHRhc2suZGF0YSwgY2IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBsZW5ndGg6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBxLnRhc2tzLmxlbmd0aDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcnVubmluZzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtlcnM7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGlkbGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHEudGFza3MubGVuZ3RoICsgd29ya2VycyA9PT0gMDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChxLnBhdXNlZCA9PT0gdHJ1ZSkgeyByZXR1cm47IH1cclxuICAgICAgICAgICAgICAgIHEucGF1c2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHEucHJvY2VzcygpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZXN1bWU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChxLnBhdXNlZCA9PT0gZmFsc2UpIHsgcmV0dXJuOyB9XHJcbiAgICAgICAgICAgICAgICBxLnBhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcS5wcm9jZXNzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBxO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgYXN5bmMucHJpb3JpdHlRdWV1ZSA9IGZ1bmN0aW9uICh3b3JrZXIsIGNvbmN1cnJlbmN5KSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZnVuY3Rpb24gX2NvbXBhcmVUYXNrcyhhLCBiKXtcclxuICAgICAgICAgIHJldHVybiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIGZ1bmN0aW9uIF9iaW5hcnlTZWFyY2goc2VxdWVuY2UsIGl0ZW0sIGNvbXBhcmUpIHtcclxuICAgICAgICAgIHZhciBiZWcgPSAtMSxcclxuICAgICAgICAgICAgICBlbmQgPSBzZXF1ZW5jZS5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgd2hpbGUgKGJlZyA8IGVuZCkge1xyXG4gICAgICAgICAgICB2YXIgbWlkID0gYmVnICsgKChlbmQgLSBiZWcgKyAxKSA+Pj4gMSk7XHJcbiAgICAgICAgICAgIGlmIChjb21wYXJlKGl0ZW0sIHNlcXVlbmNlW21pZF0pID49IDApIHtcclxuICAgICAgICAgICAgICBiZWcgPSBtaWQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgZW5kID0gbWlkIC0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIGJlZztcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgZnVuY3Rpb24gX2luc2VydChxLCBkYXRhLCBwcmlvcml0eSwgY2FsbGJhY2spIHtcclxuICAgICAgICAgIGlmICghcS5zdGFydGVkKXtcclxuICAgICAgICAgICAgcS5zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICghX2lzQXJyYXkoZGF0YSkpIHtcclxuICAgICAgICAgICAgICBkYXRhID0gW2RhdGFdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYoZGF0YS5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICAgLy8gY2FsbCBkcmFpbiBpbW1lZGlhdGVseSBpZiB0aGVyZSBhcmUgbm8gdGFza3NcclxuICAgICAgICAgICAgIHJldHVybiBhc3luYy5zZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgaWYgKHEuZHJhaW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgcS5kcmFpbigpO1xyXG4gICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgX2VhY2goZGF0YSwgZnVuY3Rpb24odGFzaykge1xyXG4gICAgICAgICAgICAgIHZhciBpdGVtID0ge1xyXG4gICAgICAgICAgICAgICAgICBkYXRhOiB0YXNrLFxyXG4gICAgICAgICAgICAgICAgICBwcmlvcml0eTogcHJpb3JpdHksXHJcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBjYWxsYmFjayA6IG51bGxcclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIHEudGFza3Muc3BsaWNlKF9iaW5hcnlTZWFyY2gocS50YXNrcywgaXRlbSwgX2NvbXBhcmVUYXNrcykgKyAxLCAwLCBpdGVtKTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKHEuc2F0dXJhdGVkICYmIHEudGFza3MubGVuZ3RoID09PSBxLmNvbmN1cnJlbmN5KSB7XHJcbiAgICAgICAgICAgICAgICAgIHEuc2F0dXJhdGVkKCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZShxLnByb2Nlc3MpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFN0YXJ0IHdpdGggYSBub3JtYWwgcXVldWVcclxuICAgICAgICB2YXIgcSA9IGFzeW5jLnF1ZXVlKHdvcmtlciwgY29uY3VycmVuY3kpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIE92ZXJyaWRlIHB1c2ggdG8gYWNjZXB0IHNlY29uZCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIHByaW9yaXR5XHJcbiAgICAgICAgcS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIHByaW9yaXR5LCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgX2luc2VydChxLCBkYXRhLCBwcmlvcml0eSwgY2FsbGJhY2spO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gUmVtb3ZlIHVuc2hpZnQgZnVuY3Rpb25cclxuICAgICAgICBkZWxldGUgcS51bnNoaWZ0O1xyXG5cclxuICAgICAgICByZXR1cm4gcTtcclxuICAgIH07XHJcblxyXG4gICAgYXN5bmMuY2FyZ28gPSBmdW5jdGlvbiAod29ya2VyLCBwYXlsb2FkKSB7XHJcbiAgICAgICAgdmFyIHdvcmtpbmcgICAgID0gZmFsc2UsXHJcbiAgICAgICAgICAgIHRhc2tzICAgICAgID0gW107XHJcblxyXG4gICAgICAgIHZhciBjYXJnbyA9IHtcclxuICAgICAgICAgICAgdGFza3M6IHRhc2tzLFxyXG4gICAgICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxyXG4gICAgICAgICAgICBzYXR1cmF0ZWQ6IG51bGwsXHJcbiAgICAgICAgICAgIGVtcHR5OiBudWxsLFxyXG4gICAgICAgICAgICBkcmFpbjogbnVsbCxcclxuICAgICAgICAgICAgZHJhaW5lZDogdHJ1ZSxcclxuICAgICAgICAgICAgcHVzaDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIV9pc0FycmF5KGRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IFtkYXRhXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF9lYWNoKGRhdGEsIGZ1bmN0aW9uKHRhc2spIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXNrcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdGFzayxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IGNhbGxiYWNrIDogbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhcmdvLmRyYWluZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FyZ28uc2F0dXJhdGVkICYmIHRhc2tzLmxlbmd0aCA9PT0gcGF5bG9hZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJnby5zYXR1cmF0ZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZShjYXJnby5wcm9jZXNzKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gcHJvY2VzcygpIHtcclxuICAgICAgICAgICAgICAgIGlmICh3b3JraW5nKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBpZiAodGFza3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoY2FyZ28uZHJhaW4gJiYgIWNhcmdvLmRyYWluZWQpIGNhcmdvLmRyYWluKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FyZ28uZHJhaW5lZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciB0cyA9IHR5cGVvZiBwYXlsb2FkID09PSAnbnVtYmVyJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0YXNrcy5zcGxpY2UoMCwgcGF5bG9hZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGFza3Muc3BsaWNlKDAsIHRhc2tzLmxlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGRzID0gX21hcCh0cywgZnVuY3Rpb24gKHRhc2spIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFzay5kYXRhO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoY2FyZ28uZW1wdHkpIGNhcmdvLmVtcHR5KCk7XHJcbiAgICAgICAgICAgICAgICB3b3JraW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHdvcmtlcihkcywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdvcmtpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XHJcbiAgICAgICAgICAgICAgICAgICAgX2VhY2godHMsIGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBsZW5ndGg6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0YXNrcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJ1bm5pbmc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB3b3JraW5nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gY2FyZ287XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBfY29uc29sZV9mbiA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcbiAgICAgICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MuY29uY2F0KFtmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uc29sZS5lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbnNvbGVbbmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2VhY2goYXJncywgZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGVbbmFtZV0oeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfV0pKTtcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIGFzeW5jLmxvZyA9IF9jb25zb2xlX2ZuKCdsb2cnKTtcclxuICAgIGFzeW5jLmRpciA9IF9jb25zb2xlX2ZuKCdkaXInKTtcclxuICAgIC8qYXN5bmMuaW5mbyA9IF9jb25zb2xlX2ZuKCdpbmZvJyk7XHJcbiAgICBhc3luYy53YXJuID0gX2NvbnNvbGVfZm4oJ3dhcm4nKTtcclxuICAgIGFzeW5jLmVycm9yID0gX2NvbnNvbGVfZm4oJ2Vycm9yJyk7Ki9cclxuXHJcbiAgICBhc3luYy5tZW1vaXplID0gZnVuY3Rpb24gKGZuLCBoYXNoZXIpIHtcclxuICAgICAgICB2YXIgbWVtbyA9IHt9O1xyXG4gICAgICAgIHZhciBxdWV1ZXMgPSB7fTtcclxuICAgICAgICBoYXNoZXIgPSBoYXNoZXIgfHwgZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcclxuICAgICAgICAgICAgdmFyIGtleSA9IGhhc2hlci5hcHBseShudWxsLCBhcmdzKTtcclxuICAgICAgICAgICAgaWYgKGtleSBpbiBtZW1vKSB7XHJcbiAgICAgICAgICAgICAgICBhc3luYy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgbWVtb1trZXldKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSBpbiBxdWV1ZXMpIHtcclxuICAgICAgICAgICAgICAgIHF1ZXVlc1trZXldLnB1c2goY2FsbGJhY2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcXVldWVzW2tleV0gPSBbY2FsbGJhY2tdO1xyXG4gICAgICAgICAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncy5jb25jYXQoW2Z1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBtZW1vW2tleV0gPSBhcmd1bWVudHM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHEgPSBxdWV1ZXNba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcXVldWVzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBxLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgcVtpXS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1dKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIG1lbW9pemVkLm1lbW8gPSBtZW1vO1xyXG4gICAgICAgIG1lbW9pemVkLnVubWVtb2l6ZWQgPSBmbjtcclxuICAgICAgICByZXR1cm4gbWVtb2l6ZWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIGFzeW5jLnVubWVtb2l6ZSA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAoZm4udW5tZW1vaXplZCB8fCBmbikuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgYXN5bmMudGltZXMgPSBmdW5jdGlvbiAoY291bnQsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBjb3VudGVyID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvdW50ZXIucHVzaChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFzeW5jLm1hcChjb3VudGVyLCBpdGVyYXRvciwgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuXHJcbiAgICBhc3luYy50aW1lc1NlcmllcyA9IGZ1bmN0aW9uIChjb3VudCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIGNvdW50ZXIgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgY291bnRlci5wdXNoKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXN5bmMubWFwU2VyaWVzKGNvdW50ZXIsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XHJcbiAgICB9O1xyXG5cclxuICAgIGFzeW5jLnNlcSA9IGZ1bmN0aW9uICgvKiBmdW5jdGlvbnMuLi4gKi8pIHtcclxuICAgICAgICB2YXIgZm5zID0gYXJndW1lbnRzO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xyXG4gICAgICAgICAgICBhc3luYy5yZWR1Y2UoZm5zLCBhcmdzLCBmdW5jdGlvbiAobmV3YXJncywgZm4sIGNiKSB7XHJcbiAgICAgICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBuZXdhcmdzLmNvbmNhdChbZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSBhcmd1bWVudHNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBjYihlcnIsIG5leHRhcmdzKTtcclxuICAgICAgICAgICAgICAgIH1dKSlcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGVyciwgcmVzdWx0cykge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodGhhdCwgW2Vycl0uY29uY2F0KHJlc3VsdHMpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgYXN5bmMuY29tcG9zZSA9IGZ1bmN0aW9uICgvKiBmdW5jdGlvbnMuLi4gKi8pIHtcclxuICAgICAgcmV0dXJuIGFzeW5jLnNlcS5hcHBseShudWxsLCBBcnJheS5wcm90b3R5cGUucmV2ZXJzZS5jYWxsKGFyZ3VtZW50cykpO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgX2FwcGx5RWFjaCA9IGZ1bmN0aW9uIChlYWNoZm4sIGZucyAvKmFyZ3MuLi4qLykge1xyXG4gICAgICAgIHZhciBnbyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBlYWNoZm4oZm5zLCBmdW5jdGlvbiAoZm4sIGNiKSB7XHJcbiAgICAgICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBhcmdzLmNvbmNhdChbY2JdKSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNhbGxiYWNrKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XHJcbiAgICAgICAgICAgIHJldHVybiBnby5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnbztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgYXN5bmMuYXBwbHlFYWNoID0gZG9QYXJhbGxlbChfYXBwbHlFYWNoKTtcclxuICAgIGFzeW5jLmFwcGx5RWFjaFNlcmllcyA9IGRvU2VyaWVzKF9hcHBseUVhY2gpO1xyXG5cclxuICAgIGFzeW5jLmZvcmV2ZXIgPSBmdW5jdGlvbiAoZm4sIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gbmV4dChlcnIpIHtcclxuICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm4obmV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5leHQoKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gTm9kZS5qc1xyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBhc3luYztcclxuICAgIH1cclxuICAgIC8vIEFNRCAvIFJlcXVpcmVKU1xyXG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShbXSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXN5bmM7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBpbmNsdWRlZCBkaXJlY3RseSB2aWEgPHNjcmlwdD4gdGFnXHJcbiAgICBlbHNlIHtcclxuICAgICAgICByb290LmFzeW5jID0gYXN5bmM7XHJcbiAgICB9XHJcblxyXG59KCkpO1xyXG4iLCIvLyAgICAgVW5kZXJzY29yZS5qcyAxLjguMlxyXG4vLyAgICAgaHR0cDovL3VuZGVyc2NvcmVqcy5vcmdcclxuLy8gICAgIChjKSAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcclxuLy8gICAgIFVuZGVyc2NvcmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXHJcblxyXG4oZnVuY3Rpb24oKSB7XHJcblxyXG4gIC8vIEJhc2VsaW5lIHNldHVwXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLy8gRXN0YWJsaXNoIHRoZSByb290IG9iamVjdCwgYHdpbmRvd2AgaW4gdGhlIGJyb3dzZXIsIG9yIGBleHBvcnRzYCBvbiB0aGUgc2VydmVyLlxyXG4gIHZhciByb290ID0gdGhpcztcclxuXHJcbiAgLy8gU2F2ZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGBfYCB2YXJpYWJsZS5cclxuICB2YXIgcHJldmlvdXNVbmRlcnNjb3JlID0gcm9vdC5fO1xyXG5cclxuICAvLyBTYXZlIGJ5dGVzIGluIHRoZSBtaW5pZmllZCAoYnV0IG5vdCBnemlwcGVkKSB2ZXJzaW9uOlxyXG4gIHZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLCBPYmpQcm90byA9IE9iamVjdC5wcm90b3R5cGUsIEZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcclxuXHJcbiAgLy8gQ3JlYXRlIHF1aWNrIHJlZmVyZW5jZSB2YXJpYWJsZXMgZm9yIHNwZWVkIGFjY2VzcyB0byBjb3JlIHByb3RvdHlwZXMuXHJcbiAgdmFyXHJcbiAgICBwdXNoICAgICAgICAgICAgID0gQXJyYXlQcm90by5wdXNoLFxyXG4gICAgc2xpY2UgICAgICAgICAgICA9IEFycmF5UHJvdG8uc2xpY2UsXHJcbiAgICB0b1N0cmluZyAgICAgICAgID0gT2JqUHJvdG8udG9TdHJpbmcsXHJcbiAgICBoYXNPd25Qcm9wZXJ0eSAgID0gT2JqUHJvdG8uaGFzT3duUHJvcGVydHk7XHJcblxyXG4gIC8vIEFsbCAqKkVDTUFTY3JpcHQgNSoqIG5hdGl2ZSBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbnMgdGhhdCB3ZSBob3BlIHRvIHVzZVxyXG4gIC8vIGFyZSBkZWNsYXJlZCBoZXJlLlxyXG4gIHZhclxyXG4gICAgbmF0aXZlSXNBcnJheSAgICAgID0gQXJyYXkuaXNBcnJheSxcclxuICAgIG5hdGl2ZUtleXMgICAgICAgICA9IE9iamVjdC5rZXlzLFxyXG4gICAgbmF0aXZlQmluZCAgICAgICAgID0gRnVuY1Byb3RvLmJpbmQsXHJcbiAgICBuYXRpdmVDcmVhdGUgICAgICAgPSBPYmplY3QuY3JlYXRlO1xyXG5cclxuICAvLyBOYWtlZCBmdW5jdGlvbiByZWZlcmVuY2UgZm9yIHN1cnJvZ2F0ZS1wcm90b3R5cGUtc3dhcHBpbmcuXHJcbiAgdmFyIEN0b3IgPSBmdW5jdGlvbigpe307XHJcblxyXG4gIC8vIENyZWF0ZSBhIHNhZmUgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgdXNlIGJlbG93LlxyXG4gIHZhciBfID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgXykgcmV0dXJuIG9iajtcclxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfKSkgcmV0dXJuIG5ldyBfKG9iaik7XHJcbiAgICB0aGlzLl93cmFwcGVkID0gb2JqO1xyXG4gIH07XHJcblxyXG4gIC8vIEV4cG9ydCB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yICoqTm9kZS5qcyoqLCB3aXRoXHJcbiAgLy8gYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgZm9yIHRoZSBvbGQgYHJlcXVpcmUoKWAgQVBJLiBJZiB3ZSdyZSBpblxyXG4gIC8vIHRoZSBicm93c2VyLCBhZGQgYF9gIGFzIGEgZ2xvYmFsIG9iamVjdC5cclxuICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcclxuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gXztcclxuICAgIH1cclxuICAgIGV4cG9ydHMuXyA9IF87XHJcbiAgfSBlbHNlIHtcclxuICAgIHJvb3QuXyA9IF87XHJcbiAgfVxyXG5cclxuICAvLyBDdXJyZW50IHZlcnNpb24uXHJcbiAgXy5WRVJTSU9OID0gJzEuOC4yJztcclxuXHJcbiAgLy8gSW50ZXJuYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGVmZmljaWVudCAoZm9yIGN1cnJlbnQgZW5naW5lcykgdmVyc2lvblxyXG4gIC8vIG9mIHRoZSBwYXNzZWQtaW4gY2FsbGJhY2ssIHRvIGJlIHJlcGVhdGVkbHkgYXBwbGllZCBpbiBvdGhlciBVbmRlcnNjb3JlXHJcbiAgLy8gZnVuY3Rpb25zLlxyXG4gIHZhciBvcHRpbWl6ZUNiID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCwgYXJnQ291bnQpIHtcclxuICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHJldHVybiBmdW5jO1xyXG4gICAgc3dpdGNoIChhcmdDb3VudCA9PSBudWxsID8gMyA6IGFyZ0NvdW50KSB7XHJcbiAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSk7XHJcbiAgICAgIH07XHJcbiAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xyXG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUsIG90aGVyKTtcclxuICAgICAgfTtcclxuICAgICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xyXG4gICAgICB9O1xyXG4gICAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCBhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgLy8gQSBtb3N0bHktaW50ZXJuYWwgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgY2FsbGJhY2tzIHRoYXQgY2FuIGJlIGFwcGxpZWRcclxuICAvLyB0byBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uLCByZXR1cm5pbmcgdGhlIGRlc2lyZWQgcmVzdWx0IOKAlCBlaXRoZXJcclxuICAvLyBpZGVudGl0eSwgYW4gYXJiaXRyYXJ5IGNhbGxiYWNrLCBhIHByb3BlcnR5IG1hdGNoZXIsIG9yIGEgcHJvcGVydHkgYWNjZXNzb3IuXHJcbiAgdmFyIGNiID0gZnVuY3Rpb24odmFsdWUsIGNvbnRleHQsIGFyZ0NvdW50KSB7XHJcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIF8uaWRlbnRpdHk7XHJcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHZhbHVlKSkgcmV0dXJuIG9wdGltaXplQ2IodmFsdWUsIGNvbnRleHQsIGFyZ0NvdW50KTtcclxuICAgIGlmIChfLmlzT2JqZWN0KHZhbHVlKSkgcmV0dXJuIF8ubWF0Y2hlcih2YWx1ZSk7XHJcbiAgICByZXR1cm4gXy5wcm9wZXJ0eSh2YWx1ZSk7XHJcbiAgfTtcclxuICBfLml0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGNvbnRleHQpIHtcclxuICAgIHJldHVybiBjYih2YWx1ZSwgY29udGV4dCwgSW5maW5pdHkpO1xyXG4gIH07XHJcblxyXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhc3NpZ25lciBmdW5jdGlvbnMuXHJcbiAgdmFyIGNyZWF0ZUFzc2lnbmVyID0gZnVuY3Rpb24oa2V5c0Z1bmMsIHVuZGVmaW5lZE9ubHkpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcclxuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XHJcbiAgICAgIGlmIChsZW5ndGggPCAyIHx8IG9iaiA9PSBudWxsKSByZXR1cm4gb2JqO1xyXG4gICAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF0sXHJcbiAgICAgICAgICAgIGtleXMgPSBrZXlzRnVuYyhzb3VyY2UpLFxyXG4gICAgICAgICAgICBsID0ga2V5cy5sZW5ndGg7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xyXG4gICAgICAgICAgaWYgKCF1bmRlZmluZWRPbmx5IHx8IG9ialtrZXldID09PSB2b2lkIDApIG9ialtrZXldID0gc291cmNlW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIG5ldyBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIGFub3RoZXIuXHJcbiAgdmFyIGJhc2VDcmVhdGUgPSBmdW5jdGlvbihwcm90b3R5cGUpIHtcclxuICAgIGlmICghXy5pc09iamVjdChwcm90b3R5cGUpKSByZXR1cm4ge307XHJcbiAgICBpZiAobmF0aXZlQ3JlYXRlKSByZXR1cm4gbmF0aXZlQ3JlYXRlKHByb3RvdHlwZSk7XHJcbiAgICBDdG9yLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcclxuICAgIHZhciByZXN1bHQgPSBuZXcgQ3RvcjtcclxuICAgIEN0b3IucHJvdG90eXBlID0gbnVsbDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfTtcclxuXHJcbiAgLy8gSGVscGVyIGZvciBjb2xsZWN0aW9uIG1ldGhvZHMgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBjb2xsZWN0aW9uXHJcbiAgLy8gc2hvdWxkIGJlIGl0ZXJhdGVkIGFzIGFuIGFycmF5IG9yIGFzIGFuIG9iamVjdFxyXG4gIC8vIFJlbGF0ZWQ6IGh0dHA6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvbGVuZ3RoXHJcbiAgdmFyIE1BWF9BUlJBWV9JTkRFWCA9IE1hdGgucG93KDIsIDUzKSAtIDE7XHJcbiAgdmFyIGlzQXJyYXlMaWtlID0gZnVuY3Rpb24oY29sbGVjdGlvbikge1xyXG4gICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24gJiYgY29sbGVjdGlvbi5sZW5ndGg7XHJcbiAgICByZXR1cm4gdHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyAmJiBsZW5ndGggPj0gMCAmJiBsZW5ndGggPD0gTUFYX0FSUkFZX0lOREVYO1xyXG4gIH07XHJcblxyXG4gIC8vIENvbGxlY3Rpb24gRnVuY3Rpb25zXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLy8gVGhlIGNvcm5lcnN0b25lLCBhbiBgZWFjaGAgaW1wbGVtZW50YXRpb24sIGFrYSBgZm9yRWFjaGAuXHJcbiAgLy8gSGFuZGxlcyByYXcgb2JqZWN0cyBpbiBhZGRpdGlvbiB0byBhcnJheS1saWtlcy4gVHJlYXRzIGFsbFxyXG4gIC8vIHNwYXJzZSBhcnJheS1saWtlcyBhcyBpZiB0aGV5IHdlcmUgZGVuc2UuXHJcbiAgXy5lYWNoID0gXy5mb3JFYWNoID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xyXG4gICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcclxuICAgIHZhciBpLCBsZW5ndGg7XHJcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xyXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpdGVyYXRlZShvYmpbaV0sIGksIG9iaik7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XHJcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpdGVyYXRlZShvYmpba2V5c1tpXV0sIGtleXNbaV0sIG9iaik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvYmo7XHJcbiAgfTtcclxuXHJcbiAgLy8gUmV0dXJuIHRoZSByZXN1bHRzIG9mIGFwcGx5aW5nIHRoZSBpdGVyYXRlZSB0byBlYWNoIGVsZW1lbnQuXHJcbiAgXy5tYXAgPSBfLmNvbGxlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XHJcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcclxuICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXHJcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXHJcbiAgICAgICAgcmVzdWx0cyA9IEFycmF5KGxlbmd0aCk7XHJcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XHJcbiAgICAgIHJlc3VsdHNbaW5kZXhdID0gaXRlcmF0ZWUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgfTtcclxuXHJcbiAgLy8gQ3JlYXRlIGEgcmVkdWNpbmcgZnVuY3Rpb24gaXRlcmF0aW5nIGxlZnQgb3IgcmlnaHQuXHJcbiAgZnVuY3Rpb24gY3JlYXRlUmVkdWNlKGRpcikge1xyXG4gICAgLy8gT3B0aW1pemVkIGl0ZXJhdG9yIGZ1bmN0aW9uIGFzIHVzaW5nIGFyZ3VtZW50cy5sZW5ndGhcclxuICAgIC8vIGluIHRoZSBtYWluIGZ1bmN0aW9uIHdpbGwgZGVvcHRpbWl6ZSB0aGUsIHNlZSAjMTk5MS5cclxuICAgIGZ1bmN0aW9uIGl0ZXJhdG9yKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGtleXMsIGluZGV4LCBsZW5ndGgpIHtcclxuICAgICAgZm9yICg7IGluZGV4ID49IDAgJiYgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IGRpcikge1xyXG4gICAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XHJcbiAgICAgICAgbWVtbyA9IGl0ZXJhdGVlKG1lbW8sIG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbWVtbztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgbWVtbywgY29udGV4dCkge1xyXG4gICAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQsIDQpO1xyXG4gICAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxyXG4gICAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXHJcbiAgICAgICAgICBpbmRleCA9IGRpciA+IDAgPyAwIDogbGVuZ3RoIC0gMTtcclxuICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBpbml0aWFsIHZhbHVlIGlmIG5vbmUgaXMgcHJvdmlkZWQuXHJcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xyXG4gICAgICAgIG1lbW8gPSBvYmpba2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXhdO1xyXG4gICAgICAgIGluZGV4ICs9IGRpcjtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gaXRlcmF0b3Iob2JqLCBpdGVyYXRlZSwgbWVtbywga2V5cywgaW5kZXgsIGxlbmd0aCk7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gKipSZWR1Y2UqKiBidWlsZHMgdXAgYSBzaW5nbGUgcmVzdWx0IGZyb20gYSBsaXN0IG9mIHZhbHVlcywgYWthIGBpbmplY3RgLFxyXG4gIC8vIG9yIGBmb2xkbGAuXHJcbiAgXy5yZWR1Y2UgPSBfLmZvbGRsID0gXy5pbmplY3QgPSBjcmVhdGVSZWR1Y2UoMSk7XHJcblxyXG4gIC8vIFRoZSByaWdodC1hc3NvY2lhdGl2ZSB2ZXJzaW9uIG9mIHJlZHVjZSwgYWxzbyBrbm93biBhcyBgZm9sZHJgLlxyXG4gIF8ucmVkdWNlUmlnaHQgPSBfLmZvbGRyID0gY3JlYXRlUmVkdWNlKC0xKTtcclxuXHJcbiAgLy8gUmV0dXJuIHRoZSBmaXJzdCB2YWx1ZSB3aGljaCBwYXNzZXMgYSB0cnV0aCB0ZXN0LiBBbGlhc2VkIGFzIGBkZXRlY3RgLlxyXG4gIF8uZmluZCA9IF8uZGV0ZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcclxuICAgIHZhciBrZXk7XHJcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xyXG4gICAgICBrZXkgPSBfLmZpbmRJbmRleChvYmosIHByZWRpY2F0ZSwgY29udGV4dCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBrZXkgPSBfLmZpbmRLZXkob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgaWYgKGtleSAhPT0gdm9pZCAwICYmIGtleSAhPT0gLTEpIHJldHVybiBvYmpba2V5XTtcclxuICB9O1xyXG5cclxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyB0aGF0IHBhc3MgYSB0cnV0aCB0ZXN0LlxyXG4gIC8vIEFsaWFzZWQgYXMgYHNlbGVjdGAuXHJcbiAgXy5maWx0ZXIgPSBfLnNlbGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XHJcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xyXG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcclxuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xyXG4gICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgbGlzdCkpIHJlc3VsdHMucHVzaCh2YWx1ZSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHRzO1xyXG4gIH07XHJcblxyXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGZvciB3aGljaCBhIHRydXRoIHRlc3QgZmFpbHMuXHJcbiAgXy5yZWplY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xyXG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5uZWdhdGUoY2IocHJlZGljYXRlKSksIGNvbnRleHQpO1xyXG4gIH07XHJcblxyXG4gIC8vIERldGVybWluZSB3aGV0aGVyIGFsbCBvZiB0aGUgZWxlbWVudHMgbWF0Y2ggYSB0cnV0aCB0ZXN0LlxyXG4gIC8vIEFsaWFzZWQgYXMgYGFsbGAuXHJcbiAgXy5ldmVyeSA9IF8uYWxsID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcclxuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XHJcbiAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxyXG4gICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoO1xyXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xyXG4gICAgICBpZiAoIXByZWRpY2F0ZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaikpIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH07XHJcblxyXG4gIC8vIERldGVybWluZSBpZiBhdCBsZWFzdCBvbmUgZWxlbWVudCBpbiB0aGUgb2JqZWN0IG1hdGNoZXMgYSB0cnV0aCB0ZXN0LlxyXG4gIC8vIEFsaWFzZWQgYXMgYGFueWAuXHJcbiAgXy5zb21lID0gXy5hbnkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xyXG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcclxuICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXHJcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XHJcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9O1xyXG5cclxuICAvLyBEZXRlcm1pbmUgaWYgdGhlIGFycmF5IG9yIG9iamVjdCBjb250YWlucyBhIGdpdmVuIHZhbHVlICh1c2luZyBgPT09YCkuXHJcbiAgLy8gQWxpYXNlZCBhcyBgaW5jbHVkZXNgIGFuZCBgaW5jbHVkZWAuXHJcbiAgXy5jb250YWlucyA9IF8uaW5jbHVkZXMgPSBfLmluY2x1ZGUgPSBmdW5jdGlvbihvYmosIHRhcmdldCwgZnJvbUluZGV4KSB7XHJcbiAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XHJcbiAgICByZXR1cm4gXy5pbmRleE9mKG9iaiwgdGFyZ2V0LCB0eXBlb2YgZnJvbUluZGV4ID09ICdudW1iZXInICYmIGZyb21JbmRleCkgPj0gMDtcclxuICB9O1xyXG5cclxuICAvLyBJbnZva2UgYSBtZXRob2QgKHdpdGggYXJndW1lbnRzKSBvbiBldmVyeSBpdGVtIGluIGEgY29sbGVjdGlvbi5cclxuICBfLmludm9rZSA9IGZ1bmN0aW9uKG9iaiwgbWV0aG9kKSB7XHJcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcclxuICAgIHZhciBpc0Z1bmMgPSBfLmlzRnVuY3Rpb24obWV0aG9kKTtcclxuICAgIHJldHVybiBfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgIHZhciBmdW5jID0gaXNGdW5jID8gbWV0aG9kIDogdmFsdWVbbWV0aG9kXTtcclxuICAgICAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IGZ1bmMgOiBmdW5jLmFwcGx5KHZhbHVlLCBhcmdzKTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYG1hcGA6IGZldGNoaW5nIGEgcHJvcGVydHkuXHJcbiAgXy5wbHVjayA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XHJcbiAgICByZXR1cm4gXy5tYXAob2JqLCBfLnByb3BlcnR5KGtleSkpO1xyXG4gIH07XHJcblxyXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbHRlcmA6IHNlbGVjdGluZyBvbmx5IG9iamVjdHNcclxuICAvLyBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxyXG4gIF8ud2hlcmUgPSBmdW5jdGlvbihvYmosIGF0dHJzKSB7XHJcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcclxuICB9O1xyXG5cclxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaW5kYDogZ2V0dGluZyB0aGUgZmlyc3Qgb2JqZWN0XHJcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cclxuICBfLmZpbmRXaGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcclxuICAgIHJldHVybiBfLmZpbmQob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcclxuICB9O1xyXG5cclxuICAvLyBSZXR1cm4gdGhlIG1heGltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXHJcbiAgXy5tYXggPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gLUluZmluaXR5LCBsYXN0Q29tcHV0ZWQgPSAtSW5maW5pdHksXHJcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xyXG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgJiYgb2JqICE9IG51bGwpIHtcclxuICAgICAgb2JqID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcclxuICAgICAgICBpZiAodmFsdWUgPiByZXN1bHQpIHtcclxuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XHJcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xyXG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KTtcclxuICAgICAgICBpZiAoY29tcHV0ZWQgPiBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IC1JbmZpbml0eSAmJiByZXN1bHQgPT09IC1JbmZpbml0eSkge1xyXG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XHJcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9O1xyXG5cclxuICAvLyBSZXR1cm4gdGhlIG1pbmltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXHJcbiAgXy5taW4gPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IEluZmluaXR5LFxyXG4gICAgICAgIHZhbHVlLCBjb21wdXRlZDtcclxuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsICYmIG9iaiAhPSBudWxsKSB7XHJcbiAgICAgIG9iaiA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xyXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XHJcbiAgICAgICAgaWYgKHZhbHVlIDwgcmVzdWx0KSB7XHJcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xyXG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcclxuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgbGlzdCk7XHJcbiAgICAgICAgaWYgKGNvbXB1dGVkIDwgbGFzdENvbXB1dGVkIHx8IGNvbXB1dGVkID09PSBJbmZpbml0eSAmJiByZXN1bHQgPT09IEluZmluaXR5KSB7XHJcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcclxuICAgICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH07XHJcblxyXG4gIC8vIFNodWZmbGUgYSBjb2xsZWN0aW9uLCB1c2luZyB0aGUgbW9kZXJuIHZlcnNpb24gb2YgdGhlXHJcbiAgLy8gW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlcuKAk1lhdGVzX3NodWZmbGUpLlxyXG4gIF8uc2h1ZmZsZSA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgdmFyIHNldCA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xyXG4gICAgdmFyIGxlbmd0aCA9IHNldC5sZW5ndGg7XHJcbiAgICB2YXIgc2h1ZmZsZWQgPSBBcnJheShsZW5ndGgpO1xyXG4gICAgZm9yICh2YXIgaW5kZXggPSAwLCByYW5kOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICByYW5kID0gXy5yYW5kb20oMCwgaW5kZXgpO1xyXG4gICAgICBpZiAocmFuZCAhPT0gaW5kZXgpIHNodWZmbGVkW2luZGV4XSA9IHNodWZmbGVkW3JhbmRdO1xyXG4gICAgICBzaHVmZmxlZFtyYW5kXSA9IHNldFtpbmRleF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2h1ZmZsZWQ7XHJcbiAgfTtcclxuXHJcbiAgLy8gU2FtcGxlICoqbioqIHJhbmRvbSB2YWx1ZXMgZnJvbSBhIGNvbGxlY3Rpb24uXHJcbiAgLy8gSWYgKipuKiogaXMgbm90IHNwZWNpZmllZCwgcmV0dXJucyBhIHNpbmdsZSByYW5kb20gZWxlbWVudC5cclxuICAvLyBUaGUgaW50ZXJuYWwgYGd1YXJkYCBhcmd1bWVudCBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBtYXBgLlxyXG4gIF8uc2FtcGxlID0gZnVuY3Rpb24ob2JqLCBuLCBndWFyZCkge1xyXG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkge1xyXG4gICAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XHJcbiAgICAgIHJldHVybiBvYmpbXy5yYW5kb20ob2JqLmxlbmd0aCAtIDEpXTtcclxuICAgIH1cclxuICAgIHJldHVybiBfLnNodWZmbGUob2JqKS5zbGljZSgwLCBNYXRoLm1heCgwLCBuKSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gU29ydCB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uIHByb2R1Y2VkIGJ5IGFuIGl0ZXJhdGVlLlxyXG4gIF8uc29ydEJ5ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xyXG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XHJcbiAgICByZXR1cm4gXy5wbHVjayhfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICBpbmRleDogaW5kZXgsXHJcbiAgICAgICAgY3JpdGVyaWE6IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgbGlzdClcclxuICAgICAgfTtcclxuICAgIH0pLnNvcnQoZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcclxuICAgICAgdmFyIGEgPSBsZWZ0LmNyaXRlcmlhO1xyXG4gICAgICB2YXIgYiA9IHJpZ2h0LmNyaXRlcmlhO1xyXG4gICAgICBpZiAoYSAhPT0gYikge1xyXG4gICAgICAgIGlmIChhID4gYiB8fCBhID09PSB2b2lkIDApIHJldHVybiAxO1xyXG4gICAgICAgIGlmIChhIDwgYiB8fCBiID09PSB2b2lkIDApIHJldHVybiAtMTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbGVmdC5pbmRleCAtIHJpZ2h0LmluZGV4O1xyXG4gICAgfSksICd2YWx1ZScpO1xyXG4gIH07XHJcblxyXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIHVzZWQgZm9yIGFnZ3JlZ2F0ZSBcImdyb3VwIGJ5XCIgb3BlcmF0aW9ucy5cclxuICB2YXIgZ3JvdXAgPSBmdW5jdGlvbihiZWhhdmlvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcclxuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcclxuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XHJcbiAgICAgICAgdmFyIGtleSA9IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgb2JqKTtcclxuICAgICAgICBiZWhhdmlvcihyZXN1bHQsIHZhbHVlLCBrZXkpO1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgLy8gR3JvdXBzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24uIFBhc3MgZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZVxyXG4gIC8vIHRvIGdyb3VwIGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY3JpdGVyaW9uLlxyXG4gIF8uZ3JvdXBCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xyXG4gICAgaWYgKF8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7IGVsc2UgcmVzdWx0W2tleV0gPSBbdmFsdWVdO1xyXG4gIH0pO1xyXG5cclxuICAvLyBJbmRleGVzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24sIHNpbWlsYXIgdG8gYGdyb3VwQnlgLCBidXQgZm9yXHJcbiAgLy8gd2hlbiB5b3Uga25vdyB0aGF0IHlvdXIgaW5kZXggdmFsdWVzIHdpbGwgYmUgdW5pcXVlLlxyXG4gIF8uaW5kZXhCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xyXG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcclxuICB9KTtcclxuXHJcbiAgLy8gQ291bnRzIGluc3RhbmNlcyBvZiBhbiBvYmplY3QgdGhhdCBncm91cCBieSBhIGNlcnRhaW4gY3JpdGVyaW9uLiBQYXNzXHJcbiAgLy8gZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZSB0byBjb3VudCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXHJcbiAgLy8gY3JpdGVyaW9uLlxyXG4gIF8uY291bnRCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xyXG4gICAgaWYgKF8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0rKzsgZWxzZSByZXN1bHRba2V5XSA9IDE7XHJcbiAgfSk7XHJcblxyXG4gIC8vIFNhZmVseSBjcmVhdGUgYSByZWFsLCBsaXZlIGFycmF5IGZyb20gYW55dGhpbmcgaXRlcmFibGUuXHJcbiAgXy50b0FycmF5ID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICBpZiAoIW9iaikgcmV0dXJuIFtdO1xyXG4gICAgaWYgKF8uaXNBcnJheShvYmopKSByZXR1cm4gc2xpY2UuY2FsbChvYmopO1xyXG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHJldHVybiBfLm1hcChvYmosIF8uaWRlbnRpdHkpO1xyXG4gICAgcmV0dXJuIF8udmFsdWVzKG9iaik7XHJcbiAgfTtcclxuXHJcbiAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gYW4gb2JqZWN0LlxyXG4gIF8uc2l6ZSA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gMDtcclxuICAgIHJldHVybiBpc0FycmF5TGlrZShvYmopID8gb2JqLmxlbmd0aCA6IF8ua2V5cyhvYmopLmxlbmd0aDtcclxuICB9O1xyXG5cclxuICAvLyBTcGxpdCBhIGNvbGxlY3Rpb24gaW50byB0d28gYXJyYXlzOiBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIHNhdGlzZnkgdGhlIGdpdmVuXHJcbiAgLy8gcHJlZGljYXRlLCBhbmQgb25lIHdob3NlIGVsZW1lbnRzIGFsbCBkbyBub3Qgc2F0aXNmeSB0aGUgcHJlZGljYXRlLlxyXG4gIF8ucGFydGl0aW9uID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcclxuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XHJcbiAgICB2YXIgcGFzcyA9IFtdLCBmYWlsID0gW107XHJcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmopIHtcclxuICAgICAgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBvYmopID8gcGFzcyA6IGZhaWwpLnB1c2godmFsdWUpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gW3Bhc3MsIGZhaWxdO1xyXG4gIH07XHJcblxyXG4gIC8vIEFycmF5IEZ1bmN0aW9uc1xyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvLyBHZXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gdGhlIGZpcnN0IE5cclxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBBbGlhc2VkIGFzIGBoZWFkYCBhbmQgYHRha2VgLiBUaGUgKipndWFyZCoqIGNoZWNrXHJcbiAgLy8gYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLlxyXG4gIF8uZmlyc3QgPSBfLmhlYWQgPSBfLnRha2UgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcclxuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xyXG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkgcmV0dXJuIGFycmF5WzBdO1xyXG4gICAgcmV0dXJuIF8uaW5pdGlhbChhcnJheSwgYXJyYXkubGVuZ3RoIC0gbik7XHJcbiAgfTtcclxuXHJcbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgbGFzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEVzcGVjaWFsbHkgdXNlZnVsIG9uXHJcbiAgLy8gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gYWxsIHRoZSB2YWx1ZXMgaW5cclxuICAvLyB0aGUgYXJyYXksIGV4Y2x1ZGluZyB0aGUgbGFzdCBOLlxyXG4gIF8uaW5pdGlhbCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xyXG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIDAsIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIChuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbikpKTtcclxuICB9O1xyXG5cclxuICAvLyBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgbGFzdCBOXHJcbiAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS5cclxuICBfLmxhc3QgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcclxuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xyXG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xyXG4gICAgcmV0dXJuIF8ucmVzdChhcnJheSwgTWF0aC5tYXgoMCwgYXJyYXkubGVuZ3RoIC0gbikpO1xyXG4gIH07XHJcblxyXG4gIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGZpcnN0IGVudHJ5IG9mIHRoZSBhcnJheS4gQWxpYXNlZCBhcyBgdGFpbGAgYW5kIGBkcm9wYC5cclxuICAvLyBFc3BlY2lhbGx5IHVzZWZ1bCBvbiB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyBhbiAqKm4qKiB3aWxsIHJldHVyblxyXG4gIC8vIHRoZSByZXN0IE4gdmFsdWVzIGluIHRoZSBhcnJheS5cclxuICBfLnJlc3QgPSBfLnRhaWwgPSBfLmRyb3AgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcclxuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCBuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbik7XHJcbiAgfTtcclxuXHJcbiAgLy8gVHJpbSBvdXQgYWxsIGZhbHN5IHZhbHVlcyBmcm9tIGFuIGFycmF5LlxyXG4gIF8uY29tcGFjdCA9IGZ1bmN0aW9uKGFycmF5KSB7XHJcbiAgICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIF8uaWRlbnRpdHkpO1xyXG4gIH07XHJcblxyXG4gIC8vIEludGVybmFsIGltcGxlbWVudGF0aW9uIG9mIGEgcmVjdXJzaXZlIGBmbGF0dGVuYCBmdW5jdGlvbi5cclxuICB2YXIgZmxhdHRlbiA9IGZ1bmN0aW9uKGlucHV0LCBzaGFsbG93LCBzdHJpY3QsIHN0YXJ0SW5kZXgpIHtcclxuICAgIHZhciBvdXRwdXQgPSBbXSwgaWR4ID0gMDtcclxuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4IHx8IDAsIGxlbmd0aCA9IGlucHV0ICYmIGlucHV0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciB2YWx1ZSA9IGlucHV0W2ldO1xyXG4gICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpICYmIChfLmlzQXJyYXkodmFsdWUpIHx8IF8uaXNBcmd1bWVudHModmFsdWUpKSkge1xyXG4gICAgICAgIC8vZmxhdHRlbiBjdXJyZW50IGxldmVsIG9mIGFycmF5IG9yIGFyZ3VtZW50cyBvYmplY3RcclxuICAgICAgICBpZiAoIXNoYWxsb3cpIHZhbHVlID0gZmxhdHRlbih2YWx1ZSwgc2hhbGxvdywgc3RyaWN0KTtcclxuICAgICAgICB2YXIgaiA9IDAsIGxlbiA9IHZhbHVlLmxlbmd0aDtcclxuICAgICAgICBvdXRwdXQubGVuZ3RoICs9IGxlbjtcclxuICAgICAgICB3aGlsZSAoaiA8IGxlbikge1xyXG4gICAgICAgICAgb3V0cHV0W2lkeCsrXSA9IHZhbHVlW2orK107XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKCFzdHJpY3QpIHtcclxuICAgICAgICBvdXRwdXRbaWR4KytdID0gdmFsdWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgfTtcclxuXHJcbiAgLy8gRmxhdHRlbiBvdXQgYW4gYXJyYXksIGVpdGhlciByZWN1cnNpdmVseSAoYnkgZGVmYXVsdCksIG9yIGp1c3Qgb25lIGxldmVsLlxyXG4gIF8uZmxhdHRlbiA9IGZ1bmN0aW9uKGFycmF5LCBzaGFsbG93KSB7XHJcbiAgICByZXR1cm4gZmxhdHRlbihhcnJheSwgc2hhbGxvdywgZmFsc2UpO1xyXG4gIH07XHJcblxyXG4gIC8vIFJldHVybiBhIHZlcnNpb24gb2YgdGhlIGFycmF5IHRoYXQgZG9lcyBub3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIHZhbHVlKHMpLlxyXG4gIF8ud2l0aG91dCA9IGZ1bmN0aW9uKGFycmF5KSB7XHJcbiAgICByZXR1cm4gXy5kaWZmZXJlbmNlKGFycmF5LCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xyXG4gIH07XHJcblxyXG4gIC8vIFByb2R1Y2UgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIHRoZSBhcnJheS4gSWYgdGhlIGFycmF5IGhhcyBhbHJlYWR5XHJcbiAgLy8gYmVlbiBzb3J0ZWQsIHlvdSBoYXZlIHRoZSBvcHRpb24gb2YgdXNpbmcgYSBmYXN0ZXIgYWxnb3JpdGhtLlxyXG4gIC8vIEFsaWFzZWQgYXMgYHVuaXF1ZWAuXHJcbiAgXy51bmlxID0gXy51bmlxdWUgPSBmdW5jdGlvbihhcnJheSwgaXNTb3J0ZWQsIGl0ZXJhdGVlLCBjb250ZXh0KSB7XHJcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIFtdO1xyXG4gICAgaWYgKCFfLmlzQm9vbGVhbihpc1NvcnRlZCkpIHtcclxuICAgICAgY29udGV4dCA9IGl0ZXJhdGVlO1xyXG4gICAgICBpdGVyYXRlZSA9IGlzU29ydGVkO1xyXG4gICAgICBpc1NvcnRlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKGl0ZXJhdGVlICE9IG51bGwpIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xyXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgdmFyIHNlZW4gPSBbXTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpXSxcclxuICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSwgaSwgYXJyYXkpIDogdmFsdWU7XHJcbiAgICAgIGlmIChpc1NvcnRlZCkge1xyXG4gICAgICAgIGlmICghaSB8fCBzZWVuICE9PSBjb21wdXRlZCkgcmVzdWx0LnB1c2godmFsdWUpO1xyXG4gICAgICAgIHNlZW4gPSBjb21wdXRlZDtcclxuICAgICAgfSBlbHNlIGlmIChpdGVyYXRlZSkge1xyXG4gICAgICAgIGlmICghXy5jb250YWlucyhzZWVuLCBjb21wdXRlZCkpIHtcclxuICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XHJcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKCFfLmNvbnRhaW5zKHJlc3VsdCwgdmFsdWUpKSB7XHJcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH07XHJcblxyXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdW5pb246IGVhY2ggZGlzdGluY3QgZWxlbWVudCBmcm9tIGFsbCBvZlxyXG4gIC8vIHRoZSBwYXNzZWQtaW4gYXJyYXlzLlxyXG4gIF8udW5pb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBfLnVuaXEoZmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUpKTtcclxuICB9O1xyXG5cclxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXZlcnkgaXRlbSBzaGFyZWQgYmV0d2VlbiBhbGwgdGhlXHJcbiAgLy8gcGFzc2VkLWluIGFycmF5cy5cclxuICBfLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKGFycmF5KSB7XHJcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIFtdO1xyXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgdmFyIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBpdGVtID0gYXJyYXlbaV07XHJcbiAgICAgIGlmIChfLmNvbnRhaW5zKHJlc3VsdCwgaXRlbSkpIGNvbnRpbnVlO1xyXG4gICAgICBmb3IgKHZhciBqID0gMTsgaiA8IGFyZ3NMZW5ndGg7IGorKykge1xyXG4gICAgICAgIGlmICghXy5jb250YWlucyhhcmd1bWVudHNbal0sIGl0ZW0pKSBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBpZiAoaiA9PT0gYXJnc0xlbmd0aCkgcmVzdWx0LnB1c2goaXRlbSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH07XHJcblxyXG4gIC8vIFRha2UgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBvbmUgYXJyYXkgYW5kIGEgbnVtYmVyIG9mIG90aGVyIGFycmF5cy5cclxuICAvLyBPbmx5IHRoZSBlbGVtZW50cyBwcmVzZW50IGluIGp1c3QgdGhlIGZpcnN0IGFycmF5IHdpbGwgcmVtYWluLlxyXG4gIF8uZGlmZmVyZW5jZSA9IGZ1bmN0aW9uKGFycmF5KSB7XHJcbiAgICB2YXIgcmVzdCA9IGZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlLCB0cnVlLCAxKTtcclxuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgZnVuY3Rpb24odmFsdWUpe1xyXG4gICAgICByZXR1cm4gIV8uY29udGFpbnMocmVzdCwgdmFsdWUpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gWmlwIHRvZ2V0aGVyIG11bHRpcGxlIGxpc3RzIGludG8gYSBzaW5nbGUgYXJyYXkgLS0gZWxlbWVudHMgdGhhdCBzaGFyZVxyXG4gIC8vIGFuIGluZGV4IGdvIHRvZ2V0aGVyLlxyXG4gIF8uemlwID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gXy51bnppcChhcmd1bWVudHMpO1xyXG4gIH07XHJcblxyXG4gIC8vIENvbXBsZW1lbnQgb2YgXy56aXAuIFVuemlwIGFjY2VwdHMgYW4gYXJyYXkgb2YgYXJyYXlzIGFuZCBncm91cHNcclxuICAvLyBlYWNoIGFycmF5J3MgZWxlbWVudHMgb24gc2hhcmVkIGluZGljZXNcclxuICBfLnVuemlwID0gZnVuY3Rpb24oYXJyYXkpIHtcclxuICAgIHZhciBsZW5ndGggPSBhcnJheSAmJiBfLm1heChhcnJheSwgJ2xlbmd0aCcpLmxlbmd0aCB8fCAwO1xyXG4gICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XHJcblxyXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICByZXN1bHRbaW5kZXhdID0gXy5wbHVjayhhcnJheSwgaW5kZXgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9O1xyXG5cclxuICAvLyBDb252ZXJ0cyBsaXN0cyBpbnRvIG9iamVjdHMuIFBhc3MgZWl0aGVyIGEgc2luZ2xlIGFycmF5IG9mIGBba2V5LCB2YWx1ZV1gXHJcbiAgLy8gcGFpcnMsIG9yIHR3byBwYXJhbGxlbCBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoIC0tIG9uZSBvZiBrZXlzLCBhbmQgb25lIG9mXHJcbiAgLy8gdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxyXG4gIF8ub2JqZWN0ID0gZnVuY3Rpb24obGlzdCwgdmFsdWVzKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbGlzdCAmJiBsaXN0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmICh2YWx1ZXMpIHtcclxuICAgICAgICByZXN1bHRbbGlzdFtpXV0gPSB2YWx1ZXNbaV07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVzdWx0W2xpc3RbaV1bMF1dID0gbGlzdFtpXVsxXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9O1xyXG5cclxuICAvLyBSZXR1cm4gdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGFuIGl0ZW0gaW4gYW4gYXJyYXksXHJcbiAgLy8gb3IgLTEgaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS5cclxuICAvLyBJZiB0aGUgYXJyYXkgaXMgbGFyZ2UgYW5kIGFscmVhZHkgaW4gc29ydCBvcmRlciwgcGFzcyBgdHJ1ZWBcclxuICAvLyBmb3IgKippc1NvcnRlZCoqIHRvIHVzZSBiaW5hcnkgc2VhcmNoLlxyXG4gIF8uaW5kZXhPZiA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBpc1NvcnRlZCkge1xyXG4gICAgdmFyIGkgPSAwLCBsZW5ndGggPSBhcnJheSAmJiBhcnJheS5sZW5ndGg7XHJcbiAgICBpZiAodHlwZW9mIGlzU29ydGVkID09ICdudW1iZXInKSB7XHJcbiAgICAgIGkgPSBpc1NvcnRlZCA8IDAgPyBNYXRoLm1heCgwLCBsZW5ndGggKyBpc1NvcnRlZCkgOiBpc1NvcnRlZDtcclxuICAgIH0gZWxzZSBpZiAoaXNTb3J0ZWQgJiYgbGVuZ3RoKSB7XHJcbiAgICAgIGkgPSBfLnNvcnRlZEluZGV4KGFycmF5LCBpdGVtKTtcclxuICAgICAgcmV0dXJuIGFycmF5W2ldID09PSBpdGVtID8gaSA6IC0xO1xyXG4gICAgfVxyXG4gICAgaWYgKGl0ZW0gIT09IGl0ZW0pIHtcclxuICAgICAgcmV0dXJuIF8uZmluZEluZGV4KHNsaWNlLmNhbGwoYXJyYXksIGkpLCBfLmlzTmFOKTtcclxuICAgIH1cclxuICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIGlmIChhcnJheVtpXSA9PT0gaXRlbSkgcmV0dXJuIGk7XHJcbiAgICByZXR1cm4gLTE7XHJcbiAgfTtcclxuXHJcbiAgXy5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBmcm9tKSB7XHJcbiAgICB2YXIgaWR4ID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xyXG4gICAgaWYgKHR5cGVvZiBmcm9tID09ICdudW1iZXInKSB7XHJcbiAgICAgIGlkeCA9IGZyb20gPCAwID8gaWR4ICsgZnJvbSArIDEgOiBNYXRoLm1pbihpZHgsIGZyb20gKyAxKTtcclxuICAgIH1cclxuICAgIGlmIChpdGVtICE9PSBpdGVtKSB7XHJcbiAgICAgIHJldHVybiBfLmZpbmRMYXN0SW5kZXgoc2xpY2UuY2FsbChhcnJheSwgMCwgaWR4KSwgXy5pc05hTik7XHJcbiAgICB9XHJcbiAgICB3aGlsZSAoLS1pZHggPj0gMCkgaWYgKGFycmF5W2lkeF0gPT09IGl0ZW0pIHJldHVybiBpZHg7XHJcbiAgICByZXR1cm4gLTE7XHJcbiAgfTtcclxuXHJcbiAgLy8gR2VuZXJhdG9yIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgZmluZEluZGV4IGFuZCBmaW5kTGFzdEluZGV4IGZ1bmN0aW9uc1xyXG4gIGZ1bmN0aW9uIGNyZWF0ZUluZGV4RmluZGVyKGRpcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcclxuICAgICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcclxuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ICE9IG51bGwgJiYgYXJyYXkubGVuZ3RoO1xyXG4gICAgICB2YXIgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XHJcbiAgICAgIGZvciAoOyBpbmRleCA+PSAwICYmIGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSBkaXIpIHtcclxuICAgICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkgcmV0dXJuIGluZGV4O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAtMTtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBvbiBhbiBhcnJheS1saWtlIHRoYXQgcGFzc2VzIGEgcHJlZGljYXRlIHRlc3RcclxuICBfLmZpbmRJbmRleCA9IGNyZWF0ZUluZGV4RmluZGVyKDEpO1xyXG5cclxuICBfLmZpbmRMYXN0SW5kZXggPSBjcmVhdGVJbmRleEZpbmRlcigtMSk7XHJcblxyXG4gIC8vIFVzZSBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gdG8gZmlndXJlIG91dCB0aGUgc21hbGxlc3QgaW5kZXggYXQgd2hpY2hcclxuICAvLyBhbiBvYmplY3Qgc2hvdWxkIGJlIGluc2VydGVkIHNvIGFzIHRvIG1haW50YWluIG9yZGVyLiBVc2VzIGJpbmFyeSBzZWFyY2guXHJcbiAgXy5zb3J0ZWRJbmRleCA9IGZ1bmN0aW9uKGFycmF5LCBvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XHJcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcclxuICAgIHZhciB2YWx1ZSA9IGl0ZXJhdGVlKG9iaik7XHJcbiAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGFycmF5Lmxlbmd0aDtcclxuICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XHJcbiAgICAgIHZhciBtaWQgPSBNYXRoLmZsb29yKChsb3cgKyBoaWdoKSAvIDIpO1xyXG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbWlkXSkgPCB2YWx1ZSkgbG93ID0gbWlkICsgMTsgZWxzZSBoaWdoID0gbWlkO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvdztcclxuICB9O1xyXG5cclxuICAvLyBHZW5lcmF0ZSBhbiBpbnRlZ2VyIEFycmF5IGNvbnRhaW5pbmcgYW4gYXJpdGhtZXRpYyBwcm9ncmVzc2lvbi4gQSBwb3J0IG9mXHJcbiAgLy8gdGhlIG5hdGl2ZSBQeXRob24gYHJhbmdlKClgIGZ1bmN0aW9uLiBTZWVcclxuICAvLyBbdGhlIFB5dGhvbiBkb2N1bWVudGF0aW9uXShodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvZnVuY3Rpb25zLmh0bWwjcmFuZ2UpLlxyXG4gIF8ucmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkge1xyXG4gICAgICBzdG9wID0gc3RhcnQgfHwgMDtcclxuICAgICAgc3RhcnQgPSAwO1xyXG4gICAgfVxyXG4gICAgc3RlcCA9IHN0ZXAgfHwgMTtcclxuXHJcbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCksIDApO1xyXG4gICAgdmFyIHJhbmdlID0gQXJyYXkobGVuZ3RoKTtcclxuXHJcbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrLCBzdGFydCArPSBzdGVwKSB7XHJcbiAgICAgIHJhbmdlW2lkeF0gPSBzdGFydDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmFuZ2U7XHJcbiAgfTtcclxuXHJcbiAgLy8gRnVuY3Rpb24gKGFoZW0pIEZ1bmN0aW9uc1xyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gZXhlY3V0ZSBhIGZ1bmN0aW9uIGFzIGEgY29uc3RydWN0b3JcclxuICAvLyBvciBhIG5vcm1hbCBmdW5jdGlvbiB3aXRoIHRoZSBwcm92aWRlZCBhcmd1bWVudHNcclxuICB2YXIgZXhlY3V0ZUJvdW5kID0gZnVuY3Rpb24oc291cmNlRnVuYywgYm91bmRGdW5jLCBjb250ZXh0LCBjYWxsaW5nQ29udGV4dCwgYXJncykge1xyXG4gICAgaWYgKCEoY2FsbGluZ0NvbnRleHQgaW5zdGFuY2VvZiBib3VuZEZ1bmMpKSByZXR1cm4gc291cmNlRnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuICAgIHZhciBzZWxmID0gYmFzZUNyZWF0ZShzb3VyY2VGdW5jLnByb3RvdHlwZSk7XHJcbiAgICB2YXIgcmVzdWx0ID0gc291cmNlRnVuYy5hcHBseShzZWxmLCBhcmdzKTtcclxuICAgIGlmIChfLmlzT2JqZWN0KHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XHJcbiAgICByZXR1cm4gc2VsZjtcclxuICB9O1xyXG5cclxuICAvLyBDcmVhdGUgYSBmdW5jdGlvbiBib3VuZCB0byBhIGdpdmVuIG9iamVjdCAoYXNzaWduaW5nIGB0aGlzYCwgYW5kIGFyZ3VtZW50cyxcclxuICAvLyBvcHRpb25hbGx5KS4gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYEZ1bmN0aW9uLmJpbmRgIGlmXHJcbiAgLy8gYXZhaWxhYmxlLlxyXG4gIF8uYmluZCA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQpIHtcclxuICAgIGlmIChuYXRpdmVCaW5kICYmIGZ1bmMuYmluZCA9PT0gbmF0aXZlQmluZCkgcmV0dXJuIG5hdGl2ZUJpbmQuYXBwbHkoZnVuYywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcclxuICAgIGlmICghXy5pc0Z1bmN0aW9uKGZ1bmMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdCaW5kIG11c3QgYmUgY2FsbGVkIG9uIGEgZnVuY3Rpb24nKTtcclxuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xyXG4gICAgdmFyIGJvdW5kID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIGNvbnRleHQsIHRoaXMsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBib3VuZDtcclxuICB9O1xyXG5cclxuICAvLyBQYXJ0aWFsbHkgYXBwbHkgYSBmdW5jdGlvbiBieSBjcmVhdGluZyBhIHZlcnNpb24gdGhhdCBoYXMgaGFkIHNvbWUgb2YgaXRzXHJcbiAgLy8gYXJndW1lbnRzIHByZS1maWxsZWQsIHdpdGhvdXQgY2hhbmdpbmcgaXRzIGR5bmFtaWMgYHRoaXNgIGNvbnRleHQuIF8gYWN0c1xyXG4gIC8vIGFzIGEgcGxhY2Vob2xkZXIsIGFsbG93aW5nIGFueSBjb21iaW5hdGlvbiBvZiBhcmd1bWVudHMgdG8gYmUgcHJlLWZpbGxlZC5cclxuICBfLnBhcnRpYWwgPSBmdW5jdGlvbihmdW5jKSB7XHJcbiAgICB2YXIgYm91bmRBcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG4gICAgdmFyIGJvdW5kID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBwb3NpdGlvbiA9IDAsIGxlbmd0aCA9IGJvdW5kQXJncy5sZW5ndGg7XHJcbiAgICAgIHZhciBhcmdzID0gQXJyYXkobGVuZ3RoKTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGFyZ3NbaV0gPSBib3VuZEFyZ3NbaV0gPT09IF8gPyBhcmd1bWVudHNbcG9zaXRpb24rK10gOiBib3VuZEFyZ3NbaV07XHJcbiAgICAgIH1cclxuICAgICAgd2hpbGUgKHBvc2l0aW9uIDwgYXJndW1lbnRzLmxlbmd0aCkgYXJncy5wdXNoKGFyZ3VtZW50c1twb3NpdGlvbisrXSk7XHJcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIHRoaXMsIHRoaXMsIGFyZ3MpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBib3VuZDtcclxuICB9O1xyXG5cclxuICAvLyBCaW5kIGEgbnVtYmVyIG9mIGFuIG9iamVjdCdzIG1ldGhvZHMgdG8gdGhhdCBvYmplY3QuIFJlbWFpbmluZyBhcmd1bWVudHNcclxuICAvLyBhcmUgdGhlIG1ldGhvZCBuYW1lcyB0byBiZSBib3VuZC4gVXNlZnVsIGZvciBlbnN1cmluZyB0aGF0IGFsbCBjYWxsYmFja3NcclxuICAvLyBkZWZpbmVkIG9uIGFuIG9iamVjdCBiZWxvbmcgdG8gaXQuXHJcbiAgXy5iaW5kQWxsID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICB2YXIgaSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCwga2V5O1xyXG4gICAgaWYgKGxlbmd0aCA8PSAxKSB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBbGwgbXVzdCBiZSBwYXNzZWQgZnVuY3Rpb24gbmFtZXMnKTtcclxuICAgIGZvciAoaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICBrZXkgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgIG9ialtrZXldID0gXy5iaW5kKG9ialtrZXldLCBvYmopO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9iajtcclxuICB9O1xyXG5cclxuICAvLyBNZW1vaXplIGFuIGV4cGVuc2l2ZSBmdW5jdGlvbiBieSBzdG9yaW5nIGl0cyByZXN1bHRzLlxyXG4gIF8ubWVtb2l6ZSA9IGZ1bmN0aW9uKGZ1bmMsIGhhc2hlcikge1xyXG4gICAgdmFyIG1lbW9pemUgPSBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgdmFyIGNhY2hlID0gbWVtb2l6ZS5jYWNoZTtcclxuICAgICAgdmFyIGFkZHJlc3MgPSAnJyArIChoYXNoZXIgPyBoYXNoZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGtleSk7XHJcbiAgICAgIGlmICghXy5oYXMoY2FjaGUsIGFkZHJlc3MpKSBjYWNoZVthZGRyZXNzXSA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgcmV0dXJuIGNhY2hlW2FkZHJlc3NdO1xyXG4gICAgfTtcclxuICAgIG1lbW9pemUuY2FjaGUgPSB7fTtcclxuICAgIHJldHVybiBtZW1vaXplO1xyXG4gIH07XHJcblxyXG4gIC8vIERlbGF5cyBhIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgYW5kIHRoZW4gY2FsbHNcclxuICAvLyBpdCB3aXRoIHRoZSBhcmd1bWVudHMgc3VwcGxpZWQuXHJcbiAgXy5kZWxheSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHtcclxuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xyXG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcclxuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkobnVsbCwgYXJncyk7XHJcbiAgICB9LCB3YWl0KTtcclxuICB9O1xyXG5cclxuICAvLyBEZWZlcnMgYSBmdW5jdGlvbiwgc2NoZWR1bGluZyBpdCB0byBydW4gYWZ0ZXIgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXNcclxuICAvLyBjbGVhcmVkLlxyXG4gIF8uZGVmZXIgPSBfLnBhcnRpYWwoXy5kZWxheSwgXywgMSk7XHJcblxyXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIG9ubHkgYmUgdHJpZ2dlcmVkIGF0IG1vc3Qgb25jZVxyXG4gIC8vIGR1cmluZyBhIGdpdmVuIHdpbmRvdyBvZiB0aW1lLiBOb3JtYWxseSwgdGhlIHRocm90dGxlZCBmdW5jdGlvbiB3aWxsIHJ1blxyXG4gIC8vIGFzIG11Y2ggYXMgaXQgY2FuLCB3aXRob3V0IGV2ZXIgZ29pbmcgbW9yZSB0aGFuIG9uY2UgcGVyIGB3YWl0YCBkdXJhdGlvbjtcclxuICAvLyBidXQgaWYgeW91J2QgbGlrZSB0byBkaXNhYmxlIHRoZSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmcgZWRnZSwgcGFzc1xyXG4gIC8vIGB7bGVhZGluZzogZmFsc2V9YC4gVG8gZGlzYWJsZSBleGVjdXRpb24gb24gdGhlIHRyYWlsaW5nIGVkZ2UsIGRpdHRvLlxyXG4gIF8udGhyb3R0bGUgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBvcHRpb25zKSB7XHJcbiAgICB2YXIgY29udGV4dCwgYXJncywgcmVzdWx0O1xyXG4gICAgdmFyIHRpbWVvdXQgPSBudWxsO1xyXG4gICAgdmFyIHByZXZpb3VzID0gMDtcclxuICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xyXG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBfLm5vdygpO1xyXG4gICAgICB0aW1lb3V0ID0gbnVsbDtcclxuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgbm93ID0gXy5ub3coKTtcclxuICAgICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSBwcmV2aW91cyA9IG5vdztcclxuICAgICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93IC0gcHJldmlvdXMpO1xyXG4gICAgICBjb250ZXh0ID0gdGhpcztcclxuICAgICAgYXJncyA9IGFyZ3VtZW50cztcclxuICAgICAgaWYgKHJlbWFpbmluZyA8PSAwIHx8IHJlbWFpbmluZyA+IHdhaXQpIHtcclxuICAgICAgICBpZiAodGltZW91dCkge1xyXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xyXG4gICAgICAgICAgdGltZW91dCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByZXZpb3VzID0gbm93O1xyXG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XHJcbiAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcclxuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgcmVtYWluaW5nKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIGFzIGxvbmcgYXMgaXQgY29udGludWVzIHRvIGJlIGludm9rZWQsIHdpbGwgbm90XHJcbiAgLy8gYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxyXG4gIC8vIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxyXG4gIC8vIGxlYWRpbmcgZWRnZSwgaW5zdGVhZCBvZiB0aGUgdHJhaWxpbmcuXHJcbiAgXy5kZWJvdW5jZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xyXG4gICAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xyXG5cclxuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgbGFzdCA9IF8ubm93KCkgLSB0aW1lc3RhbXA7XHJcblxyXG4gICAgICBpZiAobGFzdCA8IHdhaXQgJiYgbGFzdCA+PSAwKSB7XHJcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcclxuICAgICAgICBpZiAoIWltbWVkaWF0ZSkge1xyXG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuICAgICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xyXG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xyXG4gICAgICB0aW1lc3RhbXAgPSBfLm5vdygpO1xyXG4gICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcclxuICAgICAgaWYgKCF0aW1lb3V0KSB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XHJcbiAgICAgIGlmIChjYWxsTm93KSB7XHJcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGZ1bmN0aW9uIHBhc3NlZCBhcyBhbiBhcmd1bWVudCB0byB0aGUgc2Vjb25kLFxyXG4gIC8vIGFsbG93aW5nIHlvdSB0byBhZGp1c3QgYXJndW1lbnRzLCBydW4gY29kZSBiZWZvcmUgYW5kIGFmdGVyLCBhbmRcclxuICAvLyBjb25kaXRpb25hbGx5IGV4ZWN1dGUgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxyXG4gIF8ud3JhcCA9IGZ1bmN0aW9uKGZ1bmMsIHdyYXBwZXIpIHtcclxuICAgIHJldHVybiBfLnBhcnRpYWwod3JhcHBlciwgZnVuYyk7XHJcbiAgfTtcclxuXHJcbiAgLy8gUmV0dXJucyBhIG5lZ2F0ZWQgdmVyc2lvbiBvZiB0aGUgcGFzc2VkLWluIHByZWRpY2F0ZS5cclxuICBfLm5lZ2F0ZSA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgYSBsaXN0IG9mIGZ1bmN0aW9ucywgZWFjaFxyXG4gIC8vIGNvbnN1bWluZyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiB0aGF0IGZvbGxvd3MuXHJcbiAgXy5jb21wb3NlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcclxuICAgIHZhciBzdGFydCA9IGFyZ3MubGVuZ3RoIC0gMTtcclxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIGkgPSBzdGFydDtcclxuICAgICAgdmFyIHJlc3VsdCA9IGFyZ3Nbc3RhcnRdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIHdoaWxlIChpLS0pIHJlc3VsdCA9IGFyZ3NbaV0uY2FsbCh0aGlzLCByZXN1bHQpO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgb24gYW5kIGFmdGVyIHRoZSBOdGggY2FsbC5cclxuICBfLmFmdGVyID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKC0tdGltZXMgPCAxKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgdXAgdG8gKGJ1dCBub3QgaW5jbHVkaW5nKSB0aGUgTnRoIGNhbGwuXHJcbiAgXy5iZWZvcmUgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xyXG4gICAgdmFyIG1lbW87XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmICgtLXRpbWVzID4gMCkge1xyXG4gICAgICAgIG1lbW8gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRpbWVzIDw9IDEpIGZ1bmMgPSBudWxsO1xyXG4gICAgICByZXR1cm4gbWVtbztcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhdCBtb3N0IG9uZSB0aW1lLCBubyBtYXR0ZXIgaG93XHJcbiAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi5cclxuICBfLm9uY2UgPSBfLnBhcnRpYWwoXy5iZWZvcmUsIDIpO1xyXG5cclxuICAvLyBPYmplY3QgRnVuY3Rpb25zXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvLyBLZXlzIGluIElFIDwgOSB0aGF0IHdvbid0IGJlIGl0ZXJhdGVkIGJ5IGBmb3Iga2V5IGluIC4uLmAgYW5kIHRodXMgbWlzc2VkLlxyXG4gIHZhciBoYXNFbnVtQnVnID0gIXt0b1N0cmluZzogbnVsbH0ucHJvcGVydHlJc0VudW1lcmFibGUoJ3RvU3RyaW5nJyk7XHJcbiAgdmFyIG5vbkVudW1lcmFibGVQcm9wcyA9IFsndmFsdWVPZicsICdpc1Byb3RvdHlwZU9mJywgJ3RvU3RyaW5nJyxcclxuICAgICAgICAgICAgICAgICAgICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICdoYXNPd25Qcm9wZXJ0eScsICd0b0xvY2FsZVN0cmluZyddO1xyXG5cclxuICBmdW5jdGlvbiBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cykge1xyXG4gICAgdmFyIG5vbkVudW1JZHggPSBub25FbnVtZXJhYmxlUHJvcHMubGVuZ3RoO1xyXG4gICAgdmFyIGNvbnN0cnVjdG9yID0gb2JqLmNvbnN0cnVjdG9yO1xyXG4gICAgdmFyIHByb3RvID0gKF8uaXNGdW5jdGlvbihjb25zdHJ1Y3RvcikgJiYgY29uc3RydWN0b3IucHJvdG90eXBlKSB8fCBPYmpQcm90bztcclxuXHJcbiAgICAvLyBDb25zdHJ1Y3RvciBpcyBhIHNwZWNpYWwgY2FzZS5cclxuICAgIHZhciBwcm9wID0gJ2NvbnN0cnVjdG9yJztcclxuICAgIGlmIChfLmhhcyhvYmosIHByb3ApICYmICFfLmNvbnRhaW5zKGtleXMsIHByb3ApKSBrZXlzLnB1c2gocHJvcCk7XHJcblxyXG4gICAgd2hpbGUgKG5vbkVudW1JZHgtLSkge1xyXG4gICAgICBwcm9wID0gbm9uRW51bWVyYWJsZVByb3BzW25vbkVudW1JZHhdO1xyXG4gICAgICBpZiAocHJvcCBpbiBvYmogJiYgb2JqW3Byb3BdICE9PSBwcm90b1twcm9wXSAmJiAhXy5jb250YWlucyhrZXlzLCBwcm9wKSkge1xyXG4gICAgICAgIGtleXMucHVzaChwcm9wKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gUmV0cmlldmUgdGhlIG5hbWVzIG9mIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzLlxyXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBPYmplY3Qua2V5c2BcclxuICBfLmtleXMgPSBmdW5jdGlvbihvYmopIHtcclxuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XHJcbiAgICBpZiAobmF0aXZlS2V5cykgcmV0dXJuIG5hdGl2ZUtleXMob2JqKTtcclxuICAgIHZhciBrZXlzID0gW107XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcclxuICAgIC8vIEFoZW0sIElFIDwgOS5cclxuICAgIGlmIChoYXNFbnVtQnVnKSBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cyk7XHJcbiAgICByZXR1cm4ga2V5cztcclxuICB9O1xyXG5cclxuICAvLyBSZXRyaWV2ZSBhbGwgdGhlIHByb3BlcnR5IG5hbWVzIG9mIGFuIG9iamVjdC5cclxuICBfLmFsbEtleXMgPSBmdW5jdGlvbihvYmopIHtcclxuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XHJcbiAgICB2YXIga2V5cyA9IFtdO1xyXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XHJcbiAgICAvLyBBaGVtLCBJRSA8IDkuXHJcbiAgICBpZiAoaGFzRW51bUJ1ZykgY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpO1xyXG4gICAgcmV0dXJuIGtleXM7XHJcbiAgfTtcclxuXHJcbiAgLy8gUmV0cmlldmUgdGhlIHZhbHVlcyBvZiBhbiBvYmplY3QncyBwcm9wZXJ0aWVzLlxyXG4gIF8udmFsdWVzID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xyXG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xyXG4gICAgdmFyIHZhbHVlcyA9IEFycmF5KGxlbmd0aCk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhbHVlc1tpXSA9IG9ialtrZXlzW2ldXTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZXM7XHJcbiAgfTtcclxuXHJcbiAgLy8gUmV0dXJucyB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0ZWUgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBvYmplY3RcclxuICAvLyBJbiBjb250cmFzdCB0byBfLm1hcCBpdCByZXR1cm5zIGFuIG9iamVjdFxyXG4gIF8ubWFwT2JqZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xyXG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XHJcbiAgICB2YXIga2V5cyA9ICBfLmtleXMob2JqKSxcclxuICAgICAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoLFxyXG4gICAgICAgICAgcmVzdWx0cyA9IHt9LFxyXG4gICAgICAgICAgY3VycmVudEtleTtcclxuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgIGN1cnJlbnRLZXkgPSBrZXlzW2luZGV4XTtcclxuICAgICAgICByZXN1bHRzW2N1cnJlbnRLZXldID0gaXRlcmF0ZWUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gIH07XHJcblxyXG4gIC8vIENvbnZlcnQgYW4gb2JqZWN0IGludG8gYSBsaXN0IG9mIGBba2V5LCB2YWx1ZV1gIHBhaXJzLlxyXG4gIF8ucGFpcnMgPSBmdW5jdGlvbihvYmopIHtcclxuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XHJcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XHJcbiAgICB2YXIgcGFpcnMgPSBBcnJheShsZW5ndGgpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICBwYWlyc1tpXSA9IFtrZXlzW2ldLCBvYmpba2V5c1tpXV1dO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhaXJzO1xyXG4gIH07XHJcblxyXG4gIC8vIEludmVydCB0aGUga2V5cyBhbmQgdmFsdWVzIG9mIGFuIG9iamVjdC4gVGhlIHZhbHVlcyBtdXN0IGJlIHNlcmlhbGl6YWJsZS5cclxuICBfLmludmVydCA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHJlc3VsdFtvYmpba2V5c1tpXV1dID0ga2V5c1tpXTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfTtcclxuXHJcbiAgLy8gUmV0dXJuIGEgc29ydGVkIGxpc3Qgb2YgdGhlIGZ1bmN0aW9uIG5hbWVzIGF2YWlsYWJsZSBvbiB0aGUgb2JqZWN0LlxyXG4gIC8vIEFsaWFzZWQgYXMgYG1ldGhvZHNgXHJcbiAgXy5mdW5jdGlvbnMgPSBfLm1ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcclxuICAgIHZhciBuYW1lcyA9IFtdO1xyXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xyXG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9ialtrZXldKSkgbmFtZXMucHVzaChrZXkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5hbWVzLnNvcnQoKTtcclxuICB9O1xyXG5cclxuICAvLyBFeHRlbmQgYSBnaXZlbiBvYmplY3Qgd2l0aCBhbGwgdGhlIHByb3BlcnRpZXMgaW4gcGFzc2VkLWluIG9iamVjdChzKS5cclxuICBfLmV4dGVuZCA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cyk7XHJcblxyXG4gIC8vIEFzc2lnbnMgYSBnaXZlbiBvYmplY3Qgd2l0aCBhbGwgdGhlIG93biBwcm9wZXJ0aWVzIGluIHRoZSBwYXNzZWQtaW4gb2JqZWN0KHMpXHJcbiAgLy8gKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ24pXHJcbiAgXy5leHRlbmRPd24gPSBfLmFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKF8ua2V5cyk7XHJcblxyXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGtleSBvbiBhbiBvYmplY3QgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdFxyXG4gIF8uZmluZEtleSA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XHJcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xyXG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKSwga2V5O1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAga2V5ID0ga2V5c1tpXTtcclxuICAgICAgaWYgKHByZWRpY2F0ZShvYmpba2V5XSwga2V5LCBvYmopKSByZXR1cm4ga2V5O1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCBvbmx5IGNvbnRhaW5pbmcgdGhlIHdoaXRlbGlzdGVkIHByb3BlcnRpZXMuXHJcbiAgXy5waWNrID0gZnVuY3Rpb24ob2JqZWN0LCBvaXRlcmF0ZWUsIGNvbnRleHQpIHtcclxuICAgIHZhciByZXN1bHQgPSB7fSwgb2JqID0gb2JqZWN0LCBpdGVyYXRlZSwga2V5cztcclxuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcclxuICAgIGlmIChfLmlzRnVuY3Rpb24ob2l0ZXJhdGVlKSkge1xyXG4gICAgICBrZXlzID0gXy5hbGxLZXlzKG9iaik7XHJcbiAgICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihvaXRlcmF0ZWUsIGNvbnRleHQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAga2V5cyA9IGZsYXR0ZW4oYXJndW1lbnRzLCBmYWxzZSwgZmFsc2UsIDEpO1xyXG4gICAgICBpdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikgeyByZXR1cm4ga2V5IGluIG9iajsgfTtcclxuICAgICAgb2JqID0gT2JqZWN0KG9iaik7XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcclxuICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XHJcbiAgICAgIGlmIChpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmopKSByZXN1bHRba2V5XSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9O1xyXG5cclxuICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IHdpdGhvdXQgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnRpZXMuXHJcbiAgXy5vbWl0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xyXG4gICAgaWYgKF8uaXNGdW5jdGlvbihpdGVyYXRlZSkpIHtcclxuICAgICAgaXRlcmF0ZWUgPSBfLm5lZ2F0ZShpdGVyYXRlZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIga2V5cyA9IF8ubWFwKGZsYXR0ZW4oYXJndW1lbnRzLCBmYWxzZSwgZmFsc2UsIDEpLCBTdHJpbmcpO1xyXG4gICAgICBpdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gIV8uY29udGFpbnMoa2V5cywga2V5KTtcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiBfLnBpY2sob2JqLCBpdGVyYXRlZSwgY29udGV4dCk7XHJcbiAgfTtcclxuXHJcbiAgLy8gRmlsbCBpbiBhIGdpdmVuIG9iamVjdCB3aXRoIGRlZmF1bHQgcHJvcGVydGllcy5cclxuICBfLmRlZmF1bHRzID0gY3JlYXRlQXNzaWduZXIoXy5hbGxLZXlzLCB0cnVlKTtcclxuXHJcbiAgLy8gQ3JlYXRlIGEgKHNoYWxsb3ctY2xvbmVkKSBkdXBsaWNhdGUgb2YgYW4gb2JqZWN0LlxyXG4gIF8uY2xvbmUgPSBmdW5jdGlvbihvYmopIHtcclxuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xyXG4gICAgcmV0dXJuIF8uaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiBfLmV4dGVuZCh7fSwgb2JqKTtcclxuICB9O1xyXG5cclxuICAvLyBJbnZva2VzIGludGVyY2VwdG9yIHdpdGggdGhlIG9iaiwgYW5kIHRoZW4gcmV0dXJucyBvYmouXHJcbiAgLy8gVGhlIHByaW1hcnkgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0byBcInRhcCBpbnRvXCIgYSBtZXRob2QgY2hhaW4sIGluXHJcbiAgLy8gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uXHJcbiAgXy50YXAgPSBmdW5jdGlvbihvYmosIGludGVyY2VwdG9yKSB7XHJcbiAgICBpbnRlcmNlcHRvcihvYmopO1xyXG4gICAgcmV0dXJuIG9iajtcclxuICB9O1xyXG5cclxuICAvLyBSZXR1cm5zIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZiBga2V5OnZhbHVlYCBwYWlycy5cclxuICBfLmlzTWF0Y2ggPSBmdW5jdGlvbihvYmplY3QsIGF0dHJzKSB7XHJcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhhdHRycyksIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xyXG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gIWxlbmd0aDtcclxuICAgIHZhciBvYmogPSBPYmplY3Qob2JqZWN0KTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIGtleSA9IGtleXNbaV07XHJcbiAgICAgIGlmIChhdHRyc1trZXldICE9PSBvYmpba2V5XSB8fCAhKGtleSBpbiBvYmopKSByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9O1xyXG5cclxuXHJcbiAgLy8gSW50ZXJuYWwgcmVjdXJzaXZlIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIGBpc0VxdWFsYC5cclxuICB2YXIgZXEgPSBmdW5jdGlvbihhLCBiLCBhU3RhY2ssIGJTdGFjaykge1xyXG4gICAgLy8gSWRlbnRpY2FsIG9iamVjdHMgYXJlIGVxdWFsLiBgMCA9PT0gLTBgLCBidXQgdGhleSBhcmVuJ3QgaWRlbnRpY2FsLlxyXG4gICAgLy8gU2VlIHRoZSBbSGFybW9ueSBgZWdhbGAgcHJvcG9zYWxdKGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6ZWdhbCkuXHJcbiAgICBpZiAoYSA9PT0gYikgcmV0dXJuIGEgIT09IDAgfHwgMSAvIGEgPT09IDEgLyBiO1xyXG4gICAgLy8gQSBzdHJpY3QgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkgYmVjYXVzZSBgbnVsbCA9PSB1bmRlZmluZWRgLlxyXG4gICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBhID09PSBiO1xyXG4gICAgLy8gVW53cmFwIGFueSB3cmFwcGVkIG9iamVjdHMuXHJcbiAgICBpZiAoYSBpbnN0YW5jZW9mIF8pIGEgPSBhLl93cmFwcGVkO1xyXG4gICAgaWYgKGIgaW5zdGFuY2VvZiBfKSBiID0gYi5fd3JhcHBlZDtcclxuICAgIC8vIENvbXBhcmUgYFtbQ2xhc3NdXWAgbmFtZXMuXHJcbiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcclxuICAgIGlmIChjbGFzc05hbWUgIT09IHRvU3RyaW5nLmNhbGwoYikpIHJldHVybiBmYWxzZTtcclxuICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XHJcbiAgICAgIC8vIFN0cmluZ3MsIG51bWJlcnMsIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGRhdGVzLCBhbmQgYm9vbGVhbnMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxyXG4gICAgICBjYXNlICdbb2JqZWN0IFJlZ0V4cF0nOlxyXG4gICAgICAvLyBSZWdFeHBzIGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MgZm9yIGNvbXBhcmlzb24gKE5vdGU6ICcnICsgL2EvaSA9PT0gJy9hL2knKVxyXG4gICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxyXG4gICAgICAgIC8vIFByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHdyYXBwZXJzIGFyZSBlcXVpdmFsZW50OyB0aHVzLCBgXCI1XCJgIGlzXHJcbiAgICAgICAgLy8gZXF1aXZhbGVudCB0byBgbmV3IFN0cmluZyhcIjVcIilgLlxyXG4gICAgICAgIHJldHVybiAnJyArIGEgPT09ICcnICsgYjtcclxuICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzpcclxuICAgICAgICAvLyBgTmFOYHMgYXJlIGVxdWl2YWxlbnQsIGJ1dCBub24tcmVmbGV4aXZlLlxyXG4gICAgICAgIC8vIE9iamVjdChOYU4pIGlzIGVxdWl2YWxlbnQgdG8gTmFOXHJcbiAgICAgICAgaWYgKCthICE9PSArYSkgcmV0dXJuICtiICE9PSArYjtcclxuICAgICAgICAvLyBBbiBgZWdhbGAgY29tcGFyaXNvbiBpcyBwZXJmb3JtZWQgZm9yIG90aGVyIG51bWVyaWMgdmFsdWVzLlxyXG4gICAgICAgIHJldHVybiArYSA9PT0gMCA/IDEgLyArYSA9PT0gMSAvIGIgOiArYSA9PT0gK2I7XHJcbiAgICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOlxyXG4gICAgICBjYXNlICdbb2JqZWN0IEJvb2xlYW5dJzpcclxuICAgICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyXHJcbiAgICAgICAgLy8gbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zLiBOb3RlIHRoYXQgaW52YWxpZCBkYXRlcyB3aXRoIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9uc1xyXG4gICAgICAgIC8vIG9mIGBOYU5gIGFyZSBub3QgZXF1aXZhbGVudC5cclxuICAgICAgICByZXR1cm4gK2EgPT09ICtiO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBhcmVBcnJheXMgPSBjbGFzc05hbWUgPT09ICdbb2JqZWN0IEFycmF5XSc7XHJcbiAgICBpZiAoIWFyZUFycmF5cykge1xyXG4gICAgICBpZiAodHlwZW9mIGEgIT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgIT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgIC8vIE9iamVjdHMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1aXZhbGVudCwgYnV0IGBPYmplY3RgcyBvciBgQXJyYXlgc1xyXG4gICAgICAvLyBmcm9tIGRpZmZlcmVudCBmcmFtZXMgYXJlLlxyXG4gICAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLCBiQ3RvciA9IGIuY29uc3RydWN0b3I7XHJcbiAgICAgIGlmIChhQ3RvciAhPT0gYkN0b3IgJiYgIShfLmlzRnVuY3Rpb24oYUN0b3IpICYmIGFDdG9yIGluc3RhbmNlb2YgYUN0b3IgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uaXNGdW5jdGlvbihiQ3RvcikgJiYgYkN0b3IgaW5zdGFuY2VvZiBiQ3RvcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoJ2NvbnN0cnVjdG9yJyBpbiBhICYmICdjb25zdHJ1Y3RvcicgaW4gYikpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIEFzc3VtZSBlcXVhbGl0eSBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWNcclxuICAgIC8vIHN0cnVjdHVyZXMgaXMgYWRhcHRlZCBmcm9tIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMsIGFic3RyYWN0IG9wZXJhdGlvbiBgSk9gLlxyXG4gICAgXHJcbiAgICAvLyBJbml0aWFsaXppbmcgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXHJcbiAgICAvLyBJdCdzIGRvbmUgaGVyZSBzaW5jZSB3ZSBvbmx5IG5lZWQgdGhlbSBmb3Igb2JqZWN0cyBhbmQgYXJyYXlzIGNvbXBhcmlzb24uXHJcbiAgICBhU3RhY2sgPSBhU3RhY2sgfHwgW107XHJcbiAgICBiU3RhY2sgPSBiU3RhY2sgfHwgW107XHJcbiAgICB2YXIgbGVuZ3RoID0gYVN0YWNrLmxlbmd0aDtcclxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xyXG4gICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcclxuICAgICAgLy8gdW5pcXVlIG5lc3RlZCBzdHJ1Y3R1cmVzLlxyXG4gICAgICBpZiAoYVN0YWNrW2xlbmd0aF0gPT09IGEpIHJldHVybiBiU3RhY2tbbGVuZ3RoXSA9PT0gYjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgdGhlIGZpcnN0IG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXHJcbiAgICBhU3RhY2sucHVzaChhKTtcclxuICAgIGJTdGFjay5wdXNoKGIpO1xyXG5cclxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxyXG4gICAgaWYgKGFyZUFycmF5cykge1xyXG4gICAgICAvLyBDb21wYXJlIGFycmF5IGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeS5cclxuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XHJcbiAgICAgIGlmIChsZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIC8vIERlZXAgY29tcGFyZSB0aGUgY29udGVudHMsIGlnbm9yaW5nIG5vbi1udW1lcmljIHByb3BlcnRpZXMuXHJcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xyXG4gICAgICAgIGlmICghZXEoYVtsZW5ndGhdLCBiW2xlbmd0aF0sIGFTdGFjaywgYlN0YWNrKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBEZWVwIGNvbXBhcmUgb2JqZWN0cy5cclxuICAgICAgdmFyIGtleXMgPSBfLmtleXMoYSksIGtleTtcclxuICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XHJcbiAgICAgIC8vIEVuc3VyZSB0aGF0IGJvdGggb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzIGJlZm9yZSBjb21wYXJpbmcgZGVlcCBlcXVhbGl0eS5cclxuICAgICAgaWYgKF8ua2V5cyhiKS5sZW5ndGggIT09IGxlbmd0aCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcclxuICAgICAgICAvLyBEZWVwIGNvbXBhcmUgZWFjaCBtZW1iZXJcclxuICAgICAgICBrZXkgPSBrZXlzW2xlbmd0aF07XHJcbiAgICAgICAgaWYgKCEoXy5oYXMoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgYVN0YWNrLCBiU3RhY2spKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IG9iamVjdCBmcm9tIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cclxuICAgIGFTdGFjay5wb3AoKTtcclxuICAgIGJTdGFjay5wb3AoKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH07XHJcblxyXG4gIC8vIFBlcmZvcm0gYSBkZWVwIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgdHdvIG9iamVjdHMgYXJlIGVxdWFsLlxyXG4gIF8uaXNFcXVhbCA9IGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgIHJldHVybiBlcShhLCBiKTtcclxuICB9O1xyXG5cclxuICAvLyBJcyBhIGdpdmVuIGFycmF5LCBzdHJpbmcsIG9yIG9iamVjdCBlbXB0eT9cclxuICAvLyBBbiBcImVtcHR5XCIgb2JqZWN0IGhhcyBubyBlbnVtZXJhYmxlIG93bi1wcm9wZXJ0aWVzLlxyXG4gIF8uaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcclxuICAgIGlmIChpc0FycmF5TGlrZShvYmopICYmIChfLmlzQXJyYXkob2JqKSB8fCBfLmlzU3RyaW5nKG9iaikgfHwgXy5pc0FyZ3VtZW50cyhvYmopKSkgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XHJcbiAgICByZXR1cm4gXy5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xyXG4gIH07XHJcblxyXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBET00gZWxlbWVudD9cclxuICBfLmlzRWxlbWVudCA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xyXG4gIH07XHJcblxyXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYW4gYXJyYXk/XHJcbiAgLy8gRGVsZWdhdGVzIHRvIEVDTUE1J3MgbmF0aXZlIEFycmF5LmlzQXJyYXlcclxuICBfLmlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcclxuICB9O1xyXG5cclxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIGFuIG9iamVjdD9cclxuICBfLmlzT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmo7XHJcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcclxuICB9O1xyXG5cclxuICAvLyBBZGQgc29tZSBpc1R5cGUgbWV0aG9kczogaXNBcmd1bWVudHMsIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc051bWJlciwgaXNEYXRlLCBpc1JlZ0V4cCwgaXNFcnJvci5cclxuICBfLmVhY2goWydBcmd1bWVudHMnLCAnRnVuY3Rpb24nLCAnU3RyaW5nJywgJ051bWJlcicsICdEYXRlJywgJ1JlZ0V4cCcsICdFcnJvciddLCBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICBfWydpcycgKyBuYW1lXSA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCAnICsgbmFtZSArICddJztcclxuICAgIH07XHJcbiAgfSk7XHJcblxyXG4gIC8vIERlZmluZSBhIGZhbGxiYWNrIHZlcnNpb24gb2YgdGhlIG1ldGhvZCBpbiBicm93c2VycyAoYWhlbSwgSUUgPCA5KSwgd2hlcmVcclxuICAvLyB0aGVyZSBpc24ndCBhbnkgaW5zcGVjdGFibGUgXCJBcmd1bWVudHNcIiB0eXBlLlxyXG4gIGlmICghXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpKSB7XHJcbiAgICBfLmlzQXJndW1lbnRzID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgIHJldHVybiBfLmhhcyhvYmosICdjYWxsZWUnKTtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBPcHRpbWl6ZSBgaXNGdW5jdGlvbmAgaWYgYXBwcm9wcmlhdGUuIFdvcmsgYXJvdW5kIHNvbWUgdHlwZW9mIGJ1Z3MgaW4gb2xkIHY4LFxyXG4gIC8vIElFIDExICgjMTYyMSksIGFuZCBpbiBTYWZhcmkgOCAoIzE5MjkpLlxyXG4gIGlmICh0eXBlb2YgLy4vICE9ICdmdW5jdGlvbicgJiYgdHlwZW9mIEludDhBcnJheSAhPSAnb2JqZWN0Jykge1xyXG4gICAgXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09ICdmdW5jdGlvbicgfHwgZmFsc2U7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gSXMgYSBnaXZlbiBvYmplY3QgYSBmaW5pdGUgbnVtYmVyP1xyXG4gIF8uaXNGaW5pdGUgPSBmdW5jdGlvbihvYmopIHtcclxuICAgIHJldHVybiBpc0Zpbml0ZShvYmopICYmICFpc05hTihwYXJzZUZsb2F0KG9iaikpO1xyXG4gIH07XHJcblxyXG4gIC8vIElzIHRoZSBnaXZlbiB2YWx1ZSBgTmFOYD8gKE5hTiBpcyB0aGUgb25seSBudW1iZXIgd2hpY2ggZG9lcyBub3QgZXF1YWwgaXRzZWxmKS5cclxuICBfLmlzTmFOID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICByZXR1cm4gXy5pc051bWJlcihvYmopICYmIG9iaiAhPT0gK29iajtcclxuICB9O1xyXG5cclxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cclxuICBfLmlzQm9vbGVhbiA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgcmV0dXJuIG9iaiA9PT0gdHJ1ZSB8fCBvYmogPT09IGZhbHNlIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xyXG4gIH07XHJcblxyXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgZXF1YWwgdG8gbnVsbD9cclxuICBfLmlzTnVsbCA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcclxuICB9O1xyXG5cclxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIHVuZGVmaW5lZD9cclxuICBfLmlzVW5kZWZpbmVkID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqID09PSB2b2lkIDA7XHJcbiAgfTtcclxuXHJcbiAgLy8gU2hvcnRjdXQgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBwcm9wZXJ0eSBkaXJlY3RseVxyXG4gIC8vIG9uIGl0c2VsZiAoaW4gb3RoZXIgd29yZHMsIG5vdCBvbiBhIHByb3RvdHlwZSkuXHJcbiAgXy5oYXMgPSBmdW5jdGlvbihvYmosIGtleSkge1xyXG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xyXG4gIH07XHJcblxyXG4gIC8vIFV0aWxpdHkgRnVuY3Rpb25zXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLy8gUnVuIFVuZGVyc2NvcmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0c1xyXG4gIC8vIHByZXZpb3VzIG93bmVyLiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cclxuICBfLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcclxuICAgIHJvb3QuXyA9IHByZXZpb3VzVW5kZXJzY29yZTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIC8vIEtlZXAgdGhlIGlkZW50aXR5IGZ1bmN0aW9uIGFyb3VuZCBmb3IgZGVmYXVsdCBpdGVyYXRlZXMuXHJcbiAgXy5pZGVudGl0eSA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbiAgfTtcclxuXHJcbiAgLy8gUHJlZGljYXRlLWdlbmVyYXRpbmcgZnVuY3Rpb25zLiBPZnRlbiB1c2VmdWwgb3V0c2lkZSBvZiBVbmRlcnNjb3JlLlxyXG4gIF8uY29uc3RhbnQgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIF8ubm9vcCA9IGZ1bmN0aW9uKCl7fTtcclxuXHJcbiAgXy5wcm9wZXJ0eSA9IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xyXG4gICAgICByZXR1cm4gb2JqID09IG51bGwgPyB2b2lkIDAgOiBvYmpba2V5XTtcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgLy8gR2VuZXJhdGVzIGEgZnVuY3Rpb24gZm9yIGEgZ2l2ZW4gb2JqZWN0IHRoYXQgcmV0dXJucyBhIGdpdmVuIHByb3BlcnR5LlxyXG4gIF8ucHJvcGVydHlPZiA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgcmV0dXJuIG9iaiA9PSBudWxsID8gZnVuY3Rpb24oKXt9IDogZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgIHJldHVybiBvYmpba2V5XTtcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgLy8gUmV0dXJucyBhIHByZWRpY2F0ZSBmb3IgY2hlY2tpbmcgd2hldGhlciBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gc2V0IG9mIFxyXG4gIC8vIGBrZXk6dmFsdWVgIHBhaXJzLlxyXG4gIF8ubWF0Y2hlciA9IF8ubWF0Y2hlcyA9IGZ1bmN0aW9uKGF0dHJzKSB7XHJcbiAgICBhdHRycyA9IF8uZXh0ZW5kT3duKHt9LCBhdHRycyk7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgIHJldHVybiBfLmlzTWF0Y2gob2JqLCBhdHRycyk7XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIC8vIFJ1biBhIGZ1bmN0aW9uICoqbioqIHRpbWVzLlxyXG4gIF8udGltZXMgPSBmdW5jdGlvbihuLCBpdGVyYXRlZSwgY29udGV4dCkge1xyXG4gICAgdmFyIGFjY3VtID0gQXJyYXkoTWF0aC5tYXgoMCwgbikpO1xyXG4gICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSBhY2N1bVtpXSA9IGl0ZXJhdGVlKGkpO1xyXG4gICAgcmV0dXJuIGFjY3VtO1xyXG4gIH07XHJcblxyXG4gIC8vIFJldHVybiBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gbWluIGFuZCBtYXggKGluY2x1c2l2ZSkuXHJcbiAgXy5yYW5kb20gPSBmdW5jdGlvbihtaW4sIG1heCkge1xyXG4gICAgaWYgKG1heCA9PSBudWxsKSB7XHJcbiAgICAgIG1heCA9IG1pbjtcclxuICAgICAgbWluID0gMDtcclxuICAgIH1cclxuICAgIHJldHVybiBtaW4gKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xyXG4gIH07XHJcblxyXG4gIC8vIEEgKHBvc3NpYmx5IGZhc3Rlcikgd2F5IHRvIGdldCB0aGUgY3VycmVudCB0aW1lc3RhbXAgYXMgYW4gaW50ZWdlci5cclxuICBfLm5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gIH07XHJcblxyXG4gICAvLyBMaXN0IG9mIEhUTUwgZW50aXRpZXMgZm9yIGVzY2FwaW5nLlxyXG4gIHZhciBlc2NhcGVNYXAgPSB7XHJcbiAgICAnJic6ICcmYW1wOycsXHJcbiAgICAnPCc6ICcmbHQ7JyxcclxuICAgICc+JzogJyZndDsnLFxyXG4gICAgJ1wiJzogJyZxdW90OycsXHJcbiAgICBcIidcIjogJyYjeDI3OycsXHJcbiAgICAnYCc6ICcmI3g2MDsnXHJcbiAgfTtcclxuICB2YXIgdW5lc2NhcGVNYXAgPSBfLmludmVydChlc2NhcGVNYXApO1xyXG5cclxuICAvLyBGdW5jdGlvbnMgZm9yIGVzY2FwaW5nIGFuZCB1bmVzY2FwaW5nIHN0cmluZ3MgdG8vZnJvbSBIVE1MIGludGVycG9sYXRpb24uXHJcbiAgdmFyIGNyZWF0ZUVzY2FwZXIgPSBmdW5jdGlvbihtYXApIHtcclxuICAgIHZhciBlc2NhcGVyID0gZnVuY3Rpb24obWF0Y2gpIHtcclxuICAgICAgcmV0dXJuIG1hcFttYXRjaF07XHJcbiAgICB9O1xyXG4gICAgLy8gUmVnZXhlcyBmb3IgaWRlbnRpZnlpbmcgYSBrZXkgdGhhdCBuZWVkcyB0byBiZSBlc2NhcGVkXHJcbiAgICB2YXIgc291cmNlID0gJyg/OicgKyBfLmtleXMobWFwKS5qb2luKCd8JykgKyAnKSc7XHJcbiAgICB2YXIgdGVzdFJlZ2V4cCA9IFJlZ0V4cChzb3VyY2UpO1xyXG4gICAgdmFyIHJlcGxhY2VSZWdleHAgPSBSZWdFeHAoc291cmNlLCAnZycpO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xyXG4gICAgICBzdHJpbmcgPSBzdHJpbmcgPT0gbnVsbCA/ICcnIDogJycgKyBzdHJpbmc7XHJcbiAgICAgIHJldHVybiB0ZXN0UmVnZXhwLnRlc3Qoc3RyaW5nKSA/IHN0cmluZy5yZXBsYWNlKHJlcGxhY2VSZWdleHAsIGVzY2FwZXIpIDogc3RyaW5nO1xyXG4gICAgfTtcclxuICB9O1xyXG4gIF8uZXNjYXBlID0gY3JlYXRlRXNjYXBlcihlc2NhcGVNYXApO1xyXG4gIF8udW5lc2NhcGUgPSBjcmVhdGVFc2NhcGVyKHVuZXNjYXBlTWFwKTtcclxuXHJcbiAgLy8gSWYgdGhlIHZhbHVlIG9mIHRoZSBuYW1lZCBgcHJvcGVydHlgIGlzIGEgZnVuY3Rpb24gdGhlbiBpbnZva2UgaXQgd2l0aCB0aGVcclxuICAvLyBgb2JqZWN0YCBhcyBjb250ZXh0OyBvdGhlcndpc2UsIHJldHVybiBpdC5cclxuICBfLnJlc3VsdCA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHksIGZhbGxiYWNrKSB7XHJcbiAgICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IG9iamVjdFtwcm9wZXJ0eV07XHJcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xyXG4gICAgICB2YWx1ZSA9IGZhbGxiYWNrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF8uaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZS5jYWxsKG9iamVjdCkgOiB2YWx1ZTtcclxuICB9O1xyXG5cclxuICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpbnRlZ2VyIGlkICh1bmlxdWUgd2l0aGluIHRoZSBlbnRpcmUgY2xpZW50IHNlc3Npb24pLlxyXG4gIC8vIFVzZWZ1bCBmb3IgdGVtcG9yYXJ5IERPTSBpZHMuXHJcbiAgdmFyIGlkQ291bnRlciA9IDA7XHJcbiAgXy51bmlxdWVJZCA9IGZ1bmN0aW9uKHByZWZpeCkge1xyXG4gICAgdmFyIGlkID0gKytpZENvdW50ZXIgKyAnJztcclxuICAgIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyBpZCA6IGlkO1xyXG4gIH07XHJcblxyXG4gIC8vIEJ5IGRlZmF1bHQsIFVuZGVyc2NvcmUgdXNlcyBFUkItc3R5bGUgdGVtcGxhdGUgZGVsaW1pdGVycywgY2hhbmdlIHRoZVxyXG4gIC8vIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cclxuICBfLnRlbXBsYXRlU2V0dGluZ3MgPSB7XHJcbiAgICBldmFsdWF0ZSAgICA6IC88JShbXFxzXFxTXSs/KSU+L2csXHJcbiAgICBpbnRlcnBvbGF0ZSA6IC88JT0oW1xcc1xcU10rPyklPi9nLFxyXG4gICAgZXNjYXBlICAgICAgOiAvPCUtKFtcXHNcXFNdKz8pJT4vZ1xyXG4gIH07XHJcblxyXG4gIC8vIFdoZW4gY3VzdG9taXppbmcgYHRlbXBsYXRlU2V0dGluZ3NgLCBpZiB5b3UgZG9uJ3Qgd2FudCB0byBkZWZpbmUgYW5cclxuICAvLyBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uIG9yIGVzY2FwaW5nIHJlZ2V4LCB3ZSBuZWVkIG9uZSB0aGF0IGlzXHJcbiAgLy8gZ3VhcmFudGVlZCBub3QgdG8gbWF0Y2guXHJcbiAgdmFyIG5vTWF0Y2ggPSAvKC4pXi87XHJcblxyXG4gIC8vIENlcnRhaW4gY2hhcmFjdGVycyBuZWVkIHRvIGJlIGVzY2FwZWQgc28gdGhhdCB0aGV5IGNhbiBiZSBwdXQgaW50byBhXHJcbiAgLy8gc3RyaW5nIGxpdGVyYWwuXHJcbiAgdmFyIGVzY2FwZXMgPSB7XHJcbiAgICBcIidcIjogICAgICBcIidcIixcclxuICAgICdcXFxcJzogICAgICdcXFxcJyxcclxuICAgICdcXHInOiAgICAgJ3InLFxyXG4gICAgJ1xcbic6ICAgICAnbicsXHJcbiAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXHJcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcclxuICB9O1xyXG5cclxuICB2YXIgZXNjYXBlciA9IC9cXFxcfCd8XFxyfFxcbnxcXHUyMDI4fFxcdTIwMjkvZztcclxuXHJcbiAgdmFyIGVzY2FwZUNoYXIgPSBmdW5jdGlvbihtYXRjaCkge1xyXG4gICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZXNbbWF0Y2hdO1xyXG4gIH07XHJcblxyXG4gIC8vIEphdmFTY3JpcHQgbWljcm8tdGVtcGxhdGluZywgc2ltaWxhciB0byBKb2huIFJlc2lnJ3MgaW1wbGVtZW50YXRpb24uXHJcbiAgLy8gVW5kZXJzY29yZSB0ZW1wbGF0aW5nIGhhbmRsZXMgYXJiaXRyYXJ5IGRlbGltaXRlcnMsIHByZXNlcnZlcyB3aGl0ZXNwYWNlLFxyXG4gIC8vIGFuZCBjb3JyZWN0bHkgZXNjYXBlcyBxdW90ZXMgd2l0aGluIGludGVycG9sYXRlZCBjb2RlLlxyXG4gIC8vIE5COiBgb2xkU2V0dGluZ3NgIG9ubHkgZXhpc3RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cclxuICBfLnRlbXBsYXRlID0gZnVuY3Rpb24odGV4dCwgc2V0dGluZ3MsIG9sZFNldHRpbmdzKSB7XHJcbiAgICBpZiAoIXNldHRpbmdzICYmIG9sZFNldHRpbmdzKSBzZXR0aW5ncyA9IG9sZFNldHRpbmdzO1xyXG4gICAgc2V0dGluZ3MgPSBfLmRlZmF1bHRzKHt9LCBzZXR0aW5ncywgXy50ZW1wbGF0ZVNldHRpbmdzKTtcclxuXHJcbiAgICAvLyBDb21iaW5lIGRlbGltaXRlcnMgaW50byBvbmUgcmVndWxhciBleHByZXNzaW9uIHZpYSBhbHRlcm5hdGlvbi5cclxuICAgIHZhciBtYXRjaGVyID0gUmVnRXhwKFtcclxuICAgICAgKHNldHRpbmdzLmVzY2FwZSB8fCBub01hdGNoKS5zb3VyY2UsXHJcbiAgICAgIChzZXR0aW5ncy5pbnRlcnBvbGF0ZSB8fCBub01hdGNoKS5zb3VyY2UsXHJcbiAgICAgIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VcclxuICAgIF0uam9pbignfCcpICsgJ3wkJywgJ2cnKTtcclxuXHJcbiAgICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxyXG4gICAgdmFyIGluZGV4ID0gMDtcclxuICAgIHZhciBzb3VyY2UgPSBcIl9fcCs9J1wiO1xyXG4gICAgdGV4dC5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGUsIGludGVycG9sYXRlLCBldmFsdWF0ZSwgb2Zmc2V0KSB7XHJcbiAgICAgIHNvdXJjZSArPSB0ZXh0LnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UoZXNjYXBlciwgZXNjYXBlQ2hhcik7XHJcbiAgICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xyXG5cclxuICAgICAgaWYgKGVzY2FwZSkge1xyXG4gICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgZXNjYXBlICsgXCIpKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcXG4nXCI7XHJcbiAgICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGUpIHtcclxuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGludGVycG9sYXRlICsgXCIpKT09bnVsbD8nJzpfX3QpK1xcbidcIjtcclxuICAgICAgfSBlbHNlIGlmIChldmFsdWF0ZSkge1xyXG4gICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZSArIFwiXFxuX19wKz0nXCI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEFkb2JlIFZNcyBuZWVkIHRoZSBtYXRjaCByZXR1cm5lZCB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IG9mZmVzdC5cclxuICAgICAgcmV0dXJuIG1hdGNoO1xyXG4gICAgfSk7XHJcbiAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xyXG5cclxuICAgIC8vIElmIGEgdmFyaWFibGUgaXMgbm90IHNwZWNpZmllZCwgcGxhY2UgZGF0YSB2YWx1ZXMgaW4gbG9jYWwgc2NvcGUuXHJcbiAgICBpZiAoIXNldHRpbmdzLnZhcmlhYmxlKSBzb3VyY2UgPSAnd2l0aChvYmp8fHt9KXtcXG4nICsgc291cmNlICsgJ31cXG4nO1xyXG5cclxuICAgIHNvdXJjZSA9IFwidmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLFwiICtcclxuICAgICAgXCJwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xcblwiICtcclxuICAgICAgc291cmNlICsgJ3JldHVybiBfX3A7XFxuJztcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICB2YXIgcmVuZGVyID0gbmV3IEZ1bmN0aW9uKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonLCAnXycsIHNvdXJjZSk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGUuc291cmNlID0gc291cmNlO1xyXG4gICAgICB0aHJvdyBlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB0ZW1wbGF0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgcmV0dXJuIHJlbmRlci5jYWxsKHRoaXMsIGRhdGEsIF8pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBzb3VyY2UgYXMgYSBjb252ZW5pZW5jZSBmb3IgcHJlY29tcGlsYXRpb24uXHJcbiAgICB2YXIgYXJndW1lbnQgPSBzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJztcclxuICAgIHRlbXBsYXRlLnNvdXJjZSA9ICdmdW5jdGlvbignICsgYXJndW1lbnQgKyAnKXtcXG4nICsgc291cmNlICsgJ30nO1xyXG5cclxuICAgIHJldHVybiB0ZW1wbGF0ZTtcclxuICB9O1xyXG5cclxuICAvLyBBZGQgYSBcImNoYWluXCIgZnVuY3Rpb24uIFN0YXJ0IGNoYWluaW5nIGEgd3JhcHBlZCBVbmRlcnNjb3JlIG9iamVjdC5cclxuICBfLmNoYWluID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICB2YXIgaW5zdGFuY2UgPSBfKG9iaik7XHJcbiAgICBpbnN0YW5jZS5fY2hhaW4gPSB0cnVlO1xyXG4gICAgcmV0dXJuIGluc3RhbmNlO1xyXG4gIH07XHJcblxyXG4gIC8vIE9PUFxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vIElmIFVuZGVyc2NvcmUgaXMgY2FsbGVkIGFzIGEgZnVuY3Rpb24sIGl0IHJldHVybnMgYSB3cmFwcGVkIG9iamVjdCB0aGF0XHJcbiAgLy8gY2FuIGJlIHVzZWQgT08tc3R5bGUuIFRoaXMgd3JhcHBlciBob2xkcyBhbHRlcmVkIHZlcnNpb25zIG9mIGFsbCB0aGVcclxuICAvLyB1bmRlcnNjb3JlIGZ1bmN0aW9ucy4gV3JhcHBlZCBvYmplY3RzIG1heSBiZSBjaGFpbmVkLlxyXG5cclxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29udGludWUgY2hhaW5pbmcgaW50ZXJtZWRpYXRlIHJlc3VsdHMuXHJcbiAgdmFyIHJlc3VsdCA9IGZ1bmN0aW9uKGluc3RhbmNlLCBvYmopIHtcclxuICAgIHJldHVybiBpbnN0YW5jZS5fY2hhaW4gPyBfKG9iaikuY2hhaW4oKSA6IG9iajtcclxuICB9O1xyXG5cclxuICAvLyBBZGQgeW91ciBvd24gY3VzdG9tIGZ1bmN0aW9ucyB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXHJcbiAgXy5taXhpbiA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgXy5lYWNoKF8uZnVuY3Rpb25zKG9iaiksIGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgdmFyIGZ1bmMgPSBfW25hbWVdID0gb2JqW25hbWVdO1xyXG4gICAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBhcmdzID0gW3RoaXMuX3dyYXBwZWRdO1xyXG4gICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIGZ1bmMuYXBwbHkoXywgYXJncykpO1xyXG4gICAgICB9O1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gQWRkIGFsbCBvZiB0aGUgVW5kZXJzY29yZSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIgb2JqZWN0LlxyXG4gIF8ubWl4aW4oXyk7XHJcblxyXG4gIC8vIEFkZCBhbGwgbXV0YXRvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXHJcbiAgXy5lYWNoKFsncG9wJywgJ3B1c2gnLCAncmV2ZXJzZScsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xyXG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIG9iaiA9IHRoaXMuX3dyYXBwZWQ7XHJcbiAgICAgIG1ldGhvZC5hcHBseShvYmosIGFyZ3VtZW50cyk7XHJcbiAgICAgIGlmICgobmFtZSA9PT0gJ3NoaWZ0JyB8fCBuYW1lID09PSAnc3BsaWNlJykgJiYgb2JqLmxlbmd0aCA9PT0gMCkgZGVsZXRlIG9ialswXTtcclxuICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLCBvYmopO1xyXG4gICAgfTtcclxuICB9KTtcclxuXHJcbiAgLy8gQWRkIGFsbCBhY2Nlc3NvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXHJcbiAgXy5lYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAnc2xpY2UnXSwgZnVuY3Rpb24obmFtZSkge1xyXG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XHJcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIG1ldGhvZC5hcHBseSh0aGlzLl93cmFwcGVkLCBhcmd1bWVudHMpKTtcclxuICAgIH07XHJcbiAgfSk7XHJcblxyXG4gIC8vIEV4dHJhY3RzIHRoZSByZXN1bHQgZnJvbSBhIHdyYXBwZWQgYW5kIGNoYWluZWQgb2JqZWN0LlxyXG4gIF8ucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fd3JhcHBlZDtcclxuICB9O1xyXG5cclxuICAvLyBQcm92aWRlIHVud3JhcHBpbmcgcHJveHkgZm9yIHNvbWUgbWV0aG9kcyB1c2VkIGluIGVuZ2luZSBvcGVyYXRpb25zXHJcbiAgLy8gc3VjaCBhcyBhcml0aG1ldGljIGFuZCBKU09OIHN0cmluZ2lmaWNhdGlvbi5cclxuICBfLnByb3RvdHlwZS52YWx1ZU9mID0gXy5wcm90b3R5cGUudG9KU09OID0gXy5wcm90b3R5cGUudmFsdWU7XHJcbiAgXHJcbiAgXy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiAnJyArIHRoaXMuX3dyYXBwZWQ7XHJcbiAgfTtcclxuXHJcbiAgLy8gQU1EIHJlZ2lzdHJhdGlvbiBoYXBwZW5zIGF0IHRoZSBlbmQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBBTUQgbG9hZGVyc1xyXG4gIC8vIHRoYXQgbWF5IG5vdCBlbmZvcmNlIG5leHQtdHVybiBzZW1hbnRpY3Mgb24gbW9kdWxlcy4gRXZlbiB0aG91Z2ggZ2VuZXJhbFxyXG4gIC8vIHByYWN0aWNlIGZvciBBTUQgcmVnaXN0cmF0aW9uIGlzIHRvIGJlIGFub255bW91cywgdW5kZXJzY29yZSByZWdpc3RlcnNcclxuICAvLyBhcyBhIG5hbWVkIG1vZHVsZSBiZWNhdXNlLCBsaWtlIGpRdWVyeSwgaXQgaXMgYSBiYXNlIGxpYnJhcnkgdGhhdCBpc1xyXG4gIC8vIHBvcHVsYXIgZW5vdWdoIHRvIGJlIGJ1bmRsZWQgaW4gYSB0aGlyZCBwYXJ0eSBsaWIsIGJ1dCBub3QgYmUgcGFydCBvZlxyXG4gIC8vIGFuIEFNRCBsb2FkIHJlcXVlc3QuIFRob3NlIGNhc2VzIGNvdWxkIGdlbmVyYXRlIGFuIGVycm9yIHdoZW4gYW5cclxuICAvLyBhbm9ueW1vdXMgZGVmaW5lKCkgaXMgY2FsbGVkIG91dHNpZGUgb2YgYSBsb2FkZXIgcmVxdWVzdC5cclxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICBkZWZpbmUoJ3VuZGVyc2NvcmUnLCBbXSwgZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiBfO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59LmNhbGwodGhpcykpO1xyXG4iLCJ2YXIgYnVpbGRQcm9taXNlID0gcmVxdWlyZSgnLi91dGlscycpLmJ1aWxkUHJvbWlzZTtcclxudmFyIEV2ZXJsaXZlRXJyb3IgPSByZXF1aXJlKCcuL0V2ZXJsaXZlRXJyb3InKS5FdmVybGl2ZUVycm9yO1xyXG52YXIgUGxhdGZvcm0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpLlBsYXRmb3JtO1xyXG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcclxudmFyIGpzdHogPSBjb21tb24uanN0ejtcclxudmFyIF8gPSBjb21tb24uXztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQGNsYXNzIEN1cnJlbnREZXZpY2VcclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAcGFyYW0gcHVzaEhhbmRsZXJcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICB2YXIgQ3VycmVudERldmljZSA9IGZ1bmN0aW9uIChwdXNoSGFuZGxlcikge1xyXG4gICAgICAgIHRoaXMuX3B1c2hIYW5kbGVyID0gcHVzaEhhbmRsZXI7XHJcbiAgICAgICAgdGhpcy5faW5pdFN1Y2Nlc3NDYWxsYmFjayA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5faW5pdEVycm9yQ2FsbGJhY2sgPSBudWxsO1xyXG5cclxuICAgICAgICAvL1N1ZmZpeCBmb3IgdGhlIGdsb2JhbCBjYWxsYmFjayBmdW5jdGlvbnNcclxuICAgICAgICB0aGlzLl9nbG9iYWxGdW5jdGlvblN1ZmZpeCA9IG51bGw7XHJcblxyXG4gICAgICAgIHRoaXMucHVzaFNldHRpbmdzID0gbnVsbDtcclxuICAgICAgICB0aGlzLnB1c2hUb2tlbiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc0luaXRpYWxpemluZyA9IGZhbHNlO1xyXG5cclxuICAgICAgICB0aGlzLmVtdWxhdG9yTW9kZSA9IGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICBDdXJyZW50RGV2aWNlLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgdGhlIGN1cnJlbnQgZGV2aWNlIGZvciBwdXNoIG5vdGlmaWNhdGlvbnMuIFRoaXMgbWV0aG9kIHJlcXVlc3RzIGEgcHVzaCB0b2tlbiBmcm9tIHRoZSBkZXZpY2UgdmVuZG9yIGFuZCBlbmFibGVzIHRoZSBwdXNoIG5vdGlmaWNhdGlvbiBmdW5jdGlvbmFsaXR5IG9uIHRoZSBkZXZpY2UuIE9uY2UgdGhpcyBpcyBkb25lLCB5b3UgY2FuIHJlZ2lzdGVyIHRoZSBkZXZpY2UgaW4ge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSB1c2luZyB0aGUgcmVnaXN0ZXIoKSBtZXRob2QuXHJcbiAgICAgICAgICogQG1ldGhvZCBlbmFibGVOb3RpZmljYXRpb25zXHJcbiAgICAgICAgICogQG5hbWUgZW5hYmxlTm90aWZpY2F0aW9uc1xyXG4gICAgICAgICAqIEBtZW1iZXJPZiBDdXJyZW50RGV2aWNlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7UHVzaFNldHRpbmdzfSBwdXNoU2V0dGluZ3MgQW4gb2JqZWN0IHNwZWNpZnlpbmcgdmFyaW91cyBzZXR0aW5ncyBmb3IgdGhlIGluaXRpYWxpemF0aW9uLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbml0aWFsaXplcyB0aGUgY3VycmVudCBkZXZpY2UgZm9yIHB1c2ggbm90aWZpY2F0aW9ucy4gVGhpcyBtZXRob2QgcmVxdWVzdHMgYSBwdXNoIHRva2VuIGZyb20gdGhlIGRldmljZSB2ZW5kb3IgYW5kIGVuYWJsZXMgdGhlIHB1c2ggbm90aWZpY2F0aW9uIGZ1bmN0aW9uYWxpdHkgb24gdGhlIGRldmljZS4gT25jZSB0aGlzIGlzIGRvbmUsIHlvdSBjYW4gcmVnaXN0ZXIgdGhlIGRldmljZSBpbiBFdmVybGl2ZSB1c2luZyB0aGUgcmVnaXN0ZXIoKSBtZXRob2QuXHJcbiAgICAgICAgICogQG1ldGhvZCBlbmFibGVOb3RpZmljYXRpb25zXHJcbiAgICAgICAgICogQG5hbWUgZW5hYmxlTm90aWZpY2F0aW9uc1xyXG4gICAgICAgICAqIEBtZW1iZXJPZiBDdXJyZW50RGV2aWNlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7UHVzaFNldHRpbmdzfSBwdXNoU2V0dGluZ3MgQW4gb2JqZWN0IHNwZWNpZnlpbmcgdmFyaW91cyBzZXR0aW5ncyBmb3IgdGhlIGluaXRpYWxpemF0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBDYWxsYmFjayB0byBpbnZva2Ugb24gc3VjY2Vzcy5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIENhbGxiYWNrIHRvIGludm9rZSBvbiBlcnJvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBlbmFibGVOb3RpZmljYXRpb25zOiBmdW5jdGlvbiAocHVzaFNldHRpbmdzLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLnB1c2hTZXR0aW5ncyA9IHRoaXMuX2NsZWFuUGxhdGZvcm1zUHVzaFNldHRpbmdzKHB1c2hTZXR0aW5ncyk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKF8uYmluZCh0aGlzLl9pbml0aWFsaXplLCB0aGlzKSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERpc2FibGVzIHB1c2ggbm90aWZpY2F0aW9ucyBmb3IgdGhlIGN1cnJlbnQgZGV2aWNlLiBUaGlzIG1ldGhvZCBpbnZhbGlkYXRlcyBhbnkgcHVzaCB0b2tlbnMgdGhhdCB3ZXJlIG9idGFpbmVkIGZvciB0aGUgZGV2aWNlIGZyb20gdGhlIGN1cnJlbnQgYXBwbGljYXRpb24uXHJcbiAgICAgICAgICogQG1ldGhvZCBkaXNhYmxlTm90aWZpY2F0aW9uc1xyXG4gICAgICAgICAqIEBuYW1lIGRpc2FibGVOb3RpZmljYXRpb25zXHJcbiAgICAgICAgICogQG1lbWJlck9mIEN1cnJlbnREZXZpY2UucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERpc2FibGVzIHB1c2ggbm90aWZpY2F0aW9ucyBmb3IgdGhlIGN1cnJlbnQgZGV2aWNlLiBUaGlzIG1ldGhvZCBpbnZhbGlkYXRlcyBhbnkgcHVzaCB0b2tlbnMgdGhhdCB3ZXJlIG9idGFpbmVkIGZvciB0aGUgZGV2aWNlIGZyb20gdGhlIGN1cnJlbnQgYXBwbGljYXRpb24uXHJcbiAgICAgICAgICogQG1ldGhvZCBkaXNhYmxlTm90aWZpY2F0aW9uc1xyXG4gICAgICAgICAqIEBuYW1lIGRpc2FibGVOb3RpZmljYXRpb25zXHJcbiAgICAgICAgICogQG1lbWJlck9mIEN1cnJlbnREZXZpY2UucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIENhbGxiYWNrIHRvIGludm9rZSBvbiBzdWNjZXNzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIGVycm9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRpc2FibGVOb3RpZmljYXRpb25zOiBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5yZWdpc3RlcigpLnRoZW4oXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5lbXVsYXRvck1vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwdXNoTm90aWZpY2F0aW9uID0gd2luZG93LnBsdWdpbnMucHVzaE5vdGlmaWNhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdW5yZWdpc3Rlck9wdGlvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBsYXRmb3JtVHlwZSA9IHNlbGYuX2dldFBsYXRmb3JtVHlwZShkZXZpY2UucGxhdGZvcm0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwbGF0Zm9ybVR5cGUgPT09IFBsYXRmb3JtLldpbmRvd3NQaG9uZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bnJlZ2lzdGVyT3B0aW9ucyA9IHsnY2hhbm5lbE5hbWUnOiBzZWxmLnB1c2hTZXR0aW5ncy53cDguY2hhbm5lbE5hbWV9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXNoTm90aWZpY2F0aW9uLnVucmVnaXN0ZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaXNJbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzcygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5yZWdpc3Rlck9wdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvclxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZXJyb3JcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBwdXNoIHJlZ2lzdHJhdGlvbiBmb3IgdGhlIGN1cnJlbnQgZGV2aWNlLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBDdXJyZW50RGV2aWNlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgZ2V0UmVnaXN0cmF0aW9uXHJcbiAgICAgICAgICogQG5hbWUgZ2V0UmVnaXN0cmF0aW9uXHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIHB1c2ggcmVnaXN0cmF0aW9uIGZvciB0aGUgY3VycmVudCBkZXZpY2UuXHJcbiAgICAgICAgICogQG1lbWJlck9mIEN1cnJlbnREZXZpY2UucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBnZXRSZWdpc3RyYXRpb25cclxuICAgICAgICAgKiBAbmFtZSBnZXRSZWdpc3RyYXRpb25cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWNjZXNzIENhbGxiYWNrIHRvIGludm9rZSBvbiBzdWNjZXNzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVycm9yIENhbGxiYWNrIHRvIGludm9rZSBvbiBlcnJvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRSZWdpc3RyYXRpb246IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgZGV2aWNlSWQgPSBlbmNvZGVVUklDb21wb25lbnQodGhpcy5fZ2V0RGV2aWNlSWQoKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wdXNoSGFuZGxlci5kZXZpY2VzLmdldEJ5SWQoJ0hhcmR3YXJlSWQvJyArIGRldmljZUlkLCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVnaXN0ZXJzIHRoZSBjdXJyZW50IGRldmljZSBmb3IgcHVzaCBub3RpZmljYXRpb25zIGluIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0uIFRoaXMgbWV0aG9kIGNhbiBiZSBjYWxsZWQgb25seSBhZnRlciBbZW5hYmxlTm90aWZpY2F0aW9ucygpXSgjQ3VycmVudERldmljZS5lbmFibGVOb3RpZmljYXRpb25zKSBoYXMgY29tcGxldGVkIHN1Y2Nlc3NmdWxseS5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgQ3VycmVudERldmljZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHJlZ2lzdGVyXHJcbiAgICAgICAgICogQG5hbWUgcmVnaXN0ZXJcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY3VzdG9tUGFyYW1ldGVycyBDdXN0b20gcGFyYW1ldGVycyBmb3IgdGhlIHJlZ2lzdHJhdGlvbi5cclxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVnaXN0ZXJzIHRoZSBjdXJyZW50IGRldmljZSBmb3IgcHVzaCBub3RpZmljYXRpb25zIGluIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0uIFRoaXMgbWV0aG9kIGNhbiBiZSBjYWxsZWQgb25seSBhZnRlciBbZW5hYmxlTm90aWZpY2F0aW9ucygpXSgjQ3VycmVudERldmljZS5lbmFibGVOb3RpZmljYXRpb25zKSBoYXMgY29tcGxldGVkIHN1Y2Nlc3NmdWxseS5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgQ3VycmVudERldmljZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHJlZ2lzdGVyXHJcbiAgICAgICAgICogQG5hbWUgcmVnaXN0ZXJcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY3VzdG9tUGFyYW1ldGVycyBDdXN0b20gcGFyYW1ldGVycyBmb3IgdGhlIHJlZ2lzdHJhdGlvbi5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIHN1Y2Nlc3MuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBDYWxsYmFjayB0byBpbnZva2Ugb24gZXJyb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uIChjdXN0b21QYXJhbWV0ZXJzLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICB2YXIgZGV2aWNlUmVnaXN0cmF0aW9uID0ge307XHJcbiAgICAgICAgICAgIGlmIChjdXN0b21QYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGRldmljZVJlZ2lzdHJhdGlvbi5QYXJhbWV0ZXJzID0gY3VzdG9tUGFyYW1ldGVycztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BvcHVsYXRlUmVnaXN0cmF0aW9uT2JqZWN0KGRldmljZVJlZ2lzdHJhdGlvbikudGhlbihcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fcHVzaEhhbmRsZXIuZGV2aWNlcy5jcmVhdGUoZGV2aWNlUmVnaXN0cmF0aW9uLCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZXJyb3JcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVbnJlZ2lzdGVycyB0aGUgY3VycmVudCBkZXZpY2UgZnJvbSBwdXNoIG5vdGlmaWNhdGlvbnMgaW4ge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fS4gQWZ0ZXIgdGhpcyBjYWxsIGNvbXBsZXRlcyBzdWNjZXNzZnVsbHksIHt7c2l0ZS5ic319IHdpbGwgbm8gbG9uZ2VyIHNlbmQgbm90aWZpY2F0aW9ucyB0byB0aGlzIGRldmljZS4gTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgcHJldmVudCB0aGUgZGV2aWNlIGZyb20gcmVjZWl2aW5nIG5vdGlmaWNhdGlvbnMgYW5kIGRvZXMgbm90IGludmFsaWRhdGUgcHVzaCB0b2tlbnMuXHJcbiAgICAgICAgICogQG1lbWJlck9mIEN1cnJlbnREZXZpY2UucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCB1bnJlZ2lzdGVyXHJcbiAgICAgICAgICogQG5hbWUgdW5yZWdpc3RlclxyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVbnJlZ2lzdGVycyB0aGUgY3VycmVudCBkZXZpY2UgZnJvbSBwdXNoIG5vdGlmaWNhdGlvbnMgaW4ge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fS4gQWZ0ZXIgdGhpcyBjYWxsIGNvbXBsZXRlcyBzdWNjZXNzZnVsbHksIHt7c2l0ZS5ic319IHdpbGwgbm8gbG9uZ2VyIHNlbmQgbm90aWZpY2F0aW9ucyB0byB0aGlzIGRldmljZS4gTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgcHJldmVudCB0aGUgZGV2aWNlIGZyb20gcmVjZWl2aW5nIG5vdGlmaWNhdGlvbnMgYW5kIGRvZXMgbm90IGludmFsaWRhdGUgcHVzaCB0b2tlbnMuXHJcbiAgICAgICAgICogQG1lbWJlck9mIEN1cnJlbnREZXZpY2UucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCB1bnJlZ2lzdGVyXHJcbiAgICAgICAgICogQG5hbWUgdW5yZWdpc3RlclxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBDYWxsYmFjayB0byBpbnZva2Ugb24gc3VjY2Vzcy5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIENhbGxiYWNrIHRvIGludm9rZSBvbiBlcnJvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICB1bnJlZ2lzdGVyOiBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIGRldmljZUlkID0gZW5jb2RlVVJJQ29tcG9uZW50KGRldmljZS51dWlkKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hIYW5kbGVyLmRldmljZXMuZGVzdHJveVNpbmdsZSh7SWQ6ICdIYXJkd2FyZUlkLycgKyBkZXZpY2VJZH0sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGVzIHRoZSByZWdpc3RyYXRpb24gb2YgdGhlIGN1cnJlbnQgZGV2aWNlLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBDdXJyZW50RGV2aWNlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgdXBkYXRlUmVnaXN0cmF0aW9uXHJcbiAgICAgICAgICogQG5hbWUgdXBkYXRlUmVnaXN0cmF0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGN1c3RvbVBhcmFtZXRlcnMgQ3VzdG9tIHBhcmFtZXRlcnMgZm9yIHRoZSByZWdpc3RyYXRpb24uIElmIHVuZGVmaW5lZCwgY3VzdG9tUGFyYW1ldGVycyBhcmUgbm90IHVwZGF0ZWQuXHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZXMgdGhlIHJlZ2lzdHJhdGlvbiBmb3IgdGhlIGN1cnJlbnQgZGV2aWNlLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBDdXJyZW50RGV2aWNlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgdXBkYXRlUmVnaXN0cmF0aW9uXHJcbiAgICAgICAgICogQG5hbWUgdXBkYXRlUmVnaXN0cmF0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGN1c3RvbVBhcmFtZXRlcnMgQ3VzdG9tIHBhcmFtZXRlcnMgZm9yIHRoZSByZWdpc3RyYXRpb24uIElmIHVuZGVmaW5lZCwgY3VzdG9tUGFyYW1ldGVycyBhcmUgbm90IHVwZGF0ZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIENhbGxiYWNrIHRvIGludm9rZSBvbiBzdWNjZXNzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIGVycm9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHVwZGF0ZVJlZ2lzdHJhdGlvbjogZnVuY3Rpb24gKGN1c3RvbVBhcmFtZXRlcnMsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHZhciBkZXZpY2VSZWdpc3RyYXRpb24gPSB7fTtcclxuICAgICAgICAgICAgaWYgKGN1c3RvbVBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgZGV2aWNlUmVnaXN0cmF0aW9uLlBhcmFtZXRlcnMgPSBjdXN0b21QYXJhbWV0ZXJzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcG9wdWxhdGVSZWdpc3RyYXRpb25PYmplY3QoZGV2aWNlUmVnaXN0cmF0aW9uKS50aGVuKFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRldmljZVJlZ2lzdHJhdGlvbi5JZCA9ICdIYXJkd2FyZUlkLycgKyBlbmNvZGVVUklDb21wb25lbnQoZGV2aWNlUmVnaXN0cmF0aW9uLkhhcmR3YXJlSWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9wdXNoSGFuZGxlci5kZXZpY2VzLnVwZGF0ZVNpbmdsZShkZXZpY2VSZWdpc3RyYXRpb24sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlcnJvclxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9pbml0aWFsaXplSW50ZXJhY3RpdmVQdXNoOiBmdW5jdGlvbiAoaU9TU2V0dGluZ3MsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBwdXNoUGx1Z2luID0gd2luZG93LnBsdWdpbnMucHVzaE5vdGlmaWNhdGlvbjtcclxuXHJcbiAgICAgICAgICAgIHZhciBpbnRlcmFjdGl2ZVNldHRpbmdzID0gaU9TU2V0dGluZ3MuaW50ZXJhY3RpdmVTZXR0aW5ncztcclxuICAgICAgICAgICAgdmFyIG5vdGlmaWNhdGlvblR5cGVzID0gW107XHJcbiAgICAgICAgICAgIGlmIChpT1NTZXR0aW5ncy5hbGVydCkge1xyXG4gICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uVHlwZXMucHVzaChwdXNoUGx1Z2luLlVzZXJOb3RpZmljYXRpb25UeXBlcy5BbGVydCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlPU1NldHRpbmdzLmJhZGdlKSB7XHJcbiAgICAgICAgICAgICAgICBub3RpZmljYXRpb25UeXBlcy5wdXNoKHB1c2hQbHVnaW4uVXNlck5vdGlmaWNhdGlvblR5cGVzLkJhZGdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaU9TU2V0dGluZ3Muc291bmQpIHtcclxuICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvblR5cGVzLnB1c2gocHVzaFBsdWdpbi5Vc2VyTm90aWZpY2F0aW9uVHlwZXMuU291bmQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZ2V0QWN0aW9uID0gZnVuY3Rpb24gKGFjdGlvbklkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhY3Rpb24gPSBfLmZpbmQoaW50ZXJhY3RpdmVTZXR0aW5ncy5hY3Rpb25zLCBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi5pZGVudGlmaWVyID09PSBhY3Rpb25JZGVudGlmaWVyO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBfLm1hcChpbnRlcmFjdGl2ZVNldHRpbmdzLmNhdGVnb3JpZXMsIGZ1bmN0aW9uIChjYXRlZ29yeSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiBjYXRlZ29yeS5pZGVudGlmaWVyLFxyXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbnNGb3JEZWZhdWx0Q29udGV4dDogXy5tYXAoY2F0ZWdvcnkuYWN0aW9uc0ZvckRlZmF1bHRDb250ZXh0LCBnZXRBY3Rpb24pLFxyXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbnNGb3JNaW5pbWFsQ29udGV4dDogXy5tYXAoY2F0ZWdvcnkuYWN0aW9uc0Zvck1pbmltYWxDb250ZXh0LCBnZXRBY3Rpb24pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcHVzaFBsdWdpbi5yZWdpc3RlclVzZXJOb3RpZmljYXRpb25TZXR0aW5ncyhcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBzdWNjZXNzIGNhbGxiYWNrIHdoaWNoIHdpbGwgaW1tZWRpYXRlbHkgcmV0dXJuIChBUE5zIGlzIG5vdCBjb250YWN0ZWQgZm9yIHRoaXMpXHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzLFxyXG4gICAgICAgICAgICAgICAgLy8gY2FsbGVkIGluIGNhc2UgdGhlIGNvbmZpZ3VyYXRpb24gaXMgaW5jb3JyZWN0XHJcbiAgICAgICAgICAgICAgICBlcnJvciwge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFza2luZyBwZXJtaXNzaW9uIGZvciB0aGVzZSBmZWF0dXJlc1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGVzOiBub3RpZmljYXRpb25UeXBlcyxcclxuICAgICAgICAgICAgICAgICAgICAvLyByZWdpc3RlciB0aGVzZSBjYXRlZ29yaWVzXHJcbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcmllczogY2F0ZWdvcmllc1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vSW5pdGlhbGl6ZXMgdGhlIHB1c2ggZnVuY3Rpb25hbGl0eSBvbiB0aGUgZGV2aWNlLlxyXG4gICAgICAgIF9pbml0aWFsaXplOiBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNJbml0aWFsaXppbmcpIHtcclxuICAgICAgICAgICAgICAgIGVycm9yKG5ldyBFdmVybGl2ZUVycm9yKCdQdXNoIG5vdGlmaWNhdGlvbnMgYXJlIGN1cnJlbnRseSBpbml0aWFsaXppbmcuJykpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZW11bGF0b3JNb2RlICYmICghd2luZG93Lm5hdmlnYXRvciB8fCAhd2luZG93Lm5hdmlnYXRvci5nbG9iYWxpemF0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgZXJyb3IobmV3IEV2ZXJsaXZlRXJyb3IoJ1RoZSBnbG9iYWxpemF0aW9uIHBsdWdpbiBpcyBub3QgaW5pdGlhbGl6ZWQuJykpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZW11bGF0b3JNb2RlICYmICghd2luZG93LnBsdWdpbnMgfHwgIXdpbmRvdy5wbHVnaW5zLnB1c2hOb3RpZmljYXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvcihuZXcgRXZlcmxpdmVFcnJvcignVGhlIHB1c2ggbm90aWZpY2F0aW9ucyBwbHVnaW4gaXMgbm90IGluaXRpYWxpemVkLicpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5faW5pdFN1Y2Nlc3NDYWxsYmFjayA9IHN1Y2Nlc3M7XHJcbiAgICAgICAgICAgIHRoaXMuX2luaXRFcnJvckNhbGxiYWNrID0gZXJyb3I7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kZXZpY2VSZWdpc3RyYXRpb25TdWNjZXNzKHRoaXMucHVzaFRva2VuKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuZW11bGF0b3JNb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KFxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fZGV2aWNlUmVnaXN0cmF0aW9uU3VjY2VzcygnZmFrZV9wdXNoX3Rva2VuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAxMDAwXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmlzSW5pdGlhbGl6aW5nID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIHZhciBzdWZmaXggPSB0aGlzLl9nbG9iYWxGdW5jdGlvblN1ZmZpeDtcclxuICAgICAgICAgICAgaWYgKCFzdWZmaXgpIHtcclxuICAgICAgICAgICAgICAgIHN1ZmZpeCA9IERhdGUubm93KCkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2dsb2JhbEZ1bmN0aW9uU3VmZml4ID0gc3VmZml4O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcHVzaE5vdGlmaWNhdGlvbiA9IHdpbmRvdy5wbHVnaW5zLnB1c2hOb3RpZmljYXRpb247XHJcblxyXG4gICAgICAgICAgICB2YXIgcGxhdGZvcm1UeXBlID0gdGhpcy5fZ2V0UGxhdGZvcm1UeXBlKGRldmljZS5wbGF0Zm9ybSk7XHJcbiAgICAgICAgICAgIGlmIChwbGF0Zm9ybVR5cGUgPT09IFBsYXRmb3JtLmlPUykge1xyXG4gICAgICAgICAgICAgICAgLy9Jbml0aWFsaXplIGdsb2JhbCBBUE4gY2FsbGJhY2tcclxuICAgICAgICAgICAgICAgIHZhciBhcG5DYWxsYmFja05hbWUgPSAnYXBuQ2FsbGJhY2tfJyArIHN1ZmZpeDtcclxuICAgICAgICAgICAgICAgIEV2ZXJsaXZlLlB1c2hDYWxsYmFja3NbYXBuQ2FsbGJhY2tOYW1lXSA9IF8uYmluZCh0aGlzLl9vbk5vdGlmaWNhdGlvbkFQTiwgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9Db25zdHJ1Y3QgcmVnaXN0cmF0aW9uIG9wdGlvbnMgb2JqZWN0IGFuZCB2YWxpZGF0ZSBpT1Mgc2V0dGluZ3NcclxuICAgICAgICAgICAgICAgIHZhciBhcG5SZWdpc3RyYXRpb25PcHRpb25zID0gdGhpcy5wdXNoU2V0dGluZ3MuaU9TO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGVJT1NTZXR0aW5ncyhhcG5SZWdpc3RyYXRpb25PcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIGFwblJlZ2lzdHJhdGlvbk9wdGlvbnMuZWNiID0gJ0V2ZXJsaXZlLlB1c2hDYWxsYmFja3MuJyArIGFwbkNhbGxiYWNrTmFtZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL1JlZ2lzdGVyIGZvciBBUE5cclxuICAgICAgICAgICAgICAgIHB1c2hOb3RpZmljYXRpb24ucmVnaXN0ZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgXy5iaW5kKHRoaXMuX3N1Y2Nlc3NmdWxSZWdpc3RyYXRpb25BUE4sIHRoaXMpLFxyXG4gICAgICAgICAgICAgICAgICAgIF8uYmluZCh0aGlzLl9mYWlsZWRSZWdpc3RyYXRpb25BUE4sIHRoaXMpLFxyXG4gICAgICAgICAgICAgICAgICAgIGFwblJlZ2lzdHJhdGlvbk9wdGlvbnNcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGxhdGZvcm1UeXBlID09PSBQbGF0Zm9ybS5BbmRyb2lkKSB7XHJcbiAgICAgICAgICAgICAgICAvL0luaXRpYWxpemUgZ2xvYmFsIEdDTSBjYWxsYmFja1xyXG4gICAgICAgICAgICAgICAgdmFyIGdjbUNhbGxiYWNrTmFtZSA9ICdnY21DYWxsYmFja18nICsgc3VmZml4O1xyXG4gICAgICAgICAgICAgICAgRXZlcmxpdmUuUHVzaENhbGxiYWNrc1tnY21DYWxsYmFja05hbWVdID0gXy5iaW5kKHRoaXMuX29uTm90aWZpY2F0aW9uR0NNLCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL0NvbnN0cnVjdCByZWdpc3RyYXRpb24gb3B0aW9ucyBvYmplY3QgYW5kIHZhbGlkYXRlIHRoZSBBbmRyb2lkIHNldHRpbmdzXHJcbiAgICAgICAgICAgICAgICB2YXIgZ2NtUmVnaXN0cmF0aW9uT3B0aW9ucyA9IHRoaXMucHVzaFNldHRpbmdzLmFuZHJvaWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl92YWxpZGF0ZUFuZHJvaWRTZXR0aW5ncyhnY21SZWdpc3RyYXRpb25PcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIGdjbVJlZ2lzdHJhdGlvbk9wdGlvbnMuZWNiID0gJ0V2ZXJsaXZlLlB1c2hDYWxsYmFja3MuJyArIGdjbUNhbGxiYWNrTmFtZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL1JlZ2lzdGVyIGZvciBHQ01cclxuICAgICAgICAgICAgICAgIHB1c2hOb3RpZmljYXRpb24ucmVnaXN0ZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgXy5iaW5kKHRoaXMuX3N1Y2Nlc3NTZW50UmVnaXN0cmF0aW9uR0NNLCB0aGlzKSxcclxuICAgICAgICAgICAgICAgICAgICBfLmJpbmQodGhpcy5fZXJyb3JTZW50UmVnaXN0cmF0aW9uR0NNLCB0aGlzKSxcclxuICAgICAgICAgICAgICAgICAgICBnY21SZWdpc3RyYXRpb25PcHRpb25zXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBsYXRmb3JtVHlwZSA9PT0gUGxhdGZvcm0uV2luZG93c1Bob25lKSB7XHJcbiAgICAgICAgICAgICAgICAvL0luaXRpYWxpemUgZ2xvYmFsIFdQOCBjYWxsYmFja3MuXHJcbiAgICAgICAgICAgICAgICB2YXIgd3A4Q2FsbGJhY2tOYW1lID0gJ3dwOENhbGxiYWNrXycgKyBzdWZmaXg7XHJcbiAgICAgICAgICAgICAgICB2YXIgd3A4UmVnaXN0cmF0aW9uU3VjY2Vzc0NhbGxiYWNrTmFtZSA9ICd3cDhSZWdpc3RyYXRpb25TdWNjZXNzQ2FsbGJhY2tfJyArIHN1ZmZpeDtcclxuICAgICAgICAgICAgICAgIHZhciB3cDhSZWdpc3RyYXRpb25FcnJvckNhbGxiYWNrTmFtZSA9ICd3cDhSZWdpc3RyYXRpb25FcnJvckNhbGxiYWNrXycgKyBzdWZmaXg7XHJcblxyXG4gICAgICAgICAgICAgICAgRXZlcmxpdmUuUHVzaENhbGxiYWNrc1t3cDhDYWxsYmFja05hbWVdID0gXy5iaW5kKHRoaXMuX29uTm90aWZpY2F0aW9uV1A4LCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIEV2ZXJsaXZlLlB1c2hDYWxsYmFja3Nbd3A4UmVnaXN0cmF0aW9uU3VjY2Vzc0NhbGxiYWNrTmFtZV0gPSBfLmJpbmQodGhpcy5fZGV2aWNlUmVnaXN0cmF0aW9uU3VjY2Vzc1dQLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIEV2ZXJsaXZlLlB1c2hDYWxsYmFja3Nbd3A4UmVnaXN0cmF0aW9uRXJyb3JDYWxsYmFja05hbWVdID0gXy5iaW5kKHRoaXMuX2RldmljZVJlZ2lzdHJhdGlvbkZhaWxlZCwgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9Db25zdHJ1Y3QgcmVnaXN0cmF0aW9uIG9wdGlvbnMgb2JqZWN0IGFuZCB2YWxpZGF0ZSB0aGUgV1A4ICBzZXR0aW5nc1xyXG4gICAgICAgICAgICAgICAgdmFyIHdwOFJlZ2lzdHJhdGlvbk9wdGlvbnMgPSB0aGlzLnB1c2hTZXR0aW5ncy53cDg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl92YWxpZGF0ZVdQOFNldHRpbmdzKHdwOFJlZ2lzdHJhdGlvbk9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgd3A4UmVnaXN0cmF0aW9uT3B0aW9ucy5lY2IgPSAnRXZlcmxpdmUuUHVzaENhbGxiYWNrcy4nICsgd3A4Q2FsbGJhY2tOYW1lO1xyXG4gICAgICAgICAgICAgICAgd3A4UmVnaXN0cmF0aW9uT3B0aW9ucy51Y2NiID0gJ0V2ZXJsaXZlLlB1c2hDYWxsYmFja3MuJyArIHdwOFJlZ2lzdHJhdGlvblN1Y2Nlc3NDYWxsYmFja05hbWU7XHJcbiAgICAgICAgICAgICAgICB3cDhSZWdpc3RyYXRpb25PcHRpb25zLmVycmNiID0gJ0V2ZXJsaXZlLlB1c2hDYWxsYmFja3MuJyArIHdwOFJlZ2lzdHJhdGlvbkVycm9yQ2FsbGJhY2tOYW1lO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBwdXNoTm90aWZpY2F0aW9uLnJlZ2lzdGVyKFxyXG4gICAgICAgICAgICAgICAgICAgIF8uYmluZCh0aGlzLl9zdWNjZXNzU2VudFJlZ2lzdHJhdGlvbldQOCwgdGhpcyksXHJcbiAgICAgICAgICAgICAgICAgICAgXy5iaW5kKHRoaXMuX2Vycm9yU2VudFJlZ2lzdHJhdGlvbldQOCwgdGhpcyksXHJcbiAgICAgICAgICAgICAgICAgICAgd3A4UmVnaXN0cmF0aW9uT3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignVGhlIGN1cnJlbnQgcGxhdGZvcm0gaXMgbm90IHN1cHBvcnRlZDogJyArIGRldmljZS5wbGF0Zm9ybSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZGV2aWNlUmVnaXN0cmF0aW9uU3VjY2Vzc1dQOiBmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RldmljZVJlZ2lzdHJhdGlvblN1Y2Nlc3MocmVzdWx0LnVyaSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3ZhbGlkYXRlQW5kcm9pZFNldHRpbmdzOiBmdW5jdGlvbiAoYW5kcm9pZFNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIGlmICghYW5kcm9pZFNldHRpbmdzLnNlbmRlcklEKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignU2VuZGVyIElEIChwcm9qZWN0IG51bWJlcikgaXMgbm90IHNldCBpbiB0aGUgYW5kcm9pZCBzZXR0aW5ncy4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX3ZhbGlkYXRlV1A4U2V0dGluZ3M6IGZ1bmN0aW9uIChzZXR0aW5ncykge1xyXG4gICAgICAgICAgICBpZiAoIXNldHRpbmdzLmNoYW5uZWxOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignY2hhbm5lbE5hbWUgaXMgbm90IHNldCBpbiB0aGUgV1A4IHNldHRpbmdzLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3ZhbGlkYXRlSU9TU2V0dGluZ3M6IGZ1bmN0aW9uIChpT1NTZXR0aW5ncykge1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfY2xlYW5QbGF0Zm9ybXNQdXNoU2V0dGluZ3M6IGZ1bmN0aW9uIChwdXNoU2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgdmFyIGNsZWFuU2V0dGluZ3MgPSB7fTtcclxuICAgICAgICAgICAgcHVzaFNldHRpbmdzID0gcHVzaFNldHRpbmdzIHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgdmFyIGFkZFNldHRpbmdzRm9yUGxhdGZvcm0gPSBmdW5jdGlvbiBhZGRTZXR0aW5nc0ZvclBsYXRmb3JtKG5ld1NldHRpbmdzT2JqZWN0LCBwbGF0Zm9ybSwgYWxsb3dlZEZpZWxkcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFwdXNoU2V0dGluZ3NbcGxhdGZvcm1dKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIG5ld1NldHRpbmdzT2JqZWN0W3BsYXRmb3JtXSA9IG5ld1NldHRpbmdzT2JqZWN0W3BsYXRmb3JtXSB8fCB7fTtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdQbGF0Zm9ybVNldHRpbmdzID0gcHVzaFNldHRpbmdzW3BsYXRmb3JtXTtcclxuICAgICAgICAgICAgICAgIHZhciBzZXR0aW5ncyA9IG5ld1NldHRpbmdzT2JqZWN0W3BsYXRmb3JtXTtcclxuICAgICAgICAgICAgICAgIF8uZWFjaChhbGxvd2VkRmllbGRzLCBmdW5jdGlvbiAoYWxsb3dlZEZpZWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1BsYXRmb3JtU2V0dGluZ3MuaGFzT3duUHJvcGVydHkoYWxsb3dlZEZpZWxkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc1thbGxvd2VkRmllbGRdID0gbmV3UGxhdGZvcm1TZXR0aW5nc1thbGxvd2VkRmllbGRdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgYWRkU2V0dGluZ3NGb3JQbGF0Zm9ybShjbGVhblNldHRpbmdzLCAnaU9TJywgWydiYWRnZScsICdzb3VuZCcsICdhbGVydCcsICdpbnRlcmFjdGl2ZVNldHRpbmdzJ10pO1xyXG4gICAgICAgICAgICBhZGRTZXR0aW5nc0ZvclBsYXRmb3JtKGNsZWFuU2V0dGluZ3MsICdhbmRyb2lkJywgWydzZW5kZXJJRCcsICdwcm9qZWN0TnVtYmVyJ10pO1xyXG4gICAgICAgICAgICBhZGRTZXR0aW5nc0ZvclBsYXRmb3JtKGNsZWFuU2V0dGluZ3MsICd3cDgnLCBbJ2NoYW5uZWxOYW1lJ10pO1xyXG5cclxuICAgICAgICAgICAgdmFyIGNhbGxiYWNrRmllbGRzID0gWydub3RpZmljYXRpb25DYWxsYmFja0FuZHJvaWQnLCAnbm90aWZpY2F0aW9uQ2FsbGJhY2tJT1MnLCAnbm90aWZpY2F0aW9uQ2FsbGJhY2tXUDgnXTtcclxuICAgICAgICAgICAgXy5lYWNoKGNhbGxiYWNrRmllbGRzLCBmdW5jdGlvbiAoY2FsbGJhY2tGaWVsZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gcHVzaFNldHRpbmdzW2NhbGxiYWNrRmllbGRdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignVGhlIFwiJyArIGNhbGxiYWNrRmllbGQgKyAnXCIgb2YgdGhlIHB1c2ggc2V0dGluZ3Mgc2hvdWxkIGJlIGEgZnVuY3Rpb24nKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFuU2V0dGluZ3NbY2FsbGJhY2tGaWVsZF0gPSBwdXNoU2V0dGluZ3NbY2FsbGJhY2tGaWVsZF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKHB1c2hTZXR0aW5ncy5jdXN0b21QYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhblNldHRpbmdzLmN1c3RvbVBhcmFtZXRlcnMgPSBwdXNoU2V0dGluZ3MuY3VzdG9tUGFyYW1ldGVycztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNsZWFuU2V0dGluZ3M7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3BvcHVsYXRlUmVnaXN0cmF0aW9uT2JqZWN0OiBmdW5jdGlvbiAoZGV2aWNlUmVnaXN0cmF0aW9uLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxmLnB1c2hUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignUHVzaCB0b2tlbiBpcyBub3QgYXZhaWxhYmxlLicpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZ2V0TG9jYWxlTmFtZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGxvY2FsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRldmljZUlkID0gc2VsZi5fZ2V0RGV2aWNlSWQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYXJkd2FyZU1vZGVsID0gZGV2aWNlLm1vZGVsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBsYXRmb3JtVHlwZSA9IHNlbGYuX2dldFBsYXRmb3JtVHlwZShkZXZpY2UucGxhdGZvcm0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVab25lID0ganN0ei5kZXRlcm1pbmUoKS5uYW1lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHVzaFRva2VuID0gc2VsZi5wdXNoVG9rZW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFuZ3VhZ2UgPSBsb2NhbGUudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGxhdGZvcm1WZXJzaW9uID0gZGV2aWNlLnZlcnNpb247XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlUmVnaXN0cmF0aW9uLkhhcmR3YXJlSWQgPSBkZXZpY2VJZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldmljZVJlZ2lzdHJhdGlvbi5IYXJkd2FyZU1vZGVsID0gaGFyZHdhcmVNb2RlbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldmljZVJlZ2lzdHJhdGlvbi5QbGF0Zm9ybVR5cGUgPSBwbGF0Zm9ybVR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2VSZWdpc3RyYXRpb24uUGxhdGZvcm1WZXJzaW9uID0gcGxhdGZvcm1WZXJzaW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlUmVnaXN0cmF0aW9uLlRpbWVab25lID0gdGltZVpvbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2VSZWdpc3RyYXRpb24uUHVzaFRva2VuID0gcHVzaFRva2VuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlUmVnaXN0cmF0aW9uLkxvY2FsZSA9IGxhbmd1YWdlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3MsXHJcbiAgICAgICAgICAgICAgICBlcnJvclxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9nZXRMb2NhbGVOYW1lOiBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZW11bGF0b3JNb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzKHt2YWx1ZTogJ2VuX1VTJ30pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmF2aWdhdG9yLmdsb2JhbGl6YXRpb24uZ2V0TG9jYWxlTmFtZShcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAobG9jYWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MobG9jYWxlKTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgbmF2aWdhdG9yLmdsb2JhbGl6YXRpb24uZ2V0TG9jYWxlTmFtZShcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAobG9jYWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBlcnJvclxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9nZXREZXZpY2VJZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGV2aWNlLnV1aWQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy9SZXR1cm5zIHRoZSBFdmVybGl2ZSBkZXZpY2UgcGxhdGZvcm0gY29uc3RhbnQgZ2l2ZW4gYSB2YWx1ZSBhcXVpcmVkIGZyb20gY29yZG92YSdzIGRldmljZS5wbGF0Zm9ybS5cclxuICAgICAgICBfZ2V0UGxhdGZvcm1UeXBlOiBmdW5jdGlvbiAocGxhdGZvcm1TdHJpbmcpIHtcclxuICAgICAgICAgICAgdmFyIHBzTG93ZXIgPSBwbGF0Zm9ybVN0cmluZy50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHBzTG93ZXIpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2lvcyc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdpcGhvbmUnOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAnaXBhZCc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsYXRmb3JtLmlPUztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2FuZHJvaWQnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbGF0Zm9ybS5BbmRyb2lkO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnd2luY2UnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbGF0Zm9ybS5XaW5kb3dzUGhvbmU7XHJcbiAgICAgICAgICAgICAgICBjYXNlICd3aW4zMm50JzogLy8gcmVhbCB3cDggZGV2aWNlcyByZXR1cm4gdGhpcyBzdHJpbmcgYXMgcGxhdGZvcm0gaWRlbnRpZmllci5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGxhdGZvcm0uV2luZG93c1Bob25lO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGxhdGZvcm0uVW5rbm93bjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9kZXZpY2VSZWdpc3RyYXRpb25GYWlsZWQ6IGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLnB1c2hUb2tlbiA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuaXNJbml0aWFsaXppbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5faW5pdEVycm9yQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRFcnJvckNhbGxiYWNrKHtlcnJvcjogZXJyb3J9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9kZXZpY2VSZWdpc3RyYXRpb25TdWNjZXNzOiBmdW5jdGlvbiAodG9rZW4pIHtcclxuICAgICAgICAgICAgdGhpcy5wdXNoVG9rZW4gPSB0b2tlbjtcclxuICAgICAgICAgICAgdGhpcy5pc0luaXRpYWxpemluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2luaXRTdWNjZXNzQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRTdWNjZXNzQ2FsbGJhY2soe3Rva2VuOiB0b2tlbn0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy9PY2N1cnMgd2hlbiB0aGUgZGV2aWNlIHJlZ2lzdHJhdGlvbiBpbiBBUE4gc3VjY2VlZHNcclxuICAgICAgICBfc3VjY2Vzc2Z1bFJlZ2lzdHJhdGlvbkFQTjogZnVuY3Rpb24gKHRva2VuKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKHRoaXMucHVzaFNldHRpbmdzLmlPUyAmJiB0aGlzLnB1c2hTZXR0aW5ncy5pT1MuaW50ZXJhY3RpdmVTZXR0aW5ncykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZUludGVyYWN0aXZlUHVzaChcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hTZXR0aW5ncy5pT1MsXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9kZXZpY2VSZWdpc3RyYXRpb25TdWNjZXNzKHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1RoZSBpbnRlcmFjdGl2ZSBwdXNoIGNvbmZpZ3VyYXRpb24gaXMgaW5jb3JyZWN0OiAnICsgZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGV2aWNlUmVnaXN0cmF0aW9uU3VjY2Vzcyh0b2tlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvL09jY3VycyBpZiB0aGUgZGV2aWNlIHJlZ2lzdHJhdGlvbiBpbiBBUE4gZmFpbHNcclxuICAgICAgICBfZmFpbGVkUmVnaXN0cmF0aW9uQVBOOiBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGV2aWNlUmVnaXN0cmF0aW9uRmFpbGVkKGVycm9yKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvL09jY3VycyB3aGVuIGRldmljZSByZWdpc3RyYXRpb24gaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IHNlbnQgdG8gR0NNXHJcbiAgICAgICAgX3N1Y2Nlc3NTZW50UmVnaXN0cmF0aW9uR0NNOiBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlN1Y2Nlc3NmdWxseSBzZW50IHJlcXVlc3QgZm9yIHJlZ2lzdGVyaW5nIHdpdGggR0NNLlwiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vT2NjdXJzIHdoZW4gZGV2aWNlIHJlZ2lzdHJhdGlvbiBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgc2VudCBmb3IgV1A4XHJcbiAgICAgICAgX3N1Y2Nlc3NTZW50UmVnaXN0cmF0aW9uV1A4OiBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlN1Y2Nlc3NmdWxseSBzZW50IHJlcXVlc3QgZm9yIHJlZ2lzdGVyaW5nIFdQOCAuXCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy9PY2N1cnMgd2hlbiBhbiBlcnJvciBvY2N1cmVkIHdoZW4gc2VuZGluZyByZWdpc3RyYXRpb24gcmVxdWVzdCBmb3IgV1A4XHJcbiAgICAgICAgX2Vycm9yU2VudFJlZ2lzdHJhdGlvbldQODogZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RldmljZVJlZ2lzdHJhdGlvbkZhaWxlZChlcnJvcik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy9PY2N1cnMgd2hlbiBhbiBlcnJvciBvY2N1cmVkIHdoZW4gc2VuZGluZyByZWdpc3RyYXRpb24gcmVxdWVzdCB0byBHQ01cclxuICAgICAgICBfZXJyb3JTZW50UmVnaXN0cmF0aW9uR0NNOiBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGV2aWNlUmVnaXN0cmF0aW9uRmFpbGVkKGVycm9yKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvL1RoaXMgZnVuY3Rpb24gcmVjZWl2ZXMgYWxsIG5vdGlmaWNhdGlvbiBldmVudHMgZnJvbSBBUE5cclxuICAgICAgICBfb25Ob3RpZmljYXRpb25BUE46IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JhaXNlTm90aWZpY2F0aW9uRXZlbnRJT1MoZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvL1RoaXMgZnVuY3Rpb24gcmVjZWl2ZXMgYWxsIG5vdGlmaWNhdGlvbiBldmVudHMgZm9yIFdQOFxyXG4gICAgICAgIF9vbk5vdGlmaWNhdGlvbldQODogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmFpc2VOb3RpZmljYXRpb25FdmVudFdQOChlKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvL1RoaXMgZnVuY3Rpb24gcmVjZWl2ZXMgYWxsIG5vdGlmaWNhdGlvbiBldmVudHMgZnJvbSBHQ01cclxuICAgICAgICBfb25Ob3RpZmljYXRpb25HQ006IGZ1bmN0aW9uIG9uTm90aWZpY2F0aW9uR0NNKGUpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChlLmV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdyZWdpc3RlcmVkJzpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5yZWdpZC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RldmljZVJlZ2lzdHJhdGlvblN1Y2Nlc3MoZS5yZWdpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnbWVzc2FnZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmFpc2VOb3RpZmljYXRpb25FdmVudEFuZHJvaWQoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdlcnJvcic6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnB1c2hUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZXZpY2VSZWdpc3RyYXRpb25GYWlsZWQoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmFpc2VOb3RpZmljYXRpb25FdmVudEFuZHJvaWQoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yYWlzZU5vdGlmaWNhdGlvbkV2ZW50QW5kcm9pZChlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9yYWlzZU5vdGlmaWNhdGlvbkV2ZW50QW5kcm9pZDogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucHVzaFNldHRpbmdzLm5vdGlmaWNhdGlvbkNhbGxiYWNrQW5kcm9pZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoU2V0dGluZ3Mubm90aWZpY2F0aW9uQ2FsbGJhY2tBbmRyb2lkKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfcmFpc2VOb3RpZmljYXRpb25FdmVudElPUzogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucHVzaFNldHRpbmdzLm5vdGlmaWNhdGlvbkNhbGxiYWNrSU9TKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2hTZXR0aW5ncy5ub3RpZmljYXRpb25DYWxsYmFja0lPUyhlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX3JhaXNlTm90aWZpY2F0aW9uRXZlbnRXUDg6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnB1c2hTZXR0aW5ncy5ub3RpZmljYXRpb25DYWxsYmFja1dQOCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoU2V0dGluZ3Mubm90aWZpY2F0aW9uQ2FsbGJhY2tXUDgoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBDdXJyZW50RGV2aWNlO1xyXG59KCkpOyIsInZhciBTZXR1cCA9IHJlcXVpcmUoJy4vU2V0dXAnKTtcclxudmFyIERhdGEgPSByZXF1aXJlKCcuL3R5cGVzL0RhdGEnKTtcclxudmFyIHVzZXJzTW9kdWxlID0gcmVxdWlyZSgnLi90eXBlcy9Vc2VycycpO1xyXG52YXIgZmlsZXNNb2R1bGUgPSByZXF1aXJlKCcuL3R5cGVzL0ZpbGVzJyk7XHJcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xyXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XHJcbnZhciBidWlsZEF1dGhIZWFkZXIgPSB1dGlscy5idWlsZEF1dGhIZWFkZXI7XHJcbnZhciBQdXNoID0gcmVxdWlyZSgnLi9QdXNoJyk7XHJcbnZhciBBdXRoZW50aWNhdGlvbiA9IHJlcXVpcmUoJy4vYXV0aC9BdXRoZW50aWNhdGlvbicpO1xyXG52YXIgb2ZmbGluZU1vZHVsZSA9IHJlcXVpcmUoJy4vb2ZmbGluZS9vZmZsaW5lJyk7XHJcbnZhciBSZXF1ZXN0ID0gcmVxdWlyZSgnLi9SZXF1ZXN0Jyk7XHJcbnZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xyXG52YXIgcnN2cCA9IGNvbW1vbi5yc3ZwO1xyXG52YXIgXyA9IGNvbW1vbi5fO1xyXG52YXIgRXZlcmxpdmVFcnJvciA9IHJlcXVpcmUoJy4vRXZlcmxpdmVFcnJvcicpLkV2ZXJsaXZlRXJyb3I7XHJcbnZhciBFdmVybGl2ZUVycm9ycyA9IHJlcXVpcmUoJy4vRXZlcmxpdmVFcnJvcicpLkV2ZXJsaXZlRXJyb3JzO1xyXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIC8vIFRoZSBjb25zdHJ1Y3RvciBvZiBFdmVybGl2ZSBpbnN0YW5jZXMuXHJcbiAgICAvLyBUaGUgZW50cnkgcG9pbnQgZm9yIHRoZSBTREsuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAY2xhc3MgRXZlcmxpdmVcclxuICAgICAqIEBjbGFzc2Rlc2MgVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSB7e3NpdGUuYnN9fSAoRXZlcmxpdmUpIEphdmFTY3JpcHQgU0RLLiBUaGlzIGlzIHRoZSBlbnRyeSBwb2ludCBmb3IgdGhlIFNESy5cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fHN0cmluZ30gb3B0aW9ucyAtIEFuIG9iamVjdCBjb250YWluaW5nIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIFNldHVwIG9iamVjdC4gQWx0ZXJuYXRpdmVseSwgeW91IGNhbiBwYXNzIGEgc3RyaW5nIHJlcHJlc2VudGluZyB5b3VyIEFQSSBrZXkuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5hcGlLZXkgLSBZb3VyIEFQSSBrZXkuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudXJsPS8vYXBpLmV2ZXJsaXZlLmNvbS92MS9dIC0gVGhlIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gVVJMLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRva2VuXSAtIEFuIGF1dGhlbnRpY2F0aW9uIHRva2VuLiBUaGUgaW5zdGFuY2Ugd2lsbCBiZSBhc3NvY2lhdGVkIHdpdGggdGhlIHByb3ZpZGVkIHByZXZpb3VzbHkgb2J0YWluZWQgdG9rZW4uXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudG9rZW5UeXBlPWJlYXJlcl0gLSBUaGUgdHlwZSBvZiB0aGUgdG9rZW4gdGhhdCBpcyB1c2VkIGZvciBhdXRoZW50aWNhdGlvbi5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zY2hlbWU9aHR0cF0gLSBUaGUgVVJJIHNjaGVtZSB1c2VkIHRvIG1ha2UgcmVxdWVzdHMuIFN1cHBvcnRlZCB2YWx1ZXM6IGh0dHAsIGh0dHBzXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnBhcnNlT25seUNvbXBsZXRlRGF0ZVRpbWVPYmplY3RzPWZhbHNlXSAtIElmIHNldCB0byB0cnVlLCB0aGUgU0RLIHdpbGwgcGFyc2Ugb25seSBjb21wbGV0ZSBkYXRlIHN0cmluZ3MgKGFjY29yZGluZyB0byB0aGUgSVNPIDg2MDEgc3RhbmRhcmQpLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5lbXVsYXRvck1vZGU9ZmFsc2VdIC0gU2V0IHRoaXMgb3B0aW9uIHRvIHRydWUgdG8gc2V0IHRoZSBTREsgaW4gZW11bGF0b3IgbW9kZS5cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fGJvb2xlYW59IFtvcHRpb25zLm9mZmxpbmVTdG9yYWdlXSAtIFNldCB0aGlzIG9wdGlvbiB0byB0cnVlIHRvIHVzZSB0aGUgZGVmYXVsdCBvZmZsaW5lIHNldHRpbmdzLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5vZmZsaW5lU3RvcmFnZS5hdXRvU3luYz10cnVlXSAtIFdoZXRoZXIgdG8gc3luYyBkYXRhIGF1dG9tYXRpY2FsbHkgd2hlbiBvZmZpbmcgb25saW5lLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5vZmZsaW5lU3RvcmFnZS5pc09ubGluZT10cnVlXSAtIFdoZXRoZXIgdGhlIHN0b3JhZ2UgaXMgaW4gb25saW5lIG1vZGUgaW5pdGlhbGx5LlxyXG4gICAgICogQHBhcmFtIHtDb25mbGljdFJlc29sdXRpb25TdHJhdGVneXxmdW5jdGlvbn0gW29wdGlvbnMub2ZmbGluZVN0b3JhZ2UuY29uZmxpY3RSZXNvbHV0aW9uU3RyYXRlZ3k9Q29uZmxpY3RSZXNvbHV0aW9uU3RyYXRlZ3kuQ2xpZW50V2luc10gLSBBIGNvbnN0YW50IHNwZWNpZnlpbmcgdGhlIGNvbmZsaWN0IHJlc29sdXRpb24gc3RyYXRlZ3kgb3IgYSBmdW5jdGlvbiB1c2VkIHRvIHJlc29sdmUgdGhlIGNvbmZsaWN0cy5cclxuICAgICAqIEBwYXJhbSB7U3RvcmFnZVByb3ZpZGVyfG9iamVjdH0gW29wdGlvbnMub2ZmbGluZVN0b3JhZ2Uuc3RvcmFnZVByb3ZpZGVyU2V0dGluZ3M9U3RvcmFnZVByb3ZpZGVyLkxvY2FsU3RvcmFnZV0gLSBBbiBvYmplY3Qgc3BlY2lmeWluZyBzZXR0aW5ncyBmb3IgdGhlIG9mZmxpbmUgc3RvcmFnZSBwcm92aWRlci5cclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLm9mZmxpbmVTdG9yYWdlLnN5bmNTdGFydD1udWxsXSAtIEEgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbmV2ZXIgYSBzeW5jaHJvbmlzYXRpb24gc3RhcnRzLlxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMub2ZmbGluZVN0b3JhZ2Uuc3luY0VuZD1udWxsXSAtIEEgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgc3luY2hyb25pemF0aW9uIGNvbXBsZXRlcy4gVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIGEgbGlzdCBvZiBzeW5jIGVycm9ycy5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gRXZlcmxpdmUob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICB0aGlzLnNldHVwID0gbmV3IFNldHVwKG9wdGlvbnMpO1xyXG4gICAgICAgIF8uZWFjaChpbml0aWFsaXphdGlvbnMsIGZ1bmN0aW9uIChpbml0KSB7XHJcbiAgICAgICAgICAgIGluaXQuZnVuYy5jYWxsKHNlbGYsIG9wdGlvbnMpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAoRXZlcmxpdmUuJCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBFdmVybGl2ZS4kID0gc2VsZjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2VtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgRXZlcmxpdmUucHJvdG90eXBlLl9lbWl0dGVyUHJveHkgPSBmdW5jdGlvbiAoZXZlbnQsIGFyZ3MpIHtcclxuICAgICAgICB0aGlzLl9lbWl0dGVyW2V2ZW50XS5hcHBseSh0aGlzLl9lbWl0dGVyLCBhcmdzKTtcclxuICAgIH07XHJcblxyXG4gICAgRXZlcmxpdmUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX2VtaXR0ZXJQcm94eSgnYWRkTGlzdGVuZXInLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIEV2ZXJsaXZlLnByb3RvdHlwZS5vbiA9IEV2ZXJsaXZlLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcclxuXHJcbiAgICBFdmVybGl2ZS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fZW1pdHRlclByb3h5KCdyZW1vdmVMaXN0ZW5lcicsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgRXZlcmxpdmUucHJvdG90eXBlLm9mZiA9IEV2ZXJsaXZlLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcclxuXHJcbiAgICBFdmVybGl2ZS5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9lbWl0dGVyUHJveHkoJ29uY2UnLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuXHJcbiAgICBFdmVybGl2ZS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX2VtaXR0ZXJQcm94eSgncmVtb3ZlQWxsTGlzdGVuZXJzJywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqIFJlZmVyZW5jZSB0byB0aGUgY3VycmVudCB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IChFdmVybGl2ZSkgSmF2YVNjcmlwdCBTREtcclxuICAgICAqIEBtZW1iZXJPZiBFdmVybGl2ZVxyXG4gICAgICogQHR5cGUge0V2ZXJsaXZlfVxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICovXHJcbiAgICBFdmVybGl2ZS4kID0gbnVsbDtcclxuICAgIEV2ZXJsaXZlLmlkRmllbGQgPSBjb25zdGFudHMuaWRGaWVsZDtcclxuXHJcblxyXG4gICAgLy8gQW4gYXJyYXkga2VlcGluZyBpbml0aWFsaXphdGlvbiBmdW5jdGlvbnMgY2FsbGVkIGJ5IHRoZSBFdmVybGl2ZSBjb25zdHJ1Y3Rvci5cclxuICAgIC8vIFRoZXNlIGZ1bmN0aW9ucyB3aWxsIGJlIHVzZWQgdG8gZXh0ZW5kIHRoZSBmdW5jdGlvbmFsaXR5IG9mIGFuIEV2ZXJsaXZlIGluc3RhbmNlLlxyXG4gICAgdmFyIGluaXRpYWxpemF0aW9ucyA9IFtdO1xyXG5cclxuICAgIC8qKiBBbiBhcnJheSBvZiBmdW5jdGlvbnMgdGhhdCBhcmUgaW52b2tlZCBkdXJpbmcgaW5zdGFudGlhdGlvbiBvZiB0aGUge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSAoRXZlcmxpdmUpIEphdmFTY3JpcHQgU0RLLlxyXG4gICAgICogQG1lbWJlck9mIEV2ZXJsaXZlXHJcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb25bXX1cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIEV2ZXJsaXZlLmluaXRpYWxpemF0aW9ucyA9IGluaXRpYWxpemF0aW9ucztcclxuXHJcbiAgICAvKiogQ3JlYXRlcyBhIG5ldyB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IChFdmVybGl2ZSkgSmF2YSBTY3JpcHQgU0RLIGluc3RhbmNlLlxyXG4gICAgICogQG1lbWJlck9mIEV2ZXJsaXZlXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIEFuIG9iamVjdCBjb250YWluaW5nIG9wdGlvbnMgdXNlZCB0byBpbml0aWFsaXplIHRoZSB7e3NpdGUuYnN9fSBKYXZhU2NyaXB0IFNESyBpbnN0YW5jZS5cclxuICAgICAqIEByZXR1cm5zIHtFdmVybGl2ZX0gVGhlIGluc3RhbmNlIG9mIHRoZSB7e3NpdGUuYnN9fSAoRXZlcmxpdmUpIEphdmFTY3JpcHQgU0RLIHRoYXQgd2FzIGNyZWF0ZWQgdXNpbmcgdGhlIHByb3ZpZGVkIG9wdGlvbnMuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIEV2ZXJsaXZlLmluaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIEV2ZXJsaXZlLiQgPSBudWxsO1xyXG4gICAgICAgIHJldHVybiBuZXcgRXZlcmxpdmUob3B0aW9ucyk7XHJcbiAgICB9O1xyXG5cclxuICAgIEV2ZXJsaXZlLnByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24gKGNvbGxlY3Rpb25OYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhKHRoaXMuc2V0dXAsIGNvbGxlY3Rpb25OYW1lLCB0aGlzLm9mZmxpbmVTdG9yYWdlLCB0aGlzKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBVUkwgdG8gdGhlIHt7c2l0ZS5ic319IGFwcGxpY2F0aW9uIGVuZHBvaW50IHRoYXQgdGhlIFNESyB1c2VzLlxyXG4gICAgICogQG1lbWJlck9mIEV2ZXJsaXZlLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBidWlsZFVybFxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGdlbmVyYXRlZCBVUkwuXHJcbiAgICAgKi9cclxuICAgIEV2ZXJsaXZlLnByb3RvdHlwZS5idWlsZFVybCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdXRpbHMuYnVpbGRVcmwodGhpcy5zZXR1cCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIHRoZSBBdXRob3JpemF0aW9uIGhlYWRlcnMgdGhhdCBhcmUgdXNlZCBieSB0aGUge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSAoRXZlcmxpdmUpIEphdmFTY3JpcHQgU0RLIHRvIG1ha2UgcmVxdWVzdHMgdG8gdGhlIHt7c2l0ZS5ic319IHNlcnZlcnMuXHJcbiAgICAgKiBAbWVtYmVyT2YgRXZlcmxpdmVcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IEF1dGhvcml6YXRpb25IZWFkZXJzIFRoZSBnZW5lcmF0ZWQgQXV0aG9yaXphdGlvbiBoZWFkZXJzIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgRXZlcmxpdmUucHJvdG90eXBlLmJ1aWxkQXV0aEhlYWRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gYnVpbGRBdXRoSGVhZGVyKHRoaXMuc2V0dXApO1xyXG4gICAgfTtcclxuXHJcbiAgICBFdmVybGl2ZS5kaXNhYmxlUmVxdWVzdENhY2hlID0gZnVuY3Rpb24gKHVybCwgbWV0aG9kKSB7XHJcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ0dFVCcpIHtcclxuICAgICAgICAgICAgdmFyIHRpbWVzdGFtcCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgIHZhciBzZXBhcmF0b3IgPSB1cmwuaW5kZXhPZignPycpID4gLTEgPyAnJicgOiAnPyc7XHJcbiAgICAgICAgICAgIHVybCArPSBzZXBhcmF0b3IgKyAnX2VsPScgKyB0aW1lc3RhbXA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgfTtcclxuXHJcbiAgICBFdmVybGl2ZS5BdXRoU3RhdHVzID0gY29uc3RhbnRzLkF1dGhTdGF0dXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IGF1dGhlbnRpY2F0aW9uIHN0YXR1cyBvZiB0aGUge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSBKYXZhU2NyaXB0IFNESyBpbnN0YW5jZS5cclxuICAgICAqIEBtZW1iZXJPZiBFdmVybGl2ZS5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgYXV0aEluZm9cclxuICAgICAqIEBuYW1lIGF1dGhJbmZvXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBwcm9taXNlIHRvIHRoZSBhdXRoZW50aWNhdGlvbiBzdGF0dXMuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBhdXRoZW50aWNhdGlvbiBzdGF0dXMgb2YgdGhlIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gSmF2YVNjcmlwdCBTREsgaW5zdGFuY2UuXHJcbiAgICAgKiBAbWVtYmVyT2YgRXZlcmxpdmUucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGF1dGhJbmZvXHJcbiAgICAgKiBAbmFtZSBhdXRoSW5mb1xyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIEV2ZXJsaXZlLnByb3RvdHlwZS5hdXRoSW5mbyA9IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICByZXR1cm4gdXRpbHMuYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgc2V0dXAgPSBzZWxmLnNldHVwO1xyXG4gICAgICAgICAgICBpZiAoc2V0dXAubWFzdGVyS2V5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VjY2Vzcyh7c3RhdHVzOiBFdmVybGl2ZS5BdXRoU3RhdHVzLm1hc3RlcktleX0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIXNldHVwLnRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VjY2Vzcyh7c3RhdHVzOiBFdmVybGl2ZS5BdXRoU3RhdHVzLnVuYXV0aGVudGljYXRlZH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc2VsZi5hdXRoZW50aWNhdGlvbiAmJiBzZWxmLmF1dGhlbnRpY2F0aW9uLmlzQXV0aGVudGljYXRpb25JblByb2dyZXNzKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdWNjZXNzKHtzdGF0dXM6IEV2ZXJsaXZlLkF1dGhTdGF0dXMuYXV0aGVudGljYXRpbmd9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc2VsZi5Vc2Vyc1xyXG4gICAgICAgICAgICAgICAgLnNraXBBdXRoKHRydWUpXHJcbiAgICAgICAgICAgICAgICAuY3VycmVudFVzZXIoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWNjZXNzKHtzdGF0dXM6IEV2ZXJsaXZlLkF1dGhTdGF0dXMuYXV0aGVudGljYXRlZCwgdXNlcjogcmVzLnJlc3VsdH0pO1xyXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmF1dGhlbnRpY2F0aW9uICYmIHNlbGYuYXV0aGVudGljYXRpb24uaXNBdXRoZW50aWNhdGlvbkluUHJvZ3Jlc3MoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VjY2Vzcyh7c3RhdHVzOiBFdmVybGl2ZS5BdXRoU3RhdHVzLmF1dGhlbnRpY2F0aW5nfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlcnIuY29kZSA9PT0gRXZlcmxpdmVFcnJvcnMuaW52YWxpZFJlcXVlc3QuY29kZSB8fCBlcnIuY29kZSA9PT0gRXZlcmxpdmVFcnJvcnMuZXhwaXJlZFRva2VuLmNvZGUpIHsgLy8gaW52YWxpZCByZXF1ZXN0LCBpLmUuIHRoZSBhY2Nlc3MgdG9rZW4gaXMgaW52YWxpZCBvciBtaXNzaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWNjZXNzKHtzdGF0dXM6IEV2ZXJsaXZlLkF1dGhTdGF0dXMuaW52YWxpZEF1dGhlbnRpY2F0aW9ufSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1ha2UgYSByZXF1ZXN0IHRvIHRoZSBjdXJyZW50IHt7c2l0ZS5ic319IEphdmFTY3JpcHQgU0RLIGluc3RhbmNlLlxyXG4gICAgICogQG1ldGhvZCByZXF1ZXN0XHJcbiAgICAgKiBAbWVtYmVyT2YgRXZlcmxpdmUucHJvdG90eXBlXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBPYmplY3QgdXNlZCB0byBjb25maWd1cmUgdGhlIHJlcXVlc3QuXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuZW5kcG9pbnRdIFRoZSBlbmRwb2ludCBvZiB0aGUge3tzaXRlLmJzfX0gSmF2YVNjcmlwdCBBUEkgcmVsYXRpdmUgdG8gdGhlIEFQSSBrZXkgc2VjdGlvbi4gKEZvciBleGFtcGxlLCBvcHRpb25zLmVuZHBvaW50ID0gTXlUeXBlIHdpbGwgbWFrZSBhIHJlcXVlc3QgdG8gdGhlIE15VHlwZSB0eXBlLilcclxuICAgICAqIEBwYXJhbSB7SHR0cE1ldGhvZH0gW29wdGlvbnMubWV0aG9kXSBIVFRQIHJlcXVlc3QgbWV0aG9kLlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmRhdGFdIERhdGEgdG8gYmUgc2VudCB3aXRoIHRoZSByZXF1ZXN0LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuc3VjY2Vzc10gU3VjY2VzcyBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIHJlcXVlc3QgZmluaXNoZXMgc3VjY2Vzc2Z1bGx5LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZXJyb3JdIEVycm9yIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBpbiBjYXNlIG9mIGFuIGVycm9yLlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmhlYWRlcnNdIEFkZGl0aW9uYWwgaGVhZGVycyB0byBiZSBpbmNsdWRlZCBpbiB0aGUgcmVxdWVzdC5cclxuICAgICAqIEBwYXJhbSB7UXVlcnl8b2JqZWN0fSBbb3B0aW9ucy5maWx0ZXJdIFRoaXMgaXMgZWl0aGVyIGEge0BsaW5rIFF1ZXJ5fSBvciBhIFtmaWx0ZXJdKHslIHNsdWcgcmVzdC1hcGktcXVlcnlpbmctZmlsdGVyaW5nICV9KSBleHByZXNzaW9uLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hdXRoSGVhZGVycz10cnVlXSBXaGVuIHNldCB0byBmYWxzZSwgbm8gQXV0aG9yaXphdGlvbiBoZWFkZXJzIHdpbGwgYmUgc2VudCB3aXRoIHRoZSByZXF1ZXN0LlxyXG4gICAgICogQHJldHVybnMge2Z1bmN0aW9ufSBUaGUgcmVxdWVzdCBjb25maWd1cmF0aW9uIG9iamVjdCBjb250YWluaW5nIHRoZSBgc2VuZGAgZnVuY3Rpb24gdGhhdCBzZW5kcyB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgRXZlcmxpdmUucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzLnNldHVwLCBvcHRpb25zKTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gcHJvdGVjdE9mZmxpbmVFbmFibGVkKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5faXNPZmZsaW5lU3RvcmFnZUVuYWJsZWQoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignWW91IGhhdmUgaW5zdGFudGlhdGVkIHRoZSBTREsgd2l0aG91dCBzdXBwb3J0IGZvciBvZmZsaW5lIHN0b3JhZ2UnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgRXZlcmxpdmUucHJvdG90eXBlLl9pc09mZmxpbmVTdG9yYWdlRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLnNldHVwLm9mZmxpbmVTdG9yYWdlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIFNESyB0byB3b3JrIGluIG9mZmxpbmUgbW9kZVxyXG4gICAgICogQG1lbWJlck9mIEV2ZXJsaXZlLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb2ZmbGluZV0gQm9vbGVhbiBwYXJhbWV0ZXIgZm9yIHNldHRpbmcgdGhlIFNESyB0byBvbmxpbmUgb3Igb2ZmbGluZSBtb2RlXHJcbiAgICAgKi9cclxuICAgIEV2ZXJsaXZlLnByb3RvdHlwZS5vZmZsaW5lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHByb3RlY3RPZmZsaW5lRW5hYmxlZC5jYWxsKHRoaXMpO1xyXG5cclxuICAgICAgICB2YXIgaXNPZmZsaW5lO1xyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGlzT2ZmbGluZSA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaXNPZmZsaW5lID0gYXJndW1lbnRzWzBdID09IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMub2ZmbGluZVN0b3JhZ2UuX3NldE9mZmxpbmUoaXNPZmZsaW5lKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBTREsgdG8gd29yayBpbiBvbmxpbmUgbW9kZVxyXG4gICAgICogQG1lbWJlck9mIEV2ZXJsaXZlLnByb3RvdHlwZVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb25saW5lXSBCb29sZWFuIHBhcmFtZXRlciBmb3Igc2V0dGluZyB0aGUgU0RLIHRvIG9ubGluZSBvciBvZmZsaW5lIG1vZGVcclxuICAgICAqL1xyXG4gICAgRXZlcmxpdmUucHJvdG90eXBlLm9ubGluZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBwcm90ZWN0T2ZmbGluZUVuYWJsZWQuY2FsbCh0aGlzKTtcclxuXHJcbiAgICAgICAgdmFyIGlzT25saW5lO1xyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGlzT25saW5lID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpc09ubGluZSA9IGFyZ3VtZW50c1swXSA9PSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm9mZmxpbmVTdG9yYWdlLl9zZXRPZmZsaW5lKCFpc09ubGluZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgaWYgdGhlIFNESyBpcyBpbiBvZmZsaW5lIG1vZGVcclxuICAgICAqIEBtZW1iZXJPZiBFdmVybGl2ZS5wcm90b3R5cGVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBpc09mZmxpbmUgUmV0dXJucyB0cnVlIGlmIHRoZSBTREsgaXMgaW4gb2ZmbGluZSBtb2RlXHJcbiAgICAgKi9cclxuICAgIEV2ZXJsaXZlLnByb3RvdHlwZS5pc09mZmxpbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcHJvdGVjdE9mZmxpbmVFbmFibGVkLmNhbGwodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzT25saW5lKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgaWYgdGhlIFNESyBpcyBpbiBvbmxpbmUgbW9kZVxyXG4gICAgICogQG1lbWJlck9mIEV2ZXJsaXZlLnByb3RvdHlwZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGlzT25saW5lIFJldHVybnMgdHJ1ZSBpZiB0aGUgU0RLIGlzIGluIG9ubGluZSBtb2RlXHJcbiAgICAgKi9cclxuICAgIEV2ZXJsaXZlLnByb3RvdHlwZS5pc09ubGluZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBwcm90ZWN0T2ZmbGluZUVuYWJsZWQuY2FsbCh0aGlzKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5vZmZsaW5lU3RvcmFnZS5pc09ubGluZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0cyB0aGUgc3luY2hyb25pemF0aW9uIHByb2NlZHVyZS4gRW1pdHMgdGhlICdzeW5jU3RhcnQnIGV2ZW50IG9uY2Ugc3RhcnRlZCBhbmQgdGhlICdzeW5jRW5kJyBldmVudCBvbmNlIHRoZSBwcm9jZWR1cmUgZmluaXNoZXNcclxuICAgICAqIEBtZW1iZXJPZiBFdmVybGl2ZS5wcm90b3R5cGVcclxuICAgICAqL1xyXG4gICAgRXZlcmxpdmUucHJvdG90eXBlLnN5bmMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcHJvdGVjdE9mZmxpbmVFbmFibGVkLmNhbGwodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub2ZmbGluZVN0b3JhZ2Uuc3luYy5hcHBseSh0aGlzLm9mZmxpbmVTdG9yYWdlLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgaW5pdERlZmF1bHQgPSBmdW5jdGlvbiBpbml0RGVmYXVsdCgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbWVtYmVyT2YgRXZlcmxpdmVcclxuICAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gQW4gaW5zdGFuY2Ugb2YgdGhlIFtVc2Vyc117QGxpbmsgVXNlcnN9IGNsYXNzIGZvciB3b3JraW5nIHdpdGggdXNlcnMuXHJcbiAgICAgICAgICogQG1lbWJlciB7VXNlcnN9IFVzZXJzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5Vc2VycyA9IHRoaXMuZGF0YSgnVXNlcnMnKTtcclxuICAgICAgICB1c2Vyc01vZHVsZS5hZGRVc2Vyc0Z1bmN0aW9ucyh0aGlzLlVzZXJzLCB0aGlzKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1lbWJlck9mIEV2ZXJsaXZlXHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIEFuIGluc3RhbmNlIG9mIHRoZSBbRmlsZXNde0BsaW5rIEZpbGVzfSBjbGFzcyBmb3Igd29ya2luZyB3aXRoIGZpbGVzLlxyXG4gICAgICAgICAqIEBtZW1iZXIge0ZpbGVzfSBGaWxlc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuRmlsZXMgPSB0aGlzLmRhdGEoJ0ZpbGVzJyk7XHJcbiAgICAgICAgZmlsZXNNb2R1bGUuYWRkRmlsZXNGdW5jdGlvbnModGhpcy5GaWxlcyk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBFdmVybGl2ZVxyXG4gICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBBbiBpbnN0YW5jZSBvZiB0aGUgW1B1c2hde0BsaW5rIFB1c2h9IGNsYXNzIGZvciB3b3JraW5nIHdpdGggcHVzaCBub3RpZmljYXRpb25zLlxyXG4gICAgICAgICAqIEBtZW1iZXIge1B1c2h9IHB1c2hcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnB1c2ggPSBuZXcgUHVzaCh0aGlzKTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGluaXRBdXRoZW50aWNhdGlvbiA9IGZ1bmN0aW9uIGluaXRBdXRoZW50aWNhdGlvbigpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbWVtYmVyT2YgRXZlcmxpdmVcclxuICAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gQW4gaW5zdGFuY2Ugb2YgdGhlIFtBdXRoZW50aWNhdGlvbl17QGxpbmsgQXV0aGVudGljYXRpb259IGNsYXNzIGZvciB3b3JraW5nIHdpdGggdGhlIGF1dGhlbnRpY2F0aW9uIG9mIHRoZSBTREsuXHJcbiAgICAgICAgICogQG1lbWJlciB7QXV0aGVudGljYXRpb259IGF1dGhlbnRpY2F0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5hdXRoZW50aWNhdGlvbiA9IG5ldyBBdXRoZW50aWNhdGlvbih0aGlzLCB0aGlzLnNldHVwLmF1dGhlbnRpY2F0aW9uKTtcclxuICAgIH07XHJcblxyXG4gICAgaW5pdGlhbGl6YXRpb25zLnB1c2goe25hbWU6ICdvZmZsaW5lU3RvcmFnZScsIGZ1bmM6IG9mZmxpbmVNb2R1bGUuaW5pdE9mZmxpbmVTdG9yYWdlfSk7XHJcbiAgICBpbml0aWFsaXphdGlvbnMucHVzaCh7bmFtZTogJ2RlZmF1bHQnLCBmdW5jOiBpbml0RGVmYXVsdH0pO1xyXG4gICAgaW5pdGlhbGl6YXRpb25zLnB1c2goe25hbWU6ICdhdXRoZW50aWNhdGlvbicsIGZ1bmM6IGluaXRBdXRoZW50aWNhdGlvbn0pO1xyXG5cclxuICAgIHJldHVybiBFdmVybGl2ZTtcclxufSgpKTtcclxuIiwidmFyIEV2ZXJsaXZlRXJyb3JzID0ge1xyXG4gICAgaXRlbU5vdEZvdW5kOiB7XHJcbiAgICAgICAgY29kZTogODAxLFxyXG4gICAgICAgIG1lc3NhZ2U6ICdJdGVtIG5vdCBmb3VuZC4nXHJcbiAgICB9LFxyXG4gICAgc3luY0NvbmZsaWN0OiB7XHJcbiAgICAgICAgY29kZTogNDI0MixcclxuICAgICAgICBtZXNzYWdlOiAnQSBjb25mbGljdCBvY2N1cnJlZCB3aGlsZSBzeW5jaW5nIGRhdGEuJ1xyXG4gICAgfSxcclxuICAgIHN5bmNFcnJvcjoge1xyXG4gICAgICAgIGNvZGU6IDQyNDMsXHJcbiAgICAgICAgbWVzc2FnZTogJ1N5bmNocm9uaXphdGlvbiBmYWlsZWQgZm9yIGl0ZW0uJ1xyXG4gICAgfSxcclxuICAgIHN5bmNJblByb2dyZXNzOiB7XHJcbiAgICAgICAgY29kZTogNDI0NCxcclxuICAgICAgICBtZXNzYWdlOiAnQ2Fubm90IHBlcmZvcm0gb3BlcmF0aW9uIHdoaWxlIHN5bmNocm9uaXphdGlvbiBpcyBpbiBwcm9ncmVzcydcclxuICAgIH0sXHJcbiAgICBnZW5lcmFsRGF0YWJhc2VFcnJvcjoge1xyXG4gICAgICAgIGNvZGU6IDEwNyxcclxuICAgICAgICBtZXNzYWdlOiAnR2VuZXJhbCBkYXRhYmFzZSBlcnJvcidcclxuICAgIH0sXHJcbiAgICBpbnZhbGlkVG9rZW46IHtcclxuICAgICAgICBjb2RlOiAzMDEsXHJcbiAgICAgICAgbWVzc2FnZTogJ0ludmFsaWQgYWNjZXNzIHRva2VuJ1xyXG4gICAgfSxcclxuICAgIGV4cGlyZWRUb2tlbjoge1xyXG4gICAgICAgIGNvZGU6IDMwMixcclxuICAgICAgICBtZXNzYWdlOiAnRXhwaXJlZCBhY2Nlc3MgdG9rZW4nXHJcbiAgICB9LFxyXG4gICAgaW52YWxpZEV4cGFuZEV4cHJlc3Npb246IHtcclxuICAgICAgICBjb2RlOiA2MTgsXHJcbiAgICAgICAgbWVzc2FnZTogJ0ludmFsaWQgZXhwYW5kIGV4cHJlc3Npb24uJ1xyXG4gICAgfSxcclxuICAgIGludmFsaWRSZXF1ZXN0OiB7XHJcbiAgICAgICAgY29kZTogNjAxLFxyXG4gICAgICAgIG1lc3NhZ2U6ICdJbnZhbGlkIHJlcXVlc3QuJ1xyXG4gICAgfVxyXG59O1xyXG5cclxudmFyIEV2ZXJsaXZlRXJyb3IgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXZlcmxpdmVFcnJvcihtZXNzYWdlLCBjb2RlKSB7XHJcbiAgICAgICAgdmFyIHRtcCA9IEVycm9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICAgIHRtcC5uYW1lID0gdGhpcy5uYW1lID0gJ0V2ZXJsaXZlRXJyb3InO1xyXG5cclxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0bXAubWVzc2FnZTtcclxuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xyXG5cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3N0YWNrJywge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0bXAuc3RhY2tcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBFdmVybGl2ZUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcclxuICAgIEV2ZXJsaXZlRXJyb3IucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcclxuICAgICAgICAgICAgY29kZTogdGhpcy5jb2RlLFxyXG4gICAgICAgICAgICBzdGFjazogdGhpcy5zdGFja1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBFdmVybGl2ZUVycm9yO1xyXG59KCkpO1xyXG5cclxudmFyIERldmljZVJlZ2lzdHJhdGlvbkVycm9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBEZXZpY2VSZWdpc3RyYXRpb25FcnJvciA9IGZ1bmN0aW9uIChlcnJvclR5cGUsIG1lc3NhZ2UsIGFkZGl0aW9uYWxJbmZvcm1hdGlvbikge1xyXG4gICAgICAgIEV2ZXJsaXZlRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcclxuICAgICAgICB0aGlzLmVycm9yVHlwZSA9IGVycm9yVHlwZTtcclxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gICAgICAgIGlmIChhZGRpdGlvbmFsSW5mb3JtYXRpb24gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZGl0aW9uYWxJbmZvcm1hdGlvbiA9IGFkZGl0aW9uYWxJbmZvcm1hdGlvbjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIERldmljZVJlZ2lzdHJhdGlvbkVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlcmxpdmVFcnJvci5wcm90b3R5cGUpO1xyXG5cclxuICAgIERldmljZVJlZ2lzdHJhdGlvbkVycm9yLmZyb21FdmVybGl2ZUVycm9yID0gZnVuY3Rpb24gKGV2ZXJsaXZlRXJyb3IpIHtcclxuICAgICAgICB2YXIgZGV2aWNlUmVnaXN0cmF0aW9uRXJyb3IgPSBuZXcgRGV2aWNlUmVnaXN0cmF0aW9uRXJyb3IoRGV2aWNlUmVnaXN0cmF0aW9uRXJyb3JUeXBlcy5FdmVybGl2ZUVycm9yLCBldmVybGl2ZUVycm9yLm1lc3NhZ2UsIGV2ZXJsaXZlRXJyb3IpO1xyXG4gICAgICAgIHJldHVybiBkZXZpY2VSZWdpc3RyYXRpb25FcnJvcjtcclxuICAgIH07XHJcblxyXG4gICAgRGV2aWNlUmVnaXN0cmF0aW9uRXJyb3IuZnJvbVBsdWdpbkVycm9yID0gZnVuY3Rpb24gKGVycm9yT2JqKSB7XHJcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSAnQSBwbHVnaW4gZXJyb3Igb2NjdXJyZWQnO1xyXG4gICAgICAgIGlmIChlcnJvck9iaikge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGVycm9yT2JqLmVycm9yID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGVycm9yT2JqLmVycm9yO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlcnJvck9iai5tZXNzYWdlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGVycm9yT2JqLm1lc3NhZ2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBkZXZpY2VSZWdpc3RyYXRpb25FcnJvciA9IG5ldyBEZXZpY2VSZWdpc3RyYXRpb25FcnJvcihEZXZpY2VSZWdpc3RyYXRpb25FcnJvclR5cGVzLlBsdWdpbkVycm9yLCBtZXNzYWdlLCBlcnJvck9iaik7XHJcbiAgICAgICAgcmV0dXJuIGRldmljZVJlZ2lzdHJhdGlvbkVycm9yO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgRGV2aWNlUmVnaXN0cmF0aW9uRXJyb3JUeXBlcyA9IHtcclxuICAgICAgICBFdmVybGl2ZUVycm9yOiAxLFxyXG4gICAgICAgIFBsdWdpbkVycm9yOiAyXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBEZXZpY2VSZWdpc3RyYXRpb25FcnJvcjtcclxufSgpKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgRXZlcmxpdmVFcnJvcjogRXZlcmxpdmVFcnJvcixcclxuICAgIEV2ZXJsaXZlRXJyb3JzOiBFdmVybGl2ZUVycm9ycyxcclxuICAgIERldmljZVJlZ2lzdHJhdGlvbkVycm9yOiBEZXZpY2VSZWdpc3RyYXRpb25FcnJvclxyXG59OyIsInZhciBQcm9jZXNzb3IgPSByZXF1aXJlKCcuL2NvbW1vbicpLlByb2Nlc3NvcjtcclxudmFyIERhdGFRdWVyeSA9IHJlcXVpcmUoJy4vcXVlcnkvRGF0YVF1ZXJ5Jyk7XHJcbnZhciBRdWVyeSA9IHJlcXVpcmUoJy4vcXVlcnkvUXVlcnknKTtcclxudmFyIEV2ZXJsaXZlRXJyb3IgPSByZXF1aXJlKCcuL0V2ZXJsaXZlRXJyb3InKS5FdmVybGl2ZUVycm9yO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9jZXNzb3Ioe1xyXG4gICAgICAgIGV4ZWN1dGlvbk5vZGVGdW5jdGlvbjogZnVuY3Rpb24gKG5vZGUsIGV4cGFuZENvbnRleHQsIGRvbmUpIHtcclxuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLnJlYWQsXHJcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogbm9kZS50YXJnZXRUeXBlTmFtZSxcclxuICAgICAgICAgICAgICAgIGZpbHRlcjogbmV3IFF1ZXJ5KG5vZGUuZmlsdGVyLCBub2RlLnNlbGVjdCwgbm9kZS5zb3J0LCBub2RlLnNraXAsIG5vZGUudGFrZSlcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBleHBhbmRDb250ZXh0Lm9mZmxpbmVNb2R1bGUucHJvY2Vzc1F1ZXJ5KHF1ZXJ5KS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBkb25lKG51bGwsIGRhdGEucmVzdWx0KTtcclxuICAgICAgICAgICAgfSwgZG9uZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn0oKSk7XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEV4cHJlc3Npb24ob3BlcmF0b3IsIG9wZXJhbmRzKSB7XHJcbiAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xyXG4gICAgICAgIHRoaXMub3BlcmFuZHMgPSBvcGVyYW5kcyB8fCBbXTtcclxuICAgIH1cclxuXHJcbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZSA9IHtcclxuICAgICAgICBhZGRPcGVyYW5kOiBmdW5jdGlvbiAob3BlcmFuZCkge1xyXG4gICAgICAgICAgICB0aGlzLm9wZXJhbmRzLnB1c2gob3BlcmFuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gRXhwcmVzc2lvbjtcclxufSgpKTsiLCJtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvL1RPRE8gYWRkIGEgZnVuY3Rpb24gZm9yIGNhbGN1bGF0aW5nIHRoZSBkaXN0YW5jZXMgaW4gZ2Vvc3BhdGlhbCBxdWVyaWVzXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAY2xhc3NkZXNjIEEgY2xhc3MgcmVwcmVzZW50aW5nIGEgdmFsdWUgZm9yIHRoZSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IEdlb1BvaW50IGZpZWxkLlxyXG4gICAgICogQGNsYXNzIEdlb1BvaW50XHJcbiAgICAgKiBAcGFyYW0gbG9uZ2l0dWRlIExvbmdpdHVkZSBvZiB0aGUgR2VvUG9pbnQgaW4gZGVjaW1hbCBkZWdyZWVzIChyYW5nZTogLTE4MCB0byAxODApLiBFeGFtcGxlOiBgMTIzLjMyMzk0NjdgXHJcbiAgICAgKiBAcGFyYW0gbGF0aXR1ZGUgTGF0aXR1ZGUgb2YgdGhlIEdlb1BvaW50IGluIGRlY2ltYWwgZGVncmVlcyAocmFuZ2U6IC05MCB0byA5MCkuIEV4YW1wbGU6IGA0Mi42OTU0MzIyYFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBHZW9Qb2ludChsb25naXR1ZGUsIGxhdGl0dWRlKSB7XHJcbiAgICAgICAgdGhpcy5sb25naXR1ZGUgPSBsb25naXR1ZGUgfHwgMDtcclxuICAgICAgICB0aGlzLmxhdGl0dWRlID0gbGF0aXR1ZGUgfHwgMDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gR2VvUG9pbnQ7XHJcbn0oKSk7IiwidmFyIHBsYXRmb3JtID0gcmVxdWlyZSgnLi9ldmVybGl2ZS5wbGF0Zm9ybScpO1xyXG52YXIgaXNOYXRpdmVTY3JpcHQgPSBwbGF0Zm9ybS5pc05hdGl2ZVNjcmlwdDtcclxudmFyIGlzTm9kZWpzID0gcGxhdGZvcm0uaXNOb2RlanM7XHJcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldExvY2FsU3RvcmFnZShzZGspIHtcclxuICAgICAgICBpZiAoaXNOYXRpdmVTY3JpcHQpIHtcclxuICAgICAgICAgICAgdmFyIGxvY2FsU2V0dGluZ3MgPSByZXF1aXJlKCdhcHBsaWNhdGlvbi1zZXR0aW5ncycpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGdldEl0ZW06IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTZXR0aW5ncy5nZXRTdHJpbmcoa2V5KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlSXRlbTogZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFNldHRpbmdzLnJlbW92ZShrZXkpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBzZXRJdGVtOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFNldHRpbmdzLnNldFN0cmluZyhrZXksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbG9jYWxTdG9yYWdlO1xyXG4gICAgICAgICAgICBpZiAoaXNOb2RlanMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBMb2NhbFN0b3JhZ2UgPSByZXF1aXJlKCdub2RlLWxvY2Fsc3RvcmFnZScpLkxvY2FsU3RvcmFnZTtcclxuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZSA9IG5ldyBMb2NhbFN0b3JhZ2Uoc2RrLm9mZmxpbmVTdG9yYWdlLnNldHVwLnN0b3JhZ2Uuc3RvcmFnZVBhdGgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlID0gd2luZG93LmxvY2FsU3RvcmFnZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGdldEl0ZW06IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlSXRlbTogZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBzZXRJdGVtOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gTG9jYWxTdG9yZShzZGspIHtcclxuICAgICAgICB0aGlzLnNkayA9IHNkaztcclxuICAgICAgICB0aGlzLl9sb2NhbFN0b3JhZ2UgPSBnZXRMb2NhbFN0b3JhZ2UodGhpcy5zZGspO1xyXG4gICAgfVxyXG5cclxuICAgIExvY2FsU3RvcmUucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGdldEl0ZW06IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcmVtb3ZlSXRlbTogZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXRJdGVtOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gTG9jYWxTdG9yZTtcclxufSgpKTsiLCJ2YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XHJcbnZhciBidWlsZFByb21pc2UgPSB1dGlscy5idWlsZFByb21pc2U7XHJcbnZhciBEZXZpY2VSZWdpc3RyYXRpb25SZXN1bHQgPSB1dGlscy5EZXZpY2VSZWdpc3RyYXRpb25SZXN1bHQ7XHJcbnZhciBldmVybGl2ZUVycm9yTW9kdWxlID0gcmVxdWlyZSgnLi9FdmVybGl2ZUVycm9yJyk7XHJcbnZhciBEZXZpY2VSZWdpc3RyYXRpb25FcnJvciA9IGV2ZXJsaXZlRXJyb3JNb2R1bGUuRGV2aWNlUmVnaXN0cmF0aW9uRXJyb3I7XHJcbnZhciBFdmVybGl2ZUVycm9yID0gZXZlcmxpdmVFcnJvck1vZHVsZS5FdmVybGl2ZUVycm9yO1xyXG52YXIgQ3VycmVudERldmljZSA9IHJlcXVpcmUoJy4vQ3VycmVudERldmljZScpO1xyXG52YXIgUGxhdGZvcm0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpLlBsYXRmb3JtO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAY2xhc3MgUHVzaFxyXG4gICAgICogQGNsYXNzZGVzYyBBIGNsYXNzIGZvciBtYW5hZ2luZyBwdXNoIG5vdGlmaWNhdGlvbnMgaW4geW91ciBhcHBsaWNhdGlvbi4gU3VwcG9ydGVkIGFyZSBwdXNoIG5vdGlmaWNhdGlvbnMgZm9yIGh5YnJpZCBhcHBzIG9uIEFuZHJvaWQgYW5kIGlPUy5cclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEBwYXJhbSBlbCB7RXZlcmxpdmV9IEV2ZXJsaXZlIE9iamVjdFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBQdXNoKGVsKSB7XHJcbiAgICAgICAgdGhpcy5fZWwgPSBlbDtcclxuICAgICAgICB0aGlzLm5vdGlmaWNhdGlvbnMgPSBlbC5kYXRhKCdQdXNoL05vdGlmaWNhdGlvbnMnKTtcclxuICAgICAgICB0aGlzLmRldmljZXMgPSBlbC5kYXRhKCdQdXNoL0RldmljZXMnKTtcclxuICAgIH1cclxuXHJcbiAgICBQdXNoLnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5zdXJlcyB0aGF0IHRoZSBUZWxlcmlrIFB1c2ggTm90aWZpY2F0aW9ucyBwbHVnLWluIGhhcyBiZWVuIGxvYWRlZCBhbmQgaXMgcmVhZHkgdG8gdXNlLiBBbiB7RXZlcmxpdmVFcnJvcn0gaXMgcmV0dXJuZWQgaWYgdGhlIHBsdWctaW4gaXMgbm90IGF2YWlsYWJsZS5cclxuICAgICAgICAgKiBAbWV0aG9kIGVuc3VyZVB1c2hJc0F2YWlsYWJsZVxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBQdXNoLnByb3RvdHlwZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGVuc3VyZVB1c2hJc0F2YWlsYWJsZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgaXNQdXNoTm90aWZpY2F0aW9uUGx1Z2luQXZhaWxhYmxlID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wbHVnaW5zICYmIHdpbmRvdy5wbHVnaW5zLnB1c2hOb3RpZmljYXRpb24pO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFpc1B1c2hOb3RpZmljYXRpb25QbHVnaW5BdmFpbGFibGUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKFwiVGhlIHB1c2ggbm90aWZpY2F0aW9uIHBsdWdpbiBpcyBub3QgYXZhaWxhYmxlLiBFbnN1cmUgdGhhdCB0aGUgcHVzaE5vdGlmaWNhdGlvbiBwbHVnaW4gaXMgaW5jbHVkZWQgXCIgK1xyXG4gICAgICAgICAgICAgICAgXCJhbmQgdXNlIGFmdGVyIGBkZXZpY2VyZWFkeWAgZXZlbnQgaGFzIGJlZW4gZmlyZWQuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGRldmljZSBmb3Igc2VuZGluZyBwdXNoIG5vdGlmaWNhdGlvbnNcclxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuMi43XHJcbiAgICAgICAgICogQHNlZSBbUHVzaC5yZWdpc3Rlcl17QGxpbmsgcHVzaC5yZWdpc3Rlcn1cclxuICAgICAgICAgKiBAbWVtYmVyT2YgUHVzaC5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIGN1cnJlbnREZXZpY2VcclxuICAgICAgICAgKiBAbmFtZSBjdXJyZW50RGV2aWNlXHJcbiAgICAgICAgICogQHBhcmFtIFtlbXVsYXRvck1vZGVdIHtCb29sZWFufSBJZiBzZXQgdG8gdHJ1ZSwgZW11bGF0b3IgbW9kZSBpcyBlbmFibGVkIG1lYW5pbmcgeW91IGNhbm5vdCBzZW5kIHB1c2ggbm90aWZpY2F0aW9ucy5cclxuICAgICAgICAgKiBAcmV0dXJucyB7Q3VycmVudERldmljZX0gUmV0dXJucyBhbiBpbnN0YW5jZSBvZiBDdXJyZW50RGV2aWNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGN1cnJlbnREZXZpY2U6IGZ1bmN0aW9uIChlbXVsYXRvck1vZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5lbnN1cmVQdXNoSXNBdmFpbGFibGUoKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBlbXVsYXRvck1vZGUgPSB0aGlzLl9lbC5zZXR1cC5fZW11bGF0b3JNb2RlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIXdpbmRvdy5jb3Jkb3ZhKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignRXJyb3I6IGN1cnJlbnREZXZpY2UoKSBjYW4gb25seSBiZSBjYWxsZWQgZnJvbSB3aXRoaW4gYSBoeWJyaWQgbW9iaWxlIGFwcCwgYWZ0ZXIgXFwnZGV2aWNlcmVhZHlcXCcgZXZlbnQgaGFzIGJlZW4gZmlyZWQuJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fY3VycmVudERldmljZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudERldmljZSA9IG5ldyBDdXJyZW50RGV2aWNlKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50RGV2aWNlLmVtdWxhdG9yTW9kZSA9IGVtdWxhdG9yTW9kZTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50RGV2aWNlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuYWJsZXMgcHVzaCBub3RpZmljYXRpb25zIG9uIHRoZSBkZXZpY2UgYW5kIHJlZ2lzdGVycyBpdCBmb3IgdGhlIGZlYXR1cmUgd2l0aCB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IGlmIGl0IGhhc24ndCBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZC4gSWYgaXQgaGFzIGJlZW4gcmVnaXN0ZXJlZCwgdGhlIHJlZ2lzdHJhdGlvbiBkZXRhaWxzIGFyZSB1cGRhdGVkLlxyXG4gICAgICAgICAqIEBtZXRob2QgcmVnaXN0ZXJcclxuICAgICAgICAgKiBAbmFtZSByZWdpc3RlclxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBQdXNoLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5ncyBBbiBvYmplY3QgY29udGFpbmluZyBzZXR0aW5ncyBmb3IgdGhlIHJlZ2lzdHJhdGlvbi4gSXQgY2FuIGluY2x1ZGUgY3VzdG9tIHBhcmFtZXRlcnMgdG8gYmUgc3RvcmVkIGJ5IHt7c2l0ZS5ic319LlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5ncy5pT1M9bnVsbCBpT1Mtc3BlY2lmaWMgc2V0dGluZ3MuXHJcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBzZXR0aW5ncy5pT1MuYWxlcnQ9dHJ1ZSBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHB1c2ggbm90aWZpY2F0aW9uIHdpbGwgZGlzcGxheSBhcyBhIHN0YW5kYXJkIGlPUyBhbGVydC5cclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHNldHRpbmdzLmlPUy5iYWRnZT0nKzEnIFNwZWNpZmllcyB0aGUgYmFkZ2UgY291bnRlciB0byBiZSBkaXNwbGF5ZWQgb24gdGhlIGRldmljZS5cclxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNldHRpbmdzLmlPUy5zb3VuZD10cnVlIElmIHNldCB0byB0cnVlLCB0aGUgZGV2aWNlIHdpbGwgcGxheSBhIG5vdGlmaWNhdGlvbiBzb3VuZC5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3MuYW5kcm9pZD1udWxsIEFuZHJvaWQtc3BlY2lmaWMgc2V0dGluZ3MuXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNldHRpbmdzLmFuZHJvaWQuc2VuZGVySUQ9bnVsbCBZb3VyIEdvb2dsZSBBUEkgcHJvamVjdCBudW1iZXIuIEl0IGlzIHJlcXVpcmVkIHdoZW4gb2J0YWluaW5nIGEgcHVzaCB0b2tlbiBmb3IgYW4gQW5kcm9pZCBkZXZpY2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNldHRpbmdzLmFuZHJvaWQucHJvamVjdE51bWJlcj1udWxsIFN5bm9ueW0gZm9yIGFuZHJvaWQuc2VuZGVySUQuIEF2YWlsYWJsZSBpbiBKYXZhU2NyaXB0IFNESyB2ZXJzaW9ucyAxLjIuNyBhbmQgbGF0ZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzLndwOD1udWxsIFdpbmRvd3MgUGhvbmUgc3BlY2lmaWMgc2V0dGluZ3MuXHJcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbmFibGVzIHB1c2ggbm90aWZpY2F0aW9ucyBvbiB0aGUgZGV2aWNlIGFuZCByZWdpc3RlcnMgaXQgZm9yIHRoZSBmZWF0dXJlIHdpdGgge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSBpZiBpdCBoYXNuJ3QgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQuIElmIGl0IGhhcyBiZWVuIHJlZ2lzdGVyZWQsIHRoZSByZWdpc3RyYXRpb24gZGV0YWlscyBhcmUgdXBkYXRlZC5cclxuICAgICAgICAgKiBUZWxlcmlrIEJhY2tlbmQgU2VydmljZXMgaWYgaXQgaGFzbid0IGFscmVhZHkgYmVlbiByZWdpc3RlcmVkLlxyXG4gICAgICAgICAqIElmIGl0IHdhcyByZWdpc3RlcmVkIHRoZSByZWdpc3RyYXRpb24gZGV0YWlscyBhcmUgdXBkYXRlZC5cclxuICAgICAgICAgKiBAbWV0aG9kIHJlZ2lzdGVyXHJcbiAgICAgICAgICogQG5hbWUgcmVnaXN0ZXJcclxuICAgICAgICAgKiBAbWVtYmVyT2YgUHVzaC5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3MgU2V0dGluZ3MgZm9yIHRoZSByZWdpc3RyYXRpb24uIENhbiBpbmNsdWRlIGN1c3RvbSBwYXJhbWV0ZXJzIHRvIGJlIHNhdmVkIGluIGJhY2tlbmQgc2VydmljZXMuXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzLmlPUz1udWxsIGlPUyBzcGVjaWZpYyBzZXR0aW5nc1xyXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2V0dGluZ3MuaU9TLmFsZXJ0PXRydWUgU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGRldmljZSB3aWxsIGRpc3BsYXkgYW4gYWxlcnQgbWVzc2FnZS5cclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHNldHRpbmdzLmlPUy5iYWRnZT0nKzEnIFNwZWNpZmllcyB0aGUgYmFkZ2UgY291bnRlciB0byBiZSBkaXNwbGF5ZWQgb24gdGhlIGRldmljZS5cclxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNldHRpbmdzLmlPUy5zb3VuZD10cnVlIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBkZXZpY2Ugd2lsbCBwbGF5IGEgc291bmQuXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzLmFuZHJvaWQ9bnVsbCBBbmRyb2lkIHNwZWNpZmljIHNldHRpbmdzXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNldHRpbmdzLmFuZHJvaWQuc2VuZGVySUQ9bnVsbCBUaGlzIGlzIHlvdXIgR29vZ2xlIEFQSSBwcm9qZWN0IG51bWJlci4gSXQgaXMgcmVxdWlyZWQgd2hlbiBvYnRhaW5pbmcgYSBwdXNoIHRva2VuIGZvciBhbiBBbmRyb2lkIGRldmljZS5cclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2V0dGluZ3MuYW5kcm9pZC5wcm9qZWN0TnVtYmVyPW51bGwgU3lub255bSBmb3IgYW5kcm9pZC5zZW5kZXJJRC4gQXZhaWxhYmxlIGluIEphdmFTY3JpcHQgU0RLIHZlcnNpb25zIDEuMi43IGFuZCBsYXRlci5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3Mud3A4PW51bGwgV2luZG93cyBQaG9uZSBzcGVjaWZpYyBzZXR0aW5nc1xyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBDYWxsYmFjayB0byBpbnZva2Ugb24gc3VjY2Vzcy5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIENhbGxiYWNrIHRvIGludm9rZSBvbiBlcnJvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICByZWdpc3RlcjogZnVuY3Rpb24gKHNldHRpbmdzLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLmVuc3VyZVB1c2hJc0F2YWlsYWJsZSgpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGN1cnJlbnREZXZpY2UgPSB0aGlzLmN1cnJlbnREZXZpY2UoKTtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICBzZXR0aW5ncyA9IHNldHRpbmdzIHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmFuZHJvaWQpIHtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmFuZHJvaWQuc2VuZGVySUQgPSBzZXR0aW5ncy5hbmRyb2lkLnByb2plY3ROdW1iZXIgfHwgc2V0dGluZ3MuYW5kcm9pZC5zZW5kZXJJRDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHN1Y2Nlc3NDYWxsYmFjayA9IGZ1bmN0aW9uICh0b2tlbiwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgRGV2aWNlUmVnaXN0cmF0aW9uUmVzdWx0KHRva2VuKTtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB2YXIgZXJyb3JDYWxsYmFjayA9IGZ1bmN0aW9uIChlcnIsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVnaXN0cmF0aW9uRXJyb3IgPSBEZXZpY2VSZWdpc3RyYXRpb25FcnJvci5mcm9tRXZlcmxpdmVFcnJvcihlcnIpO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVnaXN0cmF0aW9uRXJyb3IpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgdmFyIGNsZWFyQmFkZ2VJZk5lZWRlZCA9IGZ1bmN0aW9uICh0b2tlbiwgc3VjY2Vzc0NiLCBlcnJvckNiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGxhdGZvcm1UeXBlID0gY3VycmVudERldmljZS5fZ2V0UGxhdGZvcm1UeXBlKGRldmljZS5wbGF0Zm9ybSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2xlYXJCYWRnZSA9IHBsYXRmb3JtVHlwZSA9PT0gUGxhdGZvcm0uaU9TO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjbGVhckJhZGdlICYmIHNldHRpbmdzLmlPUykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFyQmFkZ2UgPSBzZXR0aW5ncy5pT1MuY2xlYXJCYWRnZSAhPT0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGNsZWFyQmFkZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNsZWFyQmFkZ2VOdW1iZXIoKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc0NhbGxiYWNrKHRva2VuLCBzdWNjZXNzQ2IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JDYWxsYmFjayhlcnIsIGVycm9yQ2IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2sodG9rZW4sIHN1Y2Nlc3NDYik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzQ2IsIGVycm9yQ2IpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnREZXZpY2UuZW5hYmxlTm90aWZpY2F0aW9ucyhzZXR0aW5ncywgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRva2VuID0gcmVzcG9uc2UudG9rZW47XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1c3RvbVBhcmFtZXRlcnMgPSBzZXR0aW5ncy5jdXN0b21QYXJhbWV0ZXJzO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnREZXZpY2UuZ2V0UmVnaXN0cmF0aW9uKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudERldmljZS51cGRhdGVSZWdpc3RyYXRpb24oY3VzdG9tUGFyYW1ldGVycywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyQmFkZ2VJZk5lZWRlZCh0b2tlbiwgc3VjY2Vzc0NiLCBlcnJvckNiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrKGVyciwgZXJyb3JDYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVyci5jb2RlID09PSA4MDEpIHsgLy9Ob3QgcmVnaXN0ZXJlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREZXZpY2UucmVnaXN0ZXIoY3VzdG9tUGFyYW1ldGVycywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhckJhZGdlSWZOZWVkZWQodG9rZW4sIHN1Y2Nlc3NDYiwgZXJyb3JDYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZXJyb3JDYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ2FsbGJhY2soZXJyLCBlcnJvckNiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRldmljZVJlZ2lzdHJhdGlvbkVycm9yID0gRGV2aWNlUmVnaXN0cmF0aW9uRXJyb3IuZnJvbVBsdWdpbkVycm9yKGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JDYihkZXZpY2VSZWdpc3RyYXRpb25FcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERpc2FibGVzIHB1c2ggbm90aWZpY2F0aW9ucyBmb3IgdGhlIGN1cnJlbnQgZGV2aWNlLiBUaGlzIG1ldGhvZCBpbnZhbGlkYXRlcyBhbnkgcHVzaCB0b2tlbnMgdGhhdCB3ZXJlIG9idGFpbmVkIGZvciB0aGUgZGV2aWNlIGZyb20gdGhlIGN1cnJlbnQgYXBwbGljYXRpb24uIFRoZSBkZXZpY2Ugd2lsbCBhbHNvIGJlIHVucmVnaXN0ZXJlZCBmcm9tIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0uXHJcbiAgICAgICAgICogQG1ldGhvZCB1bnJlZ2lzdGVyXHJcbiAgICAgICAgICogQG5hbWUgdW5yZWdpc3RlclxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBQdXNoLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGlzYWJsZXMgcHVzaCBub3RpZmljYXRpb25zIGZvciB0aGUgY3VycmVudCBkZXZpY2UuIFRoaXMgbWV0aG9kIGludmFsaWRhdGVzIGFueSBwdXNoIHRva2VucyB0aGF0IHdlcmUgb2J0YWluZWQgZm9yIHRoZSBkZXZpY2UgZnJvbSB0aGUgY3VycmVudCBhcHBsaWNhdGlvbi4gVGhlIGRldmljZSB3aWxsIGFsc28gYmUgdW5yZWdpc3RlcmVkIGZyb20ge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fS5cclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBpbnZhbGlkYXRlcyBhbnkgcHVzaCB0b2tlbnMgdGhhdCB3ZXJlIG9idGFpbmVkIGZvciB0aGUgZGV2aWNlIGZyb20gdGhlIGN1cnJlbnQgYXBwbGljYXRpb24uXHJcbiAgICAgICAgICogVGhlIGRldmljZSB3aWxsIGFsc28gYmUgdW5yZWdpc3RlcmVkIGZyb20gVGVsZXJpayBCYWNrZW5kIFNlcnZpY2VzLlxyXG4gICAgICAgICAqIEBtZXRob2QgdW5yZWdpc3RlclxyXG4gICAgICAgICAqIEBuYW1lIHVucmVnaXN0ZXJcclxuICAgICAgICAgKiBAbWVtYmVyT2YgUHVzaC5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25TdWNjZXNzXSBDYWxsYmFjayB0byBpbnZva2Ugb24gc3VjY2Vzcy5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25FcnJvcl0gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIGVycm9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHVucmVnaXN0ZXI6IGZ1bmN0aW9uIChvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5lbnN1cmVQdXNoSXNBdmFpbGFibGUoKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50RGV2aWNlID0gdGhpcy5jdXJyZW50RGV2aWNlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50RGV2aWNlLmRpc2FibGVOb3RpZmljYXRpb25zLmFwcGx5KGN1cnJlbnREZXZpY2UsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlcyB0aGUgcmVnaXN0cmF0aW9uIG9mIHRoZSBjdXJyZW50IGRldmljZS5cclxuICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZVJlZ2lzdHJhdGlvblxyXG4gICAgICAgICAqIEBuYW1lIHVwZGF0ZVJlZ2lzdHJhdGlvblxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBQdXNoLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjdXN0b21QYXJhbWV0ZXJzIEN1c3RvbSBwYXJhbWV0ZXJzIGZvciB0aGUgcmVnaXN0cmF0aW9uLiBJZiB7dW5kZWZpbmVkfSwgY3VzdG9tUGFyYW1ldGVycyBhcmUgbm90IHVwZGF0ZWQuXHJcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGVzIHRoZSByZWdpc3RyYXRpb24gZm9yIHRoZSBjdXJyZW50IGRldmljZS5cclxuICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZVJlZ2lzdHJhdGlvblxyXG4gICAgICAgICAqIEBuYW1lIHVwZGF0ZVJlZ2lzdHJhdGlvblxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBQdXNoLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjdXN0b21QYXJhbWV0ZXJzIEN1c3RvbSBwYXJhbWV0ZXJzIGZvciB0aGUgcmVnaXN0cmF0aW9uLiBJZiB7dW5kZWZpbmVkfSwgY3VzdG9tUGFyYW1ldGVycyBhcmUgbm90IHVwZGF0ZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uU3VjY2Vzc10gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIHN1Y2Nlc3MuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRXJyb3JdIENhbGxiYWNrIHRvIGludm9rZSBvbiBlcnJvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICB1cGRhdGVSZWdpc3RyYXRpb246IGZ1bmN0aW9uIChjdXN0b21QYXJhbWV0ZXJzLCBvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5lbnN1cmVQdXNoSXNBdmFpbGFibGUoKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50RGV2aWNlID0gdGhpcy5jdXJyZW50RGV2aWNlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50RGV2aWNlLnVwZGF0ZVJlZ2lzdHJhdGlvbi5hcHBseShjdXJyZW50RGV2aWNlLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIGJhZGdlIG51bWJlciBvbiB0aGUge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSBzZXJ2ZXIuXHJcbiAgICAgICAgICogQG1ldGhvZCBzZXRCYWRnZU51bWJlclxyXG4gICAgICAgICAqIEBuYW1lIHNldEJhZGdlTnVtYmVyXHJcbiAgICAgICAgICogQG1lbWJlck9mIFB1c2gucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBiYWRnZSBUaGUgbnVtYmVyIHRvIGJlIHNldCBhcyBhIGJhZGdlLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgYmFkZ2UgbnVtYmVyIG9uIHRoZSBzZXJ2ZXJcclxuICAgICAgICAgKiBAbWV0aG9kIHNldEJhZGdlTnVtYmVyXHJcbiAgICAgICAgICogQG5hbWUgc2V0QmFkZ2VOdW1iZXJcclxuICAgICAgICAgKiBAbWVtYmVyT2YgUHVzaC5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGJhZGdlIFRoZSBudW1iZXIgdG8gYmUgc2V0IGFzIGEgYmFkZ2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uU3VjY2Vzc10gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIHN1Y2Nlc3MuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRXJyb3JdIENhbGxiYWNrIHRvIGludm9rZSBvbiBlcnJvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXRCYWRnZU51bWJlcjogZnVuY3Rpb24gKGJhZGdlLCBvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5lbnN1cmVQdXNoSXNBdmFpbGFibGUoKTtcclxuXHJcbiAgICAgICAgICAgIGJhZGdlID0gcGFyc2VJbnQoYmFkZ2UpO1xyXG4gICAgICAgICAgICBpZiAoaXNOYU4oYmFkZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yKG5ldyBFdmVybGl2ZUVycm9yKCdUaGUgYmFkZ2UgbXVzdCBoYXZlIGEgbnVtZXJpYyB2YWx1ZScpKTtcclxuICAgICAgICAgICAgICAgIH0sIG9uU3VjY2Vzcywgb25FcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBkZXZpY2VSZWdpc3RyYXRpb24gPSB7fTtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnREZXZpY2UgPSB0aGlzLmN1cnJlbnREZXZpY2UoKTtcclxuICAgICAgICAgICAgdmFyIGRldmljZUlkID0gY3VycmVudERldmljZS5fZ2V0RGV2aWNlSWQoKTtcclxuICAgICAgICAgICAgZGV2aWNlUmVnaXN0cmF0aW9uLklkID0gJ0hhcmR3YXJlSWQvJyArIGVuY29kZVVSSUNvbXBvbmVudChkZXZpY2VJZCk7XHJcbiAgICAgICAgICAgIGRldmljZVJlZ2lzdHJhdGlvbi5CYWRnZUNvdW50ZXIgPSBiYWRnZTtcclxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2Vzc0NiLCBlcnJvckNiKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50RGV2aWNlLl9wdXNoSGFuZGxlci5kZXZpY2VzLnVwZGF0ZVNpbmdsZShkZXZpY2VSZWdpc3RyYXRpb24pLnRoZW4oXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2luZG93LnBsdWdpbnMgJiYgd2luZG93LnBsdWdpbnMucHVzaE5vdGlmaWNhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5wbHVnaW5zLnB1c2hOb3RpZmljYXRpb24uc2V0QXBwbGljYXRpb25JY29uQmFkZ2VOdW1iZXIoc3VjY2Vzc0NiLCBlcnJvckNiLCBiYWRnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VjY2Vzc0NiKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LCBlcnJvckNiKVxyXG4gICAgICAgICAgICB9LCBvblN1Y2Nlc3MsIG9uRXJyb3IpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlc2V0cyB0aGUgYmFkZ2UgbnVtYmVyIG9uIHRoZSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IHNlcnZlciB0byAwLlxyXG4gICAgICAgICAqIEBtZXRob2QgY2xlYXJCYWRnZU51bWJlclxyXG4gICAgICAgICAqIEBuYW1lIGNsZWFyQmFkZ2VOdW1iZXJcclxuICAgICAgICAgKiBAbWVtYmVyT2YgUHVzaC5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENsZWFycyB0aGUgYmFkZ2UgbnVtYmVyIG9uIHRoZSBzZXJ2ZXIgYnkgc2V0dGluZyBpdCB0byAwXHJcbiAgICAgICAgICogQG1ldGhvZCBjbGVhckJhZGdlTnVtYmVyXHJcbiAgICAgICAgICogQG5hbWUgY2xlYXJCYWRnZU51bWJlclxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBQdXNoLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvblN1Y2Nlc3NdIENhbGxiYWNrIHRvIGludm9rZSBvbiBzdWNjZXNzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkVycm9yXSBDYWxsYmFjayB0byBpbnZva2Ugb24gZXJyb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xlYXJCYWRnZU51bWJlcjogZnVuY3Rpb24gKG9uU3VjY2Vzcywgb25FcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLmVuc3VyZVB1c2hJc0F2YWlsYWJsZSgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0QmFkZ2VOdW1iZXIoMCwgb25TdWNjZXNzLCBvbkVycm9yKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBwdXNoIG5vdGlmaWNhdGlvbnMgcmVnaXN0cmF0aW9uIGZvciB0aGUgY3VycmVudCBkZXZpY2UuXHJcbiAgICAgICAgICogQG1ldGhvZCBnZXRSZWdpc3RyYXRpb25cclxuICAgICAgICAgKiBAbmFtZSBnZXRSZWdpc3RyYXRpb25cclxuICAgICAgICAgKiBAbWVtYmVyT2YgUHVzaC5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIHB1c2ggcmVnaXN0cmF0aW9uIGZvciB0aGUgY3VycmVudCBkZXZpY2UuXHJcbiAgICAgICAgICogQG1ldGhvZCBnZXRSZWdpc3RyYXRpb25cclxuICAgICAgICAgKiBAbmFtZSBnZXRSZWdpc3RyYXRpb25cclxuICAgICAgICAgKiBAbWVtYmVyT2YgUHVzaC5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25TdWNjZXNzXSBDYWxsYmFjayB0byBpbnZva2Ugb24gc3VjY2Vzcy5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25FcnJvcl0gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIGVycm9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFJlZ2lzdHJhdGlvbjogZnVuY3Rpb24gKG9uU3VjY2Vzcywgb25FcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLmVuc3VyZVB1c2hJc0F2YWlsYWJsZSgpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGN1cnJlbnREZXZpY2UgPSB0aGlzLmN1cnJlbnREZXZpY2UoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnREZXZpY2UuZ2V0UmVnaXN0cmF0aW9uLmFwcGx5KGN1cnJlbnREZXZpY2UsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2VuZHMgYSBwdXNoIG5vdGlmaWNhdGlvbi5cclxuICAgICAgICAgKiBAbWV0aG9kIHNlbmRcclxuICAgICAgICAgKiBAbmFtZSBzZW5kXHJcbiAgICAgICAgICogQG1lbWJlck9mIFB1c2gucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5vdGlmaWNhdGlvbiBUaGUgcHVzaCBub3RpZmljYXRpb24gb2JqZWN0XHJcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNlbmRzIGEgcHVzaCBtZXNzYWdlXHJcbiAgICAgICAgICogQG1ldGhvZCBzZW5kXHJcbiAgICAgICAgICogQG5hbWUgc2VuZFxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBQdXNoLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub3RpZmljYXRpb24gVGhlIHB1c2ggbm90aWZpY2F0aW9uIG9iamVjdFxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvblN1Y2Nlc3NdIENhbGxiYWNrIHRvIGludm9rZSBvbiBzdWNjZXNzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkVycm9yXSBDYWxsYmFjayB0byBpbnZva2Ugb24gZXJyb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2VuZDogZnVuY3Rpb24gKG5vdGlmaWNhdGlvbiwgb25TdWNjZXNzLCBvbkVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlUHVzaElzQXZhaWxhYmxlKCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub3RpZmljYXRpb25zLmNyZWF0ZS5hcHBseSh0aGlzLm5vdGlmaWNhdGlvbnMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2QgcHJvdmlkZXMgYSBkaWZmZXJlbnQgb3BlcmF0aW9uIG9uIGVhY2ggc3VwcG9ydGVkIHBsYXRmb3JtOlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogLSBPbiBpT1M6IENoZWNrcyBpZiBOb3RpZmljYXRpb25zIGlzIGVuYWJsZWQgZm9yIHRoaXMgYXBwbGljYXRpb24gaW4gdGhlIGRldmljZSdzIE5vdGlmaWNhdGlvbiBDZW50ZXIuXHJcbiAgICAgICAgICogLSBPbiBXaW5kb3dzIFBob25lOiBDaGVja3MgaWYgdGhlIGFwcGxpY2F0aW9uIGhhcyBhbiBhY3RpdmUgb3BlbiBjaGFubmVsIGZvciBjb21tdW5pY2F0aW9uIHdpdGggdGhlIE1pY3Jvc29mdCBQdXNoIE5vdGlmaWNhdGlvbiBTZXJ2aWNlLiBUaGUgb3V0Y29tZSBkb2VzIG5vdCBkZXBlbmQgb24gdGhlIGRldmljZSdzIG5vdGlmaWNhdGlvbiBzZXR0aW5ncy5cclxuICAgICAgICAgKiAtIE9uIEFuZHJvaWQ6IENoZWNrcyBpZiB0aGUgYXBwbGljYXRpb24gaGFzIGVzdGFibGlzaGVkIGEgY29ubmVjdGlvbiB3aXRoIEdvb2dsZSBDbG91ZCBNZXNzYWdpbmcuIFRoZSBvdXRjb21lIGRvZXMgbm90IGRlcGVuZCBvbiB0aGUgZGV2aWNlJ3Mgbm90aWZpY2F0aW9uIHNldHRpbmdzLlxyXG4gICAgICAgICAqIEBtZXRob2QgYXJlTm90aWZpY2F0aW9uc0VuYWJsZWRcclxuICAgICAgICAgKiBAbmFtZSBhcmVOb3RpZmljYXRpb25zRW5hYmxlZFxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBQdXNoLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFuIG9iamVjdCBwYXNzZWQgdG8gdGhlIFB1c2ggTm90aWZpY2F0aW9uIHBsdWdpbidzIGFyZU5vdGlmaWNhdGlvbnNFbmFibGVkIG1ldGhvZFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogaU9TOiBDaGVja3MgaWYgdGhlIE5vdGlmaWNhdGlvbnMgYXJlIGVuYWJsZWQgZm9yIHRoaXMgQXBwbGljYXRpb24gaW4gdGhlIERldmljZSdzIE5vdGlmaWNhdGlvbiBDZW50ZXIuXHJcbiAgICAgICAgICogV2luZG93cyBQaG9uZTogQ2hlY2tzIGlmIHRoZSBBcHBsaWNhdGlvbiBoYXMgYW4gYWN0aXZlIG9wZW5lZCBDaGFubmVsIGZvciBjb21tdW5pY2F0aW9uIHdpdGggdGhlIE5vdGlmaWNhdGlvbiBTZXJ2aWNlLiBOb3QgcmVseWluZyBvbiB0aGUgZGV2aWNlIG5vdGlmaWNhdGlvbiBzZXR0aW5ncy5cclxuICAgICAgICAgKiBBbmRyb2lkOiBDaGVja3MgaWYgdGhlIEFwcGxpY2F0aW9uIGhhcyBlc3RhYmxpc2hlZCBjb25uZWN0aW9uIHdpdGggdGhlIE5vdGlmaWNhdGlvbiBTZXJ2aWNlLiBOb3QgcmVseWluZyBvbiB0aGUgZGV2aWNlIG5vdGlmaWNhdGlvbiBzZXR0aW5ncy5cclxuICAgICAgICAgKiBAbWV0aG9kIGFyZU5vdGlmaWNhdGlvbnNFbmFibGVkXHJcbiAgICAgICAgICogQG5hbWUgYXJlTm90aWZpY2F0aW9uc0VuYWJsZWRcclxuICAgICAgICAgKiBAbWVtYmVyT2YgUHVzaC5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBhbiBvYmplY3QgcGFzc2VkIHRvIHRoZSBQdXNoIE5vdGlmaWNhdGlvbiBwbHVnaW4ncyBhcmVOb3RpZmljYXRpb25zRW5hYmxlZCBtZXRob2QuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uU3VjY2Vzc10gQ2FsbGJhY2sgdG8gaW52b2tlIG9uIHN1Y2Nlc3NmdWwgY2hlY2suIFBhc3NlcyBhIHNpbmdsZSBib29sZWFuIHZhbHVlOiB0cnVlIG9yIGZhbHNlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkVycm9yXSBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbiBlcnJvciBpbiB0aGUgcHVzaCBwbHVnaW4gaGFzIG9jY3VycmVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGFyZU5vdGlmaWNhdGlvbnNFbmFibGVkOiBmdW5jdGlvbiAob3B0aW9ucywgb25TdWNjZXNzLCBvbkVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlUHVzaElzQXZhaWxhYmxlKCk7XHJcblxyXG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICAgICAgdmFyIHB1c2hOb3RpZmljYXRpb24gPSB3aW5kb3cucGx1Z2lucy5wdXNoTm90aWZpY2F0aW9uO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2Vzc0NiLCBlcnJvckNiKSB7XHJcbiAgICAgICAgICAgICAgICBwdXNoTm90aWZpY2F0aW9uLmFyZU5vdGlmaWNhdGlvbnNFbmFibGVkKHN1Y2Nlc3NDYiwgZXJyb3JDYiwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH0sIG9uU3VjY2Vzcywgb25FcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gUHVzaDtcclxufSgpKTsiLCJ2YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XHJcbnZhciByc3ZwID0gcmVxdWlyZSgnLi9jb21tb24nKS5yc3ZwO1xyXG52YXIgYnVpbGRBdXRoSGVhZGVyID0gdXRpbHMuYnVpbGRBdXRoSGVhZGVyO1xyXG52YXIgcGFyc2VVdGlsaXRpZXMgPSB1dGlscy5wYXJzZVV0aWxpdGllcztcclxudmFyIGd1YXJkVW5zZXQgPSB1dGlscy5ndWFyZFVuc2V0O1xyXG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcclxudmFyIHJlcXdlc3QgPSBjb21tb24ucmVxd2VzdDtcclxudmFyIF8gPSBjb21tb24uXztcclxudmFyIEhlYWRlcnMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpLkhlYWRlcnM7XHJcbnZhciBpc05vZGVqcyA9IHJlcXVpcmUoJy4vZXZlcmxpdmUucGxhdGZvcm0nKS5pc05vZGVqcztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBfc2VsZjtcclxuXHJcbiAgICAvLyBUaGUgUmVxdWVzdCB0eXBlIGlzIGFuIGFic3RyYWN0aW9uIG92ZXIgQWpheCBsaWJyYXJpZXNcclxuICAgIC8vIEEgUmVxdWVzdCBvYmplY3QgbmVlZHMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIEV2ZXJsaXZlIGNvbm5lY3Rpb24gYW5kIGluaXRpYWxpemF0aW9uIG9wdGlvbnNcclxuXHJcbiAgICBmdW5jdGlvbiBSZXF1ZXN0KHNldHVwLCBvcHRpb25zKSB7XHJcbiAgICAgICAgZ3VhcmRVbnNldChzZXR1cCwgJ3NldHVwJyk7XHJcbiAgICAgICAgZ3VhcmRVbnNldChvcHRpb25zLCAnb3B0aW9ucycpO1xyXG4gICAgICAgIHRoaXMuc2V0dXAgPSBzZXR1cDtcclxuICAgICAgICB0aGlzLm1ldGhvZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5lbmRwb2ludCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gbnVsbDtcclxuICAgICAgICB0aGlzLmhlYWRlcnMgPSB7fTtcclxuICAgICAgICAvLyBUT0RPIHN1Y2Nlc3MgYW5kIGVycm9yIGNhbGxiYWNrcyBzaG91bGQgYmUgdW5pZm9ybWVkIGZvciBhbGwgYWpheCBsaWJzXHJcbiAgICAgICAgdGhpcy5zdWNjZXNzID0gbnVsbDtcclxuICAgICAgICB0aGlzLmVycm9yID0gbnVsbDtcclxuICAgICAgICB0aGlzLnBhcnNlID0gUmVxdWVzdC5wYXJzZXJzLnNpbXBsZTtcclxuXHJcbiAgICAgICAgXy5leHRlbmQodGhpcywgb3B0aW9ucyk7XHJcbiAgICAgICAgX3NlbGYgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgUmVxdWVzdC5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgLy8gQ2FsbHMgdGhlIHVuZGVybHlpbmcgQWpheCBsaWJyYXJ5XHJcbiAgICAgICAgc2VuZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBSZXF1ZXN0LnNlbmRSZXF1ZXN0KHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gUmV0dXJucyBhbiBhdXRob3JpemF0aW9uIGhlYWRlciB1c2VkIGJ5IHRoZSByZXF1ZXN0LlxyXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGEgbG9nZ2VkIGluIHVzZXIgZm9yIHRoZSBFdmVybGl2ZSBpbnN0YW5jZSB0aGVuIGhlci9oaXMgYXV0aGVudGljYXRpb24gd2lsbCBiZSB1c2VkLlxyXG4gICAgICAgIGJ1aWxkQXV0aEhlYWRlcjogYnVpbGRBdXRoSGVhZGVyLFxyXG4gICAgICAgIC8vIEJ1aWxkcyB0aGUgVVJMIG9mIHRoZSB0YXJnZXQgRXZlcmxpdmUgc2VydmljZVxyXG4gICAgICAgIGJ1aWxkVXJsOiBmdW5jdGlvbiBidWlsZFVybChzZXR1cCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdXRpbHMuYnVpbGRVcmwoc2V0dXApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gUHJvY2Vzc2VzIHRoZSBnaXZlbiBxdWVyeSB0byByZXR1cm4gYXBwcm9wcmlhdGUgaGVhZGVycyB0byBiZSB1c2VkIGJ5IHRoZSByZXF1ZXN0XHJcbiAgICAgICAgYnVpbGRRdWVyeUhlYWRlcnM6IGZ1bmN0aW9uIGJ1aWxkUXVlcnlIZWFkZXJzKHF1ZXJ5KSB7XHJcbiAgICAgICAgICAgIGlmIChxdWVyeSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHF1ZXJ5IGluc3RhbmNlb2YgRXZlcmxpdmUuUXVlcnkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUmVxdWVzdC5wcm90b3R5cGUuX2J1aWxkUXVlcnlIZWFkZXJzKHF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZXF1ZXN0LnByb3RvdHlwZS5fYnVpbGRGaWx0ZXJIZWFkZXIocXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBSZXF1ZXN0IG9iamVjdCBieSB1c2luZyB0aGUgcGFzc2VkIG9wdGlvbnNcclxuICAgICAgICBfaW5pdDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgXy5leHRlbmQodGhpcy5oZWFkZXJzLCB0aGlzLmJ1aWxkQXV0aEhlYWRlcih0aGlzLnNldHVwLCBvcHRpb25zKSwgdGhpcy5idWlsZFF1ZXJ5SGVhZGVycyhvcHRpb25zLmZpbHRlciksIG9wdGlvbnMuaGVhZGVycyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBUcmFuc2xhdGVzIGFuIEV2ZXJsaXZlLlF1ZXJ5IHRvIHJlcXVlc3QgaGVhZGVyc1xyXG4gICAgICAgIF9idWlsZFF1ZXJ5SGVhZGVyczogZnVuY3Rpb24gKHF1ZXJ5KSB7XHJcbiAgICAgICAgICAgIHF1ZXJ5ID0gcXVlcnkuYnVpbGQoKTtcclxuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSB7fTtcclxuICAgICAgICAgICAgaWYgKHF1ZXJ5LiR3aGVyZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaGVhZGVyc1tIZWFkZXJzLmZpbHRlcl0gPSBKU09OLnN0cmluZ2lmeShxdWVyeS4kd2hlcmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChxdWVyeS4kc2VsZWN0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBoZWFkZXJzW0hlYWRlcnMuc2VsZWN0XSA9IEpTT04uc3RyaW5naWZ5KHF1ZXJ5LiRzZWxlY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChxdWVyeS4kc29ydCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaGVhZGVyc1tIZWFkZXJzLnNvcnRdID0gSlNPTi5zdHJpbmdpZnkocXVlcnkuJHNvcnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChxdWVyeS4kc2tpcCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaGVhZGVyc1tIZWFkZXJzLnNraXBdID0gcXVlcnkuJHNraXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHF1ZXJ5LiR0YWtlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBoZWFkZXJzW0hlYWRlcnMudGFrZV0gPSBxdWVyeS4kdGFrZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocXVlcnkuJGV4cGFuZCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaGVhZGVyc1tIZWFkZXJzLmV4cGFuZF0gPSBKU09OLnN0cmluZ2lmeShxdWVyeS4kZXhwYW5kKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gaGVhZGVycztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIENyZWF0ZXMgYSBoZWFkZXIgZnJvbSBhIHNpbXBsZSBmaWx0ZXJcclxuICAgICAgICBfYnVpbGRGaWx0ZXJIZWFkZXI6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSB7fTtcclxuICAgICAgICAgICAgaGVhZGVyc1tIZWFkZXJzLmZpbHRlcl0gPSBKU09OLnN0cmluZ2lmeShmaWx0ZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gaGVhZGVycztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBwYXJzZU9ubHlDb21wbGV0ZURhdGVUaW1lU3RyaW5nID0gX3NlbGYgJiYgX3NlbGYuc2V0dXAgJiYgX3NlbGYuc2V0dXAucGFyc2VPbmx5Q29tcGxldGVEYXRlVGltZU9iamVjdHM7XHJcblxyXG4gICAgdmFyIHJldml2ZXIgPSBwYXJzZVV0aWxpdGllcy5nZXRSZXZpdmVyKHBhcnNlT25seUNvbXBsZXRlRGF0ZVRpbWVTdHJpbmcpO1xyXG5cclxuICAgIFJlcXVlc3QucGFyc2VycyA9IHtcclxuICAgICAgICBzaW1wbGU6IHtcclxuICAgICAgICAgICAgcmVzdWx0OiBwYXJzZVV0aWxpdGllcy5wYXJzZVJlc3VsdC5iaW5kKG51bGwsIHJldml2ZXIpLFxyXG4gICAgICAgICAgICBlcnJvcjogcGFyc2VVdGlsaXRpZXMucGFyc2VFcnJvci5iaW5kKG51bGwsIHJldml2ZXIpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzaW5nbGU6IHtcclxuICAgICAgICAgICAgcmVzdWx0OiBwYXJzZVV0aWxpdGllcy5wYXJzZVNpbmdsZVJlc3VsdC5iaW5kKG51bGwsIHJldml2ZXIpLFxyXG4gICAgICAgICAgICBlcnJvcjogcGFyc2VVdGlsaXRpZXMucGFyc2VFcnJvci5iaW5kKG51bGwsIHJldml2ZXIpXHJcbiAgICAgICAgfSxcclxuICAgICAgICB1cGRhdGU6IHtcclxuICAgICAgICAgICAgcmVzdWx0OiBwYXJzZVV0aWxpdGllcy5wYXJzZVVwZGF0ZVJlc3VsdC5iaW5kKG51bGwsIHJldml2ZXIpLFxyXG4gICAgICAgICAgICBlcnJvcjogcGFyc2VVdGlsaXRpZXMucGFyc2VFcnJvci5iaW5kKG51bGwsIHJldml2ZXIpXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBUT0RPIGJ1aWx0IGZvciByZXF1ZXN0XHJcbiAgICBpZiAodHlwZW9mIFJlcXVlc3Quc2VuZFJlcXVlc3QgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgUmVxdWVzdC5zZW5kUmVxdWVzdCA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgIHZhciB1cmwgPSByZXF1ZXN0LmJ1aWxkVXJsKHJlcXVlc3Quc2V0dXApICsgcmVxdWVzdC5lbmRwb2ludDtcclxuICAgICAgICAgICAgdXJsID0gRXZlcmxpdmUuZGlzYWJsZVJlcXVlc3RDYWNoZSh1cmwsIHJlcXVlc3QubWV0aG9kKTtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSByZXF1ZXN0Lm1ldGhvZCA9PT0gJ0dFVCcgPyByZXF1ZXN0LmRhdGEgOiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0LmRhdGEpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHJlcXVlc3RQYXJhbXMgPSB7XHJcbiAgICAgICAgICAgICAgICB1cmw6IHVybCxcclxuICAgICAgICAgICAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgICAgICAgICAgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzLFxyXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJ1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgaWYgKGlzTm9kZWpzKSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0UGFyYW1zLnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZGF0YSwgcmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnN1Y2Nlc3MuY2FsbChyZXF1ZXN0LCByZXF1ZXN0LnBhcnNlLnJlc3VsdChkYXRhKSwgcmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0UGFyYW1zLmVycm9yID0gZnVuY3Rpb24gKGpxWEhSKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5lcnJvci5jYWxsKHJlcXVlc3QsIHJlcXVlc3QucGFyc2UuZXJyb3IoanFYSFIucmVzcG9uc2VUZXh0IHx8IGpxWEhSLnN0YXR1c1RleHQpKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0UGFyYW1zLnR5cGUgPSAnanNvbic7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0UGFyYW1zLmNyb3NzT3JpZ2luID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RQYXJhbXMuc3VjY2VzcyA9IGZ1bmN0aW9uIChkYXRhLCB0ZXh0U3RhdHVzLCBqcVhIUikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSByZXF1ZXN0LnBhcnNlLnJlc3VsdChkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnN1Y2Nlc3MuY2FsbChyZXF1ZXN0LCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0UGFyYW1zLmVycm9yID0gZnVuY3Rpb24gKGpxWEhSLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IHJlcXVlc3QucGFyc2UuZXJyb3IoanFYSFIucmVzcG9uc2VUZXh0IHx8IGpxWEhSLnN0YXR1c1RleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuZXJyb3IuY2FsbChyZXF1ZXN0LCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXF3ZXN0KHJlcXVlc3RQYXJhbXMpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFJlcXVlc3Q7XHJcbn0oKSk7IiwidmFyIF8gPSByZXF1aXJlKCcuL2NvbW1vbicpLl87XHJcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xyXG52YXIgQXV0aGVudGljYXRpb25TZXR1cCA9IHJlcXVpcmUoJy4vYXV0aC9BdXRoZW50aWNhdGlvblNldHVwJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXZlcmxpdmVVcmwgPSBjb25zdGFudHMuZXZlcmxpdmVVcmw7XHJcblxyXG4gICAgLy8gQW4gb2JqZWN0IHRoYXQga2VlcHMgaW5mb3JtYXRpb24gYWJvdXQgYW4gRXZlcmxpdmUgY29ubmVjdGlvblxyXG4gICAgZnVuY3Rpb24gU2V0dXAob3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMudXJsID0gZXZlcmxpdmVVcmw7XHJcbiAgICAgICAgdGhpcy5hcGlLZXkgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubWFzdGVyS2V5ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnRva2VuID0gbnVsbDtcclxuICAgICAgICB0aGlzLnRva2VuVHlwZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5wcmluY2lwYWxJZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zY2hlbWUgPSAnaHR0cCc7IC8vIGh0dHAgb3IgaHR0cHNcclxuICAgICAgICB0aGlzLnBhcnNlT25seUNvbXBsZXRlRGF0ZVRpbWVPYmplY3RzID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0aGlzLmFwaUtleSA9IG9wdGlvbnM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fZW11bGF0b3JNb2RlID0gb3B0aW9ucy5lbXVsYXRvck1vZGU7XHJcbiAgICAgICAgICAgIF8uZXh0ZW5kKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5hdXRoZW50aWNhdGlvbiA9IG5ldyBBdXRoZW50aWNhdGlvblNldHVwKHRoaXMsIG9wdGlvbnMuYXV0aGVudGljYXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIFNldHVwLnByb3RvdHlwZS5zZXRBdXRob3JpemF0aW9uUHJvcGVydGllcyA9IGZ1bmN0aW9uICh0b2tlbiwgdG9rZW5UeXBlLCBwcmluY2lwYWxJZCkge1xyXG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcclxuICAgICAgICB0aGlzLnRva2VuVHlwZSA9IHRva2VuVHlwZTtcclxuICAgICAgICB0aGlzLnByaW5jaXBhbElkID0gcHJpbmNpcGFsSWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIFNldHVwLnByb3RvdHlwZS5nZXRBdXRob3JpemF0aW9uUHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0b2tlbjogdGhpcy50b2tlbixcclxuICAgICAgICAgICAgdG9rZW5UeXBlOiB0aGlzLnRva2VuVHlwZSxcclxuICAgICAgICAgICAgcHJpbmNpcGFsSWQ6IHRoaXMucHJpbmNpcGFsSWRcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gU2V0dXA7XHJcblxyXG59KCkpOyIsIid1c2Ugc3RyaWN0JztcclxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcclxudmFyIERhdGFRdWVyeSA9IHJlcXVpcmUoJy4uL3F1ZXJ5L0RhdGFRdWVyeScpO1xyXG52YXIgUmVxdWVzdCA9IHJlcXVpcmUoJy4uL1JlcXVlc3QnKTtcclxudmFyIEV2ZXJsaXZlID0gcmVxdWlyZSgnLi4vRXZlcmxpdmUnKTtcclxudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpO1xyXG52YXIgdXNlcnNDb2xsZWN0aW9uTmFtZSA9ICdVc2Vycyc7XHJcbnZhciBidWlsZFByb21pc2UgPSB1dGlscy5idWlsZFByb21pc2U7XHJcbnZhciBMb2NhbFN0b3JlID0gcmVxdWlyZSgnLi4vTG9jYWxTdG9yZScpO1xyXG52YXIgRXZlcmxpdmVFcnJvcnMgPSByZXF1aXJlKCcuLi9FdmVybGl2ZUVycm9yJykuRXZlcmxpdmVFcnJvcnM7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEBjbGFzcyBBdXRoZW50aWNhdGlvblxyXG4gICAgICogQGNsYXNzZGVzYyBBIGNsYXNzIGZvciBtYW5hZ2luZyBhdXRoZW50aWNhdGlvbiBvZiBhIHVzZXIgaW4geW91ciBhcHBsaWNhdGlvbi5cclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEBwYXJhbSBlbCB7RXZlcmxpdmV9IEV2ZXJsaXZlIE9iamVjdFxyXG4gICAgICogQHBhcmFtIHNldHVwIHtBdXRoU2V0dXB9IHRoZSBhdXRoZW50aWNhdGlvbiBzZXR1cCBvYmplY3RcclxuICAgICAqL1xyXG4gICAgdmFyIEF1dGhlbnRpY2F0aW9uID0gZnVuY3Rpb24gKGVsLCBzZXR1cCkge1xyXG4gICAgICAgIHRoaXMuYXV0aFNldHVwID0gc2V0dXAgfHwge307XHJcbiAgICAgICAgdGhpcy5fZWwgPSBlbDtcclxuICAgICAgICB0aGlzLl9hdXRoZW50aWNhdGlvbkNhbGxiYWNrcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fbG9jYWxTdG9yZSA9IG5ldyBMb2NhbFN0b3JlKGVsKTtcclxuICAgICAgICBpZiAodGhpcy5hdXRoU2V0dXAucGVyc2lzdCkge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBsb2NhbFN0b3JlS2V5ID0gdGhpcy5fZ2V0TG9jYWxTdG9yZUtleSgpO1xyXG4gICAgICAgICAgICB2YXIgYXV0aE9wdGlvbnMgPSB0aGlzLl9sb2NhbFN0b3JlLmdldEl0ZW0obG9jYWxTdG9yZUtleSk7XHJcbiAgICAgICAgICAgIHZhciBhdXRoSW5mbztcclxuICAgICAgICAgICAgaWYgKGF1dGhPcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBhdXRoSW5mbyA9IEpTT04ucGFyc2UodGhpcy5fbG9jYWxTdG9yZS5nZXRJdGVtKGxvY2FsU3RvcmVLZXkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYXV0aEluZm8pIHtcclxuICAgICAgICAgICAgICAgIHNlbGYuX2VsLnNldHVwLnNldEF1dGhvcml6YXRpb25Qcm9wZXJ0aWVzKGF1dGhJbmZvLnRva2VuLCBhdXRoSW5mby50b2tlblR5cGUsIGF1dGhJbmZvLnByaW5jaXBhbElkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogTG9ncyBpbiBhIHVzZXIgdXNpbmcgYSB1c2VybmFtZSBhbmQgYSBwYXNzd29yZCB0byB0aGUgY3VycmVudCB7e3NpdGUuYnN9fSBKYXZhU2NyaXB0IFNESyBpbnN0YW5jZS4gQWxsIHJlcXVlc3RzIGluaXRpYXRlZCBieSB0aGUgY3VycmVudCB7e3NpdGUuYnN9fSBKYXZhU2NyaXB0IFNESyBpbnN0YW5jZSB3aWxsIGJlIGF1dGhlbnRpY2F0ZWQgd2l0aCB0aGF0IHVzZXIncyBjcmVkZW50aWFscy5cclxuICAgICAqIEBtZW1iZXJPZiBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbG9naW5cclxuICAgICAqIEBuYW1lIGxvZ2luXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcm5hbWUgVGhlIHVzZXIncyB1c2VybmFtZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgdXNlcidzIHBhc3N3b3JkLlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBMb2dzIGluIGEgdXNlciB1c2luZyBhIHVzZXJuYW1lIGFuZCBhIHBhc3N3b3JkIHRvIHRoZSBjdXJyZW50IHt7c2l0ZS5ic319IEphdmFTY3JpcHQgU0RLIGluc3RhbmNlLiBBbGwgcmVxdWVzdHMgaW5pdGlhdGVkIGJ5IHRoZSBjdXJyZW50IHt7c2l0ZS5ic319IEphdmFTY3JpcHQgU0RLIGluc3RhbmNlIHdpbGwgYmUgYXV0aGVudGljYXRlZCB3aXRoIHRoYXQgdXNlcidzIGNyZWRlbnRpYWxzLlxyXG4gICAgICogQG1lbWJlck9mIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsb2dpblxyXG4gICAgICogQG5hbWUgbG9naW5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VybmFtZSBUaGUgdXNlcidzIHVzZXJuYW1lLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSB1c2VyJ3MgcGFzc3dvcmQuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgQXV0aGVudGljYXRpb24ucHJvdG90eXBlLmxvZ2luID0gZnVuY3Rpb24gKHVzZXJuYW1lLCBwYXNzd29yZCwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIHN1Y2Nlc3NGdW5jID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5fbG9naW5TdWNjZXNzLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB2YXIgcXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcclxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXNlckxvZ2luLFxyXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbk5hbWU6IHVzZXJzQ29sbGVjdGlvbk5hbWUsXHJcbiAgICAgICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXNlcm5hbWU6IHVzZXJuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkOiBwYXNzd29yZCxcclxuICAgICAgICAgICAgICAgICAgICBncmFudF90eXBlOiAncGFzc3dvcmQnXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc2tpcEF1dGg6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IHN1Y2Nlc3NGdW5jLFxyXG4gICAgICAgICAgICAgICAgb25FcnJvcjogZXJyb3JcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fZWwuVXNlcnMucHJvY2Vzc0RhdGFRdWVyeShxdWVyeSk7XHJcbiAgICAgICAgfSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExvZyBvdXQgdGhlIHVzZXIgd2hvIGlzIGN1cnJlbnRseSBsb2dnZWQgaW4uXHJcbiAgICAgKiBAbWVtYmVyT2YgQXV0aGVudGljYXRpb24ucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxvZ291dFxyXG4gICAgICogQG5hbWUgbG9nb3V0XHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIExvZyBvdXQgdGhlIHVzZXIgd2hvIGlzIGN1cnJlbnRseSBsb2dnZWQgaW4uXHJcbiAgICAgKiBAbWVtYmVyT2YgQXV0aGVudGljYXRpb24ucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxvZ291dFxyXG4gICAgICogQG5hbWUgbG9nb3V0XHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgQXV0aGVudGljYXRpb24ucHJvdG90eXBlLmxvZ291dCA9IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgc3VjY2Vzc0Z1bmMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl9sb2dvdXRTdWNjZXNzLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB2YXIgZXJyb3JGdW5jID0gZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVyci5jb2RlID09PSAzMDEpIHsgLy9pbnZhbGlkIHRva2VuXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jbGVhckF1dGhvcml6YXRpb24oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBlcnJvci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJMb2dvdXQsXHJcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogdXNlcnNDb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgIHNraXBBdXRoOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgb25TdWNjZXNzOiBzdWNjZXNzRnVuYyxcclxuICAgICAgICAgICAgICAgIG9uRXJyb3I6IGVycm9yRnVuY1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9lbC5Vc2Vycy5wcm9jZXNzRGF0YVF1ZXJ5KHF1ZXJ5KTtcclxuICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS5fZ2V0TG9jYWxTdG9yZUtleSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gY29uc3RhbnRzLkF1dGhTdG9yZUtleSArIHRoaXMuX2VsLnNldHVwLmFwaUtleSArICckYXV0aGVudGljYXRpb24nO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExvZyBpbiBhIHVzZXIgdXNpbmcgYW4gRmFjZWJvb2sgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQG1lbWJlck9mIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsb2dpbldpdGhGYWNlYm9va1xyXG4gICAgICogQG5hbWUgbG9naW5XaXRoRmFjZWJvb2tcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBGYWNlYm9vayBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIExvZyBpbiBhIHVzZXIgdXNpbmcgYW4gRmFjZWJvb2sgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQG1lbWJlck9mIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsb2dpbldpdGhGYWNlYm9va1xyXG4gICAgICogQG5hbWUgbG9naW5XaXRoRmFjZWJvb2tcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBGYWNlYm9vayBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgQXV0aGVudGljYXRpb24ucHJvdG90eXBlLmxvZ2luV2l0aEZhY2Vib29rID0gZnVuY3Rpb24gKGFjY2Vzc1Rva2VuLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHZhciBpZGVudGl0eSA9IHtcclxuICAgICAgICAgICAgUHJvdmlkZXI6ICdGYWNlYm9vaycsXHJcbiAgICAgICAgICAgIFRva2VuOiBhY2Nlc3NUb2tlblxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ2luV2l0aFByb3ZpZGVyKGlkZW50aXR5LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9nIGluIGEgdXNlciB1c2luZyBhbiBBREZTIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBtZW1iZXJPZiBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbG9naW5XaXRoQURGU1xyXG4gICAgICogQG5hbWUgbG9naW5XaXRoQURGU1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY2Vzc1Rva2VuIEFERlMgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgaW4gYSB1c2VyIHVzaW5nIGFuIEFERlMgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQG1lbWJlck9mIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsb2dpbldpdGhBREZTXHJcbiAgICAgKiBAbmFtZSBsb2dpbldpdGhBREZTXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gQURGUyBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgQXV0aGVudGljYXRpb24ucHJvdG90eXBlLmxvZ2luV2l0aEFERlMgPSBmdW5jdGlvbiAoYWNjZXNzVG9rZW4sIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdmFyIGlkZW50aXR5ID0ge1xyXG4gICAgICAgICAgICBQcm92aWRlcjogJ0FERlMnLFxyXG4gICAgICAgICAgICBUb2tlbjogYWNjZXNzVG9rZW5cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dpbldpdGhQcm92aWRlcihpZGVudGl0eSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExvZyBpbiBhIHVzZXIgdXNpbmcgYSBMaXZlSUQgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQG1lbWJlck9mIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsb2dpbldpdGhMaXZlSURcclxuICAgICAqIEBuYW1lIGxvZ2luV2l0aExpdmVJRFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY2Vzc1Rva2VuIExpdmVJRCBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIExvZyBpbiBhIHVzZXIgdXNpbmcgYSBMaXZlSUQgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQG1lbWJlck9mIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsb2dpbldpdGhMaXZlSURcclxuICAgICAqIEBuYW1lIGxvZ2luV2l0aExpdmVJRFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY2Vzc1Rva2VuIExpdmVJRCBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgQXV0aGVudGljYXRpb24ucHJvdG90eXBlLmxvZ2luV2l0aExpdmVJRCA9IGZ1bmN0aW9uIChhY2Nlc3NUb2tlbiwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB2YXIgaWRlbnRpdHkgPSB7XHJcbiAgICAgICAgICAgIFByb3ZpZGVyOiAnTGl2ZUlEJyxcclxuICAgICAgICAgICAgVG9rZW46IGFjY2Vzc1Rva2VuXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9naW5XaXRoUHJvdmlkZXIoaWRlbnRpdHksIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgaW4gYSB1c2VyIHVzaW5nIGEgR29vZ2xlIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBtZW1iZXJPZiBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbG9naW5XaXRoR29vZ2xlXHJcbiAgICAgKiBAbmFtZSBsb2dpbldpdGhHb29nbGVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBHb29nbGUgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgaW4gYSB1c2VyIHVzaW5nIGEgR29vZ2xlIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBtZW1iZXJPZiBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbG9naW5XaXRoR29vZ2xlXHJcbiAgICAgKiBAbmFtZSBsb2dpbldpdGhHb29nbGVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBHb29nbGUgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS5sb2dpbldpdGhHb29nbGUgPSBmdW5jdGlvbiAoYWNjZXNzVG9rZW4sIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdmFyIGlkZW50aXR5ID0ge1xyXG4gICAgICAgICAgICBQcm92aWRlcjogJ0dvb2dsZScsXHJcbiAgICAgICAgICAgIFRva2VuOiBhY2Nlc3NUb2tlblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dpbldpdGhQcm92aWRlcihpZGVudGl0eSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExvZyBpbiBhIHVzZXIgd2l0aCBhIFR3aXR0ZXIgdG9rZW4uIEEgc2VjcmV0IHRva2VuIG5lZWRzIHRvIGJlIHByb3ZpZGVkLlxyXG4gICAgICogQG1lbWJlck9mIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsb2dpbldpdGhUd2l0dGVyXHJcbiAgICAgKiBAbmFtZSBsb2dpbldpdGhUd2l0dGVyXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gVHdpdHRlciB0b2tlbi5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlblNlY3JldCBUd2l0dGVyIHNlY3JldCB0b2tlbi5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogTG9nIGluIGEgdXNlciB3aXRoIGEgVHdpdHRlciB0b2tlbi4gQSBzZWNyZXQgdG9rZW4gbmVlZHMgdG8gYmUgcHJvdmlkZWQuXHJcbiAgICAgKiBAbWVtYmVyT2YgQXV0aGVudGljYXRpb24ucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxvZ2luV2l0aFR3aXR0ZXJcclxuICAgICAqIEBuYW1lIGxvZ2luV2l0aFR3aXR0ZXJcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBUd2l0dGVyIHRva2VuLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuU2VjcmV0IFR3aXR0ZXIgc2VjcmV0IHRva2VuLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS5sb2dpbldpdGhUd2l0dGVyID0gZnVuY3Rpb24gKHRva2VuLCB0b2tlblNlY3JldCwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB2YXIgaWRlbnRpdHkgPSB7XHJcbiAgICAgICAgICAgIFByb3ZpZGVyOiAnVHdpdHRlcicsXHJcbiAgICAgICAgICAgIFRva2VuOiB0b2tlbixcclxuICAgICAgICAgICAgVG9rZW5TZWNyZXQ6IHRva2VuU2VjcmV0XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ2luV2l0aFByb3ZpZGVyKGlkZW50aXR5LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgdG9rZW4gYW5kIHRva2VuIHR5cGUgdGhhdCB0aGUge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSBKYXZhU2NyaXB0IFNESyB3aWxsIHVzZSBmb3IgYXV0aG9yaXphdGlvbi5cclxuICAgICAqIEBtZW1iZXJPZiBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2Qgc2V0QXV0aG9yaXphdGlvblxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIFRva2VuIHRoYXQgd2lsbCBiZSB1c2VkIGZvciBhdXRob3JpemF0aW9uLlxyXG4gICAgICogQHBhcmFtIHtFdmVybGl2ZS5Ub2tlblR5cGV9IHRva2VuVHlwZSBUb2tlbiB0eXBlLiBDdXJyZW50bHkgb25seSAnYmVhcmVyJyB0b2tlbiBpcyBzdXBwb3J0ZWQuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJpbmNpcGFsSWQgVGhlIGlkIG9mIHRoZSB1c2VyIHRoYXQgaXMgbG9nZ2VkIGluLlxyXG4gICAgICovXHJcbiAgICBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGUuc2V0QXV0aG9yaXphdGlvbiA9IGZ1bmN0aW9uIHNldEF1dGhvcml6YXRpb24odG9rZW4sIHRva2VuVHlwZSwgcHJpbmNpcGFsSWQpIHtcclxuICAgICAgICB0aGlzLl9lbC5zZXR1cC5zZXRBdXRob3JpemF0aW9uUHJvcGVydGllcyh0b2tlbiwgdG9rZW5UeXBlLCBwcmluY2lwYWxJZCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmF1dGhTZXR1cC5wZXJzaXN0KSB7XHJcbiAgICAgICAgICAgIHZhciBsb2NhbFN0b3JlS2V5ID0gdGhpcy5fZ2V0TG9jYWxTdG9yZUtleSgpO1xyXG4gICAgICAgICAgICB2YXIgYXV0aG9yaXphdGlvblByb3BlcnRpZXMgPSB0aGlzLl9lbC5zZXR1cC5nZXRBdXRob3JpemF0aW9uUHJvcGVydGllcygpO1xyXG4gICAgICAgICAgICB0aGlzLl9sb2NhbFN0b3JlLnNldEl0ZW0obG9jYWxTdG9yZUtleSwgSlNPTi5zdHJpbmdpZnkoYXV0aG9yaXphdGlvblByb3BlcnRpZXMpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9hdXRoZW50aWNhdGlvbkNhbGxiYWNrcykge1xyXG4gICAgICAgICAgICB0aGlzLl9hdXRoZW50aWNhdGlvbkNhbGxiYWNrcy5zdWNjZXNzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2F1dGhlbnRpY2F0aW9uQ2FsbGJhY2tzID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIHRoZSBhdXRoZW50aWNhdGlvbiB0b2tlbiB0aGF0IHRoZSB7e3NpdGUuYnN9fSBKYXZhU2NyaXB0IFNESyBjdXJyZW50bHkgdXNlcy4gTm90ZSB0aGF0IHRoaXMgaXMgZGlmZmVyZW50IHRoYW4gbG9nZ2luZyBvdXQsIGJlY2F1c2UgdGhlIGF1dGhvcml6YXRpb24gdG9rZW4gdGhhdCB3YXMgdXNlZCwgd2lsbCBub3QgYmUgaW52YWxpZGF0ZWQuXHJcbiAgICAgKiBAbWV0aG9kIGNsZWFyQXV0aG9yaXphdGlvblxyXG4gICAgICogQG1lbWJlck9mIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZVxyXG4gICAgICovXHJcbiAgICBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGUuY2xlYXJBdXRob3JpemF0aW9uID0gZnVuY3Rpb24gY2xlYXJBdXRob3JpemF0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuc2V0QXV0aG9yaXphdGlvbihudWxsLCBudWxsLCBudWxsKTtcclxuICAgICAgICB0aGlzLmNsZWFyUGVyc2lzdGVkQXV0aGVudGljYXRpb24oKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgdGhlIGN1cnJlbnQgcGVyc2lzdGVkIGF1dGhlbnRpY2F0aW9uIGZyb20gdGhlIGxvY2FsIHN0b3JlIGZvciB0aGUgY3VycmVudCB7e3NpdGUuYnN9fSBKYXZhU2NyaXB0IFNESyBpbnN0YW5jZS4gV2lsbCBub3QgbG9nb3V0IG9yIG1vZGlmeSB0aGUgY3VycmVudCBhdXRoZW50aWNhdGlvbiBvZiB0aGUgSmF2YXNjcmlwdCBTREsuXHJcbiAgICAgKiBAbWV0aG9kIGNsZWFyUGVyc2lzdGVkQXV0aGVudGljYXRpb25cclxuICAgICAqIEBtZW1iZXJPZiBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGVcclxuICAgICAqL1xyXG4gICAgQXV0aGVudGljYXRpb24ucHJvdG90eXBlLmNsZWFyUGVyc2lzdGVkQXV0aGVudGljYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2xvY2FsU3RvcmUpIHtcclxuICAgICAgICAgICAgdmFyIGxvY2FsU3RvcmVLZXkgPSB0aGlzLl9nZXRMb2NhbFN0b3JlS2V5KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvY2FsU3RvcmUucmVtb3ZlSXRlbShsb2NhbFN0b3JlS2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlck9mIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZVxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIGF1dGhlbnRpY2F0aW9uIHJlcXVpcmVtZW50IGlzIGVuYWJsZWQgZm9yIHRoZSBjdXJyZW50IGluc3RhbmNlIG9mIHRoZSB7e3NpdGUuYnN9fSBKYXZhU2NyaXB0IFNESy5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIGFuIG9uQXV0aGVudGljYXRpb25SZXF1aXJlZCBmdW5jdGlvbiBpcyBwcm92aWRlZFxyXG4gICAgICovXHJcbiAgICBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGUuaXNBdXRoZW50aWNhdGlvbkluUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLmF1dGhTZXR1cC5vbkF1dGhlbnRpY2F0aW9uUmVxdWlyZWQgPT09ICdmdW5jdGlvbic7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKiBFbnN1cmVzIHRoYXQgYXV0aGVudGljYXRpb24gaXMgY29tcGxldGVkIGJlZm9yZSBjb250aW51aW5nLlxyXG4gICAgICogQG1lbWJlck9mIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdoZW4gdGhlIGF1dGhlbnRpY2F0aW9uIGlzIGNvbXBsZXRlLiBTZWUge3tAbGluayBFdmVybGl2ZS5wcm90b3R5cGUuY29tcGxldGVBdXRoZW50aWNhdGlvbn19LlxyXG4gICAgICogQHRocm93cyB0aHJvd3MgYW4gZXJyb3IgaWYgbm8gb25BdXRoZW50aWNhdGlvblJlcXVpcmVkIGhhbmRsZXIgaXMgcHJvdmlkZWQgdG8gdGhlIHNldHVwLlxyXG4gICAgICovXHJcbiAgICBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGUuX2Vuc3VyZUF1dGhlbnRpY2F0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0F1dGhlbnRpY2F0aW9uSW5Qcm9ncmVzcygpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb25BdXRoZW50aWNhdGlvblJlcXVpcmVkIG9wdGlvbiBvZiBFdmVybGl2ZS5TZXR1cC5BdXRoZW50aWNhdGlvbiBpcyByZXF1aXJlZC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNBdXRoZW50aWNhdGluZygpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hdXRoZW50aWNhdGlvbkNhbGxiYWNrcy5wcm9taXNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNsZWFyQXV0aG9yaXphdGlvbigpO1xyXG4gICAgICAgIHRoaXMuYXV0aFNldHVwLm9uQXV0aGVudGljYXRpb25SZXF1aXJlZC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX2F1dGhlbnRpY2F0aW9uQ2FsbGJhY2tzID0gdXRpbHMuZ2V0Q2FsbGJhY2tzKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F1dGhlbnRpY2F0aW9uQ2FsbGJhY2tzLnByb21pc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBtZXRob2QgdGhhdCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGF1dGhlbnRpY2F0aW9uIHJlc3VsdC5cclxuICAgICAqIEBtZW1iZXJPZiBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGVcclxuICAgICAqIEBwYXJhbSBhdXRoZW50aWNhdGlvbiBhdXRoZW50aWNhdGlvbiBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGVcclxuICAgICAqIEBwYXJhbSBhdXRoZW50aWNhdGlvbi5hY2Nlc3NfdG9rZW5cclxuICAgICAqIEBwYXJhbSBhdXRoZW50aWNhdGlvbi50b2tlbl90eXBlXHJcbiAgICAgKiBAcGFyYW0gYXV0aGVudGljYXRpb24ucHJpbmNpcGFsX2lkXHJcbiAgICAgKi9cclxuICAgIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS5jb21wbGV0ZUF1dGhlbnRpY2F0aW9uID0gZnVuY3Rpb24gKGF1dGhlbnRpY2F0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5fZWwuc2V0QXV0aG9yaXphdGlvbihhdXRoZW50aWNhdGlvbi5hY2Nlc3NfdG9rZW4sIGF1dGhlbnRpY2F0aW9uLnRva2VuX3R5cGUsIGF1dGhlbnRpY2F0aW9uLnByaW5jaXBhbF9pZCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IGF1dGhlbnRpY2F0aW9uIHN0YXR1cyBvZiB0aGUge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSBKYXZhU2NyaXB0IFNESyBpbnN0YW5jZS5cclxuICAgICAqIEBtZW1iZXJPZiBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgZ2V0QXV0aGVudGljYXRpb25TdGF0dXNcclxuICAgICAqIEBuYW1lIGdldEF1dGhlbnRpY2F0aW9uU3RhdHVzXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBwcm9taXNlIHRvIHRoZSBhdXRoZW50aWNhdGlvbiBzdGF0dXMuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBhdXRoZW50aWNhdGlvbiBzdGF0dXMgb2YgdGhlIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gSmF2YVNjcmlwdCBTREsgaW5zdGFuY2UuXHJcbiAgICAgKiBAbWVtYmVyT2YgQXV0aGVudGljYXRpb24ucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGdldEF1dGhlbnRpY2F0aW9uU3RhdHVzXHJcbiAgICAgKiBAbmFtZSBnZXRBdXRoZW50aWNhdGlvblN0YXR1c1xyXG4gICAgICogQHBhcmFtIHtFdmVybGl2ZS5DYWxsYmFja3MuYXV0aGVudGljYXRpb25TdGF0dXNTdWNjZXNzfSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgQXV0aGVudGljYXRpb24ucHJvdG90eXBlLmdldEF1dGhlbnRpY2F0aW9uU3RhdHVzID0gZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB1dGlscy5idWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBzZXR1cCA9IHNlbGYuX2VsLnNldHVwO1xyXG4gICAgICAgICAgICBpZiAoc2V0dXAubWFzdGVyS2V5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VjY2Vzcyh7c3RhdHVzOiBjb25zdGFudHMuQXV0aFN0YXR1cy5tYXN0ZXJLZXl9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFzZXR1cC50b2tlbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3Moe3N0YXR1czogY29uc3RhbnRzLkF1dGhTdGF0dXMudW5hdXRoZW50aWNhdGVkfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzZWxmLmlzQXV0aGVudGljYXRpb25JblByb2dyZXNzKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdWNjZXNzKHtzdGF0dXM6IGNvbnN0YW50cy5BdXRoU3RhdHVzLmF1dGhlbnRpY2F0aW5nfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHNlbGYuX2VsLlVzZXJzXHJcbiAgICAgICAgICAgICAgICAuc2tpcEF1dGgodHJ1ZSlcclxuICAgICAgICAgICAgICAgIC5jdXJyZW50VXNlcigpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3Moe3N0YXR1czogY29uc3RhbnRzLkF1dGhTdGF0dXMuYXV0aGVudGljYXRlZCwgdXNlcjogcmVzLnJlc3VsdH0pO1xyXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmlzQXV0aGVudGljYXRpb25JblByb2dyZXNzKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3Moe3N0YXR1czogY29uc3RhbnRzLkF1dGhTdGF0dXMuYXV0aGVudGljYXRpbmd9KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVyci5jb2RlID09PSBFdmVybGl2ZUVycm9ycy5pbnZhbGlkUmVxdWVzdC5jb2RlIHx8IGVyci5jb2RlID09PSBFdmVybGl2ZUVycm9ycy5pbnZhbGlkVG9rZW4uY29kZSkgeyAvLyBpbnZhbGlkIHJlcXVlc3QsIGkuZS4gdGhlIGFjY2VzcyB0b2tlbiBpcyBpbnZhbGlkIG9yIG1pc3NpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3Moe3N0YXR1czogY29uc3RhbnRzLkF1dGhTdGF0dXMuaW52YWxpZEF1dGhlbnRpY2F0aW9ufSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlcnIuY29kZSA9PT0gRXZlcmxpdmVFcnJvcnMuZXhwaXJlZFRva2VuLmNvZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3Moe3N0YXR1czogY29uc3RhbnRzLkF1dGhTdGF0dXMuZXhwaXJlZEF1dGhlbnRpY2F0aW9ufSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKiogUmV0dXJucyB3aGV0aGVyIHRoZSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IGlzIGN1cnJlbnRseSB3YWl0aW5nIGZvciBhdXRoZW50aWNhdGlvbiB0byBiZSBjb21wbGV0ZWQuIFNlZSB7e0BsaW5rIEV2ZXJsaXZlLnByb3RvdHlwZS5jb21wbGV0ZUF1dGhlbnRpY2F0aW9ufX0uXHJcbiAgICAgKiBAbWVtYmVyT2YgRXZlcmxpdmUucHJvdG90eXBlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgQXV0aGVudGljYXRpb24ucHJvdG90eXBlLmlzQXV0aGVudGljYXRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fYXV0aGVudGljYXRpb25DYWxsYmFja3M7XHJcbiAgICB9O1xyXG5cclxuICAgIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS5fbG9naW5TdWNjZXNzID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gZGF0YS5yZXN1bHQ7XHJcbiAgICAgICAgdGhpcy5zZXRBdXRob3JpemF0aW9uKHJlc3VsdC5hY2Nlc3NfdG9rZW4sIHJlc3VsdC50b2tlbl90eXBlLCByZXN1bHQucHJpbmNpcGFsX2lkKTtcclxuICAgIH07XHJcblxyXG4gICAgQXV0aGVudGljYXRpb24ucHJvdG90eXBlLl9sb2dvdXRTdWNjZXNzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY2xlYXJBdXRob3JpemF0aW9uKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS5fbG9naW5XaXRoUHJvdmlkZXIgPSBmdW5jdGlvbiAoaWRlbnRpdHksIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdmFyIHVzZXIgPSB7XHJcbiAgICAgICAgICAgIElkZW50aXR5OiBpZGVudGl0eVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBidWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBzdWNjZXNzRnVuYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHNlbGYuX2xvZ2luU3VjY2Vzcy5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgc3VjY2Vzcy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJMb2dpbldpdGhQcm92aWRlcixcclxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiB1c2Vyc0NvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgZGF0YTogdXNlcixcclxuICAgICAgICAgICAgICAgIGF1dGhIZWFkZXJzOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHNraXBBdXRoOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgcGFyc2U6IFJlcXVlc3QucGFyc2Vycy5zaW5nbGUsXHJcbiAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IHN1Y2Nlc3NGdW5jLFxyXG4gICAgICAgICAgICAgICAgb25FcnJvcjogZXJyb3JcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBzZWxmLl9lbC5Vc2Vycy5wcm9jZXNzRGF0YVF1ZXJ5KHF1ZXJ5KTtcclxuICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBBdXRoZW50aWNhdGlvbjtcclxufSgpKTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xyXG52YXIgQXV0aGVudGljYXRpb25TZXR1cCA9IGZ1bmN0aW9uIChldmVybGl2ZSwgb3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICB0aGlzLm9uQXV0aGVudGljYXRpb25SZXF1aXJlZCA9IG9wdGlvbnMub25BdXRoZW50aWNhdGlvblJlcXVpcmVkO1xyXG4gICAgdGhpcy5wZXJzaXN0ID0gb3B0aW9ucy5wZXJzaXN0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBdXRoZW50aWNhdGlvblNldHVwOyIsIm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBjb21tb24gPSB7fTtcclxuXHJcbiAgICB2YXIgcGxhdGZvcm0gPSByZXF1aXJlKCcuL2V2ZXJsaXZlLnBsYXRmb3JtJyk7XHJcbiAgICB2YXIgaXNOYXRpdmVTY3JpcHQgPSBwbGF0Zm9ybS5pc05hdGl2ZVNjcmlwdDtcclxuICAgIHZhciBpc05vZGVqcyA9IHBsYXRmb3JtLmlzTm9kZWpzO1xyXG5cclxuICAgIGlmICghaXNOb2RlanMgJiYgIWlzTmF0aXZlU2NyaXB0KSB7XHJcbiAgICAgICAgY29tbW9uLnJlcXdlc3QgPSByZXF1aXJlKCdyZXF3ZXN0Jyk7XHJcbiAgICB9IGVsc2UgaWYgKGlzTmF0aXZlU2NyaXB0KSB7XHJcbiAgICAgICAgY29tbW9uLnJvb3QgPSBnbG9iYWw7XHJcbiAgICAgICAgY29tbW9uLnJlcXdlc3QgPSByZXF1aXJlKCcuL3JlcXdlc3QubmF0aXZlc2NyaXB0Jyk7XHJcbiAgICB9IGVsc2UgaWYgKGlzTm9kZWpzKSB7XHJcbiAgICAgICAgY29tbW9uLnJvb3QgPSBnbG9iYWw7XHJcbiAgICAgICAgY29tbW9uLnJlcXdlc3QgPSByZXF1aXJlKCcuL3JlcXdlc3Qubm9kZWpzJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFjb21tb24ucm9vdCkge1xyXG4gICAgICAgIC8vYnJvd3Nlci9yZXF1aXJlanMvY29yZG92YVxyXG4gICAgICAgIGNvbW1vbi5yb290ID0gd2luZG93O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBlbnN1cmVEZXBlbmRlbmN5ID0gZnVuY3Rpb24gZW5zdXJlRGVwZW5kZW5jeShnbG9iYWxOYW1lLCBsb2NhbE5hbWUpIHtcclxuICAgICAgICBpZiAoIWxvY2FsTmFtZSkge1xyXG4gICAgICAgICAgICBsb2NhbE5hbWUgPSBnbG9iYWxOYW1lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFPYmplY3Qua2V5cyhjb21tb25bbG9jYWxOYW1lXSkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvbW1vbltsb2NhbE5hbWVdID0gY29tbW9uLnJvb3RbZ2xvYmFsTmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvL2ZvciB0aGUgZXZlcmxpdmUgYnVuZGxlIHdpdGhvdXQgZGVwZW5kZW5jaWVzIGluY2x1ZGVkIGJyb3dzZXJpZnkgcmVwbGFjZXMgdGhlbSB3aXRoIGVtcHR5IG9iamVjdHNcclxuICAgIGNvbW1vbi5fID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xyXG4gICAgZW5zdXJlRGVwZW5kZW5jeSgnXycpO1xyXG5cclxuICAgIGNvbW1vbi5qc3R6ID0gcmVxdWlyZSgnanN0aW1lem9uZWRldGVjdCcpLmpzdHo7XHJcbiAgICBlbnN1cmVEZXBlbmRlbmN5KCdqc3R6Jyk7XHJcblxyXG4gICAgY29tbW9uLm1vbmdvUXVlcnkgPSByZXF1aXJlKCdtb25nby1xdWVyeScpO1xyXG4gICAgZW5zdXJlRGVwZW5kZW5jeSgnbW9uZ29RdWVyeScpO1xyXG5cclxuICAgIGNvbW1vbi5NaW5nbyA9IHJlcXVpcmUoJ21pbmdvJyk7XHJcbiAgICBlbnN1cmVEZXBlbmRlbmN5KCdNaW5nbycpO1xyXG5cclxuICAgIGNvbW1vbi51dWlkID0gcmVxdWlyZSgndXVpZCcpO1xyXG4gICAgZW5zdXJlRGVwZW5kZW5jeSgndXVpZCcpO1xyXG5cclxuICAgIGNvbW1vbi5Qcm9jZXNzb3IgPSByZXF1aXJlKCcuLi9zY3JpcHRzL2JzLWV4cGFuZC1wcm9jZXNzb3InKTtcclxuICAgIGVuc3VyZURlcGVuZGVuY3koJ1Byb2Nlc3NvcicpO1xyXG5cclxuICAgIGNvbW1vbi5yc3ZwID0gcmVxdWlyZSgncnN2cCcpO1xyXG4gICAgZW5zdXJlRGVwZW5kZW5jeSgnUlNWUCcsICdyc3ZwJyk7XHJcblxyXG4gICAgaWYgKCFpc05vZGVqcyAmJiAhaXNOYXRpdmVTY3JpcHQpIHtcclxuICAgICAgICBlbnN1cmVEZXBlbmRlbmN5KCdyZXF3ZXN0Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNvbW1vbjtcclxufSgpKTsiLCJ2YXIgY29uc3RhbnRzID0ge1xyXG4gICAgaWRGaWVsZDogJ0lkJyxcclxuICAgIGd1aWRFbXB0eTogJzAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCcsXHJcbiAgICBldmVybGl2ZVVybDogJy8vYXBpLmV2ZXJsaXZlLmNvbS92MS8nLFxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGNsYXNzIHVzZWQgdG8gcmVwcmVzZW50IHRoZSBjb25mbGljdCByZXNvbHV0aW9uIHN0cmF0ZWdpZXMuXHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gQ2xpZW50V2luc1xyXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFNlcnZlcldpbnNcclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBDdXN0b21cclxuICAgICAqIEB0eXBlZGVmIHtzdHJpbmd9IEV2ZXJsaXZlLkNvbmZsaWN0UmVzb2x1dGlvblN0cmF0ZWd5XHJcbiAgICAgKi9cclxuICAgIENvbmZsaWN0UmVzb2x1dGlvblN0cmF0ZWd5OiB7XHJcbiAgICAgICAgQ2xpZW50V2luczogJ2NsaWVudFdpbnMnLFxyXG4gICAgICAgIFNlcnZlcldpbnM6ICdzZXJ2ZXJXaW5zJyxcclxuICAgICAgICBDdXN0b206ICdjdXN0b20nXHJcbiAgICB9LFxyXG4gICAgQ29uZmxpY3RSZXNvbHV0aW9uOiB7XHJcbiAgICAgICAgS2VlcFNlcnZlcjogJ2tlZXBTZXJ2ZXInLFxyXG4gICAgICAgIEtlZXBDbGllbnQ6ICdrZWVwQ2xpZW50JyxcclxuICAgICAgICBDdXN0b206ICdjdXN0b20nXHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGNsYXNzIHVzZWQgdG8gcmVwcmVzZW50IHRoZSBhdmFpbGFibGUgc3RvcmFnZSBwcm92aWRlcnMuXHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gTG9jYWxTdG9yYWdlXHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gRmlsZVN5c3RlbVxyXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IEN1c3RvbVxyXG4gICAgICogQHR5cGVkZWYge3N0cmluZ30gRXZlcmxpdmUuU3RvcmFnZVByb3ZpZGVyXHJcbiAgICAgKi9cclxuICAgIFN0b3JhZ2VQcm92aWRlcjoge1xyXG4gICAgICAgIExvY2FsU3RvcmFnZTogJ2xvY2FsU3RvcmFnZScsXHJcbiAgICAgICAgRmlsZVN5c3RlbTogJ2ZpbGVTeXN0ZW0nLFxyXG4gICAgICAgIEN1c3RvbTogJ2N1c3RvbSdcclxuICAgIH0sXHJcblxyXG4gICAgRGVmYXVsdFN0b3JhZ2VQYXRoOiAnZWxfc3RvcmUvJyxcclxuXHJcbiAgICBFbmNyeXB0aW9uUHJvdmlkZXI6IHtcclxuICAgICAgICBEZWZhdWx0OiAnZGVmYXVsdCcsXHJcbiAgICAgICAgQ3VzdG9tOiAnY3VzdG9tJ1xyXG4gICAgfSxcclxuICAgIC8vIFRoZSBoZWFkZXJzIHVzZWQgYnkgdGhlIEV2ZXJsaXZlIHNlcnZpY2VzXHJcbiAgICBIZWFkZXJzOiB7XHJcbiAgICAgICAgZmlsdGVyOiAnWC1FdmVybGl2ZS1GaWx0ZXInLFxyXG4gICAgICAgIHNlbGVjdDogJ1gtRXZlcmxpdmUtRmllbGRzJyxcclxuICAgICAgICBzb3J0OiAnWC1FdmVybGl2ZS1Tb3J0JyxcclxuICAgICAgICBza2lwOiAnWC1FdmVybGl2ZS1Ta2lwJyxcclxuICAgICAgICB0YWtlOiAnWC1FdmVybGl2ZS1UYWtlJyxcclxuICAgICAgICBleHBhbmQ6ICdYLUV2ZXJsaXZlLUV4cGFuZCcsXHJcbiAgICAgICAgc2luZ2xlRmllbGQ6ICdYLUV2ZXJsaXZlLVNpbmdsZS1GaWVsZCcsXHJcbiAgICAgICAgaW5jbHVkZUNvdW50OiAnWC1FdmVybGl2ZS1JbmNsdWRlLUNvdW50JyxcclxuICAgICAgICBwb3dlckZpZWxkczogJ1gtRXZlcmxpdmUtUG93ZXItRmllbGRzJyxcclxuICAgICAgICBkZWJ1ZzogJ1gtRXZlcmxpdmUtRGVidWcnLFxyXG4gICAgICAgIG92ZXJyaWRlU3lzdGVtRmllbGRzOiAnWC1FdmVybGl2ZS1PdmVycmlkZS1TeXN0ZW0tRmllbGRzJ1xyXG4gICAgfSxcclxuICAgIC8vQ29uc3RhbnRzIGZvciBkaWZmZXJlbnQgcGxhdGZvcm1zIGluIEV2ZXJsaXZlXHJcbiAgICBQbGF0Zm9ybToge1xyXG4gICAgICAgIFdpbmRvd3NQaG9uZTogMSxcclxuICAgICAgICBXaW5kb3dzOiAyLFxyXG4gICAgICAgIEFuZHJvaWQ6IDMsXHJcbiAgICAgICAgaU9TOiA0LFxyXG4gICAgICAgIE9TWDogNSxcclxuICAgICAgICBCbGFja2JlcnJ5OiA2LFxyXG4gICAgICAgIE5va2lhOiA3LFxyXG4gICAgICAgIFVua25vd246IDEwMFxyXG4gICAgfSxcclxuICAgIE9wZXJhdG9yVHlwZToge1xyXG4gICAgICAgIHF1ZXJ5OiAxLFxyXG5cclxuICAgICAgICB3aGVyZTogMTAwLFxyXG4gICAgICAgIGZpbHRlcjogMTAxLFxyXG5cclxuICAgICAgICBhbmQ6IDExMCxcclxuICAgICAgICBvcjogMTExLFxyXG4gICAgICAgIG5vdDogMTEyLFxyXG5cclxuICAgICAgICBlcXVhbDogMTIwLFxyXG4gICAgICAgIG5vdF9lcXVhbDogMTIxLFxyXG4gICAgICAgIGx0OiAxMjIsXHJcbiAgICAgICAgbHRlOiAxMjMsXHJcbiAgICAgICAgZ3Q6IDEyNCxcclxuICAgICAgICBndGU6IDEyNSxcclxuICAgICAgICBpc2luOiAxMjYsXHJcbiAgICAgICAgbm90aW46IDEyNyxcclxuICAgICAgICBhbGw6IDEyOCxcclxuICAgICAgICBzaXplOiAxMjksXHJcbiAgICAgICAgcmVnZXg6IDEzMCxcclxuICAgICAgICBjb250YWluczogMTMxLFxyXG4gICAgICAgIHN0YXJ0c1dpdGg6IDEzMixcclxuICAgICAgICBlbmRzV2l0aDogMTMzLFxyXG5cclxuICAgICAgICBuZWFyU2hwZXJlOiAxNDAsXHJcbiAgICAgICAgd2l0aGluQm94OiAxNDEsXHJcbiAgICAgICAgd2l0aGluUG9seWdvbjogMTQyLFxyXG4gICAgICAgIHdpdGhpblNocGVyZTogMTQzLFxyXG5cclxuICAgICAgICBzZWxlY3Q6IDIwMCxcclxuICAgICAgICBleGNsdWRlOiAyMDEsXHJcblxyXG4gICAgICAgIG9yZGVyOiAzMDAsXHJcbiAgICAgICAgb3JkZXJfZGVzYzogMzAxLFxyXG5cclxuICAgICAgICBza2lwOiA0MDAsXHJcbiAgICAgICAgdGFrZTogNDAxLFxyXG4gICAgICAgIGV4cGFuZDogNDAyXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBjbGFzcyB1c2VkIHRvIHJlcHJlc2VudCB0aGUgY3VycmVudCBhdXRoZW50aWNhdGlvbiBzdGF0dXMgb2YgdGhlIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gSmF2YVNjcmlwdCBTREsgaW5zdGFuY2UuXHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gdW5hdXRoZW50aWNhdGVkIEluZGljYXRlcyB0aGF0IG5vIHVzZXIgaXMgYXV0aGVudGljYXRlZC5cclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtYXN0ZXJLZXkgSW5kaWNhdGVzIHRoYXQgYSBtYXN0ZXIga2V5IGF1dGhlbnRpY2F0aW9uIGlzIHVzZWQuXHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gaW52YWxpZEF1dGhlbnRpY2F0aW9uIEluZGljYXRlcyBhbiBhdXRoZW50aWNhdGlvbiBoYXMgYmVlbiBhdHRlbXB0ZWQsIGJ1dCBpdCB3YXMgaW52YWxpZC5cclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhdXRoZW50aWNhdGVkIEluZGljYXRlcyB0aGF0IGEgdXNlciBpcyBhdXRoZW50aWNhdGVkLlxyXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGF1dGhlbnRpY2F0aW5nIEluZGljYXRlcyB0aGF0IGEgdXNlciBpcyBjdXJyZW50bHkgYXV0aGVudGljYXRpbmcuIFNvbWUgcmVxdWVzdHMgbWlnaHQgYmUgcGVuZGluZyBhbmQgd2FpdGluZyBmb3IgdGhlIHVzZXIgdG8gYXV0aGVudGljYXRlLlxyXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGV4cGlyZWRBdXRoZW50aWNhdGlvbiBJbmRpY2F0ZXMgdGhhdCBhIHVzZXIgaXMgY3VycmVudGx5IGF1dGhlbnRpY2F0aW5nLiBTb21lIHJlcXVlc3RzIG1pZ2h0IGJlIHBlbmRpbmcgYW5kIHdhaXRpbmcgZm9yIHRoZSB1c2VyIHRvIGF1dGhlbnRpY2F0ZS5cclxuICAgICAqIEB0eXBlZGVmIHtzdHJpbmd9IEV2ZXJsaXZlLkF1dGhTdGF0dXNcclxuICAgICAqL1xyXG4gICAgQXV0aFN0YXR1czoge1xyXG4gICAgICAgIHVuYXV0aGVudGljYXRlZDogJ3VuYXV0aGVudGljYXRlZCcsXHJcbiAgICAgICAgbWFzdGVyS2V5OiAnbWFzdGVyS2V5JyxcclxuICAgICAgICBpbnZhbGlkQXV0aGVudGljYXRpb246ICdpbnZhbGlkQXV0aGVudGljYXRpb24nLFxyXG4gICAgICAgIGF1dGhlbnRpY2F0ZWQ6ICdhdXRoZW50aWNhdGVkJyxcclxuICAgICAgICBleHBpcmVkQXV0aGVudGljYXRpb246ICdleHBpcmVkQXV0aGVudGljYXRpb24nLFxyXG4gICAgICAgIGF1dGhlbnRpY2F0aW5nOiAnYXV0aGVudGljYXRpbmcnXHJcbiAgICB9LFxyXG4gICAgb2ZmbGluZUl0ZW1TdGF0ZXM6IHtcclxuICAgICAgICBjcmVhdGVkOiAnY3JlYXRlZCcsXHJcbiAgICAgICAgbW9kaWZpZWQ6ICdtb2RpZmllZCcsXHJcbiAgICAgICAgZGVsZXRlZDogJ2RlbGV0ZWQnXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSFRUUCBNZXRob2RzXHJcbiAgICAgKiBAZW51bSB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICBIdHRwTWV0aG9kOiB7XHJcbiAgICAgICAgR0VUOiAnR0VUJyxcclxuICAgICAgICBQT1NUOiAnUE9TVCcsXHJcbiAgICAgICAgUFVUOiAnUFVUJyxcclxuICAgICAgICBERUxFVEU6ICdERUxFVEUnXHJcbiAgICB9LFxyXG4gICAgbWF4RGlzdGFuY2VDb25zdHM6IHtcclxuICAgICAgICByYWRpYW5zOiAnJG1heERpc3RhbmNlJyxcclxuICAgICAgICBrbTogJyRtYXhEaXN0YW5jZUluS2lsb21ldGVycycsXHJcbiAgICAgICAgbWlsZXM6ICckbWF4RGlzdGFuY2VJbk1pbGVzJ1xyXG4gICAgfSxcclxuICAgIHJhZGl1c0NvbnN0czoge1xyXG4gICAgICAgIHJhZGlhbnM6ICdyYWRpdXMnLFxyXG4gICAgICAgIGttOiAncmFkaXVzSW5LaWxvbWV0ZXJzJyxcclxuICAgICAgICBtaWxlczogJ3JhZGl1c0luTWlsZXMnXHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyB1c2luZyBhbiBpbnZhbGlkIGZpZWxkIG5hbWUgaW4gdGhlIGNvbnRleHQgb2YgRXZlcmxpdmVcclxuLy8gdG8gZW5zdXJlIG5vIG5hbWluZyBjb2xsaXNpb25zIGNhbiBvY2N1clxyXG5jb25zdGFudHMub2ZmbGluZUl0ZW1zU3RhdGVNYXJrZXIgPSAnX19ldmVybGl2ZV9vZmZsaW5lX3N0YXRlJztcclxuXHJcbmNvbnN0YW50cy5TeW5jRXJyb3JzID0ge1xyXG4gICAgZ2VuZXJhbEVycm9yOiAnZ2VuZXJhbEVycm9yJyxcclxuICAgIGl0ZW1TeW5jRXJyb3I6ICdpdGVtU3luY0Vycm9yJ1xyXG59O1xyXG5cclxuY29uc3RhbnRzLnN5bmNCYXRjaFNpemUgPSAxMDtcclxuXHJcbmNvbnN0YW50cy5BdXRoU3RvcmVLZXkgPSAnX19ldmVybGl2ZV9hdXRoX2tleSc7XHJcblxyXG4vLyB0aGUgbWluaW11bSBpbnRlcnZhbCBiZXR3ZWVuIHN5bmMgcmVxdWVzdHNcclxuY29uc3RhbnRzLmRlZmF1bHRTeW5jSW50ZXJ2YWwgPSAxMDAwICogNjAgKiAxMDsgLy8gMTAgbWludXRlc1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBjb25zdGFudHM7IiwidmFyIENyeXB0b0pTID0gcmVxdWlyZSgnbm9kZS1jcnlwdG9qcy1hZXMnKS5DcnlwdG9KUztcclxudmFyIEFFUyA9IENyeXB0b0pTLkFFUztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICBmdW5jdGlvbiBDcnlwdG9ncmFwaGljUHJvdmlkZXIgKHNkaykge1xyXG4gICAgICAgIHRoaXMuc2RrID0gc2RrO1xyXG4gICAgfVxyXG5cclxuICAgIENyeXB0b2dyYXBoaWNQcm92aWRlci5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgX2dldEtleTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZGsub2ZmbGluZVN0b3JhZ2Uuc2V0dXAuZW5jcnlwdGlvbi5rZXk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2NhbkVuY3J5cHREZWNyeXB0OiBmdW5jdGlvbiAoY29udGVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0S2V5KCkgJiYgY29udGVudCAhPT0gbnVsbCAmJiBjb250ZW50ICE9PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZW5jcnlwdDogZnVuY3Rpb24gKGNvbnRlbnQpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9jYW5FbmNyeXB0RGVjcnlwdChjb250ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBBRVMuZW5jcnlwdChjb250ZW50LCB0aGlzLl9nZXRLZXkoKSkudG9TdHJpbmcoKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBkZWNyeXB0OiBmdW5jdGlvbiAoY29udGVudCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2NhbkVuY3J5cHREZWNyeXB0KGNvbnRlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIEFFUy5kZWNyeXB0KGNvbnRlbnQsIHRoaXMuX2dldEtleSgpKS50b1N0cmluZyhDcnlwdG9KUy5lbmMuVXRmOCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gQ3J5cHRvZ3JhcGhpY1Byb3ZpZGVyO1xyXG59KCkpOyIsInZhciBpc05hdGl2ZVNjcmlwdEFwcGxpY2F0aW9uID0gQm9vbGVhbigoKHR5cGVvZiBhbmRyb2lkICE9PSAndW5kZWZpbmVkJyAmJiBhbmRyb2lkICYmIGFuZHJvaWQud2lkZ2V0ICYmIGFuZHJvaWQud2lkZ2V0LkJ1dHRvbilcclxuICAgIHx8ICh0eXBlb2YgVUlCdXR0b24gIT09ICd1bmRlZmluZWQnICYmIFVJQnV0dG9uKSkpO1xyXG5cclxuaWYgKGlzTmF0aXZlU2NyaXB0QXBwbGljYXRpb24pIHtcclxuICAgIGdsb2JhbC5pc05hdGl2ZVNjcmlwdEFwcGxpY2F0aW9uID0gaXNOYXRpdmVTY3JpcHRBcHBsaWNhdGlvbjtcclxuICAgIGdsb2JhbC5pc0NvcmRvdmFBcHBsaWNhdGlvbiA9IGZhbHNlO1xyXG5cclxuICAgIGdsb2JhbC53aW5kb3cgPSB7XHJcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZToge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlSXRlbTogZnVuY3Rpb24gKCkgeyB9IC8vc2hpbSBmb3IgbW9uZ28tcXVlcnkgdW5kZXIgbmF0aXZlc2NyaXB0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICB2YXIgaXNDb3Jkb3ZhQXBwbGljYXRpb24gPSAvXmZpbGU6XFwvezN9W15cXC9dL2kudGVzdCh3aW5kb3cubG9jYXRpb24uaHJlZikgJiYgL2lvc3xpcGhvbmV8aXBvZHxpcGFkfGFuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xyXG59XHJcblxyXG52YXIgaXNOb2RlanMgPSB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCc7XHJcbnZhciBpc1JlcXVpcmVqcyA9IHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZDtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgaXNDb3Jkb3ZhOiBpc0NvcmRvdmFBcHBsaWNhdGlvbixcclxuICAgIGlzTmF0aXZlU2NyaXB0OiBpc05hdGl2ZVNjcmlwdEFwcGxpY2F0aW9uLFxyXG4gICAgaXNOb2RlanM6IGlzTm9kZWpzLFxyXG4gICAgaXNSZXF1aXJlanM6IGlzUmVxdWlyZWpzXHJcbn07IiwiLyohXHJcbiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcclxuIENvcHlyaWdodCAoYykgMjAxMyBUZWxlcmlrIEFEXHJcbiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XHJcbiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXHJcbiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXHJcbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXHJcbiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcclxuIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxyXG4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcbiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cclxuIFRIRSBTT0ZUV0FSRS55IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cclxuICovXHJcbi8qIVxyXG4gRXZlcmxpdmUgU0RLXHJcbiBWZXJzaW9uIDEuMy4wXHJcbiAqL1xyXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIEV2ZXJsaXZlID0gcmVxdWlyZSgnLi9FdmVybGl2ZScpO1xyXG4gICAgdmFyIHBsYXRmb3JtID0gcmVxdWlyZSgnLi9ldmVybGl2ZS5wbGF0Zm9ybScpO1xyXG4gICAgdmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XHJcbiAgICBjb21tb24ucm9vdC5FdmVybGl2ZSA9IEV2ZXJsaXZlO1xyXG5cclxuICAgIGlmICghcGxhdGZvcm0uaXNOYXRpdmVTY3JpcHQgJiYgIXBsYXRmb3JtLmlzTm9kZWpzKSB7XHJcbiAgICAgICAgdmFyIGtlbmRvID0gcmVxdWlyZSgnLi9rZW5kby9rZW5kby5ldmVybGl2ZScpO1xyXG4gICAgICAgIEV2ZXJsaXZlLmNyZWF0ZURhdGFTb3VyY2UgPSBrZW5kby5jcmVhdGVEYXRhU291cmNlO1xyXG4gICAgICAgIEV2ZXJsaXZlLmNyZWF0ZUhpZXJhcmNoaWNhbERhdGFTb3VyY2UgPSBrZW5kby5jcmVhdGVIaWVyYXJjaGljYWxEYXRhU291cmNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vR2xvYmFsIGV2ZW50IGhhbmRsZXJzIGZvciBwdXNoIG5vdGlmaWNhdGlvbiBldmVudHMuIFJlcXVpcmVkIGJ5IHRoZSBjb3Jkb3ZhIFB1c2hOb3RpZmljYXRpb25zIHBsdWdpbiB0aGF0IHdlIHVzZS5cclxuICAgIEV2ZXJsaXZlLlB1c2hDYWxsYmFja3MgPSB7fTtcclxuICAgIEV2ZXJsaXZlLk9mZmxpbmUgPSB7fTtcclxuXHJcbiAgICBFdmVybGl2ZS5RdWVyeSA9IHJlcXVpcmUoJy4vcXVlcnkvUXVlcnknKTtcclxuICAgIEV2ZXJsaXZlLlF1ZXJ5QnVpbGRlciA9IHJlcXVpcmUoJy4vcXVlcnkvUXVlcnlCdWlsZGVyJyk7XHJcbiAgICBFdmVybGl2ZS5HZW9Qb2ludCA9IHJlcXVpcmUoJy4vR2VvUG9pbnQnKTtcclxuICAgIEV2ZXJsaXZlLkNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XHJcbiAgICBFdmVybGl2ZS5SZXF1ZXN0ID0gcmVxdWlyZSgnLi9SZXF1ZXN0Jyk7XHJcbiAgICBFdmVybGl2ZS5EYXRhID0gcmVxdWlyZSgnLi90eXBlcy9EYXRhJyk7XHJcbiAgICBFdmVybGl2ZS5fdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XHJcbiAgICBFdmVybGl2ZS5fdHJhdmVyc2VBbmRSZXZpdmUgPSBFdmVybGl2ZS5fdXRpbHMucGFyc2VVdGlsaXRpZXMudHJhdmVyc2VBbmRSZXZpdmU7XHJcbiAgICBFdmVybGl2ZS5fY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcclxuXHJcbiAgICB2YXIgcGVyc2lzdGVyc01vZHVsZSA9IHJlcXVpcmUoJy4vb2ZmbGluZS9vZmZsaW5lUGVyc2lzdGVycycpO1xyXG4gICAgRXZlcmxpdmUucGVyc2lzdGVyID0ge1xyXG4gICAgICAgIExvY2FsU3RvcmFnZTogcGVyc2lzdGVyc01vZHVsZS5Mb2NhbFN0b3JhZ2VQZXJzaXN0ZXIsXHJcbiAgICAgICAgRmlsZVN5c3RlbTogcGVyc2lzdGVyc01vZHVsZS5GaWxlU3lzdGVtUGVyc2lzdGVyXHJcbiAgICB9O1xyXG5cclxuICAgIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGNvbW1vbi5yb290LkV2ZXJsaXZlO1xyXG4gICAgfVxyXG59KCkpOyIsInZhciBRdWVyeUJ1aWxkZXIgPSByZXF1aXJlKCcuLi9xdWVyeS9RdWVyeUJ1aWxkZXInKTtcclxudmFyIFF1ZXJ5ID0gcmVxdWlyZSgnLi4vcXVlcnkvUXVlcnknKTtcclxudmFyIFJlcXVlc3QgPSByZXF1aXJlKCcuLi9SZXF1ZXN0Jyk7XHJcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKTtcclxudmFyIF8gPSByZXF1aXJlKCcuLi9jb21tb24nKS5fO1xyXG52YXIgRXZlcmxpdmUgPSByZXF1aXJlKCcuLi9FdmVybGl2ZScpO1xyXG52YXIgRXZlcmxpdmVFcnJvciA9IHJlcXVpcmUoJy4uL0V2ZXJsaXZlRXJyb3InKS5FdmVybGl2ZUVycm9yO1xyXG5cclxuKGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmpRdWVyeSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHdpbmRvdy5rZW5kbyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyICQgPSB3aW5kb3cualF1ZXJ5O1xyXG4gICAgdmFyIGtlbmRvID0gd2luZG93LmtlbmRvO1xyXG5cclxuICAgIHZhciBleHRlbmQgPSAkLmV4dGVuZDtcclxuXHJcbiAgICB2YXIgZXZlcmxpdmVUcmFuc3BvcnQgPSBrZW5kby5kYXRhLlJlbW90ZVRyYW5zcG9ydC5leHRlbmQoe1xyXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlcmxpdmUkID0gb3B0aW9ucy5kYXRhUHJvdmlkZXIgfHwgRXZlcmxpdmUuJDtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmV2ZXJsaXZlJCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBpbnN0YW5jZSBvZiB0aGUgQmFja2VuZCBzZXJ2aWNlcyBzZGsgbXVzdCBiZSBwcm92aWRlZC4nKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnR5cGVOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgdHlwZSBuYW1lIG11c3QgYmUgcHJvdmlkZWQuJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycztcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZGF0YUNvbGxlY3Rpb24gPSB0aGlzLmV2ZXJsaXZlJC5kYXRhKG9wdGlvbnMudHlwZU5hbWUpO1xyXG4gICAgICAgICAgICBrZW5kby5kYXRhLlJlbW90ZVRyYW5zcG9ydC5mbi5pbml0LmNhbGwodGhpcywgb3B0aW9ucyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcmVhZDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIG1ldGhvZE9wdGlvbiA9IHRoaXMub3B0aW9uc1sncmVhZCddO1xyXG4gICAgICAgICAgICBpZiAobWV0aG9kT3B0aW9uICYmIG1ldGhvZE9wdGlvbi51cmwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBrZW5kby5kYXRhLlJlbW90ZVRyYW5zcG9ydC5mbi5yZWFkLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG1ldGhvZEhlYWRlcnM7XHJcbiAgICAgICAgICAgIGlmIChtZXRob2RPcHRpb24gJiYgbWV0aG9kT3B0aW9uLmhlYWRlcnMpIHtcclxuICAgICAgICAgICAgICAgIG1ldGhvZEhlYWRlcnMgPSBtZXRob2RPcHRpb24uaGVhZGVycztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcXVlcnkgPSB0cmFuc2xhdGVLZW5kb1F1ZXJ5KG9wdGlvbnMuZGF0YSk7XHJcbiAgICAgICAgICAgIHZhciBldmVybGl2ZVF1ZXJ5ID0gbmV3IFF1ZXJ5KHF1ZXJ5LiR3aGVyZSwgbnVsbCwgcXVlcnkuJHNvcnQsIHF1ZXJ5LiRza2lwLCBxdWVyeS4kdGFrZSk7XHJcbiAgICAgICAgICAgIHZhciBpZCA9IG9wdGlvbnMuZGF0YS5JZDtcclxuXHJcbiAgICAgICAgICAgIGlmIChpZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhQ29sbGVjdGlvbi53aXRoSGVhZGVycyh0aGlzLmhlYWRlcnMpLndpdGhIZWFkZXJzKG1ldGhvZEhlYWRlcnMpLmdldEJ5SWQoaWQpLnRoZW4ob3B0aW9ucy5zdWNjZXNzLCBvcHRpb25zLmVycm9yKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YUNvbGxlY3Rpb24ud2l0aEhlYWRlcnModGhpcy5oZWFkZXJzKS53aXRoSGVhZGVycyhtZXRob2RIZWFkZXJzKS5nZXQoZXZlcmxpdmVRdWVyeSkudGhlbihvcHRpb25zLnN1Y2Nlc3MsIG9wdGlvbnMuZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICB2YXIgbWV0aG9kT3B0aW9uID0gdGhpcy5vcHRpb25zWyd1cGRhdGUnXTtcclxuICAgICAgICAgICAgaWYgKG1ldGhvZE9wdGlvbiAmJiBtZXRob2RPcHRpb24udXJsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ga2VuZG8uZGF0YS5SZW1vdGVUcmFuc3BvcnQuZm4ucmVhZC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBtZXRob2RIZWFkZXJzO1xyXG4gICAgICAgICAgICBpZiAobWV0aG9kT3B0aW9uICYmIG1ldGhvZE9wdGlvbi5oZWFkZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBtZXRob2RIZWFkZXJzID0gbWV0aG9kT3B0aW9uLmhlYWRlcnM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGlzTXVsdGlwbGUgPSBfLmlzQXJyYXkob3B0aW9ucy5kYXRhLm1vZGVscyk7XHJcbiAgICAgICAgICAgIGlmIChpc011bHRpcGxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhdGNoIHVwZGF0ZSBpcyBub3Qgc3VwcG9ydGVkLicpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1Gb3JVcGRhdGUgPSBvcHRpb25zLmRhdGE7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhQ29sbGVjdGlvbi53aXRoSGVhZGVycyh0aGlzLmhlYWRlcnMpLndpdGhIZWFkZXJzKG1ldGhvZEhlYWRlcnMpLnVwZGF0ZVNpbmdsZShpdGVtRm9yVXBkYXRlKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKG9wdGlvbnMuc3VjY2Vzcy5iaW5kKHRoaXMsIGl0ZW1Gb3JVcGRhdGUpLCBvcHRpb25zLmVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIG1ldGhvZE9wdGlvbiA9IHRoaXMub3B0aW9uc1snY3JlYXRlJ107XHJcbiAgICAgICAgICAgIGlmIChtZXRob2RPcHRpb24gJiYgbWV0aG9kT3B0aW9uLnVybCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtlbmRvLmRhdGEuUmVtb3RlVHJhbnNwb3J0LmZuLnJlYWQuY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbWV0aG9kSGVhZGVycztcclxuICAgICAgICAgICAgaWYgKG1ldGhvZE9wdGlvbiAmJiBtZXRob2RPcHRpb24uaGVhZGVycykge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kSGVhZGVycyA9IG1ldGhvZE9wdGlvbi5oZWFkZXJzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpc011bHRpcGxlID0gXy5pc0FycmF5KG9wdGlvbnMuZGF0YS5tb2RlbHMpO1xyXG4gICAgICAgICAgICB2YXIgY3JlYXRlRGF0YSA9IGlzTXVsdGlwbGUgPyBvcHRpb25zLmRhdGEubW9kZWxzIDogb3B0aW9ucy5kYXRhO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YUNvbGxlY3Rpb24ud2l0aEhlYWRlcnModGhpcy5oZWFkZXJzKS53aXRoSGVhZGVycyhtZXRob2RIZWFkZXJzKS5jcmVhdGUoY3JlYXRlRGF0YSlcclxuICAgICAgICAgICAgICAgIC50aGVuKG9wdGlvbnMuc3VjY2Vzcy5iaW5kKHRoaXMsIGNyZWF0ZURhdGEpLCBvcHRpb25zLmVycm9yKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICB2YXIgbWV0aG9kT3B0aW9uID0gdGhpcy5vcHRpb25zWydkZXN0cm95J107XHJcbiAgICAgICAgICAgIGlmIChtZXRob2RPcHRpb24gJiYgbWV0aG9kT3B0aW9uLnVybCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtlbmRvLmRhdGEuUmVtb3RlVHJhbnNwb3J0LmZuLnJlYWQuY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbWV0aG9kSGVhZGVycztcclxuICAgICAgICAgICAgaWYgKG1ldGhvZE9wdGlvbiAmJiBtZXRob2RPcHRpb24uaGVhZGVycykge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kSGVhZGVycyA9IG1ldGhvZE9wdGlvbi5oZWFkZXJzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpc011bHRpcGxlID0gXy5pc0FycmF5KG9wdGlvbnMuZGF0YS5tb2RlbHMpO1xyXG4gICAgICAgICAgICBpZiAoaXNNdWx0aXBsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYXRjaCBkZXN0cm95IGlzIG5vdCBzdXBwb3J0ZWQuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YUNvbGxlY3Rpb24ud2l0aEhlYWRlcnModGhpcy5oZWFkZXJzKS53aXRoSGVhZGVycyhtZXRob2RIZWFkZXJzKS5kZXN0cm95KG9wdGlvbnMuZGF0YSlcclxuICAgICAgICAgICAgICAgIC50aGVuKG9wdGlvbnMuc3VjY2Vzcywgb3B0aW9ucy5lcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgJC5leHRlbmQodHJ1ZSwga2VuZG8uZGF0YSwge1xyXG4gICAgICAgIHRyYW5zcG9ydHM6IHtcclxuICAgICAgICAgICAgZXZlcmxpdmU6IGV2ZXJsaXZlVHJhbnNwb3J0XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzY2hlbWFzOiB7XHJcbiAgICAgICAgICAgIGV2ZXJsaXZlOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnanNvbicsXHJcbiAgICAgICAgICAgICAgICB0b3RhbDogZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5oYXNPd25Qcm9wZXJ0eSgnY291bnQnKSA/IGRhdGEuY291bnQgOiBkYXRhLkNvdW50O1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGRhdGE6IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEucmVzdWx0IHx8IEV2ZXJsaXZlLl90cmF2ZXJzZUFuZFJldml2ZShkYXRhLlJlc3VsdCkgfHwgZGF0YTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBtb2RlbDoge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkOiBjb25zdGFudHMuaWRGaWVsZFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgZnVuY3Rpb24gdHJhbnNsYXRlS2VuZG9RdWVyeShkYXRhKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgIGlmIChkYXRhKSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhLnNraXApIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC4kc2tpcCA9IGRhdGEuc2tpcDtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBkYXRhLnNraXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRhdGEudGFrZSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LiR0YWtlID0gZGF0YS50YWtlO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGRhdGEudGFrZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGF0YS5zb3J0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc29ydEV4cHJlc3Npb25zID0gZGF0YS5zb3J0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHNvcnQgPSB7fTtcclxuICAgICAgICAgICAgICAgIGlmICghJC5pc0FycmF5KHNvcnRFeHByZXNzaW9ucykpIHtcclxuICAgICAgICAgICAgICAgICAgICBzb3J0RXhwcmVzc2lvbnMgPSBbc29ydEV4cHJlc3Npb25zXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICQuZWFjaChzb3J0RXhwcmVzc2lvbnMsIGZ1bmN0aW9uIChpZHgsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc29ydFt2YWx1ZS5maWVsZF0gPSB2YWx1ZS5kaXIgPT09ICdhc2MnID8gMSA6IC0xO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuJHNvcnQgPSBzb3J0O1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGRhdGEuc29ydDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGF0YS5maWx0ZXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmaWx0ZXIgPSBmaWx0ZXJCdWlsZGVyLmJ1aWxkKGRhdGEuZmlsdGVyKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC4kd2hlcmUgPSBmaWx0ZXI7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgZGF0YS5maWx0ZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcmVnZXhPcGVyYXRpb25zID0gWydzdGFydHN3aXRoJywgJ3N0YXJ0c1dpdGgnLCAnZW5kc3dpdGgnLCAnZW5kc1dpdGgnLCAnY29udGFpbnMnXTtcclxuXHJcbiAgICB2YXIgZmlsdGVyQnVpbGRlciA9IHtcclxuICAgICAgICBidWlsZDogZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyQnVpbGRlci5fYnVpbGQoZmlsdGVyKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9idWlsZDogZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgICAgICAgICBpZiAoZmlsdGVyQnVpbGRlci5faXNSYXcoZmlsdGVyKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlckJ1aWxkZXIuX3JhdyhmaWx0ZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpbHRlckJ1aWxkZXIuX2lzU2ltcGxlKGZpbHRlcikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJCdWlsZGVyLl9zaW1wbGUoZmlsdGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChmaWx0ZXJCdWlsZGVyLl9pc1JlZ2V4KGZpbHRlcikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJCdWlsZGVyLl9yZWdleChmaWx0ZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpbHRlckJ1aWxkZXIuX2lzQW5kKGZpbHRlcikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJCdWlsZGVyLl9hbmQoZmlsdGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChmaWx0ZXJCdWlsZGVyLl9pc09yKGZpbHRlcikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJCdWlsZGVyLl9vcihmaWx0ZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfaXNSYXc6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlci5vcGVyYXRvciA9PT0gJ19yYXcnO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX3JhdzogZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgICAgICAgICB2YXIgZmllbGRUZXJtID0ge307XHJcbiAgICAgICAgICAgIGZpZWxkVGVybVtmaWx0ZXIuZmllbGRdID0gZmlsdGVyLnZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm4gZmllbGRUZXJtO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2lzU2ltcGxlOiBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZmlsdGVyLmxvZ2ljID09PSAndW5kZWZpbmVkJyAmJiAhZmlsdGVyQnVpbGRlci5faXNSZWdleChmaWx0ZXIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX3NpbXBsZTogZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgICAgICAgICB2YXIgdGVybSA9IHt9LCBmaWVsZFRlcm0gPSB7fTtcclxuICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gZmlsdGVyQnVpbGRlci5fdHJhbnNsYXRlb3BlcmF0b3IoZmlsdGVyLm9wZXJhdG9yKTtcclxuICAgICAgICAgICAgaWYgKG9wZXJhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXJtW29wZXJhdG9yXSA9IGZpbHRlci52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRlcm0gPSBmaWx0ZXIudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmllbGRUZXJtW2ZpbHRlci5maWVsZF0gPSB0ZXJtO1xyXG4gICAgICAgICAgICByZXR1cm4gZmllbGRUZXJtO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2lzUmVnZXg6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuICQuaW5BcnJheShmaWx0ZXIub3BlcmF0b3IsIHJlZ2V4T3BlcmF0aW9ucykgIT09IC0xO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX3JlZ2V4OiBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIHZhciBmaWVsZFRlcm0gPSB7fTtcclxuICAgICAgICAgICAgdmFyIHJlZ2V4ID0gZmlsdGVyQnVpbGRlci5fZ2V0UmVnZXgoZmlsdGVyKTtcclxuICAgICAgICAgICAgZmllbGRUZXJtW2ZpbHRlci5maWVsZF0gPSBmaWx0ZXJCdWlsZGVyLl9nZXRSZWdleFZhbHVlKHJlZ2V4KTtcclxuICAgICAgICAgICAgcmV0dXJuIGZpZWxkVGVybTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9nZXRSZWdleDogZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgICAgICAgICB2YXIgcGF0dGVybiA9IGZpbHRlci52YWx1ZTtcclxuICAgICAgICAgICAgdmFyIGZpbHRlck9wZXJhdG9yID0gZmlsdGVyLm9wZXJhdG9yO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGZpbHRlck9wZXJhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdjb250YWlucyc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoXCIuKlwiICsgcGF0dGVybiArIFwiLipcIiwgXCJpXCIpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnc3RhcnRzV2l0aCc6IC8vIHJlbW92aW5nIHRoZSBjYW1lbCBjYXNlIG9wZXJhdG9ycyB3aWxsIGJlIGEgYnJlYWtpbmcgY2hhbmdlXHJcbiAgICAgICAgICAgICAgICBjYXNlICdzdGFydHN3aXRoJzogLy8gdGhlIEtlbmRvIFVJIG9wZXJhdG9ycyBhcmUgaW4gbG93ZXIgY2FzZVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXlwiICsgcGF0dGVybiwgXCJpXCIpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnZW5kc1dpdGgnOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAnZW5kc3dpdGgnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4gKyBcIiRcIiwgXCJpXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3BlcmF0b3IgdHlwZS5cIik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0UmVnZXhWYWx1ZTogZnVuY3Rpb24gKHJlZ2V4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBRdWVyeUJ1aWxkZXIucHJvdG90eXBlLl9nZXRSZWdleFZhbHVlLmNhbGwodGhpcywgcmVnZXgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2lzQW5kOiBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXIubG9naWMgPT09ICdhbmQnO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2FuZDogZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgICAgICAgICB2YXIgaSwgbCwgdGVybSwgcmVzdWx0ID0ge307XHJcbiAgICAgICAgICAgIHZhciBvcGVyYW5kcyA9IGZpbHRlci5maWx0ZXJzO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gb3BlcmFuZHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXJtID0gZmlsdGVyQnVpbGRlci5fYnVpbGQob3BlcmFuZHNbaV0pO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZmlsdGVyQnVpbGRlci5fYW5kQXBwZW5kKHJlc3VsdCwgdGVybSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9hbmRBcHBlbmQ6IGZ1bmN0aW9uIChhbmRPYmosIG5ld09iaikge1xyXG4gICAgICAgICAgICByZXR1cm4gUXVlcnlCdWlsZGVyLnByb3RvdHlwZS5fYW5kQXBwZW5kLmNhbGwodGhpcywgYW5kT2JqLCBuZXdPYmopO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2lzT3I6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlci5sb2dpYyA9PT0gJ29yJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9vcjogZnVuY3Rpb24gKGZpbHRlcikge1xyXG4gICAgICAgICAgICB2YXIgaSwgbCwgdGVybSwgcmVzdWx0ID0gW107XHJcbiAgICAgICAgICAgIHZhciBvcGVyYW5kcyA9IGZpbHRlci5maWx0ZXJzO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gb3BlcmFuZHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXJtID0gZmlsdGVyQnVpbGRlci5fYnVpbGQob3BlcmFuZHNbaV0pO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGVybSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHskb3I6IHJlc3VsdH07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfdHJhbnNsYXRlb3BlcmF0b3I6IGZ1bmN0aW9uIChvcGVyYXRvcikge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdlcSc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICBjYXNlICduZXEnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIiRuZVwiO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnZ3QnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIiRndFwiO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnbHQnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIiRsdFwiO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnZ3RlJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCIkZ3RlXCI7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdsdGUnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIiRsdGVcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9wZXJhdG9yIHR5cGUuXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEtlbmRvIFVJIFtEYXRhU291cmNlXShodHRwOi8vZG9jcy50ZWxlcmlrLmNvbS9rZW5kby11aS9hcGkvamF2YXNjcmlwdC9kYXRhL2RhdGFzb3VyY2UpIHRoYXQgbWFuYWdlcyBhIGNlcnRhaW4gQmFja2VuZCBTZXJ2aWNlcyBjb250ZW50IHR5cGUuXHJcbiAgICAgKiBLZW5kbyBVSSBbRGF0YVNvdXJjZV0oaHR0cDovL2RvY3MudGVsZXJpay5jb20va2VuZG8tdWkvYXBpL2phdmFzY3JpcHQvZGF0YS9kYXRhc291cmNlKSBpcyB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggb3RoZXIgS2VuZG8gVUkgd2lkZ2V0cyAoc3VjaCBhcyBbTGlzdFZpZXddKGh0dHA6Ly9kb2NzLnRlbGVyaWsuY29tL2tlbmRvLXVpL3dlYi9saXN0dmlldy9vdmVydmlldykgYW5kIFtHcmlkXShodHRwOi8vZG9jcy50ZWxlcmlrLmNvbS9rZW5kby11aS93ZWIvZ3JpZC9vdmVydmlldykpIHRvIHByb3ZpZGUgYW4gZWFzeSB3YXkgdG8gcmVuZGVyIGRhdGEgZnJvbSBCYWNrZW5kIFNlcnZpY2VzLlxyXG4gICAgICogKmluY2x1ZGluZyBLZW5kbyBzY3JpcHRzIGlzIHJlcXVpcmVkKi5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIGRhdGEgc291cmNlIG9wdGlvbnMuIFNlZSBLZW5kbyBVSSBkb2N1bWVudGF0aW9uIG9mIFtEYXRhU291cmNlXShodHRwOi8vZG9jcy50ZWxlcmlrLmNvbS9rZW5kby11aS9hcGkvamF2YXNjcmlwdC9kYXRhL2RhdGFzb3VyY2UpIGZvciBtb3JlIGluZm8uXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50cmFuc3BvcnQudHlwZU5hbWUgdGhlIGNvbnRlbnQgdHlwZSBuYW1lIGluIEJhY2tlbmQgU2VydmljZXMgdGhhdCB3aWxsIGJlIG1hbmFnZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7RGF0YVNvdXJjZX0gQSBuZXcgaW5zdGFuY2Ugb2YgS2VuZG8gVUkgRGF0YVNvdXJjZS4gU2VlIEtlbmRvIFVJIGRvY3VtZW50YXRpb24gb2YgW0RhdGFTb3VyY2VdKGh0dHA6Ly9kb2NzLnRlbGVyaWsuY29tL2tlbmRvLXVpL2FwaS9qYXZhc2NyaXB0L2RhdGEvZGF0YXNvdXJjZSkgZm9yIG1vcmUgaW5mby5cclxuICAgICAqIEBleGFtcGxlIGBgYGpzXHJcbiAgICAgKiB2YXIgYm9va3NEYXRhU291cmNlID0gRXZlcmxpdmUuY3JlYXRlRGF0YVNvdXJjZSh7XHJcbiAgICAgKiAgIHRyYW5zcG9ydDoge1xyXG4gICAgICogICAgIHR5cGVOYW1lOiAnQm9va3MnXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH0pO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIHZhciBjcmVhdGVEYXRhU291cmNlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICB2YXIgdHlwZU5hbWUgPSBvcHRpb25zLnR5cGVOYW1lO1xyXG4gICAgICAgIHZhciBldmVybGl2ZSQgPSBvcHRpb25zLmRhdGFQcm92aWRlciB8fCBFdmVybGl2ZS4kO1xyXG4gICAgICAgIGlmICghZXZlcmxpdmUkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBuZWVkIHRvIGluc3RhbnRpYXRlIGFuIEV2ZXJsaXZlIGluc3RhbmNlIGluIG9yZGVyIHRvIGNyZWF0ZSBhIGtlbmRvIERhdGFTb3VyY2UuXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF0eXBlTmFtZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbmVlZCB0byBzcGVjaWZ5IGEgJ3R5cGVOYW1lJyBpbiBvcmRlciB0byBjcmVhdGUgYSBrZW5kbyBEYXRhU291cmNlLlwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBldmVybGl2ZSQuZ2V0S2VuZG9EYXRhU291cmNlKHR5cGVOYW1lLCBvcHRpb25zKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFtIaWVyYXJjaGljYWxEYXRhU291cmNlXShodHRwOi8vZG9jcy50ZWxlcmlrLmNvbS9rZW5kby11aS9hcGkvamF2YXNjcmlwdC9kYXRhL2hpZXJhcmNoaWNhbGRhdGFzb3VyY2UpIHRoYXQgbWFuYWdlcyBhIGNlcnRhaW4gQmFja2VuZCBTZXJ2aWNlcyBjb250ZW50IHR5cGUgYW5kIGNhbiBleHBhbmQgYSBjaGFpbiBvZiByZWxhdGlvbnMuXHJcbiAgICAgKiBLZW5kbyBVSSBbSGllcmFyY2hpY2FsRGF0YVNvdXJjZV0oaHR0cDovL2RvY3MudGVsZXJpay5jb20va2VuZG8tdWkvYXBpL2phdmFzY3JpcHQvZGF0YS9oaWVyYXJjaGljYWxkYXRhc291cmNlKSBpcyB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggb3RoZXIgS2VuZG8gd2lkZ2V0cyAoc3VjaCBhcyBbVHJlZVZpZXddKGh0dHA6Ly9kb2NzLnRlbGVyaWsuY29tL2tlbmRvLXVpL3dlYi90cmVldmlldy9vdmVydmlldykpIHRvIHJlbmRlciBkYXRhIGZyb20gQmFja2VuZCBTZXJ2aWNlcyBpbiBhIHN0cnVjdHVyZWQgd2F5LlxyXG4gICAgICogVGhlIGNoYWluIG9mIHJlbGF0aW9ucyBpcyBkZWZpbmVkIGJ5IHNwZWNpZnlpbmcgdGhlIGZpZWxkIG5hbWVzIHRoYXQgY29udGFpbiB0aGUgcmVsYXRpb24gb24gZWFjaCBsZXZlbC4gRm9yIGV4YW1wbGUgYSBnZW5lcmljIGhpZXJhcmNoeSBjaGFpbiBpcyBhIGNvbnRlbnQgdHlwZSAnQ29udGluZW50cycgd2l0aCByZWxhdGlvbiB0byAnQ291bnRyaWVzJywgd2hpY2ggaW4gdHVybiBjb250YWlucyBhIHJlbGF0aW9uIHRvICdUb3ducycuXHJcbiAgICAgKiAqaW5jbHVkaW5nIEtlbmRvIHNjcmlwdHMgaXMgcmVxdWlyZWQqLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgZGF0YSBzb3VyY2Ugb3B0aW9ucyBmb3IgW0hpZXJhcmNoaWNhbERhdGFTb3VyY2VdKGh0dHA6Ly9kb2NzLnRlbGVyaWsuY29tL2tlbmRvLXVpL2FwaS9qYXZhc2NyaXB0L2RhdGEvaGllcmFyY2hpY2FsZGF0YXNvdXJjZSkuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50eXBlTmFtZSBuYW1lIG9mIHRoZSBtYWluIGNvbnRlbnQgdHlwZSBmb3IgdGhlIGRhdGEgc291cmNlLlxyXG4gICAgICogQHBhcmFtIHtFeHBhbmREZWZpbml0aW9uW119IG9wdGlvbnMuZXhwYW5kIGFuIGFycmF5IG9mIGV4cGFuZCBkZWZpbml0aW9ucy4gSXQgZGVmaW5lcyB0aGUgbGV2ZWxzIG9mIGhpZXJhcmNoeSBieSBzcGVjaWZ5aW5nIHRoZSByZWxhdGlvbiBmaWVsZHMuIEFuIGV4cGFuZCBkZWZpbml0aW9uIGNhbiBlaXRoZXIgYmUgdGhlIGZpZWxkIG5hbWUgYXMgYSAqKnN0cmluZyoqLCBvciBhbiAqKm9iamVjdCoqIHRoYXQgYWxsb3dzIGFkZGl0aW9uYWwgb3B0aW9ucy5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBFeHBhbmREZWZpbml0aW9uIC0gVGhlIGZpZWxkIG5hbWUgb2YgdGhlIHJlbGF0aW9uIHRoYXQgd2lsbCBiZSBleHBhbmRlZC4gT25seSBzdXBwb3J0ZWQgaW4gb25saW5lIG1vZGUuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gRXhwYW5kRGVmaW5pdGlvbi5yZWxhdGlvbiAtICpSZXF1aXJlZCouIFRoZSBmaWVsZCBuYW1lIG9mIHRoZSByZWxhdGlvbiB0aGF0IHdpbGwgYmUgZXhwYW5kZWQuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gRXhwYW5kRGVmaW5pdGlvbi50eXBlTmFtZSAtICpSZXF1aXJlZCBpbiBvZmZsaW5lIG1vZGUqLiBUaGUgdHlwZSBuYW1lIG9mIHRoZSByZWxhdGlvbiB0aGF0IHdpbGwgYmUgZXhwYW5kZWQuXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gRXhwYW5kRGVmaW5pdGlvbi5maWx0ZXIgLSBhbiBvYmplY3Qgc3BlY2lmeWluZyB0aGUgZmlsdGVyIGV4cHJlc3Npb24uXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gRXhwYW5kRGVmaW5pdGlvbi5zb3J0IC0gYW4gb2JqZWN0IHNwZWNpZnlpbmcgdGhlIHNvcnQgZXhwcmVzc2lvbi5cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBFeHBhbmREZWZpbml0aW9uLnNraXAgLSBhIG51bWJlciBzcGVjaWZ5aW5nIHRoZSBza2lwIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IEV4cGFuZERlZmluaXRpb24udGFrZSAtIGEgbnVtYmVyIHNwZWNpZnlpbmcgdGhlIHRha2UgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gRXhwYW5kRGVmaW5pdGlvbi5maWVsZHMgLSBhbiBvYmplY3Qgc3BlY2lmeWluZyB0aGUgZmllbGRzIGV4cHJlc3Npb24uXHJcbiAgICAgKiBAcmV0dXJucyB7SGllcmFyY2hpY2FsRGF0YVNvdXJjZX0gQSBuZXcgaW5zdGFuY2Ugb2YgS2VuZG8gVUkgSGllcmFyY2hpY2FsRGF0YVNvdXJjZS4gU2VlIEtlbmRvIFVJIGRvY3VtZW50YXRpb24gZm9yIFtIaWVyYXJjaGljYWxEYXRhU291cmNlXShodHRwOi8vZG9jcy50ZWxlcmlrLmNvbS9rZW5kby11aS9hcGkvamF2YXNjcmlwdC9kYXRhL2hpZXJhcmNoaWNhbGRhdGFzb3VyY2UpXHJcbiAgICAgKiBAZXhhbXBsZSBgYGBqc1xyXG4gICAgICogdmFyIGVsID0gbmV3IEV2ZXJsaXZlKCd5b3VyLWFwaS1rZXktaGVyZScpO1xyXG4gICAgICogdmFyIGNvbnRpbmVudHMgPSBFdmVybGl2ZS5jcmVhdGVIaWVyYXJjaGljYWxEYXRhU291cmNlKHtcclxuICAgICAqICAgXCJ0eXBlTmFtZVwiOiBcIkNvbnRpbmVudHNcIixcclxuICAgICAqICAgXCJleHBhbmRcIjogW1wiQ291bnRyaWVzXCIsIFwiVG93bnNcIl1cclxuICAgICAqIH0pO1xyXG4gICAgICpcclxuICAgICAqIC4uLlxyXG4gICAgICogKFwiI3RyZWV2aWV3XCIpLmtlbmRvVHJlZVZpZXcoe1xyXG4gICAgICogICBkYXRhU291cmNlOiBjb250aW5lbnRzLFxyXG4gICAgICogICBkYXRhVGV4dEZpZWxkOiBbXCJDb250aW5lbnROYW1lXCIsIFwiQ291bnRyeU5hbWVcIiwgXCJUb3duTmFtZVwiXVxyXG4gICAgICogfSk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgdmFyIGNyZWF0ZUhpZXJhcmNoaWNhbERhdGFTb3VyY2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIHZhciB0eXBlTmFtZSA9IG9wdGlvbnMudHlwZU5hbWU7XHJcbiAgICAgICAgdmFyIGV2ZXJsaXZlJCA9IG9wdGlvbnMuZGF0YVByb3ZpZGVyIHx8IEV2ZXJsaXZlLiQ7XHJcbiAgICAgICAgaWYgKCFldmVybGl2ZSQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG5lZWQgdG8gaW5zdGFudGlhdGUgYW4gRXZlcmxpdmUgaW5zdGFuY2UgaW4gb3JkZXIgdG8gY3JlYXRlIGEga2VuZG8gRGF0YVNvdXJjZS5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdHlwZU5hbWUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG5lZWQgdG8gc3BlY2lmeSBhICd0eXBlTmFtZScgaW4gb3JkZXIgdG8gY3JlYXRlIGEga2VuZG8gRGF0YVNvdXJjZS5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBldmVybGl2ZSQuZ2V0SGllcmFyY2hpY2FsRGF0YVNvdXJjZSh0eXBlTmFtZSwgb3B0aW9ucyk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBFdmVybGl2ZS5wcm90b3R5cGUuZ2V0S2VuZG9EYXRhU291cmNlID0gZnVuY3Rpb24gKHR5cGVOYW1lLCBkYXRhc291cmNlT3B0aW9ucykge1xyXG4gICAgICAgIGRhdGFzb3VyY2VPcHRpb25zID0gXy5leHRlbmQoe30sIGRhdGFzb3VyY2VPcHRpb25zKTtcclxuICAgICAgICBpZiAoZGF0YXNvdXJjZU9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3NlcnZlckdyb3VwaW5nJykgJiYgZGF0YXNvdXJjZU9wdGlvbnMuc2VydmVyR3JvdXBpbmcgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1NlcnZlciBHcm91cGluZyBpcyBub3Qgc3VwcG9ydGVkLicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGRlZmF1bHRFdmVybGl2ZU9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdldmVybGl2ZScsXHJcbiAgICAgICAgICAgIHRyYW5zcG9ydDoge1xyXG4gICAgICAgICAgICAgICAgdHlwZU5hbWU6IHR5cGVOYW1lLFxyXG4gICAgICAgICAgICAgICAgZGF0YVByb3ZpZGVyOiB0aGlzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB2YXIgb3B0aW9ucyA9IF8uZGVmYXVsdHMoZGVmYXVsdEV2ZXJsaXZlT3B0aW9ucywgZGF0YXNvdXJjZU9wdGlvbnMpO1xyXG4gICAgICAgIHJldHVybiBuZXcga2VuZG8uZGF0YS5EYXRhU291cmNlKG9wdGlvbnMpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgdmFyIGdldFVybEdlbmVyYXRvckZvck5vZGUgPSBmdW5jdGlvbiAoYmFzZVVybCwgZXhwYW5kQXJyYXkpIHtcclxuICAgICAgICB2YXIgZXhwYW5kRmllbGQgPSBnZXRSZWxhdGlvbkZpZWxkRm9yRXhwYW5kTm9kZShleHBhbmRBcnJheVtleHBhbmRBcnJheS5sZW5ndGggLSAxXSk7XHJcbiAgICAgICAgdmFyIHBhdGhBcnJheSA9IGV4cGFuZEFycmF5LnNsaWNlKDAsIGV4cGFuZEFycmF5Lmxlbmd0aCAtIDEpO1xyXG4gICAgICAgIHZhciBwYXRoVXJsID0gJy9fZXhwYW5kJztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhBcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBwYXRoVXJsICs9ICcvJyArIGdldFJlbGF0aW9uRmllbGRGb3JFeHBhbmROb2RlKHBhdGhBcnJheVtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKHBhdGhVcmwsIGV4cGFuZEZpZWxkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHVybCA9IGJhc2VVcmwgKyAnJztcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLklkICYmIGV4cGFuZEZpZWxkKSB7Ly9pZiB3ZSBhcmUgZXhwYW5kaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgdXJsICs9IHBhdGhVcmwgKyAnLycgKyBvcHRpb25zLklkICsgJy8nICsgZXhwYW5kRmllbGQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfShwYXRoVXJsLCBleHBhbmRGaWVsZCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBnZXRIZWFkZXJzRm9yRXhwYW5kTm9kZSA9IGZ1bmN0aW9uIChleHBhbmROb2RlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBleHBhbmROb2RlID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7fTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgJ1gtRXZlcmxpdmUtRmlsdGVyJzogSlNPTi5zdHJpbmdpZnkoZXhwYW5kTm9kZS5maWx0ZXIpLFxyXG4gICAgICAgICAgICAgICAgJ1gtRXZlcmxpdmUtU29ydCc6IEpTT04uc3RyaW5naWZ5KGV4cGFuZE5vZGUuc29ydCksXHJcbiAgICAgICAgICAgICAgICAnWC1FdmVybGl2ZS1TaW5nbGUtRmllbGQnOiBleHBhbmROb2RlLnNpbmdsZUZpZWxkLFxyXG4gICAgICAgICAgICAgICAgJ1gtRXZlcmxpdmUtU2tpcCc6IGV4cGFuZE5vZGUuc2tpcCxcclxuICAgICAgICAgICAgICAgICdYLUV2ZXJsaXZlLVRha2UnOiBleHBhbmROb2RlLnRha2UsXHJcbiAgICAgICAgICAgICAgICAnWC1FdmVybGl2ZS1GaWVsZHMnOiBKU09OLnN0cmluZ2lmeShleHBhbmROb2RlLmZpZWxkcylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdmFyIGdldFJlbGF0aW9uRmllbGRGb3JFeHBhbmROb2RlID0gZnVuY3Rpb24gKGV4cGFuZE5vZGUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGV4cGFuZE5vZGUgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV4cGFuZE5vZGU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGV4cGFuZE5vZGUucmVsYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBleHBhbmROb2RlLnJlbGF0aW9uO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG5lZWQgdG8gc3BlY2lmeSBhICdyZWxhdGlvbicgZm9yIGFuIGV4cGFuZCBub2RlIHdoZW4gdXNpbmcgdGhlIG9iamVjdCBub3RhdGlvblwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgRXZlcmxpdmUucHJvdG90eXBlLmdldEhpZXJhcmNoaWNhbERhdGFTb3VyY2UgPSBmdW5jdGlvbiAodHlwZU5hbWUsIGRhdGFTb3VyY2VPcHRpb25zKSB7XHJcbiAgICAgICAgZGF0YVNvdXJjZU9wdGlvbnMgPSBkYXRhU291cmNlT3B0aW9ucyB8fCB7fTtcclxuICAgICAgICBpZiAoZGF0YVNvdXJjZU9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3NlcnZlckdyb3VwaW5nJykgJiYgZGF0YVNvdXJjZU9wdGlvbnMuc2VydmVyR3JvdXBpbmcgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1NlcnZlciBHcm91cGluZyBpcyBub3Qgc3VwcG9ydGVkLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZXhwYW5kID0gZGF0YVNvdXJjZU9wdGlvbnMuZXhwYW5kIHx8IGRhdGFTb3VyY2VPcHRpb25zO1xyXG4gICAgICAgIGRlbGV0ZSBkYXRhU291cmNlT3B0aW9ucy5leHBhbmQ7XHJcbiAgICAgICAgaWYgKCF0eXBlTmFtZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbmVlZCB0byBzcGVjaWZ5IGEgJ3R5cGVOYW1lJyBpbiBvcmRlciB0byBjcmVhdGUgYSBrZW5kbyBIaWVyYXJjaGljYWxEYXRhU291cmNlLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEkLmlzQXJyYXkoZXhwYW5kKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbmVlZCB0byBzZXQgJ2V4cGFuZCcgYXJyYXkgb3B0aW9uIGluIG9yZGVyIHRvIGNyZWF0ZSBhIGtlbmRvIEhpZXJhcmNoaWNhbERhdGFTb3VyY2VcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBiYXNlVXJsID0gdGhpcy5idWlsZFVybCgpICsgdHlwZU5hbWU7XHJcblxyXG4gICAgICAgIHZhciBleHBhbmRTY2hlbWE7XHJcbiAgICAgICAgdmFyIGlzT2ZmbGluZVN0b3JhZ2VFbmFibGVkID0gdGhpcy5faXNPZmZsaW5lU3RvcmFnZUVuYWJsZWQoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gZXhwYW5kLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7IC8vcmVjdXJzaXZlbHkgYnVpbGQgdGhlIGhpZXJhcmNoaWNhbCBkYXRhIHNvdXJjZVxyXG4gICAgICAgICAgICB2YXIgZXhwYW5kTm9kZSA9IGV4cGFuZFtpXTtcclxuICAgICAgICAgICAgaWYgKGlzT2ZmbGluZVN0b3JhZ2VFbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoISQuaXNQbGFpbk9iamVjdChleHBhbmROb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldoZW4gb2ZmbGluZSBpcyBlbmFibGVkLCBlYWNoIG1lbWJlciBvZiB0aGUgZXhwYW5kIGFycmF5IG9wdGlvbiBtdXN0IGJlIGFuIG9iamVjdC4gKEV4cGFuZCBub2RlIGluZGV4OiBcIiArIGkgKyBcIilcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWV4cGFuZE5vZGUucmVsYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXaGVuIG9mZmxpbmUgaXMgZW5hYmxlZCwgZWFjaCBtZW1iZXIgb2YgdGhlIGV4cGFuZCBhcnJheSBvcHRpb24gbXVzdCBoYXZlIGEgYHJlbGF0aW9uYCBvcHRpb24gc2V0LiAgKEV4cGFuZCBub2RlIGluZGV4OiBcIiArIGkgKyBcIilcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWV4cGFuZE5vZGUudHlwZU5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXaGVuIG9mZmxpbmUgaXMgZW5hYmxlZCwgZWFjaCBtZW1iZXIgb2YgdGhlIGV4cGFuZCBhcnJheSBvcHRpb24gbXVzdCBoYXZlIGEgYHR5cGVOYW1lYCBvcHRpb24gc2V0LiAgKEV4cGFuZCBub2RlIGluZGV4OiBcIiArIGkgKyBcIilcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGhlYWRlcnM7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXhwYW5kRXhwcmVzc2lvbiA9IHt9O1xyXG4gICAgICAgICAgICAgICAgZXhwYW5kRXhwcmVzc2lvbltleHBhbmROb2RlLnJlbGF0aW9uXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBUYXJnZXRUeXBlTmFtZTogZXhwYW5kTm9kZS50eXBlTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBGaWx0ZXI6IGV4cGFuZE5vZGUuZmlsdGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIFNvcnQ6IGV4cGFuZE5vZGUuc29ydCxcclxuICAgICAgICAgICAgICAgICAgICBUYWtlOiBleHBhbmROb2RlLnRha2UsXHJcbiAgICAgICAgICAgICAgICAgICAgU2tpcDogZXhwYW5kTm9kZS5za2lwLFxyXG4gICAgICAgICAgICAgICAgICAgIEZpZWxkczogZXhwYW5kTm9kZS5maWVsZHMsXHJcbiAgICAgICAgICAgICAgICAgICAgU2luZ2xlRmllbGQ6IGV4cGFuZE5vZGUuc2luZ2xlRmllbGRcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBoZWFkZXJzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICdYLUV2ZXJsaXZlLUV4cGFuZCc6IEpTT04uc3RyaW5naWZ5KGV4cGFuZEV4cHJlc3Npb24pLFxyXG4gICAgICAgICAgICAgICAgICAgICdYLUV2ZXJsaXZlLVNpbmdsZS1GaWVsZCc6IGV4cGFuZE5vZGUucmVsYXRpb25cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50VHlwZTtcclxuICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50VHlwZSA9IHR5cGVOYW1lO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRUeXBlID0gZXhwYW5kW2kgLSAxXS50eXBlTmFtZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV4cGFuZFNjaGVtYSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBtb2RlbDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNDaGlsZHJlbjogZXhwYW5kTm9kZS5yZWxhdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZXZlcmxpdmVcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVOYW1lOiBwYXJlbnRUeXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWE6IGV4cGFuZFNjaGVtYVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGV4cGFuZFNjaGVtYSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBtb2RlbDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNDaGlsZHJlbjogZ2V0UmVsYXRpb25GaWVsZEZvckV4cGFuZE5vZGUoZXhwYW5kTm9kZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImV2ZXJsaXZlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogZ2V0VXJsR2VuZXJhdG9yRm9yTm9kZShiYXNlVXJsLCBleHBhbmQuc2xpY2UoMCwgaSArIDEpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogZ2V0SGVhZGVyc0ZvckV4cGFuZE5vZGUoZXhwYW5kTm9kZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1hOiBleHBhbmRTY2hlbWFcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIG9wdGlvbnMudHlwZSA9ICdldmVybGl2ZSc7XHJcbiAgICAgICAgb3B0aW9ucy50cmFuc3BvcnQgPSB7XHJcbiAgICAgICAgICAgIHR5cGVOYW1lOiB0eXBlTmFtZSxcclxuICAgICAgICAgICAgZGF0YVByb3ZpZGVyOiB0aGlzXHJcbiAgICAgICAgfTtcclxuICAgICAgICBvcHRpb25zLnNjaGVtYSA9IGV4cGFuZFNjaGVtYTtcclxuICAgICAgICBpZiAoJC5pc1BsYWluT2JqZWN0KGRhdGFTb3VyY2VPcHRpb25zKSkge1xyXG4gICAgICAgICAgICBleHRlbmQodHJ1ZSwgb3B0aW9ucywgZGF0YVNvdXJjZU9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IGtlbmRvLmRhdGEuSGllcmFyY2hpY2FsRGF0YVNvdXJjZShvcHRpb25zKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgICAgIGNyZWF0ZURhdGFTb3VyY2U6IGNyZWF0ZURhdGFTb3VyY2UsXHJcbiAgICAgICAgY3JlYXRlSGllcmFyY2hpY2FsRGF0YVNvdXJjZTogY3JlYXRlSGllcmFyY2hpY2FsRGF0YVNvdXJjZVxyXG4gICAgfTtcclxufSgpKTsiLCJ2YXIgRGF0YVF1ZXJ5ID0gcmVxdWlyZSgnLi4vcXVlcnkvRGF0YVF1ZXJ5Jyk7XHJcbnZhciBldmVybGl2ZUVycm9yTW9kdWxlID0gcmVxdWlyZSgnLi4vRXZlcmxpdmVFcnJvcicpO1xyXG52YXIgRXZlcmxpdmVFcnJvciA9IGV2ZXJsaXZlRXJyb3JNb2R1bGUuRXZlcmxpdmVFcnJvcjtcclxudmFyIEV2ZXJsaXZlRXJyb3JzID0gZXZlcmxpdmVFcnJvck1vZHVsZS5FdmVybGl2ZUVycm9ycztcclxudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpO1xyXG52YXIgb2ZmbGluZUl0ZW1TdGF0ZXMgPSBjb25zdGFudHMub2ZmbGluZUl0ZW1TdGF0ZXM7XHJcbnZhciBIZWFkZXJzID0gY29uc3RhbnRzLkhlYWRlcnM7XHJcbnZhciBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIgPSByZXF1aXJlKCcuLi9xdWVyeS9SZXF1ZXN0T3B0aW9uc0J1aWxkZXInKTtcclxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xyXG52YXIgXyA9IGNvbW1vbi5fO1xyXG52YXIgcnN2cCA9IGNvbW1vbi5yc3ZwO1xyXG52YXIgbWluZ28gPSBjb21tb24uTWluZ287XHJcbnZhciBtb25nb1F1ZXJ5ID0gY29tbW9uLm1vbmdvUXVlcnk7XHJcbnZhciB1dWlkID0gY29tbW9uLnV1aWQ7XHJcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XHJcbnZhciBSZXF1ZXN0ID0gcmVxdWlyZSgnLi4vUmVxdWVzdCcpO1xyXG52YXIgZXhwYW5kUHJvY2Vzc29yID0gcmVxdWlyZSgnLi4vRXhwYW5kUHJvY2Vzc29yJyk7XHJcbnZhciBvZmZsaW5lVHJhbnNmb3JtYXRpb25zID0gcmVxdWlyZSgnLi9vZmZsaW5lVHJhbnNmb3JtYXRpb25zJyk7XHJcbnZhciBidWlsZFByb21pc2UgPSByZXF1aXJlKCcuLi91dGlscycpLmJ1aWxkUHJvbWlzZTtcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgT2ZmbGluZU1vZHVsZVxyXG4gKiBAY2xhc3NEZXNjIEEgY2xhc3MgcHJvdmlkaW5nIGFjY2VzcyB0byBzb21lIG9mZmxpbmUgc3RvcmFnZSBmdW5jdGlvbmFsaXRpZXMuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgdGhlIHtAbGluayBPZmZsaW5lTW9kdWxlfSBjbGFzcy5cclxuICogQG1lbWJlck9mIEV2ZXJsaXZlLnByb3RvdHlwZVxyXG4gKiBAbWVtYmVyIHtPZmZsaW5lTW9kdWxlfSBzdG9yYWdlXHJcbiAqL1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gT2ZmbGluZU1vZHVsZShldmVybGl2ZSwgb3B0aW9ucywgcGVyc2lzdGVyLCBlbmNyeXB0aW9uUHJvdmlkZXIpIHtcclxuICAgICAgICB0aGlzLmV2ZXJsaXZlID0gZXZlcmxpdmU7XHJcbiAgICAgICAgdGhpcy5zZXR1cCA9IG9wdGlvbnM7XHJcbiAgICAgICAgdGhpcy5fcGVyc2lzdGVyID0gcGVyc2lzdGVyO1xyXG4gICAgICAgIHRoaXMuX2VuY3J5cHRpb25Qcm92aWRlciA9IGVuY3J5cHRpb25Qcm92aWRlcjtcclxuICAgICAgICB0aGlzLl9pc1N5bmNocm9uaXppbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9jb2xsZWN0aW9uQ2FjaGUgPSB7fTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgdmFyIGdldFN5bmNGaWx0ZXJGb3JJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICB2YXIgZmlsdGVyID0gZ2V0U3luY0ZpbHRlck5vTW9kaWZpZWRBdChpdGVtKTtcclxuICAgICAgICBmaWx0ZXIuTW9kaWZpZWRBdCA9IGl0ZW0uTW9kaWZpZWRBdDtcclxuICAgICAgICByZXR1cm4gZmlsdGVyO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgZ2V0U3luY0ZpbHRlck5vTW9kaWZpZWRBdCA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgSWQ6IGl0ZW0uSWRcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGJ1aWxkVXNlcnNFcnJvck1lc3NhZ2UoZGF0YVF1ZXJ5KSB7XHJcbiAgICAgICAgdmFyIG9wZXJhdGlvbiA9IGRhdGFRdWVyeS5vcGVyYXRpb247XHJcbiAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXNlckxvZ2luV2l0aFByb3ZpZGVyIHx8XHJcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9PT0gRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXNlckxpbmtXaXRoUHJvdmlkZXIgfHxcclxuICAgICAgICAgICAgb3BlcmF0aW9uID09PSBEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyVW5saW5rRnJvbVByb3ZpZGVyKSB7XHJcbiAgICAgICAgICAgIG9wZXJhdGlvbiArPSBkYXRhUXVlcnkuZGF0YS5Qcm92aWRlciB8fCBkYXRhUXVlcnkuZGF0YS5JZGVudGl0eS5Qcm92aWRlcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAnVGhlIFVzZXJzIG9wZXJhdGlvbiAnICsgb3BlcmF0aW9uICsgJyBpcyBub3Qgc3VwcG9ydGVkIGluIG9mZmxpbmUgbW9kZSc7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHVuc3VwcG9ydGVkVXNlcnNPcGVyYXRpb25zID0ge307XHJcbiAgICB1bnN1cHBvcnRlZFVzZXJzT3BlcmF0aW9uc1tEYXRhUXVlcnkub3BlcmF0aW9ucy5jcmVhdGVdID0gdHJ1ZTtcclxuICAgIHVuc3VwcG9ydGVkVXNlcnNPcGVyYXRpb25zW0RhdGFRdWVyeS5vcGVyYXRpb25zLnVwZGF0ZV0gPSB0cnVlO1xyXG4gICAgdW5zdXBwb3J0ZWRVc2Vyc09wZXJhdGlvbnNbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVtb3ZlXSA9IHRydWU7XHJcbiAgICB1bnN1cHBvcnRlZFVzZXJzT3BlcmF0aW9uc1tEYXRhUXVlcnkub3BlcmF0aW9ucy5yZW1vdmVTaW5nbGVdID0gdHJ1ZTtcclxuICAgIHVuc3VwcG9ydGVkVXNlcnNPcGVyYXRpb25zW0RhdGFRdWVyeS5vcGVyYXRpb25zLnJhd1VwZGF0ZV0gPSB0cnVlO1xyXG4gICAgdW5zdXBwb3J0ZWRVc2Vyc09wZXJhdGlvbnNbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuc2V0QWNsXSA9IHRydWU7XHJcbiAgICB1bnN1cHBvcnRlZFVzZXJzT3BlcmF0aW9uc1tEYXRhUXVlcnkub3BlcmF0aW9ucy5zZXRPd25lcl0gPSB0cnVlO1xyXG4gICAgdW5zdXBwb3J0ZWRVc2Vyc09wZXJhdGlvbnNbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXNlckxvZ2luV2l0aFByb3ZpZGVyXSA9IHRydWU7XHJcbiAgICB1bnN1cHBvcnRlZFVzZXJzT3BlcmF0aW9uc1tEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyTGlua1dpdGhQcm92aWRlcl0gPSB0cnVlO1xyXG4gICAgdW5zdXBwb3J0ZWRVc2Vyc09wZXJhdGlvbnNbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXNlclVubGlua0Zyb21Qcm92aWRlcl0gPSB0cnVlO1xyXG4gICAgdW5zdXBwb3J0ZWRVc2Vyc09wZXJhdGlvbnNbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXNlckxvZ2luXSA9IHRydWU7XHJcbiAgICB1bnN1cHBvcnRlZFVzZXJzT3BlcmF0aW9uc1tEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyTG9nb3V0XSA9IHRydWU7XHJcbiAgICB1bnN1cHBvcnRlZFVzZXJzT3BlcmF0aW9uc1tEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyQ2hhbmdlUGFzc3dvcmRdID0gdHJ1ZTtcclxuXHJcbiAgICB2YXIgdW5zdXBwb3J0ZWRPZmZsaW5lSGVhZGVycyA9IFtIZWFkZXJzLnBvd2VyRmllbGRzXTtcclxuXHJcbiAgICBPZmZsaW5lTW9kdWxlLnByb3RvdHlwZSA9IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGFsbCBkYXRhIGZyb20gdGhlIG9mZmxpbmUgc3RvcmFnZVxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBPZmZsaW5lTW9kdWxlLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1Y2Nlc3NcclxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBlcnJvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgYWxsIGRhdGEgZnJvbSB0aGUgb2ZmbGluZSBzdG9yYWdlXHJcbiAgICAgICAgICogQG1lbWJlck9mIE9mZmxpbmVNb2R1bGUucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMgUHJvbWlzZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHB1cmdlQWxsOiBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLl9jb2xsZWN0aW9uQ2FjaGUgPSB7fTtcclxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHNlbGYuX3BlcnNpc3Rlci5wdXJnZUFsbChzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGFsbCBkYXRhIGZvciBhIHNwZWNpZmljIGNvbnRlbnQgdHlwZSBmcm9tIHRoZSBvZmZsaW5lIHN0b3JhZ2VcclxuICAgICAgICAgKiBAbWVtYmVyT2YgT2ZmbGluZVN0b3JhZ2VNb2R1bGUucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRUeXBlIFRoZSBjb250ZW50IHR5cGUgdG8gcHVyZ2VcclxuICAgICAgICAgKiBAcGFyYW0gc3VjY2Vzc1xyXG4gICAgICAgICAqIEBwYXJhbSBlcnJvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgYWxsIGRhdGEgZm9yIGEgc3BlY2lmaWMgY29udGVudCB0eXBlIGZyb20gdGhlIG9mZmxpbmUgc3RvcmFnZVxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBPZmZsaW5lU3RvcmFnZU1vZHVsZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFR5cGUgVGhlIGNvbnRlbnQgdHlwZSB0byBwdXJnZVxyXG4gICAgICAgICAqIEByZXR1cm5zIFByb21pc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBwdXJnZTogZnVuY3Rpb24gKGNvbnRlbnRUeXBlLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiBidWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl9wZXJzaXN0ZXIucHVyZ2UoY29udGVudFR5cGUsIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICAgICAgfSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHByb2Nlc3NRdWVyeTogZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xyXG4gICAgICAgICAgICB2YXIgdW5zdXBwb3J0ZWRDbGllbnRPcE1lc3NhZ2UgPSB0aGlzLmdldFVuc3VwcG9ydGVkQ2xpZW50T3BNZXNzYWdlKGRhdGFRdWVyeSk7XHJcbiAgICAgICAgICAgIGlmICh1bnN1cHBvcnRlZENsaWVudE9wTWVzc2FnZSAmJiAhZGF0YVF1ZXJ5LmlzU3luYykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXZlcmxpdmVFcnJvcih1bnN1cHBvcnRlZENsaWVudE9wTWVzc2FnZSkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzb3J0ID0gZGF0YVF1ZXJ5LmdldEhlYWRlckFzSlNPTihIZWFkZXJzLnNvcnQpO1xyXG4gICAgICAgICAgICB2YXIgbGltaXQgPSBkYXRhUXVlcnkuZ2V0SGVhZGVyQXNKU09OKEhlYWRlcnMudGFrZSk7XHJcbiAgICAgICAgICAgIHZhciBza2lwID0gZGF0YVF1ZXJ5LmdldEhlYWRlckFzSlNPTihIZWFkZXJzLnNraXApO1xyXG4gICAgICAgICAgICB2YXIgc2VsZWN0ID0gZGF0YVF1ZXJ5LmdldEhlYWRlckFzSlNPTihIZWFkZXJzLnNlbGVjdCk7XHJcbiAgICAgICAgICAgIHZhciBmaWx0ZXIgPSBkYXRhUXVlcnkuZ2V0SGVhZGVyQXNKU09OKEhlYWRlcnMuZmlsdGVyKTtcclxuICAgICAgICAgICAgdmFyIGV4cGFuZCA9IGRhdGFRdWVyeS5nZXRIZWFkZXJBc0pTT04oSGVhZGVycy5leHBhbmQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGRhdGFRdWVyeS5maWx0ZXIgaW5zdGFuY2VvZiBFdmVybGl2ZS5RdWVyeSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpbHRlck9iaiA9IGRhdGFRdWVyeS5maWx0ZXIuYnVpbGQoKTtcclxuICAgICAgICAgICAgICAgIGZpbHRlciA9IGZpbHRlck9iai4kd2hlcmUgfHwgZmlsdGVyO1xyXG4gICAgICAgICAgICAgICAgc29ydCA9IGZpbHRlck9iai4kc29ydCB8fCBzb3J0O1xyXG4gICAgICAgICAgICAgICAgbGltaXQgPSBmaWx0ZXJPYmouJHRha2UgfHwgbGltaXQ7XHJcbiAgICAgICAgICAgICAgICBza2lwID0gZmlsdGVyT2JqLiRza2lwIHx8IHNraXA7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3QgPSBmaWx0ZXJPYmouJHNlbGVjdCB8fCBzZWxlY3Q7XHJcbiAgICAgICAgICAgICAgICBleHBhbmQgPSBmaWx0ZXJPYmouJGV4cGFuZCB8fCBleHBhbmQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXIgPSBkYXRhUXVlcnkuZmlsdGVyIHx8IGZpbHRlcjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFmaWx0ZXIpIHtcclxuICAgICAgICAgICAgICAgIGZpbHRlciA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgdW5zdXBwb3J0ZWRPcGVyYXRvcnMgPSB1dGlscy5nZXRVbnN1cHBvcnRlZE9wZXJhdG9ycyhmaWx0ZXIpO1xyXG4gICAgICAgICAgICB2YXIgdW5zdXBwb3J0ZWRPcGVyYXRvckNvdW50ID0gdW5zdXBwb3J0ZWRPcGVyYXRvcnMubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAodW5zdXBwb3J0ZWRPcGVyYXRvckNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yTWVzc2FnZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodW5zdXBwb3J0ZWRPcGVyYXRvckNvdW50ID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9ICdUaGUgb3BlcmF0b3IgJyArIHVuc3VwcG9ydGVkT3BlcmF0b3JzWzBdICsgJyBpcyBub3Qgc3VwcG9ydGVkIGluIG9mZmxpbmUgbW9kZS4nO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9ICdUaGUgb3BlcmF0b3JzICcgKyB1bnN1cHBvcnRlZE9wZXJhdG9ycy5qb2luKCcsJykgKyAnYXJlIG5vdCBzdXBwb3J0ZWQgaW4gb2ZmbGluZSBtb2RlLic7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEV2ZXJsaXZlRXJyb3IoZXJyb3JNZXNzYWdlKSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgb2ZmbGluZVRyYW5zZm9ybWF0aW9ucy50cmF2ZXJzZUFuZFRyYW5zZm9ybUZpbHRlcklkKGZpbHRlcik7XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKGRhdGFRdWVyeS5vcGVyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVhZDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkKGRhdGFRdWVyeSwgZmlsdGVyLCBzb3J0LCBza2lwLCBsaW1pdCwgc2VsZWN0LCBleHBhbmQpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBEYXRhUXVlcnkub3BlcmF0aW9ucy5yZWFkQnlJZDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkQnlJZChkYXRhUXVlcnksIGV4cGFuZCk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIERhdGFRdWVyeS5vcGVyYXRpb25zLmNvdW50OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvdW50KGRhdGFRdWVyeSwgZmlsdGVyKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuY3JlYXRlOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZShkYXRhUXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBEYXRhUXVlcnkub3BlcmF0aW9ucy5yYXdVcGRhdGU6XHJcbiAgICAgICAgICAgICAgICBjYXNlIERhdGFRdWVyeS5vcGVyYXRpb25zLnVwZGF0ZTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoZGF0YVF1ZXJ5LCBmaWx0ZXIpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBEYXRhUXVlcnkub3BlcmF0aW9ucy5yZW1vdmU6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlKGRhdGFRdWVyeSwgZmlsdGVyKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVtb3ZlU2luZ2xlOlxyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlci5faWQgPSBkYXRhUXVlcnkuYWRkaXRpb25hbE9wdGlvbnMuaWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlKGRhdGFRdWVyeSwgZmlsdGVyKTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVF1ZXJ5LmlzU3luYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFdmVybGl2ZUVycm9yKGRhdGFRdWVyeS5vcGVyYXRpb24gKyAnIGlzIG5vdCBzdXBwb3J0ZWQgaW4gb2ZmbGluZSBtb2RlJykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZXRVbnN1cHBvcnRlZENsaWVudE9wTWVzc2FnZTogZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVuc3VwcG9ydGVkT2ZmbGluZUhlYWRlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBoZWFkZXIgPSB1bnN1cHBvcnRlZE9mZmxpbmVIZWFkZXJzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFRdWVyeS5nZXRIZWFkZXIoaGVhZGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnVGhlIGhlYWRlciAnICsgaGVhZGVyICsgJyBpcyBub3Qgc3VwcG9ydGVkIGluIG9mZmxpbmUgbW9kZSc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChkYXRhUXVlcnkuY29sbGVjdGlvbk5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2ZpbGVzJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdPcGVyYXRpb25zIG9uIGZpbGVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIG9mZmxpbmUgbW9kZSc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChkYXRhUXVlcnkuY29sbGVjdGlvbk5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3VzZXJzJyAmJiB1bnN1cHBvcnRlZFVzZXJzT3BlcmF0aW9uc1tkYXRhUXVlcnkub3BlcmF0aW9uXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1aWxkVXNlcnNFcnJvck1lc3NhZ2UoZGF0YVF1ZXJ5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9nZXRFbmNyeXB0aW9uUHJvdmlkZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VuY3J5cHRpb25Qcm92aWRlcjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZ2V0Q3JlYXRlUmVzdWx0OiBmdW5jdGlvbiAoY3JlYXRlZEl0ZW1zKSB7XHJcbiAgICAgICAgICAgIGlmIChjcmVhdGVkSXRlbXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBDcmVhdGVkQXQ6IHV0aWxzLmNsb25lRGF0ZShjcmVhdGVkSXRlbXNbMF0uQ3JlYXRlZEF0KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgSWQ6IGNyZWF0ZWRJdGVtc1swXS5faWRcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbXVsdGlwbGVDcmVhdGVSZXN1bHQgPSBbXTtcclxuICAgICAgICAgICAgICAgIF8uZWFjaChjcmVhdGVkSXRlbXMsIGZ1bmN0aW9uIChjcmVhdGVkSXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG11bHRpcGxlQ3JlYXRlUmVzdWx0LnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBDcmVhdGVkQXQ6IHV0aWxzLmNsb25lRGF0ZShjcmVhdGVkSXRlbS5DcmVhdGVkQXQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBJZDogY3JlYXRlZEl0ZW0uX2lkXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogbXVsdGlwbGVDcmVhdGVSZXN1bHRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl9jcmVhdGVJdGVtcyhkYXRhUXVlcnkuY29sbGVjdGlvbk5hbWUsIGRhdGFRdWVyeS5kYXRhLCBkYXRhUXVlcnkuaXNTeW5jLCBkYXRhUXVlcnkucHJlc2VydmVTdGF0ZSwgZnVuY3Rpb24gKGNyZWF0ZWRJdGVtcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjcmVhdGVSZXN1bHQgPSBzZWxmLl9nZXRDcmVhdGVSZXN1bHQoY3JlYXRlZEl0ZW1zKTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGNyZWF0ZVJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9LCByZWplY3QpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICByZWFkOiBmdW5jdGlvbiAoZGF0YVF1ZXJ5LCBmaWx0ZXIsIHNvcnQsIHNraXAsIGxpbWl0LCBzZWxlY3QsIGV4cGFuZCkge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29sbGVjdGlvbkxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICBzZWxmLl9wcmVwYXJlRXhwYW5kKGV4cGFuZCwgZGF0YVF1ZXJ5LCB0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChwcmVwYXJlRXhwYW5kUmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVwYXJlRXhwYW5kUmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3QgPSBwcmVwYXJlRXhwYW5kUmVzdWx0Lm1haW5RdWVyeUZpZWxkc0V4cHJlc3Npb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9nZXRDb2xsZWN0aW9uKGRhdGFRdWVyeS5jb2xsZWN0aW9uTmFtZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHNlbGYuX3JlYWRJbnRlcm5hbChjb2xsZWN0aW9uLCBmaWx0ZXIsIHNvcnQsIHNraXAsIGxpbWl0LCBzZWxlY3QpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2tpcCB8fCBsaW1pdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWxsID0gc2VsZi5fcmVhZEludGVybmFsKGNvbGxlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTGVuZ3RoID0gYWxsLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2VsZi5fc2hvdWxkQXV0b2dlbmVyYXRlSWRGb3JDb250ZW50VHlwZShkYXRhUXVlcnkuY29sbGVjdGlvbk5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG9mZmxpbmVUcmFuc2Zvcm1hdGlvbnMucmVtb3ZlSWRUcmFuc2Zvcm0ocmVzdWx0LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBvZmZsaW5lVHJhbnNmb3JtYXRpb25zLmlkVHJhbnNmb3JtKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fZXhwYW5kUmVzdWx0KHByZXBhcmVFeHBhbmRSZXN1bHQsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gc2VsZi5fdHJhbnNmb3JtT2ZmbGluZVJlc3VsdChyZXN1bHQsIGNvbGxlY3Rpb25MZW5ndGgsIGRhdGFRdWVyeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9yZWFkSW50ZXJuYWw6IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBmaWx0ZXIsIHNvcnQsIHNraXAsIGxpbWl0LCBzZWxlY3QpIHtcclxuICAgICAgICAgICAgdmFyIGZpbHRlckNvcHkgPSBfLmV4dGVuZCh7fSwgZmlsdGVyKTtcclxuICAgICAgICAgICAgdmFyIGFjdHVhbEZpbHRlciA9IHRoaXMuX2dldFdpdGhvdXREZWxldGVkRmlsdGVyKGZpbHRlckNvcHkpO1xyXG4gICAgICAgICAgICBvZmZsaW5lVHJhbnNmb3JtYXRpb25zLnRyYXZlcnNlQW5kVHJhbnNmb3JtRmlsdGVySWQoYWN0dWFsRmlsdGVyKTtcclxuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gbWluZ28uUXVlcnkoYWN0dWFsRmlsdGVyKTtcclxuICAgICAgICAgICAgdmFyIGN1cnNvciA9IG1pbmdvLkN1cnNvcihjb2xsZWN0aW9uLCBxdWVyeSwgc2VsZWN0KTtcclxuICAgICAgICAgICAgaWYgKHNvcnQpIHtcclxuICAgICAgICAgICAgICAgIGN1cnNvciA9IGN1cnNvci5zb3J0KHNvcnQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc2tpcCkge1xyXG4gICAgICAgICAgICAgICAgY3Vyc29yLnNraXAoc2tpcCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChsaW1pdCkge1xyXG4gICAgICAgICAgICAgICAgY3Vyc29yLmxpbWl0KGxpbWl0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIF8ubWFwKGN1cnNvci5hbGwoKSwgZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfLmV4dGVuZCh7fSwgaXRlbSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJlYWRCeUlkOiBmdW5jdGlvbiAoZGF0YVF1ZXJ5LCBleHBhbmQpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3ByZXBhcmVFeHBhbmQoZXhwYW5kLCBkYXRhUXVlcnksIGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHByZXBhcmVFeHBhbmRSZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fZ2V0Q29sbGVjdGlvbihkYXRhUXVlcnkuY29sbGVjdGlvbk5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBzZWxmLl9nZXRCeUlkKGNvbGxlY3Rpb24sIGRhdGFRdWVyeS5hZGRpdGlvbmFsT3B0aW9ucy5pZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KEV2ZXJsaXZlRXJyb3JzLml0ZW1Ob3RGb3VuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gb2ZmbGluZVRyYW5zZm9ybWF0aW9ucy5pZFRyYW5zZm9ybShpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fZXhwYW5kUmVzdWx0KHByZXBhcmVFeHBhbmRSZXN1bHQsIGl0ZW0pLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gc2VsZi5fdHJhbnNmb3JtT2ZmbGluZVJlc3VsdChyZXN1bHQsIG51bGwsIGRhdGFRdWVyeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3ByZXBhcmVFeHBhbmQ6IGZ1bmN0aW9uIChleHBhbmQsIGRhdGFRdWVyeSwgaXNBcnJheSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXhwYW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5kUHJvY2Vzc29yLnByZXBhcmUoZXhwYW5kLCBkYXRhUXVlcnkuY29sbGVjdGlvbk5hbWUsIGlzQXJyYXksIGRhdGFRdWVyeS5maWVsZHMsIG51bGwsIG51bGwsIGZ1bmN0aW9uIChlcnIsIHByZXBhcmVSZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVyci5uYW1lID09PSAnRXhwYW5kRXJyb3InKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyLmNvZGUgPSBFdmVybGl2ZUVycm9ycy5pbnZhbGlkRXhwYW5kRXhwcmVzc2lvbi5jb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocHJlcGFyZVJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2V4cGFuZFJlc3VsdDogZnVuY3Rpb24gKHByZXBhcmVFeHBhbmRSZXN1bHQsIHJlc3VsdCkge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcmVwYXJlRXhwYW5kUmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5kUHJvY2Vzc29yLmV4cGFuZChwcmVwYXJlRXhwYW5kUmVzdWx0LnJlbGF0aW9uc1RyZWUsIHJlc3VsdCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZsaW5lTW9kdWxlOiBzZWxmXHJcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIubmFtZSA9PT0gJ0V4cGFuZEVycm9yJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyci5jb2RlID0gRXZlcmxpdmVFcnJvcnMuaW52YWxpZEV4cGFuZEV4cHJlc3Npb24uY29kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZ2V0V2l0aG91dERlbGV0ZWRGaWx0ZXI6IGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgdmFyIHdpdGhvdXREZWxldGVkRmlsdGVyID0ge1xyXG4gICAgICAgICAgICAgICAgJGFuZDogW11cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgd2l0aG91dERlbGV0ZWRGaWx0ZXIuJGFuZC5wdXNoKGZpbHRlcik7XHJcbiAgICAgICAgICAgIHZhciBkZWxldGVPZmZsaW5lRmlsdGVyID0ge307XHJcbiAgICAgICAgICAgIGRlbGV0ZU9mZmxpbmVGaWx0ZXJbY29uc3RhbnRzLm9mZmxpbmVJdGVtc1N0YXRlTWFya2VyXSA9IHskbmU6IG9mZmxpbmVJdGVtU3RhdGVzLmRlbGV0ZWR9O1xyXG4gICAgICAgICAgICB3aXRob3V0RGVsZXRlZEZpbHRlci4kYW5kLnB1c2goZGVsZXRlT2ZmbGluZUZpbHRlcik7XHJcbiAgICAgICAgICAgIHJldHVybiB3aXRob3V0RGVsZXRlZEZpbHRlcjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChkYXRhUXVlcnksIGZpbHRlcikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLl91cGRhdGVJdGVtcyhkYXRhUXVlcnksIGRhdGFRdWVyeS5kYXRhLCBmaWx0ZXIsIGRhdGFRdWVyeS5pc1N5bmMsIHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGRhdGFRdWVyeSwgZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5fcmVtb3ZlSXRlbXMoZGF0YVF1ZXJ5LCBmaWx0ZXIsIGRhdGFRdWVyeS5pc1N5bmMsIHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNvdW50OiBmdW5jdGlvbiAoZGF0YVF1ZXJ5LCBmaWx0ZXIpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5fZ2V0Q29sbGVjdGlvbihkYXRhUXVlcnkuY29sbGVjdGlvbk5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbHRlclJlc3VsdCA9IHNlbGYuX3JlYWRJbnRlcm5hbChjb2xsZWN0aW9uLCBmaWx0ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtyZXN1bHQ6IGZpbHRlclJlc3VsdC5sZW5ndGh9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfc2V0T2ZmbGluZTogZnVuY3Rpb24gKG9mZmxpbmUpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXR1cC5vZmZsaW5lID0gb2ZmbGluZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBpc09ubGluZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuc2V0dXAub2ZmbGluZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfcHJlcGFyZVN5bmNEYXRhOiBmdW5jdGlvbiAoY29udGVudFR5cGVzRm9yU3luYykge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICB2YXIgY29udGVudFR5cGVzU3luY0RhdGEgPSB7fTtcclxuICAgICAgICAgICAgdmFyIGNvbmZsaWN0cyA9IFtdO1xyXG4gICAgICAgICAgICBfLmVhY2goY29udGVudFR5cGVzRm9yU3luYywgZnVuY3Rpb24gKGNvbnRlbnRUeXBlLCB0eXBlTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN5bmNJdGVtcyA9IG9mZmxpbmVUcmFuc2Zvcm1hdGlvbnMuaWRUcmFuc2Zvcm0oY29udGVudFR5cGUub2ZmbGluZUl0ZW1zVG9TeW5jKTtcclxuICAgICAgICAgICAgICAgIHZhciBzeW5jRGF0YSA9IHNlbGYuX2dldFN5bmNJdGVtU3RhdGVzKHR5cGVOYW1lLCBzeW5jSXRlbXMsIGNvbnRlbnRUeXBlLnNlcnZlckl0ZW1zKTtcclxuICAgICAgICAgICAgICAgIGNvbmZsaWN0cy5wdXNoKHN5bmNEYXRhLmNvbmZsaWN0cyk7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZXNTeW5jRGF0YVt0eXBlTmFtZV0gPSBzeW5jRGF0YS5pdGVtc0ZvclN5bmM7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGNvbmZsaWN0czogY29uZmxpY3RzLFxyXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGVzU3luY0RhdGE6IGNvbnRlbnRUeXBlc1N5bmNEYXRhXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3Jlc29sdmVDb25mbGljdHM6IGZ1bmN0aW9uIChzeW5jRGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hcHBseVJlc29sdXRpb25TdHJhdGVneShzeW5jRGF0YS5jb25mbGljdHMpXHJcbiAgICAgICAgICAgICAgICAudGhlbihzZWxmLl9tZXJnZVJlc29sdmVkQ29uZmxpY3RzLmJpbmQoc2VsZiwgc3luY0RhdGEuY29uZmxpY3RzLCBzeW5jRGF0YS5jb250ZW50VHlwZXNTeW5jRGF0YSkpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN5bmNEYXRhLmNvbnRlbnRUeXBlc1N5bmNEYXRhO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgaXNTeW5jaHJvbml6aW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1N5bmNocm9uaXppbmc7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2ZpcmVTeW5jU3RhcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuICAgICAgICAgICAgICAgIGlmICghc2VsZi5faXNTeW5jaHJvbml6aW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5faXNTeW5jaHJvbml6aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmV2ZXJsaXZlLl9lbWl0dGVyLmVtaXQoJ3N5bmNTdGFydCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZmlyZVN5bmNFbmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5faXNTeW5jaHJvbml6aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIF8uZWFjaCh0aGlzLl9zeW5jUmVzdWx0SW5mby5zeW5jZWRJdGVtcywgZnVuY3Rpb24gKHN5bmNlZEl0ZW1zLCBjb250ZW50VHlwZU5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHNlbGYuX3N5bmNSZXN1bHRJbmZvLnN5bmNlZFRvU2VydmVyICs9IF8ud2hlcmUoc3luY2VkSXRlbXMsIHtzdG9yYWdlOiAnc2VydmVyJ30pLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHNlbGYuX3N5bmNSZXN1bHRJbmZvLnN5bmNlZFRvQ2xpZW50ICs9IF8ud2hlcmUoc3luY2VkSXRlbXMsIHtzdG9yYWdlOiAnY2xpZW50J30pLmxlbmd0aDtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmV2ZXJsaXZlLl9lbWl0dGVyLmVtaXQoJ3N5bmNFbmQnLCB0aGlzLl9zeW5jUmVzdWx0SW5mbyk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zeW5jUmVzdWx0SW5mbztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZWFjaFN5bmNJdGVtOiBmdW5jdGlvbiAoaXRlbXMsIGdldEZpbHRlckZ1bmN0aW9uLCBjb250ZW50VHlwZU5hbWUsIG9wZXJhdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICBfLmVhY2goaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXRlbUZpbHRlciA9IGdldEZpbHRlckZ1bmN0aW9uKGl0ZW0ucmVtb3RlSXRlbSk7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhbHJlYWR5IGhhdmUgYW4gZXJyb3IgZm9yIHRoaXMgaXRlbSB3ZSBkbyBub3Qgd2FudCB0byB0cnkgYW5kIHN5bmMgaXQgYWdhaW5cclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHRJdGVtID0gaXRlbS5yZXN1bHRpbmdJdGVtO1xyXG4gICAgICAgICAgICAgICAgaWYgKF8uc29tZShzZWxmLl9zeW5jUmVzdWx0SW5mby5mYWlsZWRJdGVtc1tjb250ZW50VHlwZU5hbWVdLCB7aXRlbUlkOiByZXN1bHRJdGVtLklkfSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uKHJlc3VsdEl0ZW0sIGl0ZW1GaWx0ZXIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfYWRkQ3JlYXRlZEl0ZW1zRm9yU3luYzogZnVuY3Rpb24gKGNvbnRlbnRUeXBlRGF0YSwgc3luY1Byb21pc2VzLCBkYXRhQ29sbGVjdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICB2YXIgcmVzdWx0aW5nSXRlbXNGb3JDcmVhdGUgPSBfLnBsdWNrKGNvbnRlbnRUeXBlRGF0YS5jcmVhdGVkSXRlbXMsICdyZXN1bHRpbmdJdGVtJyk7XHJcbiAgICAgICAgICAgIHZhciBpZHM7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fc2hvdWxkQXV0b2dlbmVyYXRlSWRGb3JDb250ZW50VHlwZShkYXRhQ29sbGVjdGlvbi5jb2xsZWN0aW9uTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIGlkcyA9IF8ucGx1Y2socmVzdWx0aW5nSXRlbXNGb3JDcmVhdGUsICdJZCcpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0aW5nSXRlbXNGb3JDcmVhdGUgPSBvZmZsaW5lVHJhbnNmb3JtYXRpb25zLnJlbW92ZUlkVHJhbnNmb3JtKHJlc3VsdGluZ0l0ZW1zRm9yQ3JlYXRlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc3luY1Byb21pc2VzWydjcmVhdGUnXSA9XHJcbiAgICAgICAgICAgICAgICBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhQ29sbGVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuaXNTeW5jKHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBseU9mZmxpbmUoZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jcmVhdGUocmVzdWx0aW5nSXRlbXNGb3JDcmVhdGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ0l0ZW1zRm9yQ3JlYXRlID0gXy5tYXAocmVzdWx0aW5nSXRlbXNGb3JDcmVhdGUsIGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uSWQgPSByZXMucmVzdWx0W2luZGV4XS5JZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLkNyZWF0ZWRBdCA9IGl0ZW0uTW9kaWZpZWRBdCA9IHJlcy5yZXN1bHRbaW5kZXhdLkNyZWF0ZWRBdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhQ29sbGVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5pc1N5bmModHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudXNlT2ZmbGluZSh0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jcmVhdGUocmVzdWx0aW5nSXRlbXNGb3JDcmVhdGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sbGVjdGlvbk5hbWUgPSBkYXRhQ29sbGVjdGlvbi5jb2xsZWN0aW9uTmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5lYWNoKHJlc3VsdGluZ0l0ZW1zRm9yQ3JlYXRlLCBmdW5jdGlvbiAoY3JlYXRlZEl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2FkZEl0ZW1TeW5jZWQoY3JlYXRlZEl0ZW0sIGNvbGxlY3Rpb25OYW1lLCAnc2VydmVyJywgJ2NyZWF0ZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZHMgJiYgaWRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbHRlciA9IHtJZDogeyRpbjogaWRzfX07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YUNvbGxlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaXNTeW5jKHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnVzZU9mZmxpbmUodHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZGVzdHJveShmaWx0ZXIpLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjcmVhdGUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IHJlc3VsdGluZ0l0ZW1zRm9yQ3JlYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGU6IGRhdGFDb2xsZWN0aW9uLmNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JhZ2U6ICdjbGllbnQnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY3JlYXRlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiByZXN1bHRpbmdJdGVtc0ZvckNyZWF0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBkYXRhQ29sbGVjdGlvbi5jb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yYWdlOiAnY2xpZW50J1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3Qoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjcmVhdGUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiByZXN1bHRpbmdJdGVtc0ZvckNyZWF0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogZGF0YUNvbGxlY3Rpb24uY29sbGVjdGlvbk5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yYWdlOiAnc2VydmVyJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NyZWF0ZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IHJlc3VsdGluZ0l0ZW1zRm9yQ3JlYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBkYXRhQ29sbGVjdGlvbi5jb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfYWRkVXBkYXRlZEl0ZW1zRm9yU3luYzogZnVuY3Rpb24gKGNvbnRlbnRUeXBlRGF0YSwgZ2V0RmlsdGVyT3BlcmF0aW9uLCBzeW5jUHJvbWlzZXMsIGRhdGFDb2xsZWN0aW9uLCBpdGVtVXBkYXRlT3BlcmF0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGNvbGxlY3Rpb25OYW1lID0gZGF0YUNvbGxlY3Rpb24uY29sbGVjdGlvbk5hbWU7XHJcbiAgICAgICAgICAgIHNlbGYuX2VhY2hTeW5jSXRlbShjb250ZW50VHlwZURhdGEubW9kaWZpZWRJdGVtcywgZ2V0RmlsdGVyT3BlcmF0aW9uLCBjb2xsZWN0aW9uTmFtZSwgaXRlbVVwZGF0ZU9wZXJhdGlvbik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2FkZERlbGV0ZWRJdGVtc0ZvclN5bmM6IGZ1bmN0aW9uIChjb250ZW50VHlwZURhdGEsIGdldEZpbHRlck9wZXJhdGlvbiwgc3luY1Byb21pc2VzLCBkYXRhQ29sbGVjdGlvbiwgaXRlbURlbGV0ZU9wZXJhdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICB2YXIgY29sbGVjdGlvbk5hbWUgPSBkYXRhQ29sbGVjdGlvbi5jb2xsZWN0aW9uTmFtZTtcclxuICAgICAgICAgICAgc2VsZi5fZWFjaFN5bmNJdGVtKGNvbnRlbnRUeXBlRGF0YS5kZWxldGVkSXRlbXMsIGdldEZpbHRlck9wZXJhdGlvbiwgY29sbGVjdGlvbk5hbWUsIGl0ZW1EZWxldGVPcGVyYXRpb24pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9vblN5bmNSZXNwb25zZTogZnVuY3Rpb24gKHJlcywgaXRlbSwgY29sbGVjdGlvbk5hbWUsIG9wZXJhdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICBpZiAocmVzLnJlc3VsdCAhPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3JlbW92ZUl0ZW1TeW5jZWQoaXRlbSwgY29sbGVjdGlvbk5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChfLmV4dGVuZCh7fSwgRXZlcmxpdmVFcnJvcnMuc3luY0NvbmZsaWN0LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBjb2xsZWN0aW9uTmFtZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXBkYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fYWRkSXRlbVN5bmNlZChpdGVtLCBjb2xsZWN0aW9uTmFtZSwgJ3NlcnZlcicsICd1cGRhdGUnKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdXBkYXRlZEl0ZW0gPSBfLmV4dGVuZCh7fSwgaXRlbSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBNb2RpZmllZEF0OiByZXMuTW9kaWZpZWRBdFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgdXBkYXRlUXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBvcGVyYXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHVwZGF0ZWRJdGVtLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsT3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGl0ZW0uSWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbk5hbWU6IGNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1N5bmM6IHRydWVcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1F1ZXJ5KHVwZGF0ZVF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSBEYXRhUXVlcnkub3BlcmF0aW9ucy5yZW1vdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9hZGRJdGVtU3luY2VkKGl0ZW0sIGNvbGxlY3Rpb25OYW1lLCAnc2VydmVyJywgJ2RlbGV0ZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wdXJnZUJ5SWQoY29sbGVjdGlvbk5hbWUsIGl0ZW0uSWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3B1cmdlQnlJZDogZnVuY3Rpb24gKGNvbnRlbnRUeXBlLCBpdGVtSWQpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2dldENvbGxlY3Rpb24oY29udGVudFR5cGUpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoY29sbGVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjb2xsZWN0aW9uW2l0ZW1JZF07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3BlcnNpc3REYXRhKGNvbnRlbnRUeXBlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHN5bmM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICBzZWxmLl9zeW5jUmVzdWx0SW5mbyA9IHNlbGYuX3N5bmNSZXN1bHRJbmZvIHx8IHtcclxuICAgICAgICAgICAgICAgIHN5bmNlZEl0ZW1zOiB7fSxcclxuICAgICAgICAgICAgICAgIHN5bmNlZFRvU2VydmVyOiAwLFxyXG4gICAgICAgICAgICAgICAgc3luY2VkVG9DbGllbnQ6IDAsXHJcbiAgICAgICAgICAgICAgICBmYWlsZWRJdGVtczoge30sXHJcbiAgICAgICAgICAgICAgICBlcnJvcjogdW5kZWZpbmVkIC8vIGFkZGVkIGZvciB2aXNpYmlsaXR5XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNPbmxpbmUoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ0Nhbm5vdCBzeW5jaHJvbml6ZSB3aGlsZSBvZmZsaW5lJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHNlbGYuX2ZpcmVTeW5jU3RhcnQoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oc2VsZi5fYXBwbHlTeW5jLmJpbmQoc2VsZikpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoc3luY1Jlc3VsdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29uZmxpY3RzV2hpbGVTeW5jID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgXy5lYWNoKHN5bmNSZXN1bHRzLCBmdW5jdGlvbiAoc3luY1Jlc3VsdCwgaXRlbUlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzeW5jUmVzdWx0ICYmIHN5bmNSZXN1bHQuc3RhdGUgPT09ICdyZWplY3RlZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRUeXBlID0gc3luY1Jlc3VsdC5yZWFzb24uY29udGVudFR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3luY1Jlc3VsdC5yZWFzb24gJiYgc3luY1Jlc3VsdC5yZWFzb24uY29kZSA9PT0gRXZlcmxpdmVFcnJvcnMuc3luY0NvbmZsaWN0LmNvZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25mbGljdHNXaGlsZVN5bmMucHVzaChzeW5jUmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gc2F2ZSB0aW1lIGFuZCB0cmFmZmljIHdlIGFyZSB1c2luZyBhIHNpbmdsZSBjcmVhdGUgcmVxdWVzdCBmb3IgYWxsIGl0ZW1zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyB3aHkgaWYgdGhlcmUgaXMgYW4gZXJyb3Igd2UgbmVlZCB0byBzcGxpdCB0aGUgaXRlbXMgd2UgdHJpZWQgdG8gY3JlYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHNldCB0aGUgc2FtZSBlcnJvciBmb3IgYWxsIGl0ZW1zLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gc3luY1Jlc3VsdC5yZWFzb24udHlwZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9zeW5jUmVzdWx0SW5mby5mYWlsZWRJdGVtc1t0YXJnZXRUeXBlXSA9IHNlbGYuX3N5bmNSZXN1bHRJbmZvLmZhaWxlZEl0ZW1zW3RhcmdldFR5cGVdIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnY3JlYXRlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmVhY2goc3luY1Jlc3VsdC5yZWFzb24uaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9yZW1vdmVJdGVtU3luY2VkKGl0ZW0sIHRhcmdldFR5cGUsICdzZXJ2ZXInLCAnY3JlYXRlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9zeW5jUmVzdWx0SW5mby5mYWlsZWRJdGVtc1t0YXJnZXRUeXBlXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wdXNoKF8uZXh0ZW5kKHtpdGVtSWQ6IGl0ZW0uSWR9LCBfLnBpY2soc3luY1Jlc3VsdC5yZWFzb24sICdzdG9yYWdlJywgJ3R5cGUnLCAnZXJyb3InKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9yZW1vdmVJdGVtU3luY2VkKGl0ZW1JZCwgdGFyZ2V0VHlwZSwgJ3NlcnZlcicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9zeW5jUmVzdWx0SW5mby5mYWlsZWRJdGVtc1t0YXJnZXRUeXBlXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnB1c2goXy5leHRlbmQoe2l0ZW1JZDogaXRlbUlkfSwgXy5waWNrKHN5bmNSZXN1bHQucmVhc29uLCAnc3RvcmFnZScsICd0eXBlJywgJ2Vycm9yJykpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZsaWN0c1doaWxlU3luYy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuc3luYygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2ZpcmVTeW5jRW5kKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fc3luY1Jlc3VsdEluZm8uZXJyb3IgPSBlcnI7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZmlyZVN5bmNFbmQoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9oYW5kbGVLZWVwU2VydmVyOiBmdW5jdGlvbiAodHlwZU5hbWUsIGNvbmZsaWN0aW5nSXRlbSwgb2ZmbGluZVN5bmNPcGVyYXRpb25zKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHZhciBzZXJ2ZXJJdGVtID0gY29uZmxpY3RpbmdJdGVtLnNlcnZlckl0ZW07XHJcbiAgICAgICAgICAgIHZhciBjbGllbnRJdGVtID0gY29uZmxpY3RpbmdJdGVtLmNsaWVudEl0ZW07XHJcbiAgICAgICAgICAgIHZhciBzeW5jUXVlcnk7XHJcbiAgICAgICAgICAgIGlmIChzZXJ2ZXJJdGVtICYmIGNsaWVudEl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgaXRlbSBvZmZsaW5lXHJcbiAgICAgICAgICAgICAgICBzeW5jUXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogdHlwZU5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy51cGRhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbE9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHNlcnZlckl0ZW0uSWRcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHNlcnZlckl0ZW1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlcnZlckl0ZW0gJiYgIWNsaWVudEl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBpdGVtIG9mZmxpbmVcclxuICAgICAgICAgICAgICAgIHN5bmNRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiB0eXBlTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLmNyZWF0ZSxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBzZXJ2ZXJJdGVtXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICghc2VydmVySXRlbSAmJiBjbGllbnRJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkZWxldGUgaXRlbSBvZmZsaW5lXHJcbiAgICAgICAgICAgICAgICBzeW5jUXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogdHlwZU5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy5yZW1vdmVTaW5nbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbE9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGNsaWVudEl0ZW0uSWRcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdCb3RoIHNlcnZlckl0ZW0gYW5kIGNsaWVudEl0ZW0gYXJlIG5vdCBzZXQgd2hlbiBzeW5jaW5nIGRhdGEgd2l0aCBcIktlZXBTZXJ2ZXJcIiByZXNvbHV0aW9uIHN0cmF0ZWd5LicpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzeW5jUXVlcnkuaXNTeW5jID0gdHJ1ZTtcclxuICAgICAgICAgICAgb2ZmbGluZVN5bmNPcGVyYXRpb25zLnB1c2gobmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLnByb2Nlc3NRdWVyeShzeW5jUXVlcnkpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN5bmNRdWVyeS5vcGVyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXBkYXRlOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2FkZEl0ZW1TeW5jZWQoc2VydmVySXRlbSwgdHlwZU5hbWUsICdjbGllbnQnLCAndXBkYXRlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERhdGFRdWVyeS5vcGVyYXRpb25zLmNyZWF0ZTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9hZGRJdGVtU3luY2VkKHNlcnZlckl0ZW0sIHR5cGVOYW1lLCAnY2xpZW50JywgJ2NyZWF0ZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEYXRhUXVlcnkub3BlcmF0aW9ucy5yZW1vdmVTaW5nbGU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fYWRkSXRlbVN5bmNlZChjbGllbnRJdGVtLCB0eXBlTmFtZSwgJ2NsaWVudCcsICdkZWxldGUnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbUlkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3BlcmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN5bmNRdWVyeS5vcGVyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXBkYXRlOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1JZCA9IHNlcnZlckl0ZW0uSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uID0gJ3VwZGF0ZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERhdGFRdWVyeS5vcGVyYXRpb25zLmNyZWF0ZTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtSWQgPSBzZXJ2ZXJJdGVtLklkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9ICdjcmVhdGUnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEYXRhUXVlcnkub3BlcmF0aW9ucy5yZW1vdmVTaW5nbGU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUlkID0gY2xpZW50SXRlbS5JZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb24gPSAnZGVsZXRlJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1JZDogaXRlbUlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogb3BlcmF0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGU6IHN5bmNRdWVyeS5jb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yYWdlOiAnY2xpZW50J1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfaGFuZGxlS2VlcENsaWVudDogZnVuY3Rpb24gKGNvbmZsaWN0aW5nSXRlbSwgY29udGVudFR5cGVTeW5jRGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgc2VydmVySXRlbSA9IGNvbmZsaWN0aW5nSXRlbS5zZXJ2ZXJJdGVtO1xyXG4gICAgICAgICAgICB2YXIgY2xpZW50SXRlbSA9IGNvbmZsaWN0aW5nSXRlbS5jbGllbnRJdGVtO1xyXG4gICAgICAgICAgICBpZiAoc2VydmVySXRlbSAmJiBjbGllbnRJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbW9kaWZpZWRPYmplY3QgPSBfLmV4dGVuZChjbGllbnRJdGVtLCB7TW9kaWZpZWRBdDogbmV3IERhdGUoc2VydmVySXRlbS5Nb2RpZmllZEF0KX0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlU3luY0RhdGEubW9kaWZpZWRJdGVtcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdGVJdGVtOiBjb25mbGljdGluZ0l0ZW0uc2VydmVySXRlbSxcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRpbmdJdGVtOiBtb2RpZmllZE9iamVjdFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VydmVySXRlbSAmJiAhY2xpZW50SXRlbSkge1xyXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGVTeW5jRGF0YS5kZWxldGVkSXRlbXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlSXRlbTogY29uZmxpY3RpbmdJdGVtLnNlcnZlckl0ZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nSXRlbTogc2VydmVySXRlbVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXNlcnZlckl0ZW0gJiYgY2xpZW50SXRlbSkge1xyXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGVTeW5jRGF0YS5jcmVhdGVkSXRlbXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlSXRlbTogY29uZmxpY3RpbmdJdGVtLnNlcnZlckl0ZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nSXRlbTogY2xpZW50SXRlbVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignQm90aCBzZXJ2ZXJJdGVtIGFuZCBjbGllbnRJdGVtIGFyZSBub3Qgc2V0IHdoZW4gc3luY2luZyBkYXRhIHdpdGggXCJLZWVwQ2xpZW50XCIgcmVzb2x1dGlvbiBzdHJhdGVneS4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9oYW5kbGVDdXN0b206IGZ1bmN0aW9uIChjb25mbGljdGluZ0l0ZW0sIHR5cGVOYW1lLCBvZmZsaW5lU3luY09wZXJhdGlvbnMsIGNvbnRlbnRUeXBlU3luY0RhdGEpIHtcclxuICAgICAgICAgICAgdmFyIHNlcnZlckl0ZW0gPSBjb25mbGljdGluZ0l0ZW0uc2VydmVySXRlbTtcclxuICAgICAgICAgICAgdmFyIGNsaWVudEl0ZW0gPSBjb25mbGljdGluZ0l0ZW0uY2xpZW50SXRlbTtcclxuICAgICAgICAgICAgdmFyIGN1c3RvbUl0ZW0gPSBfLm9taXQoY29uZmxpY3RpbmdJdGVtLnJlc3VsdC5pdGVtLCAnQ3JlYXRlZEF0JywgJ01vZGlmaWVkQXQnKTtcclxuICAgICAgICAgICAgaWYgKHNlcnZlckl0ZW0gJiYgY3VzdG9tSXRlbSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNyZWF0ZUl0ZW1PZmZsaW5lUXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogdHlwZU5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy5jcmVhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogc2VydmVySXRlbSAvLyBjcmVhdGUgdGhlIHNlcnZlciBpdGVtIG9mZmxpbmUgYW5kIGl0IHdpbGwgYmUgdXBkYXRlZCB3aGVuIHN5bmMgZmluaXNoZXNcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGNyZWF0ZUl0ZW1PZmZsaW5lUXVlcnkucHJlc2VydmVTdGF0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjcmVhdGVJdGVtT2ZmbGluZVF1ZXJ5LmlzU3luYyA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgb2ZmbGluZVN5bmNPcGVyYXRpb25zLnB1c2godGhpcy5wcm9jZXNzUXVlcnkoY3JlYXRlSXRlbU9mZmxpbmVRdWVyeSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc2VydmVySXRlbSAmJiBjdXN0b21JdGVtICYmICFjbGllbnRJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICBjdXN0b21JdGVtLklkID0gc2VydmVySXRlbS5JZDtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlU3luY0RhdGEubW9kaWZpZWRJdGVtcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdGVJdGVtOiBzZXJ2ZXJJdGVtLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ0l0ZW06IGN1c3RvbUl0ZW1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlcnZlckl0ZW0gJiYgIWN1c3RvbUl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlU3luY0RhdGEuZGVsZXRlZEl0ZW1zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZUl0ZW06IGNvbmZsaWN0aW5nSXRlbS5zZXJ2ZXJJdGVtLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ0l0ZW06IHNlcnZlckl0ZW1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzZXJ2ZXJJdGVtICYmIGN1c3RvbUl0ZW0gJiYgY2xpZW50SXRlbSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZUl0ZW1PZmZsaW5lUXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogdHlwZU5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy51cGRhdGUsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3VzdG9tSXRlbSxcclxuICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsT3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogY2xpZW50SXRlbS5JZFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIG9mZmxpbmVTeW5jT3BlcmF0aW9ucy5wdXNoKHRoaXMucHJvY2Vzc1F1ZXJ5KHVwZGF0ZUl0ZW1PZmZsaW5lUXVlcnkpKTtcclxuICAgICAgICAgICAgICAgIGN1c3RvbUl0ZW0uSWQgPSBjbGllbnRJdGVtLklkO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlU3luY0RhdGEuY3JlYXRlZEl0ZW1zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZUl0ZW06IHNlcnZlckl0ZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nSXRlbTogY3VzdG9tSXRlbVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjdXN0b21JdGVtLklkID0gc2VydmVySXRlbS5JZDtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlU3luY0RhdGEubW9kaWZpZWRJdGVtcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdGVJdGVtOiBzZXJ2ZXJJdGVtLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ0l0ZW06IGN1c3RvbUl0ZW1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX21lcmdlUmVzb2x2ZWRDb25mbGljdHM6IGZ1bmN0aW9uIChjb25mbGljdHMsIHN5bmNEYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHZhciBvZmZsaW5lU3luY09wZXJhdGlvbnMgPSBbXTtcclxuICAgICAgICAgICAgXy5lYWNoKGNvbmZsaWN0cywgZnVuY3Rpb24gKGNvbmZsaWN0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHlwZU5hbWUgPSBjb25mbGljdC5jb250ZW50VHlwZU5hbWU7XHJcbiAgICAgICAgICAgICAgICBfLmVhY2goY29uZmxpY3QuY29uZmxpY3RpbmdJdGVtcywgZnVuY3Rpb24gKGNvbmZsaWN0aW5nSXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50VHlwZVN5bmNEYXRhID0gc3luY0RhdGFbdHlwZU5hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29uZmxpY3RpbmdJdGVtLnJlc3VsdC5yZXNvbHV0aW9uVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNvbnN0YW50cy5Db25mbGljdFJlc29sdXRpb24uS2VlcFNlcnZlcjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2hhbmRsZUtlZXBTZXJ2ZXIodHlwZU5hbWUsIGNvbmZsaWN0aW5nSXRlbSwgb2ZmbGluZVN5bmNPcGVyYXRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNvbnN0YW50cy5Db25mbGljdFJlc29sdXRpb24uS2VlcENsaWVudDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2hhbmRsZUtlZXBDbGllbnQoY29uZmxpY3RpbmdJdGVtLCBjb250ZW50VHlwZVN5bmNEYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNvbnN0YW50cy5Db25mbGljdFJlc29sdXRpb24uQ3VzdG9tOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5faGFuZGxlQ3VzdG9tKGNvbmZsaWN0aW5nSXRlbSwgdHlwZU5hbWUsIG9mZmxpbmVTeW5jT3BlcmF0aW9ucywgY29udGVudFR5cGVTeW5jRGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcnN2cC5hbGwob2ZmbGluZVN5bmNPcGVyYXRpb25zKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZ2V0U3luY0l0ZW1TdGF0ZXM6IGZ1bmN0aW9uIChjb250ZW50VHlwZSwgb2ZmbGluZUl0ZW1zLCBzZXJ2ZXJJdGVtcykge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICB2YXIgY29udGVudFR5cGVTeW5jRGF0YSA9IHtcclxuICAgICAgICAgICAgICAgIGl0ZW1zRm9yU3luYzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZWRJdGVtczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRJdGVtczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlZEl0ZW1zOiBbXVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGNvbmZsaWN0czoge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlTmFtZTogY29udGVudFR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmxpY3RpbmdJdGVtczogW11cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIF8uZWFjaChvZmZsaW5lSXRlbXMsIGZ1bmN0aW9uIChvZmZsaW5lSXRlbSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlcnZlckl0ZW0gPSBfLmZpbmRXaGVyZShzZXJ2ZXJJdGVtcywge0lkOiBvZmZsaW5lSXRlbS5JZH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlcnZlckl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VydmVySXRlbS5JZCA9PT0gb2ZmbGluZUl0ZW0uSWQgJiYgb2ZmbGluZUl0ZW1bY29uc3RhbnRzLm9mZmxpbmVJdGVtc1N0YXRlTWFya2VyXSA9PT0gb2ZmbGluZUl0ZW1TdGF0ZXMuY3JlYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9zeW5jUmVzdWx0SW5mby5mYWlsZWRJdGVtc1tjb250ZW50VHlwZV0gPSBzZWxmLl9zeW5jUmVzdWx0SW5mby5mYWlsZWRJdGVtc1tjb250ZW50VHlwZV0gfHwgW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3N5bmNSZXN1bHRJbmZvLmZhaWxlZEl0ZW1zW2NvbnRlbnRUeXBlXS5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1JZDogc2VydmVySXRlbS5JZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjcmVhdGUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTogJ2NsaWVudCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogRXZlcmxpdmVFcnJvcnMuc3luY0Vycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsaWVudEl0ZW1DaGFuZ2VkID0gISFvZmZsaW5lSXRlbVtjb25zdGFudHMub2ZmbGluZUl0ZW1zU3RhdGVNYXJrZXJdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoYXNVcGRhdGVDb25mbGljdCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xpZW50SXRlbUNoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzVXBkYXRlQ29uZmxpY3QgPSBzZXJ2ZXJJdGVtLk1vZGlmaWVkQXQuZ2V0VGltZSgpICE9PSBvZmZsaW5lSXRlbS5Nb2RpZmllZEF0LmdldFRpbWUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNVcGRhdGVDb25mbGljdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZVN5bmNEYXRhLmNvbmZsaWN0cy5jb25mbGljdGluZ0l0ZW1zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGl0ZW0gd2FzIG1vZGlmaWVkIG9uIHRoZSBzZXJ2ZXIgYW5kIGRlbGV0ZWQgbG9jYWxseSB3ZSBoYXZlIGEgY29uZmxpY3QgYW5kIHNldCB0aGUgY2xpZW50IGl0ZW0gdG8gbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGl0IGlzIGEgc2ltcGxlIG1vZGlmaWNhdGlvbiBjb25mbGljdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50SXRlbTogb2ZmbGluZUl0ZW1bY29uc3RhbnRzLm9mZmxpbmVJdGVtc1N0YXRlTWFya2VyXSA9PT0gb2ZmbGluZUl0ZW1TdGF0ZXMuZGVsZXRlZCA/IG51bGwgOiBvZmZsaW5lSXRlbSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlckl0ZW06IHNlcnZlckl0ZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHt9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvZmZsaW5lSXRlbVtjb25zdGFudHMub2ZmbGluZUl0ZW1zU3RhdGVNYXJrZXJdID09PSBvZmZsaW5lSXRlbVN0YXRlcy5kZWxldGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZVN5bmNEYXRhLml0ZW1zRm9yU3luYy5kZWxldGVkSXRlbXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3RlSXRlbTogc2VydmVySXRlbSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRpbmdJdGVtOiBvZmZsaW5lSXRlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZVN5bmNEYXRhLml0ZW1zRm9yU3luYy5tb2RpZmllZEl0ZW1zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZUl0ZW06IHNlcnZlckl0ZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nSXRlbTogb2ZmbGluZUl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgaXRlbSBpbiBtZW1vcnkgaGFzIGJlZW4gbW9kaWZpZWQsIGJ1dCB0aGUgaXRlbSBvbiB0aGUgc2VydmVyIGhhcyBiZWVuIGRlbGV0ZWRcclxuICAgICAgICAgICAgICAgICAgICBpZiAob2ZmbGluZUl0ZW1bY29uc3RhbnRzLm9mZmxpbmVJdGVtc1N0YXRlTWFya2VyXSA9PT0gb2ZmbGluZUl0ZW1TdGF0ZXMubW9kaWZpZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGVTeW5jRGF0YS5jb25mbGljdHMuY29uZmxpY3RpbmdJdGVtcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudEl0ZW06IG9mZmxpbmVJdGVtLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVySXRlbTogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDoge31cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGVTeW5jRGF0YS5pdGVtc0ZvclN5bmMuY3JlYXRlZEl0ZW1zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3RlSXRlbTogc2VydmVySXRlbSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ0l0ZW06IG9mZmxpbmVJdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBkZWxldGUgb2ZmbGluZUl0ZW1bY29uc3RhbnRzLm9mZmxpbmVJdGVtc1N0YXRlTWFya2VyXTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY29udGVudFR5cGVTeW5jRGF0YTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfc2V0UmVzb2x1dGlvblR5cGVGb3JJdGVtOiBmdW5jdGlvbiAocmVzb2x1dGlvblR5cGUsIGNvbmZsaWN0aW5nSXRlbSkge1xyXG4gICAgICAgICAgICBjb25mbGljdGluZ0l0ZW0ucmVzdWx0ID0ge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x1dGlvblR5cGU6IHJlc29sdXRpb25UeXBlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2FwcGx5UmVzb2x1dGlvblN0cmF0ZWd5OiBmdW5jdGlvbiAoY29uZmxpY3RzKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGNvbmZsaWN0UmVzb2x1dGlvblN0cmF0ZWd5ID0gc2VsZi5zZXR1cC5jb25mbGljdHMuc3RyYXRlZ3k7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29uZmxpY3RzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbmZsaWN0ID0gY29uZmxpY3RzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25mbGljdC5jb25mbGljdGluZ0l0ZW1zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvbmZsaWN0UmVzb2x1dGlvblN0cmF0ZWd5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNvbnN0YW50cy5Db25mbGljdFJlc29sdXRpb25TdHJhdGVneS5TZXJ2ZXJXaW5zOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uZWFjaChjb25mbGljdC5jb25mbGljdGluZ0l0ZW1zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9zZXRSZXNvbHV0aW9uVHlwZUZvckl0ZW0uYmluZChzZWxmLCBjb25zdGFudHMuQ29uZmxpY3RSZXNvbHV0aW9uLktlZXBTZXJ2ZXIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzLkNvbmZsaWN0UmVzb2x1dGlvblN0cmF0ZWd5LkNsaWVudFdpbnM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNvbnN0YW50cy5Db25mbGljdFJlc29sdXRpb25TdHJhdGVneS5DdXN0b206XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1c3RvbVN0cmF0ZWd5ID0gc2VsZi5zZXR1cC5jb25mbGljdHMuaW1wbGVtZW50YXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXN0b21TdHJhdGVneSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFdmVybGl2ZUVycm9yKCdJbXBsZW1lbnRhdGlvbiBvZiB0aGUgY29uZmxpY3QgcmVzb2x1dGlvbiBzdHJhdGVneSAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ211c3QgYmUgcHJvdmlkZWQgd2hlbiBzZXQgdG8gQ3VzdG9tJykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tU3RyYXRlZ3koY29uZmxpY3RzLCByZXNvbHZlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXZlcmxpdmVFcnJvcignSW52YWxpZCByZXNvbHV0aW9uIHN0cmF0ZWd5IHByb3ZpZGVkJykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2dldFN5bmNQcm9taXNlQmF0Y2g6IGZ1bmN0aW9uIChjb250ZW50VHlwZSwgYmF0Y2hJZHMpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGFRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBjb250ZW50VHlwZSxcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0lkJzoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRpbic6IGJhdGNoSWRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVhZCxcclxuICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXMucmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGFwcGx5T2ZmbGluZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcjogcmVqZWN0XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZ2V0UmVxdWVzdE9wdGlvbnNGcm9tUXVlcnkgPSBSZXF1ZXN0T3B0aW9uc0J1aWxkZXJbZGF0YVF1ZXJ5Lm9wZXJhdGlvbl07XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdE9wdGlvbnMgPSBnZXRSZXF1ZXN0T3B0aW9uc0Zyb21RdWVyeShkYXRhUXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdChzZWxmLmV2ZXJsaXZlLnNldHVwLCByZXF1ZXN0T3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnNlbmQoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2dldFN5bmNQcm9taXNlRm9yQ29sbGVjdGlvbjogZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGNvbnRlbnRUeXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHZhciBiYXRjaGVzID0gW107XHJcbiAgICAgICAgICAgIHZhciBiYXRjaFNpemUgPSBjb25zdGFudHMuc3luY0JhdGNoU2l6ZTtcclxuXHJcbiAgICAgICAgICAgIHZhciBvZmZsaW5lSXRlbXNUb1N5bmMgPSBzZWxmLl9nZXREaXJ0eUl0ZW1zKGNvbGxlY3Rpb24pO1xyXG5cclxuICAgICAgICAgICAgdmFyIGFsbElkc0ZvclN5bmM7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9zaG91bGRBdXRvZ2VuZXJhdGVJZEZvckNvbnRlbnRUeXBlKGNvbnRlbnRUeXBlKSkge1xyXG4gICAgICAgICAgICAgICAgYWxsSWRzRm9yU3luYyA9IF8ucGx1Y2sob2ZmbGluZUl0ZW1zVG9TeW5jLCAnX2lkJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhbGxJZHNGb3JTeW5jID0gXy5wbHVjayhfLnJlamVjdChvZmZsaW5lSXRlbXNUb1N5bmMsIGZ1bmN0aW9uIChvZmZsaW5lSXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvZmZsaW5lSXRlbVtjb25zdGFudHMub2ZmbGluZUl0ZW1zU3RhdGVNYXJrZXJdID09PSBvZmZsaW5lSXRlbVN0YXRlcy5jcmVhdGVkO1xyXG4gICAgICAgICAgICAgICAgfSksICdfaWQnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGJhdGNoQ291bnQgPSBNYXRoLmNlaWwoYWxsSWRzRm9yU3luYy5sZW5ndGggLyBiYXRjaFNpemUpO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXRjaENvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBiYXRjaFNraXBTaXplID0gaSAqIGJhdGNoU2l6ZTtcclxuICAgICAgICAgICAgICAgIHZhciBiYXRjaElkcyA9IGFsbElkc0ZvclN5bmMuc2xpY2UoYmF0Y2hTa2lwU2l6ZSwgYmF0Y2hTa2lwU2l6ZSArIGJhdGNoU2l6ZSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3luY0dldFNlcnZlckl0ZW1zUHJvbWlzZSA9IHRoaXMuX2dldFN5bmNQcm9taXNlQmF0Y2goY29udGVudFR5cGUsIGJhdGNoSWRzKTtcclxuICAgICAgICAgICAgICAgIGJhdGNoZXMucHVzaChzeW5jR2V0U2VydmVySXRlbXNQcm9taXNlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJzdnAuYWxsKGJhdGNoZXMpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoc2VydmVySXRlbXNTeW5jUmVzcG9uc2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVySXRlbXM6IFtdXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXy5lYWNoKHNlcnZlckl0ZW1zU3luY1Jlc3BvbnNlcywgZnVuY3Rpb24gKHNlcnZlckl0ZW1zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXJ2ZXJJdGVtcyA9IF8udW5pb24ocmVzdWx0LnNlcnZlckl0ZW1zLCBzZXJ2ZXJJdGVtcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5vZmZsaW5lSXRlbXNUb1N5bmMgPSBvZmZsaW5lSXRlbXNUb1N5bmM7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9hZGRJdGVtU3luY2VkOiBmdW5jdGlvbiAoaXRlbSwgY29udGVudFR5cGUsIHN5bmNTdG9yYWdlLCBzeW5jVHlwZSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3N5bmNSZXN1bHRJbmZvLnN5bmNlZEl0ZW1zW2NvbnRlbnRUeXBlXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3luY1Jlc3VsdEluZm8uc3luY2VkSXRlbXNbY29udGVudFR5cGVdID0gW107XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3N5bmNSZXN1bHRJbmZvLnN5bmNlZEl0ZW1zW2NvbnRlbnRUeXBlXS5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGl0ZW1JZDogaXRlbS5JZCxcclxuICAgICAgICAgICAgICAgIHR5cGU6IHN5bmNUeXBlLFxyXG4gICAgICAgICAgICAgICAgc3RvcmFnZTogc3luY1N0b3JhZ2VcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfcmVtb3ZlSXRlbVN5bmNlZDogZnVuY3Rpb24gKGl0ZW0sIGNvbnRlbnRUeXBlKSB7XHJcbiAgICAgICAgICAgIHZhciBpdGVtSWQ7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGl0ZW0gPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtSWQgPSBpdGVtO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaXRlbUlkID0gaXRlbS5JZDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9zeW5jUmVzdWx0SW5mby5zeW5jZWRJdGVtc1tjb250ZW50VHlwZV0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N5bmNSZXN1bHRJbmZvLnN5bmNlZEl0ZW1zW2NvbnRlbnRUeXBlXSA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgc3luY2VkSXRlbXMgPSB0aGlzLl9zeW5jUmVzdWx0SW5mby5zeW5jZWRJdGVtc1tjb250ZW50VHlwZV07XHJcbiAgICAgICAgICAgIHRoaXMuX3N5bmNSZXN1bHRJbmZvLnN5bmNlZEl0ZW1zW2NvbnRlbnRUeXBlXSA9IF8ud2l0aG91dChzeW5jZWRJdGVtcywgXy5maW5kV2hlcmUoc3luY2VkSXRlbXMsIHtpdGVtSWQ6IGl0ZW1JZH0pKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZ2V0Q2xpZW50V2luc1N5bmNEYXRhOiBmdW5jdGlvbiAoY29sbGVjdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgdmFyIHN5bmNEYXRhID0ge307XHJcbiAgICAgICAgICAgIF8uZWFjaChjb2xsZWN0aW9ucywgZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGtleSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzeW5jRGF0YVtrZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3luY0RhdGFba2V5XSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlZEl0ZW1zOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRJdGVtczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZWRJdGVtczogW11cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBkaXJ0eUl0ZW1zID0gc2VsZi5fZ2V0RGlydHlJdGVtcyhjb2xsZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIHZhciBpdGVtc0ZvclN5bmMgPSBvZmZsaW5lVHJhbnNmb3JtYXRpb25zLmlkVHJhbnNmb3JtKGRpcnR5SXRlbXMpO1xyXG4gICAgICAgICAgICAgICAgXy5lYWNoKGl0ZW1zRm9yU3luYywgZnVuY3Rpb24gKGl0ZW1Gb3JTeW5jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChpdGVtRm9yU3luY1tjb25zdGFudHMub2ZmbGluZUl0ZW1zU3RhdGVNYXJrZXJdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2Ugb2ZmbGluZUl0ZW1TdGF0ZXMuY3JlYXRlZDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bmNEYXRhW2tleV0uY3JlYXRlZEl0ZW1zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZUl0ZW06IGl0ZW1Gb3JTeW5jLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ0l0ZW06IGl0ZW1Gb3JTeW5jXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIG9mZmxpbmVJdGVtU3RhdGVzLm1vZGlmaWVkOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3luY0RhdGFba2V5XS5tb2RpZmllZEl0ZW1zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZUl0ZW06IGl0ZW1Gb3JTeW5jLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ0l0ZW06IGl0ZW1Gb3JTeW5jXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIG9mZmxpbmVJdGVtU3RhdGVzLmRlbGV0ZWQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW5jRGF0YVtrZXldLmRlbGV0ZWRJdGVtcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdGVJdGVtOiBpdGVtRm9yU3luYyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRpbmdJdGVtOiBpdGVtRm9yU3luY1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBpdGVtRm9yU3luY1tjb25zdGFudHMub2ZmbGluZUl0ZW1zU3RhdGVNYXJrZXJdO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgc3luY0RhdGFba2V5XS5vZmZsaW5lSXRlbXNUb1N5bmMgPSBpdGVtc0ZvclN5bmM7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gc3luY0RhdGE7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2FkZE1vZGlmaWVkSXRlbXNGb3JTeW5jQ2xpZW50V2luczogZnVuY3Rpb24gKGNvbnRlbnRUeXBlRGF0YSwgc3luY1Byb21pc2VzLCBkYXRhQ29sbGVjdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9hZGRVcGRhdGVkSXRlbXNGb3JTeW5jKGNvbnRlbnRUeXBlRGF0YSwgZ2V0U3luY0ZpbHRlck5vTW9kaWZpZWRBdCwgc3luY1Byb21pc2VzLCBkYXRhQ29sbGVjdGlvbiwgZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgIHZhciBpdGVtSWQgPSBpdGVtLklkO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignV2hlbiB1cGRhdGluZyBhbiBpdGVtIGl0IG11c3QgaGF2ZSBhbiBJZCBmaWVsZC4nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBjb2xsZWN0aW9uTmFtZSA9IGRhdGFDb2xsZWN0aW9uLmNvbGxlY3Rpb25OYW1lO1xyXG4gICAgICAgICAgICAgICAgc3luY1Byb21pc2VzW2l0ZW1JZF0gPSBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YUNvbGxlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgLmlzU3luYyh0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwbHlPZmZsaW5lKGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudXBkYXRlU2luZ2xlKGl0ZW0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2FkZEl0ZW1TeW5jZWQoaXRlbSwgY29sbGVjdGlvbk5hbWUsICdzZXJ2ZXInLCAndXBkYXRlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXBkYXRlZEl0ZW0gPSBfLmV4dGVuZCh7fSwgaXRlbSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1vZGlmaWVkQXQ6IHJlcy5Nb2RpZmllZEF0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXBkYXRlUXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLnVwZGF0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB1cGRhdGVkSXRlbSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsT3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogaXRlbS5JZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbk5hbWU6IGNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzU3luYzogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucHJvY2Vzc1F1ZXJ5KHVwZGF0ZVF1ZXJ5KS50aGVuKHJlc29sdmUsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoXy5leHRlbmQoe30sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTogJ2NsaWVudCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1cGRhdGUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtSWQ6IGl0ZW0uSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBjb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHJlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAocmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoXy5leHRlbmQoe30sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yYWdlOiAnc2VydmVyJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndXBkYXRlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtSWQ6IGl0ZW0uSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGU6IGNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiByZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfYWRkRGVsZXRlZEl0ZW1zRm9yU3luY0NsaWVudFdpbnM6IGZ1bmN0aW9uIChjb250ZW50VHlwZURhdGEsIHN5bmNQcm9taXNlcywgZGF0YUNvbGxlY3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fYWRkRGVsZXRlZEl0ZW1zRm9yU3luYyhjb250ZW50VHlwZURhdGEsIGdldFN5bmNGaWx0ZXJOb01vZGlmaWVkQXQsIHN5bmNQcm9taXNlcywgZGF0YUNvbGxlY3Rpb24sXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoaXRlbSwgaXRlbUZpbHRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xsZWN0aW9uTmFtZSA9IGRhdGFDb2xsZWN0aW9uLmNvbGxlY3Rpb25OYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIHN5bmNQcm9taXNlc1tpdGVtLklkXSA9IG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbUlkID0gaXRlbS5JZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdXaGVuIGRlbGV0aW5nIGFuIGl0ZW0gaXQgbXVzdCBoYXZlIGFuIElkIGZpZWxkLicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YUNvbGxlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5pc1N5bmModHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBseU9mZmxpbmUoZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZGVzdHJveVNpbmdsZShpdGVtRmlsdGVyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2FkZEl0ZW1TeW5jZWQoaXRlbSwgY29sbGVjdGlvbk5hbWUsICdzZXJ2ZXInLCAnZGVsZXRlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3B1cmdlQnlJZChjb2xsZWN0aW9uTmFtZSwgaXRlbS5JZCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChfLmV4dGVuZCh7fSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTogJ2NsaWVudCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGVsZXRlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBjb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1JZDogaXRlbUlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVyclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KF8uZXh0ZW5kKHt9LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JhZ2U6ICdzZXJ2ZXInLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGVsZXRlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGU6IGNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtSWQ6IGl0ZW1JZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2FwcGx5Q2xpZW50V2luczogZnVuY3Rpb24gKGNvbGxlY3Rpb25zKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIHN5bmNEYXRhID0gdGhpcy5fZ2V0Q2xpZW50V2luc1N5bmNEYXRhKGNvbGxlY3Rpb25zKTtcclxuICAgICAgICAgICAgdmFyIHN5bmNQcm9taXNlcyA9IHt9O1xyXG5cclxuICAgICAgICAgICAgXy5lYWNoKHN5bmNEYXRhLCBmdW5jdGlvbiAoY29udGVudFR5cGVEYXRhLCB0eXBlTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGFDb2xsZWN0aW9uID0gc2VsZi5ldmVybGl2ZS5kYXRhKHR5cGVOYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmIChjb250ZW50VHlwZURhdGEuY3JlYXRlZEl0ZW1zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2FkZENyZWF0ZWRJdGVtc0ZvclN5bmMoY29udGVudFR5cGVEYXRhLCBzeW5jUHJvbWlzZXMsIGRhdGFDb2xsZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudFR5cGVEYXRhLm1vZGlmaWVkSXRlbXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fYWRkTW9kaWZpZWRJdGVtc0ZvclN5bmNDbGllbnRXaW5zKGNvbnRlbnRUeXBlRGF0YSwgc3luY1Byb21pc2VzLCBkYXRhQ29sbGVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlRGF0YS5kZWxldGVkSXRlbXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fYWRkRGVsZXRlZEl0ZW1zRm9yU3luY0NsaWVudFdpbnMoY29udGVudFR5cGVEYXRhLCBzeW5jUHJvbWlzZXMsIGRhdGFDb2xsZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcnN2cC5oYXNoU2V0dGxlZChzeW5jUHJvbWlzZXMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9hcHBseVN0YW5kYXJkU3luYzogZnVuY3Rpb24gKGNvbGxlY3Rpb25zKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IHt9O1xyXG4gICAgICAgICAgICBfLmVhY2goY29sbGVjdGlvbnMsIGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBjb250ZW50VHlwZSkge1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZXNbY29udGVudFR5cGVdID0gc2VsZi5fZ2V0U3luY1Byb21pc2VGb3JDb2xsZWN0aW9uKGNvbGxlY3Rpb24sIGNvbnRlbnRUeXBlKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcnN2cC5oYXNoKHByb21pc2VzKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oc2VsZi5fcHJlcGFyZVN5bmNEYXRhLmJpbmQoc2VsZikpXHJcbiAgICAgICAgICAgICAgICAudGhlbihzZWxmLl9yZXNvbHZlQ29uZmxpY3RzLmJpbmQoc2VsZikpXHJcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoY29udGVudFR5cGVTeW5jRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzeW5jUHJvbWlzZXMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBfLmVhY2goY29udGVudFR5cGVTeW5jRGF0YSwgZnVuY3Rpb24gKGNvbnRlbnRUeXBlRGF0YSwgdHlwZU5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFDb2xsZWN0aW9uID0gc2VsZi5ldmVybGl2ZS5kYXRhKHR5cGVOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlRGF0YS5jcmVhdGVkSXRlbXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9hZGRDcmVhdGVkSXRlbXNGb3JTeW5jKGNvbnRlbnRUeXBlRGF0YSwgc3luY1Byb21pc2VzLCBkYXRhQ29sbGVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50VHlwZURhdGEubW9kaWZpZWRJdGVtcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2FkZFVwZGF0ZWRJdGVtc0ZvclN5bmMoY29udGVudFR5cGVEYXRhLCBnZXRTeW5jRmlsdGVyRm9ySXRlbSwgc3luY1Byb21pc2VzLCBkYXRhQ29sbGVjdGlvbiwgZnVuY3Rpb24gKGl0ZW0sIGl0ZW1GaWx0ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW5jUHJvbWlzZXNbaXRlbS5JZF0gPSBkYXRhQ29sbGVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaXNTeW5jKHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBseU9mZmxpbmUoZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC51cGRhdGUoaXRlbSwgaXRlbUZpbHRlcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX29uU3luY1Jlc3BvbnNlKHJlcywgaXRlbSwgdHlwZU5hbWUsIERhdGFRdWVyeS5vcGVyYXRpb25zLnVwZGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50VHlwZURhdGEuZGVsZXRlZEl0ZW1zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fYWRkRGVsZXRlZEl0ZW1zRm9yU3luYyhjb250ZW50VHlwZURhdGEsIGdldFN5bmNGaWx0ZXJGb3JJdGVtLCBzeW5jUHJvbWlzZXMsIGRhdGFDb2xsZWN0aW9uLCBmdW5jdGlvbiAoaXRlbSwgaXRlbUZpbHRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bmNQcm9taXNlc1tpdGVtLklkXSA9IGRhdGFDb2xsZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5pc1N5bmModHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGx5T2ZmbGluZShmYWxzZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmRlc3Ryb3koaXRlbUZpbHRlcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX29uU3luY1Jlc3BvbnNlKHJlcywgaXRlbSwgdHlwZU5hbWUsIERhdGFRdWVyeS5vcGVyYXRpb25zLnJlbW92ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJzdnAuaGFzaFNldHRsZWQoc3luY1Byb21pc2VzKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9hcHBseVN5bmM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEFsbENvbGxlY3Rpb25zKClcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjb2xsZWN0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLnNldHVwLmNvbmZsaWN0cy5zdHJhdGVneSA9PT0gY29uc3RhbnRzLkNvbmZsaWN0UmVzb2x1dGlvblN0cmF0ZWd5LkNsaWVudFdpbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2FwcGx5Q2xpZW50V2lucyhjb2xsZWN0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2FwcGx5U3RhbmRhcmRTeW5jKGNvbGxlY3Rpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZ2V0RGlydHlJdGVtczogZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIGZpbHRlciA9IHt9O1xyXG4gICAgICAgICAgICBmaWx0ZXJbY29uc3RhbnRzLm9mZmxpbmVJdGVtc1N0YXRlTWFya2VyXSA9IHskZXhpc3RzOiB0cnVlfTtcclxuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gbWluZ28uUXVlcnkoZmlsdGVyKTtcclxuICAgICAgICAgICAgdmFyIGN1cnNvciA9IG1pbmdvLkN1cnNvcihjb2xsZWN0aW9uLCBxdWVyeSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjdXJzb3IuYWxsKCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2dldEFsbENvbGxlY3Rpb25zOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKHRoaXMuX3BlcnNpc3Rlci5nZXRBbGxEYXRhLmJpbmQodGhpcy5fcGVyc2lzdGVyKSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2dldENvbGxlY3Rpb246IGZ1bmN0aW9uIChjb250ZW50VHlwZSkge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayB0aGUgcGVyc2lzdGVyIGlmIHRoZXJlIGlzIG5vIGRhdGEgaW4gdGhlIGNvbGxlY3Rpb24gY2FjaGUgZm9yIHRoaXMgY29udGVudCB0eXBlXHJcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGYuX2NvbGxlY3Rpb25DYWNoZVtjb250ZW50VHlwZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9wZXJzaXN0ZXIuZ2V0RGF0YShjb250ZW50VHlwZSwgZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fY29sbGVjdGlvbkNhY2hlW2NvbnRlbnRUeXBlXSA9IGRhdGEgfHwge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoc2VsZi5fY29sbGVjdGlvbkNhY2hlW2NvbnRlbnRUeXBlXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgcmVqZWN0KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzZWxmLl9jb2xsZWN0aW9uQ2FjaGVbY29udGVudFR5cGVdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3BlcnNpc3REYXRhOiBmdW5jdGlvbiAoY29udGVudFR5cGUpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlRGF0YSA9IHNlbGYuX2NvbGxlY3Rpb25DYWNoZVtjb250ZW50VHlwZV07XHJcbiAgICAgICAgICAgICAgICBzZWxmLl90cmFuc2Zvcm1QZXJzaXN0ZWREYXRhKGNvbnRlbnRUeXBlLCBjb250ZW50VHlwZURhdGEpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5fcGVyc2lzdGVyLnNhdmVEYXRhKGNvbnRlbnRUeXBlLCBjb250ZW50VHlwZURhdGEsIHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9nZXRCeUlkOiBmdW5jdGlvbiAoY29sbGVjdGlvbiwgaWQpIHtcclxuICAgICAgICAgICAgaWYgKCFpZCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ0lkIGZpZWxkIGlzIG1hbmRhdG9yeSB3aGVuIHVzaW5nIG9mZmxpbmUgc3RvcmFnZScpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoY29sbGVjdGlvbltpZF0pIHtcclxuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gXy5leHRlbmQoe30sIGNvbGxlY3Rpb25baWRdKTtcclxuICAgICAgICAgICAgICAgIHZhciBpc0RlbGV0ZWQgPSBpdGVtICYmIGl0ZW1bY29uc3RhbnRzLm9mZmxpbmVJdGVtc1N0YXRlTWFya2VyXSA9PT0gb2ZmbGluZUl0ZW1TdGF0ZXMuZGVsZXRlZDtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNEZWxldGVkID8gdW5kZWZpbmVkIDogaXRlbTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9zZXRJdGVtOiBmdW5jdGlvbiAoY29sbGVjdGlvbiwgaXRlbSwgc3RhdGUpIHtcclxuICAgICAgICAgICAgaWYgKCFzdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGl0ZW1bY29uc3RhbnRzLm9mZmxpbmVJdGVtc1N0YXRlTWFya2VyXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGl0ZW1bY29uc3RhbnRzLm9mZmxpbmVJdGVtc1N0YXRlTWFya2VyXSA9IHN0YXRlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb2xsZWN0aW9uW2l0ZW0uX2lkXSA9IGl0ZW07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3Nob3VsZEF1dG9nZW5lcmF0ZUlkRm9yQ29udGVudFR5cGU6IGZ1bmN0aW9uIChjb250ZW50VHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gISh0aGlzLnNldHVwICYmIHRoaXMuc2V0dXAudHlwZVNldHRpbmdzICYmIHRoaXMuc2V0dXAudHlwZVNldHRpbmdzW2NvbnRlbnRUeXBlXSAmJiB0aGlzLnNldHVwLnR5cGVTZXR0aW5nc1tjb250ZW50VHlwZV0uYXV0b0dlbmVyYXRlSWQgPT09IGZhbHNlKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfY3JlYXRlSXRlbXM6IGZ1bmN0aW9uIChjb250ZW50VHlwZSwgaXRlbXMsIGlzU3luYywgcHJlc2VydmVTdGF0ZSwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLl9nZXRDb2xsZWN0aW9uKGNvbnRlbnRUeXBlKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbXNGb3JDcmVhdGUgPSBfLmlzQXJyYXkoaXRlbXMpID8gaXRlbXMgOiBbaXRlbXNdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjcmVhdGVkSXRlbXMgPSBfLm1hcChpdGVtc0ZvckNyZWF0ZSwgZnVuY3Rpb24gKGN1cnJlbnRJdGVtLCBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbVRvQ3JlYXRlID0gXy5leHRlbmQoe30sIGN1cnJlbnRJdGVtKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Ub0NyZWF0ZS5faWQgPSBpdGVtVG9DcmVhdGUuSWQgfHwgdXVpZC52MSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgaXRlbVRvQ3JlYXRlLklkO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nSXRlbSA9IHNlbGYuX2dldEJ5SWQoY29sbGVjdGlvbiwgaXRlbVRvQ3JlYXRlLl9pZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtRXhpc3RzID0gISFleGlzdGluZ0l0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1FeGlzdHMgJiYgKCFpc1N5bmMgJiYgIXByZXNlcnZlU3RhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBbb2ZmbGluZV0gcmV0dXJuIHRoZSBzYW1lIGVycm9yIGFzIHRoZSBzZXJ2ZXIgZG9lc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKG5ldyBFcnJvcignQW4gaXRlbSB3aXRoIHRoZSBzcGVjaWZpZWQgaWQgYWxyZWFkeSBleGlzdHMnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTeW5jICYmIHByZXNlcnZlU3RhdGUgJiYgaXRlbUV4aXN0cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gZXhpc3RpbmdJdGVtW2NvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlcl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gaXNTeW5jID8gdW5kZWZpbmVkIDogb2ZmbGluZUl0ZW1TdGF0ZXMuY3JlYXRlZDsgLy8gc2V0IHRoZSBzdGF0ZSB0byBjcmVhdGVkIG9ubHkgaWYgbm90IHN5bmNpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBtYW51YWxseSBjbG9uZSB0aGUgZGF0ZXMgaW4gb3JkZXIgdG8gZGVyZWZlcmVuY2UgdGhlbSBmcm9tIHRoZSBvcmlnaW5hbCBvYmplY3QgYXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gXy5leHRlbmRzIHdpbGwgcGFzcyBhIHJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYWwgZGF0ZSBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgbmV3IGluc3RhbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SXRlbS5DcmVhdGVkQXQgJiYgY3VycmVudEl0ZW0uQ3JlYXRlZEF0IGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbVRvQ3JlYXRlLkNyZWF0ZWRBdCA9IHV0aWxzLmNsb25lRGF0ZShjdXJyZW50SXRlbS5DcmVhdGVkQXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbVRvQ3JlYXRlLkNyZWF0ZWRBdCA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SXRlbS5Nb2RpZmllZEF0ICYmIGN1cnJlbnRJdGVtLk1vZGlmaWVkQXQgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtVG9DcmVhdGUuTW9kaWZpZWRBdCA9IHV0aWxzLmNsb25lRGF0ZShjdXJyZW50SXRlbS5Nb2RpZmllZEF0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Ub0NyZWF0ZS5Nb2RpZmllZEF0ID0gdXRpbHMuY2xvbmVEYXRlKGl0ZW1Ub0NyZWF0ZS5DcmVhdGVkQXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtVG9DcmVhdGUuQ3JlYXRlZEJ5ID0gaXRlbVRvQ3JlYXRlLkNyZWF0ZWRCeSB8fCBzZWxmLmV2ZXJsaXZlLnNldHVwLnByaW5jaXBhbElkIHx8IGNvbnN0YW50cy5ndWlkRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Ub0NyZWF0ZS5Nb2RpZmllZEJ5ID0gaXRlbVRvQ3JlYXRlLk1vZGlmaWVkQnkgfHwgaXRlbVRvQ3JlYXRlLkNyZWF0ZWRCeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlID09PSAnVXNlcnMnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtVG9DcmVhdGUuT3duZXIgPSBpdGVtVG9DcmVhdGUuX2lkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbVRvQ3JlYXRlLk93bmVyID0gaXRlbVRvQ3JlYXRlLkNyZWF0ZWRCeSB8fCBjb25zdGFudHMuZ3VpZEVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9zZXRJdGVtKGNvbGxlY3Rpb24sIF8uZXh0ZW5kKHt9LCBpdGVtVG9DcmVhdGUpLCBzdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtVG9DcmVhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9wZXJzaXN0RGF0YShjb250ZW50VHlwZSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2VsZi5fc2hvdWxkQXV0b2dlbmVyYXRlSWRGb3JDb250ZW50VHlwZShjb250ZW50VHlwZSkgJiYgIWlzU3luYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlZEl0ZW1zID0gb2ZmbGluZVRyYW5zZm9ybWF0aW9ucy5yZW1vdmVJZFRyYW5zZm9ybShjcmVhdGVkSXRlbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MoY3JlYXRlZEl0ZW1zKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGVycm9yKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfYXBwbHlVcGRhdGVPcGVyYXRpb246IGZ1bmN0aW9uIChvcmlnaW5hbFVwZGF0ZUV4cHJlc3Npb24sIGl0ZW1Ub1VwZGF0ZSwgY29sbGVjdGlvbiwgaXNTeW5jKSB7XHJcbiAgICAgICAgICAgIHZhciBkYk9wZXJhdG9ycyA9IHV0aWxzLmdldERiT3BlcmF0b3JzKG9yaWdpbmFsVXBkYXRlRXhwcmVzc2lvbiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHZhciBoYXNEYk9wZXJhdG9yID0gZGJPcGVyYXRvcnMubGVuZ3RoICE9PSAwO1xyXG5cclxuICAgICAgICAgICAgdmFyIHVwZGF0ZUV4cHJlc3Npb247XHJcbiAgICAgICAgICAgIGlmIChoYXNEYk9wZXJhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVFeHByZXNzaW9uID0gb3JpZ2luYWxVcGRhdGVFeHByZXNzaW9uO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlRXhwcmVzc2lvbiA9IHtcclxuICAgICAgICAgICAgICAgICAgICAkc2V0OiBvcmlnaW5hbFVwZGF0ZUV4cHJlc3Npb25cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHVwZGF0ZUV4cHJlc3Npb25Gb3JVc2VyID0ge1xyXG4gICAgICAgICAgICAgICAgTW9kaWZpZWRCeTogdGhpcy5ldmVybGl2ZS5zZXR1cC5wcmluY2lwYWxJZCB8fCBjb25zdGFudHMuZ3VpZEVtcHR5XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHVwZGF0ZUV4cHJlc3Npb24uJHNldCA9IF8uZXh0ZW5kKHVwZGF0ZUV4cHJlc3Npb25Gb3JVc2VyLCB1cGRhdGVFeHByZXNzaW9uLiRzZXQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGlzU3luYykge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlRXhwcmVzc2lvbi4kc2V0Lk1vZGlmaWVkQXQgPSB1dGlscy5jbG9uZURhdGUob3JpZ2luYWxVcGRhdGVFeHByZXNzaW9uLk1vZGlmaWVkQXQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBtb25nb1F1ZXJ5KGl0ZW1Ub1VwZGF0ZSwge30sIHVwZGF0ZUV4cHJlc3Npb24sIHtzdHJpY3Q6IHRydWV9KTsgLy8gU2V0dGluZyBzdHJpY3QgdG8gdHJ1ZSBzbyBvbmx5IGV4YWN0IG1hdGNoZXMgd291bGQgYmUgdXBkYXRlZFxyXG5cclxuICAgICAgICAgICAgaXRlbVRvVXBkYXRlLl9pZCA9IGl0ZW1Ub1VwZGF0ZS5faWQgfHwgdXBkYXRlRXhwcmVzc2lvbi5faWQgfHwgdXBkYXRlRXhwcmVzc2lvbi5JZDtcclxuICAgICAgICAgICAgZGVsZXRlIGl0ZW1Ub1VwZGF0ZS5JZDtcclxuXHJcbiAgICAgICAgICAgIHZhciBuZXdTdGF0ZTtcclxuICAgICAgICAgICAgaWYgKGlzU3luYykge1xyXG4gICAgICAgICAgICAgICAgbmV3U3RhdGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbVRvVXBkYXRlW2NvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlcl0gPT09IG9mZmxpbmVJdGVtU3RhdGVzLmNyZWF0ZWQpIHtcclxuICAgICAgICAgICAgICAgIG5ld1N0YXRlID0gb2ZmbGluZUl0ZW1TdGF0ZXMuY3JlYXRlZDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5ld1N0YXRlID0gb2ZmbGluZUl0ZW1TdGF0ZXMubW9kaWZpZWQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3NldEl0ZW0oY29sbGVjdGlvbiwgaXRlbVRvVXBkYXRlLCBuZXdTdGF0ZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3VwZGF0ZUl0ZW1zOiBmdW5jdGlvbiAoZGF0YVF1ZXJ5LCB1cGRhdGVFeHByZXNzaW9uLCBmaWx0ZXIsIGlzU3luYywgcmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHNlbGYuX2dldENvbGxlY3Rpb24oZGF0YVF1ZXJ5LmNvbGxlY3Rpb25OYW1lKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdXBkYXRlSXRlbXM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhUXVlcnkuYWRkaXRpb25hbE9wdGlvbnMgJiYgZGF0YVF1ZXJ5LmFkZGl0aW9uYWxPcHRpb25zLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Ub1VwZGF0ZSA9IHNlbGYuX2dldEJ5SWQoY29sbGVjdGlvbiwgZGF0YVF1ZXJ5LmFkZGl0aW9uYWxPcHRpb25zLmlkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fYXBwbHlVcGRhdGVPcGVyYXRpb24odXBkYXRlRXhwcmVzc2lvbiwgaXRlbVRvVXBkYXRlLCBjb2xsZWN0aW9uLCBpc1N5bmMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVJdGVtcyA9IFtpdGVtVG9VcGRhdGVdO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUl0ZW1zID0gc2VsZi5fcmVhZEludGVybmFsKGNvbGxlY3Rpb24sIGZpbHRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXBkYXRlSXRlbXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtVG9VcGRhdGUgPSB1cGRhdGVJdGVtc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtRXhpc3RzID0gISFzZWxmLl9nZXRCeUlkKGNvbGxlY3Rpb24sIGl0ZW1Ub1VwZGF0ZS5faWQudG9TdHJpbmcoKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtRXhpc3RzICYmICFpc1N5bmMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KEV2ZXJsaXZlRXJyb3JzLml0ZW1Ob3RGb3VuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fYXBwbHlVcGRhdGVPcGVyYXRpb24odXBkYXRlRXhwcmVzc2lvbiwgaXRlbVRvVXBkYXRlLCBjb2xsZWN0aW9uLCBpc1N5bmMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fcGVyc2lzdERhdGEoZGF0YVF1ZXJ5LmNvbGxlY3Rpb25OYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXBkYXRlZEl0ZW1Db3VudCA9IHVwZGF0ZUl0ZW1zLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2RpZmllZEF0UmVzdWx0ID0gdXBkYXRlZEl0ZW1Db3VudCA/IHVwZGF0ZUl0ZW1zWzBdLk1vZGlmaWVkQXQgOiBuZXcgRGF0ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTW9kaWZpZWRBdDogbW9kaWZpZWRBdFJlc3VsdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHVwZGF0ZWRJdGVtQ291bnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2NsZWFySXRlbTogZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGl0ZW0pIHtcclxuICAgICAgICAgICAgZGVsZXRlIGNvbGxlY3Rpb25baXRlbS5faWRdO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9yZW1vdmVJdGVtczogZnVuY3Rpb24gKGRhdGFRdWVyeSwgZmlsdGVyLCBpc1N5bmMsIHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICBzZWxmLl9nZXRDb2xsZWN0aW9uKGRhdGFRdWVyeS5jb2xsZWN0aW9uTmFtZSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1zVG9SZW1vdmUgPSBzZWxmLl9yZWFkSW50ZXJuYWwoY29sbGVjdGlvbiwgZmlsdGVyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtc1RvUmVtb3ZlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtVG9SZW1vdmUgPSBpdGVtc1RvUmVtb3ZlW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtVG9SZW1vdmUuX2lkID0gaXRlbVRvUmVtb3ZlLl9pZCB8fCBpdGVtVG9SZW1vdmUuSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtRXhpc3RzID0gISFzZWxmLl9nZXRCeUlkKGNvbGxlY3Rpb24sIGl0ZW1Ub1JlbW92ZS5faWQudG9TdHJpbmcoKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW1FeGlzdHMgJiYgIWlzU3luYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXZlcmxpdmVFcnJvcignQ2Fubm90IGRlbGV0ZSBpdGVtIC0gaXRlbSB3aXRoIGlkICcgKyBpdGVtVG9SZW1vdmUuX2lkICsgJyBkb2VzIG5vdCBleGlzdC4nKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZW1vdmVGcm9tTWVtb3J5ID0gaXRlbVRvUmVtb3ZlW2NvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlcl0gPT09IG9mZmxpbmVJdGVtU3RhdGVzLmNyZWF0ZWQgfHwgaXNTeW5jO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3ZlRnJvbU1lbW9yeSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fY2xlYXJJdGVtKGNvbGxlY3Rpb24sIGl0ZW1Ub1JlbW92ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9zZXRJdGVtKGNvbGxlY3Rpb24sIGl0ZW1Ub1JlbW92ZSwgb2ZmbGluZUl0ZW1TdGF0ZXMuZGVsZXRlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9wZXJzaXN0RGF0YShkYXRhUXVlcnkuY29sbGVjdGlvbk5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZSA9IHNlbGYuX3RyYW5zZm9ybU9mZmxpbmVSZXN1bHQoaXRlbXNUb1JlbW92ZS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfYXBwbHlUcmFuc2Zvcm1hdGlvbnM6IGZ1bmN0aW9uICh0cmFuc2Zvcm1lZFJlc3VsdCwgdHJhbnNmb3JtYXRpb25zKSB7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkUmVzdWx0LnJlc3VsdCkpIHtcclxuICAgICAgICAgICAgICAgIF8uZWFjaCh0cmFuc2Zvcm1hdGlvbnMsIGZ1bmN0aW9uICh0cmFuc2Zvcm1hdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkUmVzdWx0LnJlc3VsdC5tYXAoZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRSZXN1bHQucmVzdWx0W2tleV0gPSB0cmFuc2Zvcm1hdGlvbih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF8uZWFjaCh0cmFuc2Zvcm1hdGlvbnMsIGZ1bmN0aW9uICh0cmFuc2Zvcm1hdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkUmVzdWx0LnJlc3VsdCA9IHRyYW5zZm9ybWF0aW9uKHRyYW5zZm9ybWVkUmVzdWx0LnJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF90cmFuc2Zvcm1PZmZsaW5lUmVzdWx0OiBmdW5jdGlvbiAocmVzdWx0U2V0LCBjb3VudCwgZGF0YVF1ZXJ5LCBhZGRpdGlvbmFsVHJhbnNmb3JtYXRpb25zKSB7XHJcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZFJlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0U2V0LFxyXG4gICAgICAgICAgICAgICAgY291bnQ6IGNvdW50IHx8IChyZXN1bHRTZXQgfHwgW10pLmxlbmd0aFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgaWYgKChjb3VudCAhPT0gdW5kZWZpbmVkICYmIGNvdW50ICE9PSBudWxsKSB8fCBBcnJheS5pc0FycmF5KHJlc3VsdFNldCkpIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkUmVzdWx0LmNvdW50ID0gY291bnQgfHwgcmVzdWx0U2V0Lmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWF0aW9ucyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgdHJhbnNmb3JtYXRpb25zLnB1c2gob2ZmbGluZVRyYW5zZm9ybWF0aW9ucy5pZFRyYW5zZm9ybSk7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybWF0aW9ucy5wdXNoKG9mZmxpbmVUcmFuc2Zvcm1hdGlvbnMucmVtb3ZlTWFya2Vyc1RyYW5zZm9ybSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0YVF1ZXJ5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5jbHVkZUNvdW50ID0gZGF0YVF1ZXJ5LmdldEhlYWRlcihIZWFkZXJzLmluY2x1ZGVDb3VudCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZUNvdW50ID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0cmFuc2Zvcm1lZFJlc3VsdC5jb3VudDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgc2luZ2xlRmllbGRFeHByZXNzaW9uID0gZGF0YVF1ZXJ5LmdldEhlYWRlcihIZWFkZXJzLnNpbmdsZUZpZWxkKTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2luZ2xlRmllbGRFeHByZXNzaW9uID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWF0aW9ucy5wdXNoKG9mZmxpbmVUcmFuc2Zvcm1hdGlvbnMuc2luZ2xlRmllbGRUcmFuc2Zvcm0uYmluZCh0aGlzLCBzaW5nbGVGaWVsZEV4cHJlc3Npb24pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGFkZGl0aW9uYWxUcmFuc2Zvcm1hdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWF0aW9ucyA9IHRyYW5zZm9ybWF0aW9ucy5jb25jYXQoYWRkaXRpb25hbFRyYW5zZm9ybWF0aW9ucyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5VHJhbnNmb3JtYXRpb25zKHRyYW5zZm9ybWVkUmVzdWx0LCB0cmFuc2Zvcm1hdGlvbnMpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybWVkUmVzdWx0LmNvdW50ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0cmFuc2Zvcm1lZFJlc3VsdC5jb3VudDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkUmVzdWx0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF90cmFuc2Zvcm1QZXJzaXN0ZWREYXRhOiBmdW5jdGlvbiAoY29udGVudFR5cGUsIGNvbnRlbnRUeXBlRGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtRmllbGRzID0gW107XHJcblxyXG4gICAgICAgICAgICBpZiAoY29udGVudFR5cGUgPT09ICdVc2VycycpIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybUZpZWxkcyA9IHRyYW5zZm9ybUZpZWxkcy5jb25jYXQoWydQYXNzd29yZCcsICdRdWVzdGlvbklkJywgJ1NlY3JldEFuc3dlciddKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybUZpZWxkcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIF8uZWFjaChjb250ZW50VHlwZURhdGEsIGZ1bmN0aW9uIChjb250ZW50VHlwZU9iamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZmxpbmVUcmFuc2Zvcm1hdGlvbnMucmVtb3ZlRmllbGRzVHJhbnNmb3JtKGNvbnRlbnRUeXBlT2JqZWN0LCB0cmFuc2Zvcm1GaWVsZHMpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBPZmZsaW5lTW9kdWxlO1xyXG59KSgpOyIsInZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKTtcclxudmFyIHBlcnNpc3RlcnNNb2R1bGUgPSByZXF1aXJlKCcuL29mZmxpbmVQZXJzaXN0ZXJzJyk7XHJcbnZhciBMb2NhbFN0b3JhZ2VQZXJzaXN0ZXIgPSBwZXJzaXN0ZXJzTW9kdWxlLkxvY2FsU3RvcmFnZVBlcnNpc3RlcjtcclxudmFyIEZpbGVTeXN0ZW1QZXJzaXN0ZXIgPSBwZXJzaXN0ZXJzTW9kdWxlLkZpbGVTeXN0ZW1QZXJzaXN0ZXI7XHJcbnZhciBPZmZsaW5lU3RvcmFnZU1vZHVsZSA9IHJlcXVpcmUoJy4vT2ZmbGluZVN0b3JhZ2VNb2R1bGUnKTtcclxudmFyIEV2ZXJsaXZlRXJyb3IgPSByZXF1aXJlKCcuLi9FdmVybGl2ZUVycm9yJykuRXZlcmxpdmVFcnJvcjtcclxudmFyIGlzTmF0aXZlU2NyaXB0ID0gcmVxdWlyZSgnLi4vZXZlcmxpdmUucGxhdGZvcm0nKS5pc05hdGl2ZVNjcmlwdDtcclxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xyXG52YXIgXyA9IGNvbW1vbi5fO1xyXG52YXIgcnN2cCA9IGNvbW1vbi5yc3ZwO1xyXG52YXIgQ3J5cHRvZ3JhcGhpY1Byb3ZpZGVyID0gcmVxdWlyZSgnLi4vZW5jcnlwdGlvbi9DcnlwdG9ncmFwaGljUHJvdmlkZXInKTtcclxuXHJcbnZhciBkZWZhdWx0T2ZmbGluZVN0b3JhZ2VPcHRpb25zID0ge1xyXG4gICAgYXV0b1N5bmM6IHRydWUsXHJcbiAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgY29uZmxpY3RzOiB7XHJcbiAgICAgICAgc3RyYXRlZ3k6IGNvbnN0YW50cy5Db25mbGljdFJlc29sdXRpb25TdHJhdGVneS5DbGllbnRXaW5zLFxyXG4gICAgICAgIGltcGxlbWVudGF0aW9uOiBudWxsXHJcbiAgICB9LFxyXG4gICAgb2ZmbGluZTogZmFsc2UsXHJcbiAgICBzdG9yYWdlOiB7XHJcbiAgICAgICAgbmFtZTogJycsXHJcbiAgICAgICAgcHJvdmlkZXI6IGlzTmF0aXZlU2NyaXB0ID8gY29uc3RhbnRzLlN0b3JhZ2VQcm92aWRlci5GaWxlU3lzdGVtIDogY29uc3RhbnRzLlN0b3JhZ2VQcm92aWRlci5Mb2NhbFN0b3JhZ2UsXHJcbiAgICAgICAgaW1wbGVtZW50YXRpb246IG51bGwsXHJcbiAgICAgICAgc3RvcmFnZVBhdGg6IGNvbnN0YW50cy5EZWZhdWx0U3RvcmFnZVBhdGhcclxuICAgIH0sXHJcbiAgICB0eXBlU2V0dGluZ3M6IHt9LFxyXG4gICAgZW5jcnlwdGlvbjoge1xyXG4gICAgICAgIHByb3ZpZGVyOiBjb25zdGFudHMuRW5jcnlwdGlvblByb3ZpZGVyLkRlZmF1bHQsXHJcbiAgICAgICAgaW1wbGVtZW50YXRpb246IG51bGwsXHJcbiAgICAgICAga2V5OiAnJ1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBjb25mbGljdFJlc29sdXRpb25TdHJhdGVnaWVzID0ge307XHJcblxyXG4gICAgY29uZmxpY3RSZXNvbHV0aW9uU3RyYXRlZ2llc1tjb25zdGFudHMuQ29uZmxpY3RSZXNvbHV0aW9uU3RyYXRlZ3kuQ2xpZW50V2luc10gPSBmdW5jdGlvbiAoY29sbGVjdGlvbiwgbG9jYWwsIHNlcnZlcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgICAgIHJlc29sdmUobG9jYWwpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25mbGljdFJlc29sdXRpb25TdHJhdGVnaWVzW2NvbnN0YW50cy5Db25mbGljdFJlc29sdXRpb25TdHJhdGVneS5TZXJ2ZXJXaW5zXSA9IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBsb2NhbCwgc2VydmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyByc3ZwLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuICAgICAgICAgICAgcmVzb2x2ZShzZXJ2ZXIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgaW5pdFN0b3JhZ2VQZXJzaXN0ZXIgPSBmdW5jdGlvbiBpbml0U3RvcmFnZVBlcnNpc3RlcihvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIHBlcnNpc3RlcjtcclxuICAgICAgICB2YXIgc3RvcmFnZVByb3ZpZGVyID0gb3B0aW9ucy5zdG9yYWdlLnByb3ZpZGVyO1xyXG4gICAgICAgIHZhciBzdG9yYWdlUHJvdmlkZXJJbXBsZW1lbnRhdGlvbiA9IG9wdGlvbnMuc3RvcmFnZS5pbXBsZW1lbnRhdGlvbjtcclxuICAgICAgICB2YXIgc3RvcmFnZUtleSA9IG9wdGlvbnMuc3RvcmFnZS5uYW1lIHx8ICdldmVybGl2ZU9mZmxpbmVTdG9yYWdlXycgKyB0aGlzLnNldHVwLmFwaUtleTtcclxuICAgICAgICBpZiAoXy5pc09iamVjdChzdG9yYWdlUHJvdmlkZXJJbXBsZW1lbnRhdGlvbikgJiYgc3RvcmFnZVByb3ZpZGVyID09PSBjb25zdGFudHMuU3RvcmFnZVByb3ZpZGVyLkN1c3RvbSkge1xyXG4gICAgICAgICAgICBwZXJzaXN0ZXIgPSBzdG9yYWdlUHJvdmlkZXJJbXBsZW1lbnRhdGlvbjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHN0b3JhZ2VQcm92aWRlcikge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBjb25zdGFudHMuU3RvcmFnZVByb3ZpZGVyLkxvY2FsU3RvcmFnZTpcclxuICAgICAgICAgICAgICAgICAgICBwZXJzaXN0ZXIgPSBuZXcgTG9jYWxTdG9yYWdlUGVyc2lzdGVyKHN0b3JhZ2VLZXksIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBjb25zdGFudHMuU3RvcmFnZVByb3ZpZGVyLkZpbGVTeXN0ZW06XHJcbiAgICAgICAgICAgICAgICAgICAgcGVyc2lzdGVyID0gbmV3IEZpbGVTeXN0ZW1QZXJzaXN0ZXIoc3RvcmFnZUtleSwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIGNvbnN0YW50cy5TdG9yYWdlUHJvdmlkZXIuQ3VzdG9tOlxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdDdXN0b20gc3RvcmFnZSBwcm92aWRlciByZXF1aXJlcyBhbiBpbXBsZW1lbnRhdGlvbiBvYmplY3QnKTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1Vuc3VwcG9ydGVkIHN0b3JhZ2UgdHlwZSAnICsgc3RvcmFnZVByb3ZpZGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb3B0aW9ucy5zdG9yYWdlLmltcGxlbWVudGF0aW9uID0gcGVyc2lzdGVyO1xyXG4gICAgICAgIHJldHVybiBwZXJzaXN0ZXI7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBpbml0RW5jcnlwdGlvblByb3ZpZGVyID0gZnVuY3Rpb24gaW5pdEVuY3J5cHRpb25Qcm92aWRlcihvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIGVuY3J5cHRvcjtcclxuICAgICAgICB2YXIgZW5jcnlwdGlvblByb3ZpZGVyID0gb3B0aW9ucy5lbmNyeXB0aW9uLnByb3ZpZGVyO1xyXG4gICAgICAgIHZhciBlbmNyeXB0aW9uSW1wbGVtZW50YXRpb24gPSBvcHRpb25zLmVuY3J5cHRpb24uaW1wbGVtZW50YXRpb247XHJcbiAgICAgICAgaWYgKF8uaXNPYmplY3QoZW5jcnlwdGlvbkltcGxlbWVudGF0aW9uKSAmJiBlbmNyeXB0aW9uUHJvdmlkZXIgPT09IGNvbnN0YW50cy5FbmNyeXB0aW9uUHJvdmlkZXIuQ3VzdG9tKSB7XHJcbiAgICAgICAgICAgIGVuY3J5cHRvciA9IGVuY3J5cHRpb25JbXBsZW1lbnRhdGlvbjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGVuY3J5cHRpb25Qcm92aWRlcikge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBjb25zdGFudHMuRW5jcnlwdGlvblByb3ZpZGVyLkRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgZW5jcnlwdG9yID0gbmV3IENyeXB0b2dyYXBoaWNQcm92aWRlcih0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzLkVuY3J5cHRpb25Qcm92aWRlci5DdXN0b206XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ0N1c3RvbSBlbmNyeXB0aW9uIHByb3ZpZGVyIHJlcXVpcmVzIGFuIGltcGxlbWVudGF0aW9uIG9iamVjdCcpO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignVW5zdXBwb3J0ZWQgZW5jcnlwdGlvbiBwcm92aWRlciAnICsgZW5jcnlwdGlvblByb3ZpZGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb3B0aW9ucy5lbmNyeXB0aW9uLmltcGxlbWVudGF0aW9uID0gZW5jcnlwdG9yO1xyXG4gICAgICAgIHJldHVybiBlbmNyeXB0b3I7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBidWlsZE9mZmxpbmVTdG9yYWdlTW9kdWxlID0gZnVuY3Rpb24gYnVpbGRPZmZsaW5lU3RvcmFnZU1vZHVsZShzdG9yYWdlT3B0aW9ucykge1xyXG4gICAgICAgIHZhciBvcHRpb25zO1xyXG4gICAgICAgIGlmIChzdG9yYWdlT3B0aW9ucyA9PT0gdHJ1ZSkgeyAvLyBleHBsaWNpdCBjaGVjayBmb3Igc2hvcnRoYW5kIGluaXRpYWxpemF0aW9uXHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSBfLmRlZmF1bHRzKHt9LCBkZWZhdWx0T2ZmbGluZVN0b3JhZ2VPcHRpb25zKTtcclxuICAgICAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3Qoc3RvcmFnZU9wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSBfLmRlZmF1bHRzKHN0b3JhZ2VPcHRpb25zLCBkZWZhdWx0T2ZmbGluZVN0b3JhZ2VPcHRpb25zKTtcclxuICAgICAgICAgICAgb3B0aW9ucy5zdG9yYWdlID0gXy5kZWZhdWx0cyhzdG9yYWdlT3B0aW9ucy5zdG9yYWdlLCBkZWZhdWx0T2ZmbGluZVN0b3JhZ2VPcHRpb25zLnN0b3JhZ2UpO1xyXG4gICAgICAgICAgICBvcHRpb25zLmVuY3J5cHRpb24gPSBfLmRlZmF1bHRzKHN0b3JhZ2VPcHRpb25zLmVuY3J5cHRpb24sIGRlZmF1bHRPZmZsaW5lU3RvcmFnZU9wdGlvbnMuZW5jcnlwdGlvbik7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuY29uZmxpY3RzID0gXy5kZWZhdWx0cyhzdG9yYWdlT3B0aW9ucy5jb25mbGljdHMsIGRlZmF1bHRPZmZsaW5lU3RvcmFnZU9wdGlvbnMuY29uZmxpY3RzKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBvcHRpb25zID0gXy5kZWZhdWx0cyh7fSwgZGVmYXVsdE9mZmxpbmVTdG9yYWdlT3B0aW9ucyk7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuZW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHBlcnNpc3RlciA9IGluaXRTdG9yYWdlUGVyc2lzdGVyLmNhbGwodGhpcywgb3B0aW9ucywgc3RvcmFnZU9wdGlvbnMpO1xyXG4gICAgICAgIHZhciBlbmNyeXB0aW9uUHJvdmlkZXIgPSBpbml0RW5jcnlwdGlvblByb3ZpZGVyLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgT2ZmbGluZVN0b3JhZ2VNb2R1bGUodGhpcywgb3B0aW9ucywgcGVyc2lzdGVyLCBlbmNyeXB0aW9uUHJvdmlkZXIpO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgaW5pdE9mZmxpbmVTdG9yYWdlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLm9mZmxpbmVTdG9yYWdlID0gYnVpbGRPZmZsaW5lU3RvcmFnZU1vZHVsZS5jYWxsKHRoaXMsIG9wdGlvbnMub2ZmbGluZVN0b3JhZ2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGluaXRPZmZsaW5lU3RvcmFnZTogaW5pdE9mZmxpbmVTdG9yYWdlXHJcbiAgICB9XHJcbn0oKSk7IiwidmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xyXG52YXIgXyA9IGNvbW1vbi5fO1xyXG52YXIgcGxhdGZvcm0gPSByZXF1aXJlKCcuLi9ldmVybGl2ZS5wbGF0Zm9ybScpO1xyXG52YXIgaXNOYXRpdmVTY3JpcHQgPSBwbGF0Zm9ybS5pc05hdGl2ZVNjcmlwdDtcclxudmFyIGlzQ29yZG92YSA9IHBsYXRmb3JtLmlzQ29yZG92YTtcclxudmFyIHJzdnAgPSBjb21tb24ucnN2cDtcclxudmFyIHBhcnNlVXRpbGl0aWVzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5wYXJzZVV0aWxpdGllcztcclxudmFyIEV2ZXJsaXZlRXJyb3IgPSByZXF1aXJlKCcuLi9FdmVybGl2ZUVycm9yJykuRXZlcmxpdmVFcnJvcjtcclxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XHJcbnZhciBMb2NhbFN0b3JlID0gcmVxdWlyZSgnLi4vTG9jYWxTdG9yZScpO1xyXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzJyk7XHJcblxyXG4vKipcclxuICogQ2FuIGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHR5cGVzOiB7QGxpbmsgTG9jYWxTdG9yYWdlUGVyc2lzdGVyfSxcclxuICoge0BsaW5rIEZpbGVTeXN0ZW1QZXJzaXN0ZXJ9IG9yIGEgY3VzdG9tIGJhc2VkIG9uIHtAbGluayBCYXNlUGVyc2lzdGVyfVxyXG4gKiBAbWVtYmVyT2YgT2ZmbGluZU1vZHVsZVxyXG4gKiBAaW5zdGFuY2VcclxuICogQG1lbWJlciB7QmFzZVBlcnNpc3Rlcn0gbG9jYWxcclxuICovXHJcblxyXG52YXIgQmFzZVBlcnNpc3RlciA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAY2xhc3MgQmFzZVBlcnNpc3RlclxyXG4gICAgICogQGNsYXNzZGVzYyBBbiBhYnN0cmFjdGlvbiBsYXllciBmb3IgYWxsIHBlcnNpc3RlcnMuIEV2ZXJ5IHBlcnNpc3RlciBjYW4gd3JpdGUvcmVhZFxyXG4gICAgICogZGF0YSBmcm9tIGEgc3BlY2lmaWMgcGxhY2UuIFRoZSBkYXRhIGlzIHNhdmVkIGFzIGtleS12YWx1ZSBwYWlycyB3aGVyZSB0aGUga2V5cyBhcmVcclxuICAgICAqIGNvbnRlbnQgdHlwZXMuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEJhc2VQZXJzaXN0ZXIoa2V5LCBzZGspIHtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgICAgICB0aGlzLnNkayA9IHNkaztcclxuICAgIH1cclxuXHJcbiAgICBCYXNlUGVyc2lzdGVyLnByb3RvdHlwZSA9IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIGFsbCB0aGUgc2F2ZWQgZGF0YS5cclxuICAgICAgICAgKiBAbWV0aG9kIGdldEFsbERhdGFcclxuICAgICAgICAgKiBAbWVtYmVyb2YgQmFzZVBlcnNpc3RlclxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1Y2Nlc3MgQSBzdWNjZXNzIGNhbGxiYWNrXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXJyb3IgQW4gZXJyb3IgY2FsbGJhY2tcclxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBLZXlzIGFyZSB0aGUgY29udGVudCB0eXBlcyBhbmQgdGhlIHZhbHVlcyBhcmUgdGhlIGNvcnJlc3BvbmRpbmcgZGF0YVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldEFsbERhdGE6IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignVGhlIG1ldGhvZCBnZXRBbGxEYXRhIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIHNhdmVkIGRhdGEgZm9yIGEgc3BlY2lmaWMgY29udGVudCB0eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBnZXREYXRhXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRUeXBlIFRoZSBjb250ZW50IHR5cGUgZm9yIHdoaWNoIHRvIHJldHJlaXZlIHRoZSBkYXRhXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3VjY2VzcyBBIHN1Y2Nlc3MgY2FsbGJhY2tcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJvciBBbiBlcnJvciBjYWxsYmFja1xyXG4gICAgICAgICAqIEBtZW1iZXJvZiBCYXNlUGVyc2lzdGVyXHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0gVGhlIHJldHJpZXZlZCBkYXRhXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0RGF0YTogZnVuY3Rpb24gKGNvbnRlbnRUeXBlLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignVGhlIG1ldGhvZCBnZXREYXRhIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNhdmVzIGRhdGEgZm9yIGEgc3BlY2lmaWMgY29udGVudCB0eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBzYXZlRGF0YVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50VHlwZSBUaGUgY29udGVudCBmb3Igd2hpY2ggdG8gc2F2ZSB0aGUgZGF0YVxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIFRoZSBkYXRhIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHNwZWNpZmllZCBjb250ZW50IHR5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWNjZXNzIEEgc3VjY2VzcyBjYWxsYmFja1xyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVycm9yIEFuIGVycm9yIGNhbGxiYWNrXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEJhc2VQZXJzaXN0ZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBzYXZlRGF0YTogZnVuY3Rpb24gKGNvbnRlbnRUeXBlLCBkYXRhLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignVGhlIG1ldGhvZCBzYXZlRGF0YSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDbGVhcnMgdGhlIHBlcnNpc3RlZCBkYXRhIGZvciBhIHNwZWNpZmljIGNvbnRlbnQgdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgY2xlYXJcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFR5cGUgVGhlIGNvbnRlbnQgdHlwZSBmb3Igd2hpY2ggdG8gY2xlYXIgdGhlIGRhdGFcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWNjZXNzIEEgc3VjY2VzcyBjYWxsYmFja1xyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVycm9yIEFuIGVycm9yIGNhbGxiYWNrXHJcbiAgICAgICAgICogQG1lbWJlcm9mIEJhc2VQZXJzaXN0ZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBwdXJnZTogZnVuY3Rpb24gKGNvbnRlbnRUeXBlLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignVGhlIG1ldGhvZCBjbGVhciBpcyBub3QgaW1wbGVtZW50ZWQnKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDbGVhcnMgdGhlIHBlcnNpc3RlZCBkYXRhIGZvciBhIGNvbnRlbnQgdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgY2xlYXJBbGxcclxuICAgICAgICAgKiBAbWVtYmVyb2YgQmFzZVBlcnNpc3RlclxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1Y2Nlc3MgQSBzdWNjZXNzIGNhbGxiYWNrXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXJyb3IgQW4gZXJyb3IgY2FsbGJhY2tcclxuICAgICAgICAgKi9cclxuICAgICAgICBwdXJnZUFsbDogZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKCdUaGUgbWV0aG9kIGNsZWFyQWxsIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9nZXRLZXk6IGZ1bmN0aW9uIChjb250ZW50VHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5rZXkgKyAnXycgKyBjb250ZW50VHlwZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZ2V0RW5jcnlwdGlvblByb3ZpZGVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNkay5vZmZsaW5lU3RvcmFnZS5fZ2V0RW5jcnlwdGlvblByb3ZpZGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gQmFzZVBlcnNpc3RlcjtcclxufSgpKTtcclxuXHJcbnZhciBMb2NhbFN0b3JhZ2VQZXJzaXN0ZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAY2xhc3MgTG9jYWxTdG9yYWdlUGVyc2lzdGVyXHJcbiAgICAgKiBAZXh0ZW5kcyBCYXNlUGVyc2lzdGVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIExvY2FsU3RvcmFnZVBlcnNpc3RlcihrZXksIHNkaykge1xyXG4gICAgICAgIEJhc2VQZXJzaXN0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLl9sb2NhbFN0b3JlID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICB1dGlsLmluaGVyaXRzKExvY2FsU3RvcmFnZVBlcnNpc3RlciwgQmFzZVBlcnNpc3Rlcik7XHJcblxyXG4gICAgLy9XZSBuZWVkIHRvIG9mZmxpbmUgc3RvcmFnZSBwYXRoIGZyb20gdGhlIHNkay5vZmZsaW5lU3RvcmFnZS5zZXR1cCBpbiBub2RlanNcclxuICAgIC8vYnV0IGl0IGlzIG5vdCBhdmFpbGFibGUgc2luY2UgaXQgaXMgY3JlYXRlZCBhZnRlciB0aGUgcGVyc2lzdGVycyBhcmUgaW5pdGlhbGl6ZWRcclxuICAgIC8vdGhhdCBpcyB3aHkgd2UgcG9zcG9uZSB0aGUgbG9jYWxzdG9yZSBpbml0aWFsaXphdGlvbiBmb3IgdGhlIGZpcnN0IHRpbWUgaXQgaXMgbmVlZGVkXHJcbiAgICBMb2NhbFN0b3JhZ2VQZXJzaXN0ZXIucHJvdG90eXBlLl9lbnN1cmVMb2NhbFN0b3JlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fbG9jYWxTdG9yZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2NhbFN0b3JlID0gbmV3IExvY2FsU3RvcmUodGhpcy5zZGspO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTG9jYWxTdG9yYWdlUGVyc2lzdGVyLnByb3RvdHlwZS5nZXRBbGxEYXRhID0gZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBjb250ZW50VHlwZXMgPSB0aGlzLl9nZXRDb250ZW50VHlwZXMoKTtcclxuICAgICAgICB2YXIgYWxsQ29sbGVjdGlvbnMgPSB7fTtcclxuICAgICAgICBfLmVhY2goY29udGVudFR5cGVzLCBmdW5jdGlvbiAoY29udGVudFR5cGUpIHtcclxuICAgICAgICAgICAgYWxsQ29sbGVjdGlvbnNbY29udGVudFR5cGVdID0gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmdldERhdGEoY29udGVudFR5cGUsIHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByc3ZwLmhhc2goYWxsQ29sbGVjdGlvbnMpLnRoZW4oc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMb2NhbFN0b3JhZ2VQZXJzaXN0ZXIucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiAoY29udGVudFR5cGUsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuX2dldEtleShjb250ZW50VHlwZSk7XHJcbiAgICAgICAgICAgIHZhciBzdG9yZWRJdGVtID0gdGhpcy5fZ2V0SXRlbShrZXkpIHx8ICd7fSc7XHJcbiAgICAgICAgICAgIHZhciByZXZpdmVyID0gcGFyc2VVdGlsaXRpZXMuZ2V0UmV2aXZlcigpO1xyXG4gICAgICAgICAgICB2YXIgc3RvcmVkSXRlbU9iamVjdCA9IEpTT04ucGFyc2Uoc3RvcmVkSXRlbSwgcmV2aXZlcik7XHJcbiAgICAgICAgICAgIHN1Y2Nlc3Moc3RvcmVkSXRlbU9iamVjdCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBlcnJvcihlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIExvY2FsU3RvcmFnZVBlcnNpc3Rlci5wcm90b3R5cGUuc2F2ZURhdGEgPSBmdW5jdGlvbiAoY29udGVudFR5cGUsIGRhdGEsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFyIGNvbGxlY3Rpb25zU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XHJcbiAgICAgICAgICAgIHZhciBjb250ZW50VHlwZUtleSA9IHRoaXMuX2dldEtleShjb250ZW50VHlwZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldEl0ZW0oY29udGVudFR5cGVLZXksIGNvbGxlY3Rpb25zU3RyaW5nKTtcclxuICAgICAgICAgICAgc3VjY2VzcygpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgZXJyb3IoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMb2NhbFN0b3JhZ2VQZXJzaXN0ZXIucHJvdG90eXBlLnB1cmdlID0gZnVuY3Rpb24gKGNvbnRlbnRUeXBlLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLl9nZXRLZXkoY29udGVudFR5cGUpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVJdGVtKGtleSk7XHJcbiAgICAgICAgICAgIHN1Y2Nlc3MoKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGVycm9yKGUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTG9jYWxTdG9yYWdlUGVyc2lzdGVyLnByb3RvdHlwZS5wdXJnZUFsbCA9IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHZhciBjb250ZW50VHlwZXMgPSB0aGlzLl9nZXRDb250ZW50VHlwZXMoKTtcclxuICAgICAgICAgICAgXy5lYWNoKGNvbnRlbnRUeXBlcywgZnVuY3Rpb24gKGNvbnRlbnRUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudFR5cGVLZXkgPSBzZWxmLl9nZXRLZXkoY29udGVudFR5cGUpO1xyXG4gICAgICAgICAgICAgICAgc2VsZi5fcmVtb3ZlSXRlbShjb250ZW50VHlwZUtleSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlc0tleSA9IHRoaXMuX2dldENvbnRlbnRUeXBlc0NvbGxlY3Rpb25LZXkoKTtcclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlSXRlbShjb250ZW50VHlwZXNLZXkpO1xyXG5cclxuICAgICAgICAgICAgc3VjY2VzcygpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgZXJyb3IoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBMb2NhbFN0b3JhZ2VQZXJzaXN0ZXIucHJvdG90eXBlLl9nZXRJdGVtID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZUxvY2FsU3RvcmUoKTtcclxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9sb2NhbFN0b3JlLmdldEl0ZW0oa2V5KTtcclxuICAgICAgICB2YXIgZW5jcnlwdGlvblByb3ZpZGVyID0gdGhpcy5fZ2V0RW5jcnlwdGlvblByb3ZpZGVyKCk7XHJcbiAgICAgICAgcmV0dXJuIGVuY3J5cHRpb25Qcm92aWRlci5kZWNyeXB0KHZhbHVlKTtcclxuICAgIH07XHJcblxyXG4gICAgTG9jYWxTdG9yYWdlUGVyc2lzdGVyLnByb3RvdHlwZS5fc2V0SXRlbSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fZW5zdXJlTG9jYWxTdG9yZSgpO1xyXG4gICAgICAgIHZhciBlbmNyeXB0aW9uUHJvdmlkZXIgPSB0aGlzLl9nZXRFbmNyeXB0aW9uUHJvdmlkZXIoKTtcclxuICAgICAgICB2YWx1ZSA9IGVuY3J5cHRpb25Qcm92aWRlci5lbmNyeXB0KHZhbHVlKTtcclxuXHRcdHJldHVybiB0aGlzLl9sb2NhbFN0b3JlLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBMb2NhbFN0b3JhZ2VQZXJzaXN0ZXIucHJvdG90eXBlLl9yZW1vdmVJdGVtID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZUxvY2FsU3RvcmUoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxTdG9yZS5yZW1vdmVJdGVtKGtleSk7XHJcbiAgICB9O1xyXG5cclxuICAgIExvY2FsU3RvcmFnZVBlcnNpc3Rlci5wcm90b3R5cGUuX2dldEtleSA9IGZ1bmN0aW9uIChjb250ZW50VHlwZSkge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZUxvY2FsU3RvcmUoKTtcclxuICAgICAgICB0aGlzLl9hZGRUeXBlVG9Db2xsZWN0aW9uc0NhY2hlKGNvbnRlbnRUeXBlKTtcclxuICAgICAgICByZXR1cm4gTG9jYWxTdG9yYWdlUGVyc2lzdGVyLnN1cGVyXy5wcm90b3R5cGUuX2dldEtleS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMb2NhbFN0b3JhZ2VQZXJzaXN0ZXIucHJvdG90eXBlLl9nZXRDb250ZW50VHlwZXNDb2xsZWN0aW9uS2V5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmtleSArICdAQ29udGVudFR5cGVzJztcclxuICAgIH07XHJcblxyXG4gICAgTG9jYWxTdG9yYWdlUGVyc2lzdGVyLnByb3RvdHlwZS5fZ2V0Q29udGVudFR5cGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjb2xsZWN0aW9uS2V5ID0gdGhpcy5fZ2V0Q29udGVudFR5cGVzQ29sbGVjdGlvbktleSgpO1xyXG4gICAgICAgIHZhciBsb2NhbFN0b3JhZ2VTdHJpbmcgPSB0aGlzLl9nZXRJdGVtKGNvbGxlY3Rpb25LZXkpO1xyXG5cclxuICAgICAgICBpZiAobG9jYWxTdG9yYWdlU3RyaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZVN0cmluZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9O1xyXG5cclxuICAgIExvY2FsU3RvcmFnZVBlcnNpc3Rlci5wcm90b3R5cGUuX3NldENvbnRlbnRUeXBlc0NvbGxlY3Rpb24gPSBmdW5jdGlvbiAoY29sbGVjdGlvbikge1xyXG4gICAgICAgIHZhciBjb2xsZWN0aW9uS2V5ID0gdGhpcy5fZ2V0Q29udGVudFR5cGVzQ29sbGVjdGlvbktleSgpO1xyXG4gICAgICAgIHRoaXMuX3NldEl0ZW0oY29sbGVjdGlvbktleSwgSlNPTi5zdHJpbmdpZnkoY29sbGVjdGlvbikpO1xyXG4gICAgfTtcclxuXHJcbiAgICBMb2NhbFN0b3JhZ2VQZXJzaXN0ZXIucHJvdG90eXBlLl9hZGRUeXBlVG9Db2xsZWN0aW9uc0NhY2hlID0gZnVuY3Rpb24gKHR5cGVOYW1lKSB7XHJcbiAgICAgICAgdmFyIGNvbnRlbnRUeXBlc0NvbGxlY3Rpb24gPSB0aGlzLl9nZXRDb250ZW50VHlwZXMoKTtcclxuICAgICAgICBpZiAoIV8uY29udGFpbnMoY29udGVudFR5cGVzQ29sbGVjdGlvbiwgdHlwZU5hbWUpKSB7XHJcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlc0NvbGxlY3Rpb24ucHVzaCh0eXBlTmFtZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldENvbnRlbnRUeXBlc0NvbGxlY3Rpb24oY29udGVudFR5cGVzQ29sbGVjdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gTG9jYWxTdG9yYWdlUGVyc2lzdGVyO1xyXG59KCkpO1xyXG5cclxudmFyIEZpbGVTeXN0ZW1QZXJzaXN0ZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAY2xhc3MgRmlsZVN5c3RlbVBlcnNpc3RlclxyXG4gICAgICogQGV4dGVuZHMgQmFzZVBlcnNpc3RlclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBGaWxlU3lzdGVtUGVyc2lzdGVyKGtleSwgc2RrKSB7XHJcbiAgICAgICAgQmFzZVBlcnNpc3Rlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cclxuICAgICAgICBpZiAoIWlzQ29yZG92YSAmJiAhaXNOYXRpdmVTY3JpcHQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ0ZpbGVTeXN0ZW1QZXJzaXN0ZXIgY2FuIGJlIHVzZWQgb25seSB3aXRoIENvcmRvdmEgYW5kIE5hdGl2ZVNjcmlwdCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jb250ZW50VHlwZXNTdG9yZUtleSA9ICdAQ29udGVudFR5cGVzJztcclxuICAgIH1cclxuXHJcbiAgICB1dGlsLmluaGVyaXRzKEZpbGVTeXN0ZW1QZXJzaXN0ZXIsIEJhc2VQZXJzaXN0ZXIpO1xyXG5cclxuICAgIEZpbGVTeXN0ZW1QZXJzaXN0ZXIucHJvdG90eXBlLmdldEFsbERhdGEgPSBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGVycm9ySGFuZGxlciA9IHRoaXMuX2ZpbGVTeXN0ZW1FcnJvckhhbmRsZXIoZXJyb3IpO1xyXG4gICAgICAgIHZhciBwcm9taXNlcyA9IHt9O1xyXG4gICAgICAgIHRoaXMuX2dldENvbnRlbnRUeXBlc01ldGFkYXRhKGZ1bmN0aW9uIChjb250ZW50VHlwZXMpIHtcclxuICAgICAgICAgICAgT2JqZWN0LmtleXMoY29udGVudFR5cGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChjb250ZW50VHlwZSkge1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZXNbY29udGVudFR5cGVdID0gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5nZXREYXRhKGNvbnRlbnRUeXBlLCByZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcnN2cC5oYXNoKHByb21pc2VzKS50aGVuKHN1Y2Nlc3MsIGVycm9ySGFuZGxlcik7XHJcbiAgICAgICAgfSwgZXJyb3JIYW5kbGVyKTtcclxuICAgIH07XHJcblxyXG4gICAgRmlsZVN5c3RlbVBlcnNpc3Rlci5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uIChjb250ZW50VHlwZSwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGVycm9ySGFuZGxlciA9IHRoaXMuX2ZpbGVTeXN0ZW1FcnJvckhhbmRsZXIoZXJyb3IpO1xyXG4gICAgICAgIHRoaXMuX2dldEZpbGVGdWxsKGNvbnRlbnRUeXBlLCBmdW5jdGlvbiAoZmlsZUVudHJ5KSB7XHJcbiAgICAgICAgICAgIHNlbGYuX3JlYWRGaWxlQ29udGVudChmaWxlRW50cnksIHN1Y2Nlc3MsIGVycm9ySGFuZGxlcik7XHJcbiAgICAgICAgfSwgZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICBGaWxlU3lzdGVtUGVyc2lzdGVyLnByb3RvdHlwZS5zYXZlRGF0YSA9IGZ1bmN0aW9uIChjb250ZW50VHlwZSwgZGF0YSwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGRhdGFTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcclxuICAgICAgICB2YXIgZXJyb3JIYW5kbGVyID0gdGhpcy5fZmlsZVN5c3RlbUVycm9ySGFuZGxlcihlcnJvcik7XHJcbiAgICAgICAgdGhpcy5fZ2V0RmlsZUZ1bGwoY29udGVudFR5cGUsIGZ1bmN0aW9uIChmaWxlRW50cnkpIHtcclxuICAgICAgICAgICAgc2VsZi5fd3JpdGVGaWxlQ29udGVudChmaWxlRW50cnksIGRhdGFTdHJpbmcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHNlbGYuX3NhdmVDb250ZW50VHlwZXNNZXRhZGF0YShjb250ZW50VHlwZSwgc3VjY2VzcywgZXJyb3JIYW5kbGVyKTtcclxuICAgICAgICAgICAgfSwgZXJyb3JIYW5kbGVyKTtcclxuICAgICAgICB9LCBlcnJvckhhbmRsZXIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBGaWxlU3lzdGVtUGVyc2lzdGVyLnByb3RvdHlwZS5wdXJnZSA9IGZ1bmN0aW9uIChjb250ZW50VHlwZSwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGVycm9ySGFuZGxlciA9IHRoaXMuX2ZpbGVTeXN0ZW1FcnJvckhhbmRsZXIoZXJyb3IpO1xyXG4gICAgICAgIHRoaXMuX2dldEZpbGVGdWxsKGNvbnRlbnRUeXBlLCBmdW5jdGlvbiAoZmlsZUVudHJ5KSB7XHJcbiAgICAgICAgICAgIHNlbGYuX3JlbW92ZUZpbGUoZmlsZUVudHJ5LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgfSwgZXJyb3JIYW5kbGVyKTtcclxuICAgIH07XHJcblxyXG4gICAgRmlsZVN5c3RlbVBlcnNpc3Rlci5wcm90b3R5cGUucHVyZ2VBbGwgPSBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGVycm9ySGFuZGxlciA9IHRoaXMuX2ZpbGVTeXN0ZW1FcnJvckhhbmRsZXIoZXJyb3IpO1xyXG4gICAgICAgIHRoaXMuX3Jlc29sdmVEYXRhRGlyZWN0b3J5KGZ1bmN0aW9uIChkYXRhRGlyRW50cnkpIHtcclxuICAgICAgICAgICAgc2VsZi5fcmVtb3ZlRmlsZXNEaXJlY3RvcnkoZGF0YURpckVudHJ5LCBzdWNjZXNzLCBlcnJvckhhbmRsZXIpO1xyXG4gICAgICAgIH0sIGVycm9ySGFuZGxlcik7XHJcbiAgICB9O1xyXG5cclxuICAgIEZpbGVTeXN0ZW1QZXJzaXN0ZXIucHJvdG90eXBlLl9lbnN1cmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5maWxlc0RpcmVjdG9yeVBhdGgpIHtcclxuICAgICAgICAgICAgdGhpcy5maWxlc0RpcmVjdG9yeVBhdGggPSB0aGlzLnNkay5vZmZsaW5lU3RvcmFnZS5zZXR1cC5zdG9yYWdlLnN0b3JhZ2VQYXRoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmRhdGFEaXJlY3RvcnlQYXRoKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0NvcmRvdmEpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb3Jkb3ZhICYmICFjb3Jkb3ZhLmZpbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXZlcmxpdmVFcnJvcignWW91IG5lZWQgdG8gZW5hYmxlIHRoZSBjb3Jkb3ZhIGZpbGUgcGx1Z2luIHRvIHVzZSBmaWxlIG9mZmxpbmUgc3RvcmFnZS4gJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ01ha2Ugc3VyZSB0aGF0IHRoZSBcImRldmljZVJlYWR5XCIgZXZlbnQgaGFzIGZpcmVkLicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YURpcmVjdG9yeVBhdGggPSBjb3Jkb3ZhLmZpbGUuZGF0YURpcmVjdG9yeTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc05hdGl2ZVNjcmlwdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcyA9IHJlcXVpcmUoJ2ZpbGUtc3lzdGVtJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFEaXJlY3RvcnlQYXRoID0gdGhpcy5mcy5rbm93bkZvbGRlcnMuZG9jdW1lbnRzKCkucGF0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgRmlsZVN5c3RlbVBlcnNpc3Rlci5wcm90b3R5cGUuX2dldENvbnRlbnRUeXBlc01ldGFkYXRhID0gZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdGhpcy5fZW5zdXJlUHJvcGVydGllcygpO1xyXG4gICAgICAgIHRoaXMuZ2V0RGF0YSh0aGlzLmNvbnRlbnRUeXBlc1N0b3JlS2V5LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIEZpbGVTeXN0ZW1QZXJzaXN0ZXIucHJvdG90eXBlLl9zYXZlQ29udGVudFR5cGVzTWV0YWRhdGEgPSBmdW5jdGlvbiAoY29udGVudFR5cGUsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdGhpcy5fZW5zdXJlUHJvcGVydGllcygpO1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICB0aGlzLl9nZXRDb250ZW50VHlwZXNNZXRhZGF0YShmdW5jdGlvbiAoc2F2ZWRDb250ZW50VHlwZXMpIHtcclxuICAgICAgICAgICAgc2F2ZWRDb250ZW50VHlwZXNbY29udGVudFR5cGVdID0gdHJ1ZTtcclxuICAgICAgICAgICAgc2VsZi5fZ2V0RmlsZUZ1bGwoc2VsZi5jb250ZW50VHlwZXNTdG9yZUtleSwgZnVuY3Rpb24gKGNvbnRlbnRUeXBlc0ZpbGUpIHtcclxuICAgICAgICAgICAgICAgIHNlbGYuX3dyaXRlRmlsZUNvbnRlbnQoY29udGVudFR5cGVzRmlsZSwgSlNPTi5zdHJpbmdpZnkoc2F2ZWRDb250ZW50VHlwZXMpLCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgICAgIH0sIGVycm9yKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgRmlsZVN5c3RlbVBlcnNpc3Rlci5wcm90b3R5cGUuX2dldEZpbGVGdWxsID0gZnVuY3Rpb24gKGNvbnRlbnRUeXBlLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZVByb3BlcnRpZXMoKTtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fZW5zdXJlRmlsZXNEaXJlY3RvcnkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcGF0aCA9IHNlbGYuX2dldEZpbGVQYXRoKGNvbnRlbnRUeXBlKTtcclxuICAgICAgICAgICAgc2VsZi5fZ2V0RmlsZUZyb21TeXN0ZW0ocGF0aCwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgIH0sIGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgRmlsZVN5c3RlbVBlcnNpc3Rlci5wcm90b3R5cGUuX3JlbW92ZUZpbGVzRGlyZWN0b3J5ID0gZnVuY3Rpb24gKGRpcmVjdG9yeUVudHJ5LCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZVByb3BlcnRpZXMoKTtcclxuICAgICAgICBpZiAoaXNDb3Jkb3ZhKSB7XHJcbiAgICAgICAgICAgIGRpcmVjdG9yeUVudHJ5LmdldERpcmVjdG9yeSh0aGlzLmZpbGVzRGlyZWN0b3J5UGF0aCwge1xyXG4gICAgICAgICAgICAgICAgY3JlYXRlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZXhjbHVzaXZlOiBmYWxzZVxyXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZmlsZXNEaXJFbnRyeSkge1xyXG4gICAgICAgICAgICAgICAgZmlsZXNEaXJFbnRyeS5yZW1vdmVSZWN1cnNpdmVseShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzcygpO1xyXG4gICAgICAgICAgICAgICAgfSwgZXJyb3IpO1xyXG4gICAgICAgICAgICB9LCBlcnJvcilcclxuICAgICAgICB9IGVsc2UgaWYgKGlzTmF0aXZlU2NyaXB0KSB7XHJcbiAgICAgICAgICAgIHZhciBmaWxlc0RpcmVjdG9yeVBhdGggPSB0aGlzLmZzLnBhdGguam9pbihkaXJlY3RvcnlFbnRyeS5wYXRoLCB0aGlzLmZpbGVzRGlyZWN0b3J5UGF0aCk7XHJcbiAgICAgICAgICAgIHZhciBmaWxlc0RpcmVjdG9yeSA9IHRoaXMuZnMuRm9sZGVyLmZyb21QYXRoKGZpbGVzRGlyZWN0b3J5UGF0aCk7XHJcbiAgICAgICAgICAgIGZpbGVzRGlyZWN0b3J5LnJlbW92ZSgpLnRoZW4oc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgRmlsZVN5c3RlbVBlcnNpc3Rlci5wcm90b3R5cGUuX3JlbW92ZUZpbGUgPSBmdW5jdGlvbiAoZmlsZUVudHJ5LCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZVByb3BlcnRpZXMoKTtcclxuICAgICAgICBpZiAoaXNDb3Jkb3ZhKSB7XHJcbiAgICAgICAgICAgIGZpbGVFbnRyeS5yZW1vdmUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgc3VjY2VzcygpO1xyXG4gICAgICAgICAgICB9LCBlcnJvcik7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc05hdGl2ZVNjcmlwdCkge1xyXG4gICAgICAgICAgICBmaWxlRW50cnkucmVtb3ZlKCkudGhlbihzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBGaWxlU3lzdGVtUGVyc2lzdGVyLnByb3RvdHlwZS5fcmVhZEZpbGVDb250ZW50ID0gZnVuY3Rpb24gKGZpbGVFbnRyeSwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB0aGlzLl9lbnN1cmVQcm9wZXJ0aWVzKCk7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgIHZhciByZWFkVGV4dFN1Y2Nlc3MgPSBmdW5jdGlvbiAoY29udGVudCkge1xyXG4gICAgICAgICAgICB2YXIgZW5jcnlwdGlvblByb3ZpZGVyID0gdGhhdC5fZ2V0RW5jcnlwdGlvblByb3ZpZGVyKCk7XHJcbiAgICAgICAgICAgIGNvbnRlbnQgPSBlbmNyeXB0aW9uUHJvdmlkZXIuZGVjcnlwdChjb250ZW50KTtcclxuXHJcbiAgICAgICAgICAgIHZhciByZXZpdmVyID0gcGFyc2VVdGlsaXRpZXMuZ2V0UmV2aXZlcigpO1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0T2JqZWN0ID0gSlNPTi5wYXJzZShjb250ZW50IHx8ICd7fScsIHJldml2ZXIpO1xyXG4gICAgICAgICAgICBzdWNjZXNzKHJlc3VsdE9iamVjdCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYgKGlzQ29yZG92YSkge1xyXG4gICAgICAgICAgICBmaWxlRW50cnkuZmlsZShmdW5jdGlvbiAoZmlsZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcbiAgICAgICAgICAgICAgICByZWFkZXIub25sb2FkZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlYWRUZXh0U3VjY2Vzcyh0aGlzLnJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSBlcnJvcjtcclxuICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGUpO1xyXG4gICAgICAgICAgICB9LCBlcnJvcik7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc05hdGl2ZVNjcmlwdCkge1xyXG4gICAgICAgICAgICBmaWxlRW50cnkucmVhZFRleHQoKS50aGVuKHJlYWRUZXh0U3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgRmlsZVN5c3RlbVBlcnNpc3Rlci5wcm90b3R5cGUuX3dyaXRlRmlsZUNvbnRlbnQgPSBmdW5jdGlvbiAoZmlsZUVudHJ5LCBjb250ZW50LCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZVByb3BlcnRpZXMoKTtcclxuICAgICAgICB2YXIgZW5jcnlwdGlvblByb3ZpZGVyID0gdGhpcy5fZ2V0RW5jcnlwdGlvblByb3ZpZGVyKCk7XHJcbiAgICAgICAgY29udGVudCA9IGVuY3J5cHRpb25Qcm92aWRlci5lbmNyeXB0KGNvbnRlbnQpO1xyXG5cclxuICAgICAgICBpZiAoaXNDb3Jkb3ZhKSB7XHJcbiAgICAgICAgICAgIGZpbGVFbnRyeS5jcmVhdGVXcml0ZXIoZnVuY3Rpb24gKGZpbGVXcml0ZXIpIHtcclxuICAgICAgICAgICAgICAgIGZpbGVXcml0ZXIub253cml0ZWVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIGZpbGVXcml0ZXIub25lcnJvciA9IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgZmlsZVdyaXRlci53cml0ZShjb250ZW50KTtcclxuICAgICAgICAgICAgfSwgZXJyb3IpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNOYXRpdmVTY3JpcHQpIHtcclxuICAgICAgICAgICAgZmlsZUVudHJ5LndyaXRlVGV4dChjb250ZW50KS50aGVuKHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIEZpbGVTeXN0ZW1QZXJzaXN0ZXIucHJvdG90eXBlLl9nZXRGaWxlRnJvbVN5c3RlbSA9IGZ1bmN0aW9uIChwYXRoLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZVByb3BlcnRpZXMoKTtcclxuICAgICAgICB0aGlzLl9yZXNvbHZlRGF0YURpcmVjdG9yeShmdW5jdGlvbiAoZGlyZWN0b3J5RW50cnkpIHtcclxuICAgICAgICAgICAgaWYgKGlzQ29yZG92YSkge1xyXG4gICAgICAgICAgICAgICAgZGlyZWN0b3J5RW50cnkuZ2V0RmlsZShwYXRoLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGV4Y2x1c2l2ZTogZmFsc2VcclxuICAgICAgICAgICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc05hdGl2ZVNjcmlwdCkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZnVsbEZpbGVQYXRoID0gdGhpcy5mcy5wYXRoLmpvaW4oZGlyZWN0b3J5RW50cnkucGF0aCwgcGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGUgPSB0aGlzLmZzLkZpbGUuZnJvbVBhdGgoZnVsbEZpbGVQYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKGZpbGUpO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yKGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgIH07XHJcblxyXG4gICAgRmlsZVN5c3RlbVBlcnNpc3Rlci5wcm90b3R5cGUuX2dldEZpbGVQYXRoID0gZnVuY3Rpb24gKGNvbnRlbnRUeXBlKSB7XHJcbiAgICAgICAgdGhpcy5fZW5zdXJlUHJvcGVydGllcygpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZpbGVzRGlyZWN0b3J5UGF0aCArIHRoaXMuX2dldEtleShjb250ZW50VHlwZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIEZpbGVTeXN0ZW1QZXJzaXN0ZXIucHJvdG90eXBlLl9yZXNvbHZlRGF0YURpcmVjdG9yeSA9IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZVByb3BlcnRpZXMoKTtcclxuICAgICAgICBpZiAoaXNDb3Jkb3ZhKSB7XHJcbiAgICAgICAgICAgIHJlc29sdmVMb2NhbEZpbGVTeXN0ZW1VUkwodGhpcy5kYXRhRGlyZWN0b3J5UGF0aCwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNOYXRpdmVTY3JpcHQpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGFEaXJlY3RvcnkgPSB0aGlzLmZzLkZvbGRlci5mcm9tUGF0aCh0aGlzLmRhdGFEaXJlY3RvcnlQYXRoKTtcclxuICAgICAgICAgICAgc3VjY2VzcyhkYXRhRGlyZWN0b3J5KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIEZpbGVTeXN0ZW1QZXJzaXN0ZXIucHJvdG90eXBlLl9lbnN1cmVGaWxlc0RpcmVjdG9yeSA9IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZVByb3BlcnRpZXMoKTtcclxuICAgICAgICB2YXIgZmlsZXNEaXJlY3RvcnlQYXRoID0gdGhpcy5maWxlc0RpcmVjdG9yeVBhdGg7XHJcbiAgICAgICAgdGhpcy5fcmVzb2x2ZURhdGFEaXJlY3RvcnkoZnVuY3Rpb24gKGRpcmVjdG9yeUVudHJ5KSB7XHJcbiAgICAgICAgICAgIGlmIChpc0NvcmRvdmEpIHtcclxuICAgICAgICAgICAgICAgIGRpcmVjdG9yeUVudHJ5LmdldERpcmVjdG9yeShmaWxlc0RpcmVjdG9yeVBhdGgsIHtcclxuICAgICAgICAgICAgICAgICAgICBjcmVhdGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZXhjbHVzaXZlOiBmYWxzZVxyXG4gICAgICAgICAgICAgICAgfSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTmF0aXZlU2NyaXB0KSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWxlRGlyZWN0b3J5UGF0aCA9IHRoaXMuZnMucGF0aC5qb2luKGRpcmVjdG9yeUVudHJ5LnBhdGgsIGZpbGVzRGlyZWN0b3J5UGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcy5Gb2xkZXIuZnJvbVBhdGgoZmlsZURpcmVjdG9yeVBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MoKTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBlcnJvciAoZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LmJpbmQodGhpcyksIGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgRmlsZVN5c3RlbVBlcnNpc3Rlci5wcm90b3R5cGUuX2ZpbGVTeXN0ZW1FcnJvckhhbmRsZXIgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAoIWlzTmF0aXZlU2NyaXB0KSB7XHJcbiAgICAgICAgICAgIHZhciBlcnJvcnNNYXAgPSB7fTtcclxuICAgICAgICAgICAgXy5lYWNoKE9iamVjdC5rZXlzKEZpbGVFcnJvciksIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgZXJyb3JzTWFwW0ZpbGVFcnJvcltlcnJvcl1dID0gZXJyb3I7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2UgPSBlcnJvcnNNYXBbZS5jb2RlXTtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gRmlsZVN5c3RlbVBlcnNpc3RlcjtcclxufSgpKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgQmFzZVBlcnNpc3RlcjogQmFzZVBlcnNpc3RlcixcclxuICAgIExvY2FsU3RvcmFnZVBlcnNpc3RlcjogTG9jYWxTdG9yYWdlUGVyc2lzdGVyLFxyXG4gICAgRmlsZVN5c3RlbVBlcnNpc3RlcjogRmlsZVN5c3RlbVBlcnNpc3RlclxyXG59OyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKTtcclxudmFyIF8gPSByZXF1aXJlKCcuLi9jb21tb24nKS5fO1xyXG52YXIgb2ZmbGluZUl0ZW1TdGF0ZU1hcmtlciA9IGNvbnN0YW50cy5vZmZsaW5lSXRlbXNTdGF0ZU1hcmtlcjtcclxuXHJcbnZhciB0cmF2ZXJzZUFuZEFwcGx5ID0gZnVuY3Rpb24gKHZhbHVlLCBvcGVyYXRpb24sIGFkZGl0aW9uYWxPcHRpb25zKSB7XHJcbiAgICBpZiAoXy5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiBfLm1hcCh2YWx1ZSwgZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9wZXJhdGlvbihpdGVtLCBhZGRpdGlvbmFsT3B0aW9ucyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBvcGVyYXRpb24odmFsdWUsIGFkZGl0aW9uYWxPcHRpb25zKTtcclxuICAgIH1cclxufTtcclxuXHJcbnZhciBpZFRyYW5zZm9ybWF0aW9uID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5faWQgJiYgIXZhbHVlLklkKSB7XHJcbiAgICAgICAgdmFsdWUuSWQgPSB2YWx1ZS5faWQ7XHJcbiAgICAgICAgZGVsZXRlIHZhbHVlLl9pZDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn07XHJcblxyXG52YXIgcmVtb3ZlSWRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUsIG9wdHMpIHtcclxuICAgIHZhciB2ZXJpZnlTdGF0ZUNyZWF0ZWQgPSBvcHRzLnZlcmlmeVN0YXRlQ3JlYXRlZDtcclxuICAgIHZhciBzaG91bGRNb2RpZnlPYmplY3QgPSB2ZXJpZnlTdGF0ZUNyZWF0ZWQgPyB2YWx1ZVtjb25zdGFudHMub2ZmbGluZUl0ZW1zU3RhdGVNYXJrZXJdID09PSBjb25zdGFudHMub2ZmbGluZUl0ZW1TdGF0ZXMuY3JlYXRlZCA6IHRydWU7XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAodmFsdWUuX2lkIHx8IHZhbHVlLklkKSAmJiBzaG91bGRNb2RpZnlPYmplY3QpIHtcclxuICAgICAgICBkZWxldGUgdmFsdWUuX2lkO1xyXG4gICAgICAgIGRlbGV0ZSB2YWx1ZS5JZDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn07XHJcblxyXG52YXIgcmVtb3ZlTWFya2VyVHJhbnNmb3JtID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICBkZWxldGUgdmFsdWVbb2ZmbGluZUl0ZW1TdGF0ZU1hcmtlcl07XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn07XHJcblxyXG52YXIgb2ZmbGluZVRyYW5zZm9ybWF0aW9ucyA9IHtcclxuICAgIHJlbW92ZUlkVHJhbnNmb3JtOiBmdW5jdGlvbiAodmFsdWUsIHZlcmlmeVN0YXRlQ3JlYXRlZCkge1xyXG4gICAgICAgIHJldHVybiB0cmF2ZXJzZUFuZEFwcGx5KHZhbHVlLCByZW1vdmVJZFRyYW5zZm9ybSwge3ZlcmlmeVN0YXRlQ3JlYXRlZDogdmVyaWZ5U3RhdGVDcmVhdGVkfSk7XHJcbiAgICB9LFxyXG4gICAgaWRUcmFuc2Zvcm06IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB0cmF2ZXJzZUFuZEFwcGx5KHZhbHVlLCBpZFRyYW5zZm9ybWF0aW9uKTtcclxuICAgIH0sXHJcbiAgICBzaW5nbGVGaWVsZFRyYW5zZm9ybTogZnVuY3Rpb24gKHNpbmdsZUZpZWxkRXhwcmVzc2lvbiwgdmFsdWUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyB8fCB2YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWVbc2luZ2xlRmllbGRFeHByZXNzaW9uXTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgdHJhdmVyc2VBbmRUcmFuc2Zvcm1GaWx0ZXJJZDogZnVuY3Rpb24gKGZpbHRlck9iaikge1xyXG4gICAgICAgIGlmIChmaWx0ZXJPYmogJiYgZmlsdGVyT2JqLklkKSB7XHJcbiAgICAgICAgICAgIGZpbHRlck9iai5faWQgPSBmaWx0ZXJPYmouSWQ7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBmaWx0ZXJPYmouSWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGZpbHRlck9iaikge1xyXG4gICAgICAgICAgICBpZiAoZmlsdGVyT2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0TWVtYmVyID0gZmlsdGVyT2JqW3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3RNZW1iZXIgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2ZmbGluZVRyYW5zZm9ybWF0aW9ucy50cmF2ZXJzZUFuZFRyYW5zZm9ybUZpbHRlcklkKG9iamVjdE1lbWJlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgcmVtb3ZlTWFya2Vyc1RyYW5zZm9ybTogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRyYXZlcnNlQW5kQXBwbHkodmFsdWUsIHJlbW92ZU1hcmtlclRyYW5zZm9ybSk7XHJcbiAgICB9LFxyXG4gICAgcmVtb3ZlRmllbGRzVHJhbnNmb3JtOiBmdW5jdGlvbiAodmFsdWUsIGZpZWxkcykge1xyXG4gICAgICAgIF8uZWFjaChmaWVsZHMsIGZ1bmN0aW9uIChmaWVsZCkge1xyXG4gICAgICAgICAgICBkZWxldGUgdmFsdWVbZmllbGRdO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG9mZmxpbmVUcmFuc2Zvcm1hdGlvbnM7IiwidmFyIF8gPSByZXF1aXJlKCcuLi9jb21tb24nKS5fO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gVE9ETzogW29mZmxpbmVdIFVwZGF0ZSB0aGUgc3RydWN0dXJlIC0gZmlsdGVyIGZpZWxkIGNhbiBiZSByZWZhY3RvcmVkIGZvciBleGFtcGxlIGFuZCBhIHNraXAvbGltaXQvc29ydCBwcm9wZXJ0eSBjYW4gYmUgYWRkZWRcclxuICAgIHZhciBEYXRhUXVlcnkgPSBmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uTmFtZSA9IGNvbmZpZy5jb2xsZWN0aW9uTmFtZTtcclxuICAgICAgICB0aGlzLmhlYWRlcnMgPSBjb25maWcuaGVhZGVycyB8fCB7fTtcclxuICAgICAgICB0aGlzLmZpbHRlciA9IGNvbmZpZy5maWx0ZXI7XHJcbiAgICAgICAgdGhpcy5vblN1Y2Nlc3MgPSBjb25maWcub25TdWNjZXNzO1xyXG4gICAgICAgIHRoaXMub25FcnJvciA9IGNvbmZpZy5vbkVycm9yO1xyXG4gICAgICAgIHRoaXMub3BlcmF0aW9uID0gY29uZmlnLm9wZXJhdGlvbjtcclxuICAgICAgICB0aGlzLnBhcnNlID0gY29uZmlnLnBhcnNlO1xyXG4gICAgICAgIHRoaXMuYWRkaXRpb25hbE9wdGlvbnMgPSBjb25maWcuYWRkaXRpb25hbE9wdGlvbnM7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gY29uZmlnLmRhdGE7XHJcbiAgICAgICAgdGhpcy51c2VPZmZsaW5lID0gY29uZmlnLnVzZU9mZmxpbmU7XHJcbiAgICAgICAgdGhpcy5hcHBseU9mZmxpbmUgPSBjb25maWcuYXBwbHlPZmZsaW5lO1xyXG4gICAgICAgIHRoaXMubm9SZXRyeSA9IGNvbmZpZy5ub1JldHJ5OyAvL3JldHJ5IHdpbGwgYmUgZG9uZSBieSBkZWZhdWx0LCB3aGVuIGEgcmVxdWVzdCBmYWlscyBiZWNhdXNlIG9mIGV4cGlyZWQgdG9rZW4sIG9uY2UgdGhlIGF1dGhlbnRpY2F0aW9uLmNvbXBsZXRlQXV0aGVudGljYXRpb24gaW4gc2RrIGlzIGNhbGxlZC5cclxuICAgICAgICB0aGlzLnNraXBBdXRoID0gY29uZmlnLnNraXBBdXRoOyAvL2lmIHNldCB0byB0cnVlLCB0aGUgc2RrIHdpbGwgbm90IHJlcXVpcmUgYXV0aG9yaXphdGlvbiBpZiB0aGUgZGF0YSBxdWVyeSBmYWlscyBiZWNhdXNlIG9mIGV4cGlyZWQgdG9rZW4uIFVzZWQgaW50ZXJuYWxseSBmb3IgdmFyaW91cyBsb2dpbiBtZXRob2RzLlxyXG4gICAgICAgIHRoaXMuX25vcm1hbGl6ZWRIZWFkZXJzID0gbnVsbDtcclxuICAgICAgICB0aGlzLmlzU3luYyA9IGNvbmZpZy5pc1N5bmM7XHJcbiAgICB9O1xyXG5cclxuICAgIERhdGFRdWVyeS5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgZ2V0SGVhZGVyOiBmdW5jdGlvbiAoaGVhZGVyKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGhlYWRlcktleXMgPSBPYmplY3Qua2V5cyh0aGlzLmhlYWRlcnMpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9ub3JtYWxpemVkSGVhZGVycykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbm9ybWFsaXplZEhlYWRlcnMgPSB7fTtcclxuICAgICAgICAgICAgICAgIF8uZWFjaChoZWFkZXJLZXlzLCBmdW5jdGlvbiAoaGVhZGVyS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRLZXkgPSBoZWFkZXJLZXkudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGVhZGVyVmFsdWUgPSBzZWxmLmhlYWRlcnNbaGVhZGVyS2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9ub3JtYWxpemVkSGVhZGVyc1tub3JtYWxpemVkS2V5XSA9IGhlYWRlclZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBub3JtYWxpemVkSGVhZGVyID0gaGVhZGVyLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub3JtYWxpemVkSGVhZGVyc1tub3JtYWxpemVkSGVhZGVyXTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZXRIZWFkZXJBc0pTT046IGZ1bmN0aW9uIChoZWFkZXIpIHtcclxuICAgICAgICAgICAgdmFyIGhlYWRlclZhbHVlID0gdGhpcy5fbm9ybWFsaXplZEhlYWRlcnNbaGVhZGVyLnRvTG93ZXJDYXNlKCldO1xyXG4gICAgICAgICAgICBpZiAoXy5pc09iamVjdChoZWFkZXJWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBoZWFkZXJWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoXy5pc1N0cmluZyhoZWFkZXJWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoaGVhZGVyVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWFkZXJWYWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBoZWFkZXJWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMgPSB7XHJcbiAgICAgICAgcmVhZDogJ3JlYWQnLFxyXG4gICAgICAgIGNyZWF0ZTogJ2NyZWF0ZScsXHJcbiAgICAgICAgdXBkYXRlOiAndXBkYXRlJyxcclxuICAgICAgICByZW1vdmU6ICdkZXN0cm95JyxcclxuICAgICAgICByZW1vdmVTaW5nbGU6ICdkZXN0cm95U2luZ2xlJyxcclxuICAgICAgICByZWFkQnlJZDogJ3JlYWRCeUlkJyxcclxuICAgICAgICBjb3VudDogJ2NvdW50JyxcclxuICAgICAgICByYXdVcGRhdGU6ICdyYXdVcGRhdGUnLFxyXG4gICAgICAgIHNldEFjbDogJ3NldEFjbCcsXHJcbiAgICAgICAgc2V0T3duZXI6ICdzZXRPd25lcicsXHJcbiAgICAgICAgdXNlckxvZ2luOiAnbG9naW4nLFxyXG4gICAgICAgIHVzZXJMb2dvdXQ6ICdsb2dvdXQnLFxyXG4gICAgICAgIHVzZXJDaGFuZ2VQYXNzd29yZDogJ2NoYW5nZVBhc3N3b3JkJyxcclxuICAgICAgICB1c2VyTG9naW5XaXRoUHJvdmlkZXI6ICdsb2dpbldpdGgnLFxyXG4gICAgICAgIHVzZXJMaW5rV2l0aFByb3ZpZGVyOiAnbGlua1dpdGgnLFxyXG4gICAgICAgIHVzZXJVbmxpbmtGcm9tUHJvdmlkZXI6ICd1bmxpbmtGcm9tJyxcclxuICAgICAgICBmaWxlc1VwZGF0ZUNvbnRlbnQ6ICd1cGRhdGVDb250ZW50JyxcclxuICAgICAgICBmaWxlc0dldERvd25sb2FkVXJsQnlJZDogJ2Rvd25sb2FkVXJsQnlJZCdcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIERhdGFRdWVyeTtcclxufSgpKTsiLCJ2YXIgRXhwcmVzc2lvbiA9IHJlcXVpcmUoJy4uL0V4cHJlc3Npb24nKTtcclxudmFyIE9wZXJhdG9yVHlwZSA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpLk9wZXJhdG9yVHlwZTtcclxudmFyIFdoZXJlUXVlcnkgPSByZXF1aXJlKCcuL1doZXJlUXVlcnknKTtcclxudmFyIFF1ZXJ5QnVpbGRlciA9IHJlcXVpcmUoJy4vUXVlcnlCdWlsZGVyJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEBjbGFzcyBRdWVyeVxyXG4gICAgICogQGNsYXNzZGVzYyBBIHF1ZXJ5IGNsYXNzIHVzZWQgdG8gZGVzY3JpYmUgYSByZXF1ZXN0IHRoYXQgd2lsbCBiZSBtYWRlIHRvIHRoZSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IEphdmFTY3JpcHQgQVBJLlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtmaWx0ZXJdIEEgW2ZpbHRlciBleHByZXNzaW9uXSh7JSBzbHVnIHJlc3QtYXBpLXF1ZXJ5aW5nLWZpbHRlcmluZyAlfSkgZGVmaW5pdGlvbi5cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbZmllbGRzXSBBIFtmaWVsZHMgZXhwcmVzc2lvbl0oeyUgc2x1ZyByZXN0LWFwaS1xdWVyeWluZy1TdWJzZXQtb2YtZmllbGRzICV9KSBkZWZpbml0aW9uLlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtzb3J0XSBBIFtzb3J0IGV4cHJlc3Npb25dKHslIHNsdWcgcmVzdC1hcGktcXVlcnlpbmctc29ydGluZyAlfSkgZGVmaW5pdGlvbi5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2tpcF0gTnVtYmVyIG9mIGl0ZW1zIHRvIHNraXAuIFVzZWQgZm9yIHBhZ2luZy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdGFrZV0gTnVtYmVyIG9mIGl0ZW1zIHRvIHRha2UuIFVzZWQgZm9yIHBhZ2luZy5cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbZXhwYW5kXSBBbiBbZXhwYW5kIGV4cHJlc3Npb25dKHslIHNsdWcgZmVhdHVyZXMtZGF0YS1yZWxhdGlvbnMtZGVmaW5pbmctZXhwYW5kICV9KSBkZWZpbml0aW9uLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBRdWVyeShmaWx0ZXIsIGZpZWxkcywgc29ydCwgc2tpcCwgdGFrZSwgZXhwYW5kKSB7XHJcbiAgICAgICAgdGhpcy5maWx0ZXIgPSBmaWx0ZXI7XHJcbiAgICAgICAgdGhpcy5maWVsZHMgPSBmaWVsZHM7XHJcbiAgICAgICAgdGhpcy5zb3J0ID0gc29ydDtcclxuICAgICAgICB0aGlzLnRvc2tpcCA9IHNraXA7XHJcbiAgICAgICAgdGhpcy50b3Rha2UgPSB0YWtlO1xyXG4gICAgICAgIHRoaXMuZXhwYW5kRXhwcmVzc2lvbiA9IGV4cGFuZDtcclxuICAgICAgICB0aGlzLmV4cHIgPSBuZXcgRXhwcmVzc2lvbihPcGVyYXRvclR5cGUucXVlcnkpO1xyXG4gICAgfVxyXG5cclxuICAgIFF1ZXJ5LnByb3RvdHlwZSA9IHtcclxuICAgICAgICAvKiogQXBwbGllcyBhIGZpbHRlciB0byB0aGUgY3VycmVudCBxdWVyeS4gVGhpcyBhbGxvd3MgeW91IHRvIHJldHJpZXZlIG9ubHkgYSBzdWJzZXQgb2YgdGhlIGl0ZW1zIGJhc2VkIG9uIHZhcmlvdXMgZmlsdGVyaW5nIGNyaXRlcmlhLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHdoZXJlXHJcbiAgICAgICAgICogQG5hbWUgd2hlcmVcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gZmlsdGVyIEEgW2ZpbHRlciBleHByZXNzaW9uXSh7JSBzbHVnIHJlc3QtYXBpLXF1ZXJ5aW5nLWZpbHRlcmluZyAlfSkgZGVmaW5pdGlvbi5cclxuICAgICAgICAgKiBAcmV0dXJucyB7UXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqIERlZmluZXMgYSBmaWx0ZXIgZGVmaW5pdGlvbiBmb3IgdGhlIGN1cnJlbnQgcXVlcnkuXHJcbiAgICAgICAgICogQG1lbWJlck9mIFF1ZXJ5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2Qgd2hlcmVcclxuICAgICAgICAgKiBAbmFtZSB3aGVyZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHdoZXJlOiBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIGlmIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLmZpbHRlciwgW2ZpbHRlcl0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBXaGVyZVF1ZXJ5KHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKiogQXBwbGllcyBhIGZpZWxkcyBzZWxlY3Rpb24gdG8gdGhlIGN1cnJlbnQgcXVlcnkuIFRoaXMgYWxsb3dzIHlvdSB0byByZXRyaWV2ZSBvbmx5IGEgc3Vic2V0IG9mIGFsbCBhdmFpbGFibGUgaXRlbSBmaWVsZHMuXHJcbiAgICAgICAgICogQG1lbWJlck9mIFF1ZXJ5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2Qgc2VsZWN0XHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGZpZWxkc0V4cHJlc3Npb24gQSBbZmllbGRzIGV4cHJlc3Npb25dKHslIHNsdWcgcmVzdC1hcGktcXVlcnlpbmctU3Vic2V0LW9mLWZpZWxkcyAlfSkgZGVmaW5pdGlvbi5cclxuICAgICAgICAgKiBAcmV0dXJucyB7UXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2VsZWN0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLnNlbGVjdCwgYXJndW1lbnRzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIFRPRE9cclxuICAgICAgICAvL2V4Y2x1ZGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS5leGNsdWRlLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIC8vfSxcclxuICAgICAgICAvKiogU29ydHMgdGhlIGl0ZW1zIGluIHRoZSBjdXJyZW50IHF1ZXJ5IGluIGFzY2VuZGluZyBvcmRlciBieSB0aGUgc3BlY2lmaWVkIGZpZWxkLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIG9yZGVyXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCBuYW1lIHRvIG9yZGVyIGJ5IGluIGFzY2VuZGluZyBvcmRlci5cclxuICAgICAgICAgKiBAcmV0dXJucyB7UXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgb3JkZXI6IGZ1bmN0aW9uIChmaWVsZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS5vcmRlciwgW2ZpZWxkXSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKiogU29ydHMgdGhlIGl0ZW1zIGluIHRoZSBjdXJyZW50IHF1ZXJ5IGluIGRlc2NlbmRpbmcgb3JkZXIgYnkgdGhlIHNwZWNpZmllZCBmaWVsZC5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBvcmRlckRlc2NcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkIG5hbWUgdG8gb3JkZXIgYnkgaW4gZGVzY2VuZGluZyBvcmRlci5cclxuICAgICAgICAgKiBAcmV0dXJucyB7UXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgb3JkZXJEZXNjOiBmdW5jdGlvbiAoZmllbGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUub3JkZXJfZGVzYywgW2ZpZWxkXSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKiogU2tpcHMgYSBjZXJ0YWluIG51bWJlciBvZiBpdGVtcyBmcm9tIHRoZSBiZWdpbm5pbmcgYmVmb3JlIHJldHVybmluZyB0aGUgcmVzdCBvZiB0aGUgaXRlbXMuIFVzZWQgZm9yIHBhZ2luZy5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBza2lwXHJcbiAgICAgICAgICogQHNlZSBbcXVlcnkudGFrZV17QGxpbmsgcXVlcnkudGFrZX1cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIG51bWJlciBvZiBpdGVtcyB0byBza2lwLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBza2lwOiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUuc2tpcCwgW3ZhbHVlXSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKiogVGFrZXMgYSBzcGVjaWZpZWQgbnVtYmVyIG9mIGl0ZW1zIGZyb20gdGhlIHF1ZXJ5IHJlc3VsdC4gVXNlZCBmb3IgcGFnaW5nLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHRha2VcclxuICAgICAgICAgKiBAc2VlIFtxdWVyeS5za2lwXXtAbGluayBxdWVyeS5za2lwfVxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgbnVtYmVyIG9mIGl0ZW1zIHRvIHRha2UuXHJcbiAgICAgICAgICogQHJldHVybnMge1F1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRha2U6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS50YWtlLCBbdmFsdWVdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKiBTZXRzIGFuIGV4cGFuZCBleHByZXNzaW9uIGZvciB0aGUgY3VycmVudCBxdWVyeS4gVGhpcyBhbGxvd3MgeW91IHRvIHJldHJpZXZlIGNvbXBsZXggZGF0YSBzZXRzIHVzaW5nIGEgc2luZ2xlIHF1ZXJ5IGJhc2VkIG9uIHJlbGF0aW9ucyBiZXR3ZWVuIGRhdGEgdHlwZXMuXHJcbiAgICAgICAgICogQG1lbWJlck9mIFF1ZXJ5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgZXhwYW5kXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGV4cGFuZEV4cHJlc3Npb24gQW4gW2V4cGFuZCBleHByZXNzaW9uXSh7JSBzbHVnIGZlYXR1cmVzLWRhdGEtcmVsYXRpb25zLWRlZmluaW5nLWV4cGFuZCAlfSkgZGVmaW5pdGlvbi5cclxuICAgICAgICAgKiBAcmV0dXJucyB7UXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZXhwYW5kOiBmdW5jdGlvbiAoZXhwYW5kRXhwcmVzc2lvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS5leHBhbmQsIFtleHBhbmRFeHByZXNzaW9uXSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKiogQnVpbGRzIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBkaWZmZXJlbnQgZXhwcmVzc2lvbnMgdGhhdCB3aWxsIGJlIHNlbnQgdG8ge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fS4gSXQgYmFzaWNhbGx5IHRyYW5zbGF0ZXMgYW55IHByZXZpb3VzbHkgc3BlY2lmaWVkIGV4cHJlc3Npb25zIGludG8gc3RhbmRhcmQgcXVlcmllcyB0aGF0IHt7c2l0ZS5ic319IGNhbiB1bmRlcnN0YW5kLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIGJ1aWxkXHJcbiAgICAgICAgICogQHJldHVybnMge3skd2hlcmUsJHNlbGVjdCwkc29ydCwkc2tpcCwkdGFrZSwkZXhwYW5kfX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBidWlsZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5QnVpbGRlcih0aGlzKS5idWlsZCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX3NpbXBsZTogZnVuY3Rpb24gKG9wLCBvcHJzKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChvcHJzKTtcclxuICAgICAgICAgICAgdGhpcy5leHByLmFkZE9wZXJhbmQobmV3IEV4cHJlc3Npb24ob3AsIGFyZ3MpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gUXVlcnk7XHJcbn0oKSk7IiwidmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpO1xyXG52YXIgT3BlcmF0b3JUeXBlID0gY29uc3RhbnRzLk9wZXJhdG9yVHlwZTtcclxudmFyIF8gPSByZXF1aXJlKCcuLi9jb21tb24nKS5fO1xyXG52YXIgR2VvUG9pbnQgPSByZXF1aXJlKCcuLi9HZW9Qb2ludCcpO1xyXG52YXIgRXZlcmxpdmVFcnJvciA9IHJlcXVpcmUoJy4uL0V2ZXJsaXZlRXJyb3InKS5FdmVybGl2ZUVycm9yO1xyXG52YXIgRXhwcmVzc2lvbiA9IHJlcXVpcmUoJy4uL0V4cHJlc3Npb24nKTtcclxudmFyIG1heERpc3RhbmNlQ29uc3RzID0gY29uc3RhbnRzLm1heERpc3RhbmNlQ29uc3RzO1xyXG52YXIgcmFkaXVzQ29uc3RzID0gY29uc3RhbnRzLnJhZGl1c0NvbnN0cztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFF1ZXJ5QnVpbGRlcihxdWVyeSkge1xyXG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcclxuICAgICAgICB0aGlzLmV4cHIgPSBxdWVyeS5leHByO1xyXG4gICAgfVxyXG5cclxuICAgIFF1ZXJ5QnVpbGRlci5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgLy8gVE9ETyBtZXJnZSB0aGUgdHdvIG9iamVjdHMgYmVmb3JlIHJldHVybmluZyB0aGVtXHJcbiAgICAgICAgYnVpbGQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeTtcclxuICAgICAgICAgICAgaWYgKHF1ZXJ5LmZpbHRlciB8fCBxdWVyeS5maWVsZHMgfHwgcXVlcnkuc29ydCB8fCBxdWVyeS50b3NraXAgfHwgcXVlcnkudG90YWtlIHx8IHF1ZXJ5LmV4cGFuZEV4cHJlc3Npb24pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgJHdoZXJlOiBxdWVyeS5maWx0ZXIgfHwgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAkc2VsZWN0OiBxdWVyeS5maWVsZHMgfHwgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAkc29ydDogcXVlcnkuc29ydCB8fCBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICRza2lwOiBxdWVyeS50b3NraXAgfHwgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAkdGFrZTogcXVlcnkudG90YWtlIHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgJGV4cGFuZDogcXVlcnkuZXhwYW5kRXhwcmVzc2lvbiB8fCBudWxsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAkd2hlcmU6IHRoaXMuX2J1aWxkV2hlcmUoKSxcclxuICAgICAgICAgICAgICAgICRzZWxlY3Q6IHRoaXMuX2J1aWxkU2VsZWN0KCksXHJcbiAgICAgICAgICAgICAgICAkc29ydDogdGhpcy5fYnVpbGRTb3J0KCksXHJcbiAgICAgICAgICAgICAgICAkc2tpcDogdGhpcy5fZ2V0U2tpcCgpLFxyXG4gICAgICAgICAgICAgICAgJHRha2U6IHRoaXMuX2dldFRha2UoKSxcclxuICAgICAgICAgICAgICAgICRleHBhbmQ6IHRoaXMuX2dldEV4cGFuZCgpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0U2tpcDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgc2tpcEV4cHJlc3Npb24gPSBfLmZpbmQodGhpcy5leHByLm9wZXJhbmRzLCBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBsaXN0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUub3BlcmF0b3IgPT09IE9wZXJhdG9yVHlwZS5za2lwO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHNraXBFeHByZXNzaW9uID8gc2tpcEV4cHJlc3Npb24ub3BlcmFuZHNbMF0gOiBudWxsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2dldFRha2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHRha2VFeHByZXNzaW9uID0gXy5maW5kKHRoaXMuZXhwci5vcGVyYW5kcywgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgbGlzdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm9wZXJhdG9yID09PSBPcGVyYXRvclR5cGUudGFrZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0YWtlRXhwcmVzc2lvbiA/IHRha2VFeHByZXNzaW9uLm9wZXJhbmRzWzBdIDogbnVsbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9nZXRFeHBhbmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGV4cGFuZEV4cHJlc3Npb24gPSBfLmNoYWluKHRoaXMuZXhwci5vcGVyYW5kcylcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm9wZXJhdG9yID09PSBPcGVyYXRvclR5cGUuZXhwYW5kO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgZXhwcmVzc2lvbikgeyAvL2V4cHJlc3Npb24gY29udGFpbnMgb3BlcmFuZHMgYW5kIGhhcyBvcGVyYXRvciB0eXBlIGV4cGFuZFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLmV4dGVuZChyZXN1bHQsIGV4cHJlc3Npb24ub3BlcmFuZHNbMF0pO1xyXG4gICAgICAgICAgICAgICAgfSwge30pXHJcbiAgICAgICAgICAgICAgICAudmFsdWUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIF8uaXNFbXB0eShleHBhbmRFeHByZXNzaW9uKSA/IG51bGwgOiBleHBhbmRFeHByZXNzaW9uO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2J1aWxkU2VsZWN0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxlY3RFeHByZXNzaW9uID0gXy5maW5kKHRoaXMuZXhwci5vcGVyYW5kcywgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgbGlzdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm9wZXJhdG9yID09PSBPcGVyYXRvclR5cGUuc2VsZWN0O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgICAgICBpZiAoc2VsZWN0RXhwcmVzc2lvbikge1xyXG4gICAgICAgICAgICAgICAgXy5yZWR1Y2Uoc2VsZWN0RXhwcmVzc2lvbi5vcGVyYW5kcywgZnVuY3Rpb24gKG1lbW8sIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVtb1t2YWx1ZV0gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZW1vO1xyXG4gICAgICAgICAgICAgICAgfSwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2J1aWxkU29ydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgc29ydEV4cHJlc3Npb25zID0gXy5maWx0ZXIodGhpcy5leHByLm9wZXJhbmRzLCBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBsaXN0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUub3BlcmF0b3IgPT09IE9wZXJhdG9yVHlwZS5vcmRlciB8fCB2YWx1ZS5vcGVyYXRvciA9PT0gT3BlcmF0b3JUeXBlLm9yZGVyX2Rlc2M7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICAgICAgICAgIGlmIChzb3J0RXhwcmVzc2lvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgXy5yZWR1Y2Uoc29ydEV4cHJlc3Npb25zLCBmdW5jdGlvbiAobWVtbywgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBtZW1vW3ZhbHVlLm9wZXJhbmRzWzBdXSA9IHZhbHVlLm9wZXJhdG9yID09PSBPcGVyYXRvclR5cGUub3JkZXIgPyAxIDogLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lbW87XHJcbiAgICAgICAgICAgICAgICB9LCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfYnVpbGRXaGVyZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgd2hlcmVFeHByZXNzaW9uID0gXy5maW5kKHRoaXMuZXhwci5vcGVyYW5kcywgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgbGlzdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm9wZXJhdG9yID09PSBPcGVyYXRvclR5cGUud2hlcmU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAod2hlcmVFeHByZXNzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYnVpbGQobmV3IEV4cHJlc3Npb24oT3BlcmF0b3JUeXBlLmFuZCwgd2hlcmVFeHByZXNzaW9uLm9wZXJhbmRzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmlsdGVyRXhwcmVzc2lvbiA9IF8uZmluZCh0aGlzLmV4cHIub3BlcmFuZHMsIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUub3BlcmF0b3IgPT09IE9wZXJhdG9yVHlwZS5maWx0ZXI7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJFeHByZXNzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlckV4cHJlc3Npb24ub3BlcmFuZHNbMF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2J1aWxkOiBmdW5jdGlvbiAoZXhwcikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNTaW1wbGUoZXhwcikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoZXhwcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5faXNSZWdleChleHByKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlZ2V4KGV4cHIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzR2VvKGV4cHIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2VvKGV4cHIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzQW5kKGV4cHIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYW5kKGV4cHIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzT3IoZXhwcikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcihleHByKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9pc05vdChleHByKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vdChleHByKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2lzU2ltcGxlOiBmdW5jdGlvbiAoZXhwcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZXhwci5vcGVyYXRvciA+PSBPcGVyYXRvclR5cGUuZXF1YWwgJiYgZXhwci5vcGVyYXRvciA8PSBPcGVyYXRvclR5cGUuc2l6ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9zaW1wbGU6IGZ1bmN0aW9uIChleHByKSB7XHJcbiAgICAgICAgICAgIHZhciB0ZXJtID0ge30sIGZpZWxkVGVybSA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgb3BlcmFuZHMgPSBleHByLm9wZXJhbmRzO1xyXG4gICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSB0aGlzLl90cmFuc2xhdGVvcGVyYXRvcihleHByLm9wZXJhdG9yKTtcclxuICAgICAgICAgICAgaWYgKG9wZXJhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXJtW29wZXJhdG9yXSA9IG9wZXJhbmRzWzFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGVybSA9IG9wZXJhbmRzWzFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpZWxkVGVybVtvcGVyYW5kc1swXV0gPSB0ZXJtO1xyXG4gICAgICAgICAgICByZXR1cm4gZmllbGRUZXJtO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2lzUmVnZXg6IGZ1bmN0aW9uIChleHByKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBleHByLm9wZXJhdG9yID49IE9wZXJhdG9yVHlwZS5yZWdleCAmJiBleHByLm9wZXJhdG9yIDw9IE9wZXJhdG9yVHlwZS5lbmRzV2l0aDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9yZWdleDogZnVuY3Rpb24gKGV4cHIpIHtcclxuICAgICAgICAgICAgdmFyIGZpZWxkVGVybSA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgcmVnZXggPSB0aGlzLl9nZXRSZWdleChleHByKTtcclxuICAgICAgICAgICAgdmFyIHJlZ2V4VmFsdWUgPSB0aGlzLl9nZXRSZWdleFZhbHVlKHJlZ2V4KTtcclxuICAgICAgICAgICAgdmFyIG9wZXJhbmRzID0gZXhwci5vcGVyYW5kcztcclxuICAgICAgICAgICAgZmllbGRUZXJtW29wZXJhbmRzWzBdXSA9IHJlZ2V4VmFsdWU7XHJcbiAgICAgICAgICAgIHJldHVybiBmaWVsZFRlcm07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0UmVnZXg6IGZ1bmN0aW9uIChleHByKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXR0ZXJuID0gZXhwci5vcGVyYW5kc1sxXTtcclxuICAgICAgICAgICAgdmFyIGZsYWdzID0gZXhwci5vcGVyYW5kc1syXSA/IGV4cHIub3BlcmFuZHNbMl0gOiAnJztcclxuICAgICAgICAgICAgc3dpdGNoIChleHByLm9wZXJhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE9wZXJhdG9yVHlwZS5yZWdleDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCA/IHBhdHRlcm4gOiBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgT3BlcmF0b3JUeXBlLnN0YXJ0c1dpdGg6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeXCIgKyBwYXR0ZXJuLCBmbGFncyk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE9wZXJhdG9yVHlwZS5lbmRzV2l0aDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuICsgXCIkXCIsIGZsYWdzKTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1Vua25vd24gb3BlcmF0b3IgdHlwZS4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2dldFJlZ2V4VmFsdWU6IGZ1bmN0aW9uIChyZWdleCkge1xyXG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9ICcnO1xyXG4gICAgICAgICAgICBpZiAocmVnZXguZ2xvYmFsKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zICs9ICdnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVnZXgubXVsdGlsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zICs9ICdtJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVnZXguaWdub3JlQ2FzZSkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucyArPSAnaSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHskcmVnZXg6IHJlZ2V4LnNvdXJjZSwgJG9wdGlvbnM6IG9wdGlvbnN9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2lzR2VvOiBmdW5jdGlvbiAoZXhwcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZXhwci5vcGVyYXRvciA+PSBPcGVyYXRvclR5cGUubmVhclNocGVyZSAmJiBleHByLm9wZXJhdG9yIDw9IE9wZXJhdG9yVHlwZS53aXRoaW5TaHBlcmU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2VvOiBmdW5jdGlvbiAoZXhwcikge1xyXG4gICAgICAgICAgICB2YXIgZmllbGRUZXJtID0ge307XHJcbiAgICAgICAgICAgIHZhciBvcGVyYW5kcyA9IGV4cHIub3BlcmFuZHM7XHJcbiAgICAgICAgICAgIGZpZWxkVGVybVtvcGVyYW5kc1swXV0gPSB0aGlzLl9nZXRHZW9UZXJtKGV4cHIpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmllbGRUZXJtO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2dldEdlb1Rlcm06IGZ1bmN0aW9uIChleHByKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZXhwci5vcGVyYXRvcikge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBPcGVyYXRvclR5cGUubmVhclNocGVyZTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TmVhclNwaGVyZVRlcm0oZXhwcik7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE9wZXJhdG9yVHlwZS53aXRoaW5Cb3g6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFdpdGhpbkJveChleHByKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgT3BlcmF0b3JUeXBlLndpdGhpblBvbHlnb246XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFdpdGhpblBvbHlnb24oZXhwcik7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE9wZXJhdG9yVHlwZS53aXRoaW5TaHBlcmU6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFdpdGhpbkNlbnRlclNwaGVyZShleHByKTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1Vua25vd24gb3BlcmF0b3IgdHlwZS4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2dldE5lYXJTcGhlcmVUZXJtOiBmdW5jdGlvbiAoZXhwcikge1xyXG4gICAgICAgICAgICB2YXIgb3BlcmFuZHMgPSBleHByLm9wZXJhbmRzO1xyXG4gICAgICAgICAgICB2YXIgY2VudGVyID0gdGhpcy5fZ2V0R2VvUG9pbnQob3BlcmFuZHNbMV0pO1xyXG4gICAgICAgICAgICB2YXIgbWF4RGlzdGFuY2UgPSBvcGVyYW5kc1syXTtcclxuICAgICAgICAgICAgdmFyIG1ldHJpY3MgPSBvcGVyYW5kc1szXTtcclxuICAgICAgICAgICAgdmFyIG1heERpc3RhbmNlQ29uc3Q7XHJcbiAgICAgICAgICAgIHZhciB0ZXJtID0ge1xyXG4gICAgICAgICAgICAgICAgJyRuZWFyU3BoZXJlJzogY2VudGVyXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWF4RGlzdGFuY2UgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBtYXhEaXN0YW5jZUNvbnN0ID0gbWF4RGlzdGFuY2VDb25zdHNbbWV0cmljc10gfHwgbWF4RGlzdGFuY2VDb25zdHMucmFkaWFucztcclxuICAgICAgICAgICAgICAgIHRlcm1bbWF4RGlzdGFuY2VDb25zdF0gPSBtYXhEaXN0YW5jZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGVybTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9nZXRXaXRoaW5Cb3g6IGZ1bmN0aW9uIChleHByKSB7XHJcbiAgICAgICAgICAgIHZhciBvcGVyYW5kcyA9IGV4cHIub3BlcmFuZHM7XHJcbiAgICAgICAgICAgIHZhciBib3R0b21MZWZ0ID0gdGhpcy5fZ2V0R2VvUG9pbnQob3BlcmFuZHNbMV0pO1xyXG4gICAgICAgICAgICB2YXIgdXBwZXJSaWdodCA9IHRoaXMuX2dldEdlb1BvaW50KG9wZXJhbmRzWzJdKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICckd2l0aGluJzoge1xyXG4gICAgICAgICAgICAgICAgICAgICckYm94JzogW2JvdHRvbUxlZnQsIHVwcGVyUmlnaHRdXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfZ2V0V2l0aGluUG9seWdvbjogZnVuY3Rpb24gKGV4cHIpIHtcclxuICAgICAgICAgICAgdmFyIG9wZXJhbmRzID0gZXhwci5vcGVyYW5kcztcclxuICAgICAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuX2dldEdlb1BvaW50cyhvcGVyYW5kc1sxXSk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAnJHdpdGhpbic6IHtcclxuICAgICAgICAgICAgICAgICAgICAnJHBvbHlnb24nOiBwb2ludHNcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9nZXRXaXRoaW5DZW50ZXJTcGhlcmU6IGZ1bmN0aW9uIChleHByKSB7XHJcbiAgICAgICAgICAgIHZhciBvcGVyYW5kcyA9IGV4cHIub3BlcmFuZHM7XHJcbiAgICAgICAgICAgIHZhciBjZW50ZXIgPSB0aGlzLl9nZXRHZW9Qb2ludChvcGVyYW5kc1sxXSk7XHJcbiAgICAgICAgICAgIHZhciByYWRpdXMgPSBvcGVyYW5kc1syXTtcclxuICAgICAgICAgICAgdmFyIG1ldHJpY3MgPSBvcGVyYW5kc1szXTtcclxuICAgICAgICAgICAgdmFyIHJhZGl1c0NvbnN0ID0gcmFkaXVzQ29uc3RzW21ldHJpY3NdIHx8IHJhZGl1c0NvbnN0cy5yYWRpYW5zO1xyXG4gICAgICAgICAgICB2YXIgc3BoZXJlSW5mbyA9IHtcclxuICAgICAgICAgICAgICAgICdjZW50ZXInOiBjZW50ZXJcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgc3BoZXJlSW5mb1tyYWRpdXNDb25zdF0gPSByYWRpdXM7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAnJHdpdGhpbic6IHtcclxuICAgICAgICAgICAgICAgICAgICAnJGNlbnRlclNwaGVyZSc6IHNwaGVyZUluZm9cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9nZXRHZW9Qb2ludDogZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgICAgICAgICAgIGlmIChfLmlzQXJyYXkocG9pbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEdlb1BvaW50KHBvaW50WzBdLCBwb2ludFsxXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHBvaW50O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2dldEdlb1BvaW50czogZnVuY3Rpb24gKHBvaW50cykge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiBfLm1hcChwb2ludHMsIGZ1bmN0aW9uIChwb2ludCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2dldEdlb1BvaW50KHBvaW50KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfaXNBbmQ6IGZ1bmN0aW9uIChleHByKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBleHByLm9wZXJhdG9yID09PSBPcGVyYXRvclR5cGUuYW5kO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2FuZDogZnVuY3Rpb24gKGV4cHIpIHtcclxuICAgICAgICAgICAgdmFyIGksIGwsIHRlcm0sIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgb3BlcmFuZHMgPSBleHByLm9wZXJhbmRzO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gb3BlcmFuZHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXJtID0gdGhpcy5fYnVpbGQob3BlcmFuZHNbaV0pO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fYW5kQXBwZW5kKHJlc3VsdCwgdGVybSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9hbmRBcHBlbmQ6IGZ1bmN0aW9uIChhbmRPYmosIG5ld09iaikge1xyXG4gICAgICAgICAgICB2YXIgaSwgbCwga2V5LCB2YWx1ZSwgbmV3VmFsdWU7XHJcbiAgICAgICAgICAgIHZhciBrZXlzID0gXy5rZXlzKG5ld09iaik7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAga2V5ID0ga2V5c1tpXTtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gYW5kT2JqW2tleV07XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGFuZE9ialtrZXldID0gbmV3T2JqW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IG5ld09ialtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBuZXdWYWx1ZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfLmV4dGVuZCh2YWx1ZSwgbmV3VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGFuZE9ialtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGFuZE9iajtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9pc09yOiBmdW5jdGlvbiAoZXhwcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZXhwci5vcGVyYXRvciA9PT0gT3BlcmF0b3JUeXBlLm9yO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX29yOiBmdW5jdGlvbiAoZXhwcikge1xyXG4gICAgICAgICAgICB2YXIgaSwgbCwgdGVybSwgcmVzdWx0ID0gW107XHJcbiAgICAgICAgICAgIHZhciBvcGVyYW5kcyA9IGV4cHIub3BlcmFuZHM7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBvcGVyYW5kcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRlcm0gPSB0aGlzLl9idWlsZChvcGVyYW5kc1tpXSk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0ZXJtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4geyRvcjogcmVzdWx0fTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9pc05vdDogZnVuY3Rpb24gKGV4cHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV4cHIub3BlcmF0b3IgPT09IE9wZXJhdG9yVHlwZS5ub3Q7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfbm90OiBmdW5jdGlvbiAoZXhwcikge1xyXG4gICAgICAgICAgICByZXR1cm4geyRub3Q6IHRoaXMuX2J1aWxkKGV4cHIub3BlcmFuZHNbMF0pfTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF90cmFuc2xhdGVvcGVyYXRvcjogZnVuY3Rpb24gKG9wZXJhdG9yKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgT3BlcmF0b3JUeXBlLmVxdWFsOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBPcGVyYXRvclR5cGUubm90X2VxdWFsOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJG5lJztcclxuICAgICAgICAgICAgICAgIGNhc2UgT3BlcmF0b3JUeXBlLmd0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJGd0JztcclxuICAgICAgICAgICAgICAgIGNhc2UgT3BlcmF0b3JUeXBlLmx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJGx0JztcclxuICAgICAgICAgICAgICAgIGNhc2UgT3BlcmF0b3JUeXBlLmd0ZTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyRndGUnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBPcGVyYXRvclR5cGUubHRlOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJGx0ZSc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE9wZXJhdG9yVHlwZS5pc2luOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJGluJztcclxuICAgICAgICAgICAgICAgIGNhc2UgT3BlcmF0b3JUeXBlLm5vdGluOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJG5pbic7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE9wZXJhdG9yVHlwZS5hbGw6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICckYWxsJztcclxuICAgICAgICAgICAgICAgIGNhc2UgT3BlcmF0b3JUeXBlLnNpemU6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICckc2l6ZSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgbmV3IEV2ZXJsaXZlRXJyb3IoJ1Vua25vd24gb3BlcmF0b3IgdHlwZS4nKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBRdWVyeUJ1aWxkZXI7XHJcbn0oKSk7IiwidmFyIERhdGFRdWVyeSA9IHJlcXVpcmUoJy4vRGF0YVF1ZXJ5Jyk7XHJcbnZhciBSZXF1ZXN0ID0gcmVxdWlyZSgnLi4vUmVxdWVzdCcpO1xyXG52YXIgXyA9IHJlcXVpcmUoJy4uL2NvbW1vbicpLl87XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgUmVxdWVzdE9wdGlvbnNCdWlsZGVyID0ge307XHJcblxyXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZEVuZHBvaW50VXJsID0gZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xyXG4gICAgICAgIHZhciBlbmRwb2ludCA9IGRhdGFRdWVyeS5jb2xsZWN0aW9uTmFtZTtcclxuICAgICAgICBpZiAoZGF0YVF1ZXJ5LmFkZGl0aW9uYWxPcHRpb25zICYmIGRhdGFRdWVyeS5hZGRpdGlvbmFsT3B0aW9ucy5pZCkge1xyXG4gICAgICAgICAgICBlbmRwb2ludCArPSAnLycgKyBkYXRhUXVlcnkuYWRkaXRpb25hbE9wdGlvbnMuaWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZW5kcG9pbnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGRCYXNlT2JqZWN0ID0gZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xyXG4gICAgICAgIHZhciBkZWZhdWx0T2JqZWN0ID0ge1xyXG4gICAgICAgICAgICBlbmRwb2ludDogUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZEVuZHBvaW50VXJsKGRhdGFRdWVyeSksXHJcbiAgICAgICAgICAgIGZpbHRlcjogZGF0YVF1ZXJ5LmZpbHRlcixcclxuICAgICAgICAgICAgc3VjY2VzczogZGF0YVF1ZXJ5Lm9uU3VjY2VzcyxcclxuICAgICAgICAgICAgZXJyb3I6IGRhdGFRdWVyeS5vbkVycm9yLFxyXG4gICAgICAgICAgICBkYXRhOiBkYXRhUXVlcnkuZGF0YSxcclxuICAgICAgICAgICAgaGVhZGVyczogZGF0YVF1ZXJ5LmhlYWRlcnNcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAoZGF0YVF1ZXJ5LnBhcnNlKSB7XHJcbiAgICAgICAgICAgIGRlZmF1bHRPYmplY3QucGFyc2UgPSBkYXRhUXVlcnkucGFyc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZGVmYXVsdE9iamVjdDtcclxuICAgIH07XHJcblxyXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZCA9IGZ1bmN0aW9uIChkYXRhUXVlcnksIGFkZGl0aW9uYWxPcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIF8uZXh0ZW5kKFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGRCYXNlT2JqZWN0KGRhdGFRdWVyeSksIGFkZGl0aW9uYWxPcHRpb25zKTtcclxuICAgIH07XHJcblxyXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyW0RhdGFRdWVyeS5vcGVyYXRpb25zLnJlYWRdID0gZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xyXG4gICAgICAgIHJldHVybiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkKGRhdGFRdWVyeSwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlcltEYXRhUXVlcnkub3BlcmF0aW9ucy5yZWFkQnlJZF0gPSBmdW5jdGlvbiAoZGF0YVF1ZXJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGQoZGF0YVF1ZXJ5LCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCdcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyW0RhdGFRdWVyeS5vcGVyYXRpb25zLmNvdW50XSA9IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcclxuICAgICAgICByZXR1cm4gUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZChkYXRhUXVlcnksIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgICAgICAgZW5kcG9pbnQ6IGRhdGFRdWVyeS5jb2xsZWN0aW9uTmFtZSArICcvX2NvdW50J1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBSZXF1ZXN0T3B0aW9uc0J1aWxkZXJbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuY3JlYXRlXSA9IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcclxuICAgICAgICByZXR1cm4gUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZChkYXRhUXVlcnksIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCdcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyW0RhdGFRdWVyeS5vcGVyYXRpb25zLnJhd1VwZGF0ZV0gPSBmdW5jdGlvbiAoZGF0YVF1ZXJ5KSB7XHJcbiAgICAgICAgdmFyIGVuZHBvaW50ID0gZGF0YVF1ZXJ5LmNvbGxlY3Rpb25OYW1lO1xyXG4gICAgICAgIHZhciBmaWx0ZXIgPSBkYXRhUXVlcnkuZmlsdGVyO1xyXG4gICAgICAgIHZhciBvZmlsdGVyID0gbnVsbDsgLy8gcmVxdWVzdCBvcHRpb25zIGZpbHRlclxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgZW5kcG9pbnQgKz0gJy8nICsgZmlsdGVyOyAvLyBzZW5kIHRoZSBmaWx0ZXIgdGhyb3VnaCBxdWVyeSBzdHJpbmdcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIG9maWx0ZXIgPSBmaWx0ZXI7IC8vIHNlbmQgdGhlIGZpbHRlciBhcyBmaWx0ZXIgaGVhZGVyc1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGQoZGF0YVF1ZXJ5LCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXHJcbiAgICAgICAgICAgIGVuZHBvaW50OiBlbmRwb2ludCxcclxuICAgICAgICAgICAgZmlsdGVyOiBvZmlsdGVyXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlcltEYXRhUXVlcnkub3BlcmF0aW9ucy51cGRhdGVdID0gZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xyXG4gICAgICAgIHJldHVybiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkKGRhdGFRdWVyeSwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQVVQnXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlcltEYXRhUXVlcnkub3BlcmF0aW9ucy5yZW1vdmVdID0gZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xyXG4gICAgICAgIHJldHVybiBfLmV4dGVuZChSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkQmFzZU9iamVjdChkYXRhUXVlcnkpLCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURSdcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyW0RhdGFRdWVyeS5vcGVyYXRpb25zLnJlbW92ZVNpbmdsZV0gPSBSZXF1ZXN0T3B0aW9uc0J1aWxkZXJbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVtb3ZlXTtcclxuXHJcbiAgICBSZXF1ZXN0T3B0aW9uc0J1aWxkZXJbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuc2V0QWNsXSA9IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcclxuICAgICAgICB2YXIgZW5kcG9pbnQgPSBkYXRhUXVlcnkuY29sbGVjdGlvbk5hbWU7XHJcbiAgICAgICAgdmFyIGZpbHRlciA9IGRhdGFRdWVyeS5maWx0ZXI7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgZmlsdGVyID09PSAnc3RyaW5nJykgeyAvLyBpZiBmaWx0ZXIgaXMgc3RyaW5nIHRoYW4gd2lsbCB1cGRhdGUgYSBzaW5nbGUgaXRlbSB1c2luZyB0aGUgZmlsdGVyIGFzIGFuIGlkZW50aWZpZXJcclxuICAgICAgICAgICAgZW5kcG9pbnQgKz0gJy8nICsgZmlsdGVyO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ29iamVjdCcpIHsgLy8gZWxzZSBpZiBpdCBpcyBhbiBvYmplY3QgdGhhbiB3ZSB3aWxsIHVzZSBpdCdzIGlkIHByb3BlcnR5XHJcbiAgICAgICAgICAgIGVuZHBvaW50ICs9ICcvJyArIGZpbHRlcltpZEZpZWxkXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZW5kcG9pbnQgKz0gJy9fYWNsJztcclxuICAgICAgICB2YXIgbWV0aG9kLCBkYXRhO1xyXG4gICAgICAgIGlmIChkYXRhUXVlcnkuYWRkaXRpb25hbE9wdGlvbnMuYWNsID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIG1ldGhvZCA9ICdERUxFVEUnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG1ldGhvZCA9ICdQVVQnO1xyXG4gICAgICAgICAgICBkYXRhID0gZGF0YVF1ZXJ5LmFkZGl0aW9uYWxPcHRpb25zLmFjbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkKGRhdGFRdWVyeSwge1xyXG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcclxuICAgICAgICAgICAgZW5kcG9pbnQ6IGVuZHBvaW50LFxyXG4gICAgICAgICAgICBkYXRhOiBkYXRhXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlcltEYXRhUXVlcnkub3BlcmF0aW9ucy5zZXRPd25lcl0gPSBmdW5jdGlvbiAoZGF0YVF1ZXJ5KSB7XHJcbiAgICAgICAgdmFyIGVuZHBvaW50ID0gZGF0YVF1ZXJ5LmNvbGxlY3Rpb25OYW1lO1xyXG4gICAgICAgIHZhciBmaWx0ZXIgPSBkYXRhUXVlcnkuZmlsdGVyO1xyXG4gICAgICAgIGlmICh0eXBlb2YgZmlsdGVyID09PSAnc3RyaW5nJykgeyAvLyBpZiBmaWx0ZXIgaXMgc3RyaW5nIHRoYW4gd2lsbCB1cGRhdGUgYSBzaW5nbGUgaXRlbSB1c2luZyB0aGUgZmlsdGVyIGFzIGFuIGlkZW50aWZpZXJcclxuICAgICAgICAgICAgZW5kcG9pbnQgKz0gJy8nICsgZmlsdGVyO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ29iamVjdCcpIHsgLy8gZWxzZSBpZiBpdCBpcyBhbiBvYmplY3QgdGhhbiB3ZSB3aWxsIHVzZSBpdCdzIGlkIHByb3BlcnR5XHJcbiAgICAgICAgICAgIGVuZHBvaW50ICs9ICcvJyArIGZpbHRlcltpZEZpZWxkXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZW5kcG9pbnQgKz0gJy9fb3duZXInO1xyXG5cclxuICAgICAgICByZXR1cm4gUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZChkYXRhUXVlcnksIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcclxuICAgICAgICAgICAgZW5kcG9pbnQ6IGVuZHBvaW50XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlcltEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyTG9naW5dID0gZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xyXG4gICAgICAgIHJldHVybiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkKGRhdGFRdWVyeSwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgZW5kcG9pbnQ6ICdvYXV0aC90b2tlbicsXHJcbiAgICAgICAgICAgIGF1dGhIZWFkZXJzOiBmYWxzZSxcclxuICAgICAgICAgICAgcGFyc2U6IFJlcXVlc3QucGFyc2Vycy5zaW5nbGVcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyW0RhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJMb2dvdXRdID0gZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xyXG4gICAgICAgIHJldHVybiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkKGRhdGFRdWVyeSwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxyXG4gICAgICAgICAgICBlbmRwb2ludDogJ29hdXRoL2xvZ291dCdcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgUmVxdWVzdE9wdGlvbnNCdWlsZGVyW0RhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJDaGFuZ2VQYXNzd29yZF0gPSBmdW5jdGlvbiAoZGF0YVF1ZXJ5KSB7XHJcbiAgICAgICAgdmFyIGtlZXBUb2tlbnMgPSBkYXRhUXVlcnkuYWRkaXRpb25hbE9wdGlvbnMua2VlcFRva2VucztcclxuICAgICAgICB2YXIgZW5kcG9pbnQgPSAnVXNlcnMvY2hhbmdlcGFzc3dvcmQnO1xyXG4gICAgICAgIGlmIChrZWVwVG9rZW5zKSB7XHJcbiAgICAgICAgICAgIGVuZHBvaW50ICs9ICc/a2VlcFRva2Vucz10cnVlJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkKGRhdGFRdWVyeSwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgZW5kcG9pbnQ6IGVuZHBvaW50LFxyXG4gICAgICAgICAgICBhdXRoSGVhZGVyczogZmFsc2UsXHJcbiAgICAgICAgICAgIHBhcnNlOiBSZXF1ZXN0LnBhcnNlcnMuc2luZ2xlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlcltEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyTG9naW5XaXRoUHJvdmlkZXJdID0gZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xyXG4gICAgICAgIHJldHVybiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkKGRhdGFRdWVyeSwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgYXV0aEhlYWRlcnM6IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlcltEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyTGlua1dpdGhQcm92aWRlcl0gPSBmdW5jdGlvbiAoZGF0YVF1ZXJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGQoZGF0YVF1ZXJ5LCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICBlbmRwb2ludDogUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZEVuZHBvaW50VXJsKGRhdGFRdWVyeSkgKyAnL2xpbmsnXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIFJlcXVlc3RPcHRpb25zQnVpbGRlcltEYXRhUXVlcnkub3BlcmF0aW9ucy51c2VyVW5saW5rRnJvbVByb3ZpZGVyXSA9IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcclxuICAgICAgICByZXR1cm4gUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZChkYXRhUXVlcnksIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgIGVuZHBvaW50OiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkRW5kcG9pbnRVcmwoZGF0YVF1ZXJ5KSArICcvdW5saW5rJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBSZXF1ZXN0T3B0aW9uc0J1aWxkZXJbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuZmlsZXNVcGRhdGVDb250ZW50XSA9IGZ1bmN0aW9uIChkYXRhUXVlcnkpIHtcclxuICAgICAgICByZXR1cm4gUmVxdWVzdE9wdGlvbnNCdWlsZGVyLl9idWlsZChkYXRhUXVlcnksIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcclxuICAgICAgICAgICAgZW5kcG9pbnQ6IFJlcXVlc3RPcHRpb25zQnVpbGRlci5fYnVpbGRFbmRwb2ludFVybChkYXRhUXVlcnkpICsgJy9Db250ZW50J1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBSZXF1ZXN0T3B0aW9uc0J1aWxkZXJbRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuZmlsZXNHZXREb3dubG9hZFVybEJ5SWRdID0gZnVuY3Rpb24gKGRhdGFRdWVyeSkge1xyXG4gICAgICAgIHJldHVybiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXIuX2J1aWxkKGRhdGFRdWVyeSwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBSZXF1ZXN0T3B0aW9uc0J1aWxkZXI7XHJcbn0oKSk7IiwidmFyIEV4cHJlc3Npb24gPSByZXF1aXJlKCcuLi9FeHByZXNzaW9uJyk7XHJcbnZhciBPcGVyYXRvclR5cGUgPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKS5PcGVyYXRvclR5cGU7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEBjbGFzc2Rlc2MgQSBmbHVlbnQgQVBJIG9wZXJhdGlvbiBmb3IgY3JlYXRpbmcgYSBmaWx0ZXIgZm9yIGEgcXVlcnkgYnkgY2hhaW5pbmcgZGlmZmVyZW50IHJ1bGVzLlxyXG4gICAgICogQGNsYXNzIFdoZXJlUXVlcnlcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEBib3Jyb3dzIFdoZXJlUXVlcnkjZXEgYXMgV2hlcmVRdWVyeSNlcXVhbFxyXG4gICAgICogQGJvcnJvd3MgV2hlcmVRdWVyeSNuZSBhcyBXaGVyZVF1ZXJ5I25vdEVxdWFsXHJcbiAgICAgKiBAYm9ycm93cyBXaGVyZVF1ZXJ5I2d0IGFzIFdoZXJlUXVlcnkjZ3JlYXRlclRoYW5cclxuICAgICAqIEBib3Jyb3dzIFdoZXJlUXVlcnkjZ3RlIGFzIFdoZXJlUXVlcnkjZ3JlYXRlclRoYW5FcXVhbFxyXG4gICAgICogQGJvcnJvd3MgV2hlcmVRdWVyeSNsdCBhcyBXaGVyZVF1ZXJ5I2xlc3NUaGFuXHJcbiAgICAgKiBAYm9ycm93cyBXaGVyZVF1ZXJ5I2x0ZSBhcyBXaGVyZVF1ZXJ5I2xlc3NUaGFuRXF1YWxcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gV2hlcmVRdWVyeShwYXJlbnRRdWVyeSwgZXhwck9wLCBzaW5nbGVPcGVyYW5kKSB7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnRRdWVyeTtcclxuICAgICAgICB0aGlzLnNpbmdsZSA9IHNpbmdsZU9wZXJhbmQ7XHJcbiAgICAgICAgdGhpcy5leHByID0gbmV3IEV4cHJlc3Npb24oZXhwck9wIHx8IE9wZXJhdG9yVHlwZS53aGVyZSk7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQuZXhwci5hZGRPcGVyYW5kKHRoaXMuZXhwcik7XHJcbiAgICB9XHJcblxyXG4gICAgV2hlcmVRdWVyeS5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhbiBgYW5kYCBjbGF1c2UgdG8gdGhlIGN1cnJlbnQgY29uZGl0aW9uIGFuZCByZXR1cm5zIGl0IGZvciBmdXJ0aGVyIGNoYWluaW5nLlxyXG4gICAgICAgICAqIEBtZXRob2QgYW5kXHJcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge1doZXJlUXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2hlcmVRdWVyeSh0aGlzLCBPcGVyYXRvclR5cGUuYW5kKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYW4gYG9yYCBjbGF1c2UgdG8gdGhlIGN1cnJlbnQgY29uZGl0aW9uIGFuZCByZXR1cm5zIGl0IGZvciBmdXJ0aGVyIGNoYWluaW5nLlxyXG4gICAgICAgICAqIEBtZXRob2Qgb3JcclxuICAgICAgICAgKiBAbWVtYmVyT2YgV2hlcmVRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7V2hlcmVRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBvcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdoZXJlUXVlcnkodGhpcywgT3BlcmF0b3JUeXBlLm9yKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBgbm90YCBjbGF1c2UgdG8gdGhlIGN1cnJlbnQgY29uZGl0aW9uIGFuZCByZXR1cm5zIGl0IGZvciBmdXJ0aGVyIGNoYWluaW5nLlxyXG4gICAgICAgICAqIEBtZXRob2Qgbm90XHJcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge1doZXJlUXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbm90OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2hlcmVRdWVyeSh0aGlzLCBPcGVyYXRvclR5cGUubm90LCB0cnVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9zaW1wbGU6IGZ1bmN0aW9uIChvcGVyYXRvcikge1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuICAgICAgICAgICAgdGhpcy5leHByLmFkZE9wZXJhbmQobmV3IEV4cHJlc3Npb24ob3BlcmF0b3IsIGFyZ3MpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RvbmUoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBjb25kaXRpb24gdGhhdCBhIGZpZWxkIG11c3QgYmUgZXF1YWwgdG8gYSBzcGVjaWZpYyB2YWx1ZS5cclxuICAgICAgICAgKiBAbWV0aG9kIGVxXHJcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIEZpZWxkIG5hbWUuXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBDb21wYXJpc29uIHZhbHVlICh0byB3aGljaCB0aGUgZmllbGRzIG11c3QgYmUgZXF1YWwpLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGVxOiBmdW5jdGlvbiAoZmllbGQsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLmVxdWFsLCBmaWVsZCwgdmFsdWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIGNvbmRpdGlvbiB0aGF0IGEgZmllbGQgbXVzdCAqbm90KiBiZSBlcXVhbCB0byBhIHNwZWNpZmljIHZhbHVlLlxyXG4gICAgICAgICAqIEBtZXRob2QgbmVcclxuICAgICAgICAgKiBAbWVtYmVyT2YgV2hlcmVRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgRmllbGQgbmFtZS5cclxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIENvbXBhcmlzb24gdmFsdWUgKHRvIHdoaWNoIHRoZSBmaWVsZCBtdXN0IG5vdCBiZSBlcXVhbCkuXHJcbiAgICAgICAgICogQHJldHVybnMge1doZXJlUXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbmU6IGZ1bmN0aW9uIChmaWVsZCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUubm90X2VxdWFsLCBmaWVsZCwgdmFsdWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIGNvbmRpdGlvbiB0aGF0IGEgZmllbGQgbXVzdCBiZSBgZ3JlYXRlciB0aGFuYCBhIGNlcnRhaW4gdmFsdWUuIEFwcGxpY2FibGUgdG8gTnVtYmVyLCBTdHJpbmcsIGFuZCBEYXRlIGZpZWxkcy5cclxuICAgICAgICAgKiBAbWV0aG9kIGd0XHJcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIEZpZWxkIG5hbWUuXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBDb21wYXJpc29uIHZhbHVlICh0aGF0IHRoZSBmaWVsZCBzaG91bGQgYmUgZ3JlYXRlciB0aGFuKS5cclxuICAgICAgICAgKiBAcmV0dXJucyB7V2hlcmVRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBndDogZnVuY3Rpb24gKGZpZWxkLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS5ndCwgZmllbGQsIHZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBjb25kaXRpb24gdGhhdCBhIGZpZWxkIG11c3QgYmUgYGdyZWF0ZXIgdGhhbiBvciBlcXVhbGAgdG8gYSBjZXJ0YWluIHZhbHVlLiBBcHBsaWNhYmxlIHRvIE51bWJlciwgU3RyaW5nLCBhbmQgRGF0ZSBmaWVsZHMuXHJcbiAgICAgICAgICogQG1ldGhvZCBndGVcclxuICAgICAgICAgKiBAbWVtYmVyT2YgV2hlcmVRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgRmllbGQgbmFtZS5cclxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIENvbXBhcmlzb24gdmFsdWUgKHRoYXQgdGhlIGZpZWxkIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8pLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGd0ZTogZnVuY3Rpb24gKGZpZWxkLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS5ndGUsIGZpZWxkLCB2YWx1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgY29uZGl0aW9uIHRoYXQgYSBmaWVsZCBtdXN0IGJlIGBsZXNzIHRoYW5gIGEgY2VydGFpbiB2YWx1ZS4gQXBwbGljYWJsZSB0byBOdW1iZXIsIFN0cmluZywgYW5kIERhdGUgZmllbGRzLlxyXG4gICAgICAgICAqIEBtZXRob2QgbHRcclxuICAgICAgICAgKiBAbWVtYmVyT2YgV2hlcmVRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgRmllbGQgbmFtZS5cclxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIENvbXBhcmlzb24gdmFsdWUgKHRoYXQgdGhlIGZpZWxkIHNob3VsZCBiZSBsZXNzIHRoYW4pLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGx0OiBmdW5jdGlvbiAoZmllbGQsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLmx0LCBmaWVsZCwgdmFsdWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIGNvbmRpdGlvbiB0aGF0IGEgZmllbGQgbXVzdCBiZSBgbGVzcyB0aGFuIG9yIGVxdWFsYCB0byBhIGNlcnRhaW4gdmFsdWUuIEFwcGxpY2FibGUgdG8gTnVtYmVyLCBTdHJpbmcsIGFuZCBEYXRlIGZpZWxkcy5cclxuICAgICAgICAgKiBAbWV0aG9kIGx0ZVxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBXaGVyZVF1ZXJ5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBGaWVsZCBuYW1lLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgQ29tcGFyaXNvbiB2YWx1ZSAodGhhdCB0aGUgZmllbGQgc2hvdWxkIGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0bykuXHJcbiAgICAgICAgICogQHJldHVybnMge1doZXJlUXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbHRlOiBmdW5jdGlvbiAoZmllbGQsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLmx0ZSwgZmllbGQsIHZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBjb25kaXRpb24gdGhhdCBhIGZpZWxkIG11c3QgYmUgaW4gYSBzZXQgb2YgdmFsdWVzLlxyXG4gICAgICAgICAqIEBtZXRob2QgaXNpblxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBXaGVyZVF1ZXJ5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBGaWVsZCBuYW1lLlxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlIEFuIGFycmF5IG9mIHRoZSB2YWx1ZXMgdGhhdCB0aGUgZmllbGQgc2hvdWxkIGJlIGluLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlzaW46IGZ1bmN0aW9uIChmaWVsZCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUuaXNpbiwgZmllbGQsIHZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBjb25kaXRpb24gdGhhdCBhIGZpZWxkIG11c3QgKm5vdCogYmUgaW4gYSBzZXQgb2YgdmFsdWVzLlxyXG4gICAgICAgICAqIEBtZXRob2Qgbm90aW5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgV2hlcmVRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgRmllbGQgbmFtZS5cclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZSBBbiBhcnJheSBvZiB2YWx1ZXMgdGhhdCB0aGUgZmllbGQgc2hvdWxkIG5vdCBiZSBpbi5cclxuICAgICAgICAgKiBAcmV0dXJucyB7V2hlcmVRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBub3RpbjogZnVuY3Rpb24gKGZpZWxkLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS5ub3RpbiwgZmllbGQsIHZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBjb25kaXRpb24gdGhhdCBhIGZpZWxkIG11c3QgaW5jbHVkZSAqYWxsKiBvZiB0aGUgc3BlY2lmaWVkIHZhbHVlcy4gQXBwbGljYWJsZSB0byBBcnJheSBmaWVsZHMuXHJcbiAgICAgICAgICogQG1ldGhvZCBhbGxcclxuICAgICAgICAgKiBAbWVtYmVyT2YgV2hlcmVRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgRmllbGQgbmFtZS5cclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZSBBbiBhcnJheSBvZiB2YWx1ZXMgdGhhdCB0aGUgZmllbGQgbXVzdCBpbmNsdWRlLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGFsbDogZnVuY3Rpb24gKGZpZWxkLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS5hbGwsIGZpZWxkLCB2YWx1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgY29uZGl0aW9uIHRoYXQgYSBmaWVsZCBtdXN0IGNvbnRhaW4gYW4gYXJyYXkgd2hvc2UgbGVuZ3RoIGlzIGxhcmdlciB0aGFuIGEgc3BlY2lmaWVkIHZhbHVlLiBBcHBsaWNhYmxlIHRvIEFycmF5IGZpZWxkcy5cclxuICAgICAgICAgKiBAbWV0aG9kIHNpemVcclxuICAgICAgICAgKiBAbWVtYmVyT2YgV2hlcmVRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgRmllbGQgbmFtZS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIHNpemUgdGhhdCB0aGUgYXJyYXkgbXVzdCBiZSBiaWdnZXIgdGhhbi5cclxuICAgICAgICAgKiBAcmV0dXJucyB7V2hlcmVRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBzaXplOiBmdW5jdGlvbiAoZmllbGQsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLnNpemUsIGZpZWxkLCB2YWx1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgY29uZGl0aW9uIHRoYXQgYSBmaWVsZCBtdXN0IHNhdGlzZnkgYSBzcGVjaWZpZWQgcmVnZXguXHJcbiAgICAgICAgICogQG1ldGhvZCByZWdleFxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBXaGVyZVF1ZXJ5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBGaWVsZCBuYW1lLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZWd1bGFyRXhwcmVzc2lvbiBSZWd1bGFyIGV4cHJlc3Npb24gaW4gUENSRSBmb3JtYXQuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zXSBBIHN0cmluZyBvZiByZWdleCBvcHRpb25zIHRvIHVzZS4gU2VlIFtzcGVjc10oe2h0dHA6Ly9kb2NzLm1vbmdvZGIub3JnL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvcXVlcnkvcmVnZXgvI29wLl9TX29wdGlvbnN9KSBmb3IgYSBkZXNjcmlwdGlvbiBvZiBhdmFpbGFibGUgb3B0aW9ucy5cclxuICAgICAgICAgKiBAcmV0dXJucyB7V2hlcmVRdWVyeX1cclxuICAgICAgICAgKi9cclxuICAgICAgICByZWdleDogZnVuY3Rpb24gKGZpZWxkLCB2YWx1ZSwgZmxhZ3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUucmVnZXgsIGZpZWxkLCB2YWx1ZSwgZmxhZ3MpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIGNvbmRpdGlvbiB0aGF0IGEgZmllbGQgdmFsdWUgbXVzdCAqc3RhcnQqIHdpdGggYSBzcGVjaWZpZWQgc3RyaW5nLlxyXG4gICAgICAgICAqIEBtZXRob2Qgc3RhcnRzV2l0aFxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBXaGVyZVF1ZXJ5LnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBGaWVsZCBuYW1lLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgc3RyaW5nIHRoYXQgdGhlIGZpZWxkIHNob3VsZCBzdGFydCB3aXRoLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9uc10gQSBzdHJpbmcgb2YgcmVnZXggb3B0aW9ucyB0byB1c2UuIFNlZSBbc3BlY3NdKHtodHRwOi8vZG9jcy5tb25nb2RiLm9yZy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3F1ZXJ5L3JlZ2V4LyNvcC5fU19vcHRpb25zfSkgZm9yIGEgZGVzY3JpcHRpb24gb2YgYXZhaWxhYmxlIG9wdGlvbnMuXHJcbiAgICAgICAgICogQHJldHVybnMge1doZXJlUXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3RhcnRzV2l0aDogZnVuY3Rpb24gKGZpZWxkLCB2YWx1ZSwgZmxhZ3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUuc3RhcnRzV2l0aCwgZmllbGQsIHZhbHVlLCBmbGFncyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgY29uZGl0aW9uIHRoYXQgYSBmaWVsZCB2YWx1ZSBtdXN0ICplbmQqIHdpdGggYSBzcGVjaWZpZWQgc3RyaW5nLlxyXG4gICAgICAgICAqIEBtZXRob2QgZW5kc1dpdGhcclxuICAgICAgICAgKiBAbWVtYmVyT2YgV2hlcmVRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgRmllbGQgbmFtZS5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIHN0cmluZyB0aGF0IHRoZSBmaWVsZCBzaG91bGQgZW5kIHdpdGguXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zXSBBIHN0cmluZyBvZiAgcmVnZXggb3B0aW9ucyB0byB1c2UuIFNlZSBbc3BlY3NdKHtodHRwOi8vZG9jcy5tb25nb2RiLm9yZy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3F1ZXJ5L3JlZ2V4LyNvcC5fU19vcHRpb25zfSkgZm9yIGEgZGVzY3JpcHRpb24gb2YgYXZhaWxhYmxlIG9wdGlvbnMuXHJcbiAgICAgICAgICogQHJldHVybnMge1doZXJlUXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZW5kc1dpdGg6IGZ1bmN0aW9uIChmaWVsZCwgdmFsdWUsIGZsYWdzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLmVuZHNXaXRoLCBmaWVsZCwgdmFsdWUsIGZsYWdzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBHZW9zcGF0aWFsIGNvbmRpdGlvbiB0aGF0IGEgc3BlY2lmaWVkIGdlb3BvaW50IG11c3QgYmUgd2l0aGluIGEgY2VydGFpbiBkaXN0YW5jZSBmcm9tIGFub3RoZXIgZ2VvcG9pbnQuIEFwcGxpY2FibGUgdG8gR2VvUG9pbnQgZmllbGRzIG9ubHkuXHJcbiAgICAgICAgICogQG1ldGhvZCBuZWFyU3BoZXJlXHJcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIEZpZWxkIG5hbWUgY29udGFpbmluZyBhIHtHZW9Qb2ludH0gaW4gdGhlIGZvbGxvd2luZyBmb3JtYXQ6IGAoZGVjaW1hbF9kZWdyZWVzX2xhdGl0dWRlLGRlY2ltYWxfZGVncmVlc19sb25naXR1ZGUpYCwgd2hlcmUgKmRlY2ltYWxfZGVncmVlc19sYXRpdHVkZSogcmFuZ2VzIGZyb20gLTkwIHRvIDkwIGFuZCAqZGVjaW1hbF9kZWdyZWVzX2xvbmdpdHVkZSogcmFuZ2VzIGZyb20gLTE4MCB0byAxODAuIEV4YW1wbGU6IGAoNDIuNjk1NDMyMiwxMjMuMzIzOTQ2NylgXHJcbiAgICAgICAgICogQHBhcmFtIHtFdmVybGl2ZS5HZW9Qb2ludH0gcG9pbnQgQ29tcGFyaXNvbiBnZW9wb2ludCB2YWx1ZS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2UgRGlzdGFuY2UgdmFsdWUuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFttZXRyaWNzPXJhZGlhbnNdIEEgc3RyaW5nIHJlcHJlc2VudGluZyB3aGF0IHVuaXQgb2YgbWVhc3VyZW1lbnQgaXMgdXNlZCBmb3IgZGlzdGFuY2UuIFBvc3NpYmxlIHZhbHVlczogcmFkaWFucywga20sIG1pbGVzLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG5lYXJTcGhlcmU6IGZ1bmN0aW9uIChmaWVsZCwgcG9pbnQsIGRpc3RhbmNlLCBtZXRyaWNzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLm5lYXJTaHBlcmUsIGZpZWxkLCBwb2ludCwgZGlzdGFuY2UsIG1ldHJpY3MpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIEdlb3NwYXRpYWwgY29uZGl0aW9uIHRoYXQgYSBzcGVjaWZpZWQgZ2VvcG9pbnQgbXVzdCBiZSB3aXRoaW4gYSBzcGVjaWZpZWQgY29vcmRpbmF0ZSByZWN0YW5nbGUuIEFwcGxpY2FibGUgdG8gR2VvUG9pbnQgZmllbGRzIG9ubHkuXHJcbiAgICAgICAgICogQG1ldGhvZCB3aXRoaW5Cb3hcclxuICAgICAgICAgKiBAbWVtYmVyT2YgV2hlcmVRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgRmllbGQgbmFtZSBjb250YWluaW5nIGEge0dlb1BvaW50fSBpbiB0aGUgZm9sbG93aW5nIGZvcm1hdDogYChkZWNpbWFsX2RlZ3JlZXNfbGF0aXR1ZGUsZGVjaW1hbF9kZWdyZWVzX2xvbmdpdHVkZSlgLCB3aGVyZSAqZGVjaW1hbF9kZWdyZWVzX2xhdGl0dWRlKiByYW5nZXMgZnJvbSAtOTAgdG8gOTAgYW5kICpkZWNpbWFsX2RlZ3JlZXNfbG9uZ2l0dWRlKiByYW5nZXMgZnJvbSAtMTgwIHRvIDE4MC4gRXhhbXBsZTogYCg0Mi42OTU0MzIyLDEyMy4zMjM5NDY3KWBcclxuICAgICAgICAgKiBAcGFyYW0ge0V2ZXJsaXZlLkdlb1BvaW50fSBwb2ludEJvdHRvbUxlZnQgVmFsdWUgcmVwcmVzZW50aW5nIHRoZSBib3R0b20gbGVmdCBjb3JuZXIgb2YgdGhlIGJveC5cclxuICAgICAgICAgKiBAcGFyYW0ge0V2ZXJsaXZlLkdlb1BvaW50fSBwb2ludFVwcGVyUmlnaHQgVmFsdWUgcmVwcmVzZW50aW5nIHRoZSB1cHBlciByaWdodCBjb3JuZXIgb2YgdGhlIGJveC5cclxuICAgICAgICAgKiBAZXhhbXBsZSBgYGBqc1xyXG4gICAgICAgICB2YXIgcXVlcnkgPSBuZXcgRXZlcmxpdmUuUXVlcnkoKTtcclxuICAgICAgICAgcXVlcnkud2hlcmUoKS53aXRoaW5Cb3goJ0xvY2F0aW9uJyxcclxuICAgICAgICAgbmV3IEV2ZXJsaXZlLkdlb1BvaW50KDIzLjMxNzg3MSwgNDIuNjg3NzA5KSxcclxuICAgICAgICAgbmV3IEV2ZXJsaXZlLkdlb1BvaW50KDIzLjMzMTM0NiwgNDIuNzA3MDc1KSk7XHJcbiAgICAgICAgIGBgYFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtXaGVyZVF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHdpdGhpbkJveDogZnVuY3Rpb24gKGZpZWxkLCBwb2ludEJvdHRvbUxlZnQsIHBvaW50VXBwZXJSaWdodCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2ltcGxlKE9wZXJhdG9yVHlwZS53aXRoaW5Cb3gsIGZpZWxkLCBwb2ludEJvdHRvbUxlZnQsIHBvaW50VXBwZXJSaWdodCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgR2Vvc3BhdGlhbCBjb25kaXRpb24gdGhhdCBhIHNwZWNpZmllZCBnZW9wb2ludCBtdXN0IGJlIHdpdGhpbiBhIHNwZWNpZmllZCBjb29yZGluYXRlIHBvbHlnb24uIFRoZSBwb2x5Z29uIGlzIHNwZWNpZmllZCBhcyBhbiBhcnJheSBvZiBnZW9wb2ludHMuIFRoZSBsYXN0IHBvaW50IGluIHRoZSBhcnJheSBpcyBpbXBsaWNpdGx5IGNvbm5lY3RlZCB0byB0aGUgZmlyc3QgcG9pbnQgdGh1cyBjbG9zaW5nIHRoZSBzaGFwZS4gQXBwbGljYWJsZSB0byBHZW9Qb2ludCBmaWVsZHMgb25seS5cclxuICAgICAgICAgKiBAbWV0aG9kIHdpdGhpblBvbHlnb25cclxuICAgICAgICAgKiBAbWVtYmVyT2YgV2hlcmVRdWVyeS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgRmllbGQgbmFtZSBjb250YWluaW5nIGEge0dlb1BvaW50fSBpbiB0aGUgZm9sbG93aW5nIGZvcm1hdDogYChkZWNpbWFsX2RlZ3JlZXNfbGF0aXR1ZGUsZGVjaW1hbF9kZWdyZWVzX2xvbmdpdHVkZSlgLCB3aGVyZSAqZGVjaW1hbF9kZWdyZWVzX2xhdGl0dWRlKiByYW5nZXMgZnJvbSAtOTAgdG8gOTAgYW5kICpkZWNpbWFsX2RlZ3JlZXNfbG9uZ2l0dWRlKiByYW5nZXMgZnJvbSAtMTgwIHRvIDE4MC4gRXhhbXBsZTogYCg0Mi42OTU0MzIyLDEyMy4zMjM5NDY3KWBcclxuICAgICAgICAgKiBAcGFyYW0ge0V2ZXJsaXZlLkdlb1BvaW50W119IHBvaW50cyBDb21wYXJpc29uIHZhbHVlIGluIHRoZSBmb3JtIG9mIGFuIGFycmF5IG9mIGdlb3BvaW50cyBkZWZpbmluZyB0aGUgcG9seWdvbi5cclxuICAgICAgICAgKiBAZXhhbXBsZSBgYGBqc1xyXG4gICAgICAgICB2YXIgcG9pbnQxID0gbmV3IEV2ZXJsaXZlLkdlb1BvaW50KDIzLjMxNzg3MSwgNDIuNjg3NzA5KTtcclxuICAgICAgICAgdmFyIHBvaW50MiA9IG5ldyBFdmVybGl2ZS5HZW9Qb2ludCg0Mi42OTg3NDksIDQyLjY5ODc0OSk7XHJcbiAgICAgICAgIHZhciBwb2ludDMgPSBuZXcgRXZlcmxpdmUuR2VvUG9pbnQoMjMuMzMxMzQ2LCA0Mi43MDIyODIpO1xyXG5cclxuICAgICAgICAgdmFyIHF1ZXJ5ID0gbmV3IEV2ZXJsaXZlLlF1ZXJ5KCk7XHJcbiAgICAgICAgIHF1ZXJ5LndoZXJlKCkud2l0aGluUG9seWdvbihcImxvY2F0aW9uXCIsIFtwb2ludDEsIHBvaW50MiwgcG9pbnQzXSk7XHJcbiAgICAgICAgICogYGBgXHJcbiAgICAgICAgICogQHJldHVybnMge1doZXJlUXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgd2l0aGluUG9seWdvbjogZnVuY3Rpb24gKGZpZWxkLCBwb2ludHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZShPcGVyYXRvclR5cGUud2l0aGluUG9seWdvbiwgZmllbGQsIHBvaW50cyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgR2Vvc3BhdGlhbCBjb25kaXRpb24gdGhhdCBhIHNwZWNpZmllZCBnZW9wb2ludCBtdXN0IGJlIHdpdGhpbiBhIGNvb3JkaW5hdGUgY2lyY2xlLiBBcHBsaWNhYmxlIHRvIEdlb1BvaW50IGZpZWxkcyBvbmx5LlxyXG4gICAgICAgICAqIEBtZXRob2Qgd2l0aGluQ2VudGVyU3BoZXJlXHJcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIEZpZWxkIG5hbWUgY29udGFpbmluZyBhIHtHZW9Qb2ludH0gaW4gdGhlIGZvbGxvd2luZyBmb3JtYXQ6IGAoZGVjaW1hbF9kZWdyZWVzX2xhdGl0dWRlLGRlY2ltYWxfZGVncmVlc19sb25naXR1ZGUpYCwgd2hlcmUgKmRlY2ltYWxfZGVncmVlc19sYXRpdHVkZSogcmFuZ2VzIGZyb20gLTkwIHRvIDkwIGFuZCAqZGVjaW1hbF9kZWdyZWVzX2xvbmdpdHVkZSogcmFuZ2VzIGZyb20gLTE4MCB0byAxODAuIEV4YW1wbGU6IGAoNDIuNjk1NDMyMiwxMjMuMzIzOTQ2NylgXHJcbiAgICAgICAgICogQHBhcmFtIHtFdmVybGl2ZS5HZW9Qb2ludH0gY2VudGVyIENvbXBhcmlzb24gdmFsdWUgc3BlY2lmeWluZyB0aGUgY2VudGVyIG9mIHRoZSBjb29yZGluYXRlIGNpcmNsZS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFZhbHVlIHNwZWNpZnlpbmcgdGhlIHJhZGl1cyBsZW5ndGguXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFttZXRyaWNzPXJhZGlhbnNdIEEgc3RyaW5nIHJlcHJlc2VudGluZyB3aGF0IHVuaXQgb2YgbWVhc3VyZW1lbnQgaXMgdXNlZCBmb3IgcmFkaXVzIGxlbmd0aC4gUG9zc2libGUgdmFsdWVzOiByYWRpYW5zLCBrbSwgbWlsZXMuXHJcbiAgICAgICAgICogQHJldHVybnMge1doZXJlUXVlcnl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgd2l0aGluQ2VudGVyU3BoZXJlOiBmdW5jdGlvbiAoZmllbGQsIGNlbnRlciwgcmFkaXVzLCBtZXRyaWNzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaW1wbGUoT3BlcmF0b3JUeXBlLndpdGhpblNocGVyZSwgZmllbGQsIGNlbnRlciwgcmFkaXVzLCBtZXRyaWNzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuZHMgdGhlIGRlZmluaXRpb24gb2YgdGhlIGN1cnJlbnQgV2hlcmVRdWVyeS4gWW91IG5lZWQgdG8gY2FsbCB0aGlzIG1ldGhvZCBpbiBvcmRlciB0byBjb250aW51ZSB3aXRoIHRoZSBkZWZpbml0aW9uIG9mIHRoZSBwYXJlbnQgYFF1ZXJ5YC4gQWxsIG90aGVyIGBXaGVyZVF1ZXJ5YCBtZXRob2RzIHJldHVybiB0aGUgY3VycmVudCBpbnN0YW5jZSBvZiBgV2hlcmVRdWVyeWAgdG8gYWxsb3cgY2hhaW5pbmcuXHJcbiAgICAgICAgICogQG1ldGhvZCBkb25lXHJcbiAgICAgICAgICogQG1lbWJlck9mIFdoZXJlUXVlcnkucHJvdG90eXBlXHJcbiAgICAgICAgICogQHJldHVybnMge1F1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50IGluc3RhbmNlb2YgV2hlcmVRdWVyeSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Ll9kb25lKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIF9kb25lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNpbmdsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIFdoZXJlUXVlcnkucHJvdG90eXBlLmVxdWFsID0gV2hlcmVRdWVyeS5wcm90b3R5cGUuZXE7XHJcbiAgICBXaGVyZVF1ZXJ5LnByb3RvdHlwZS5ub3RFcXVhbCA9IFdoZXJlUXVlcnkucHJvdG90eXBlLm5lO1xyXG4gICAgV2hlcmVRdWVyeS5wcm90b3R5cGUuZ3JlYXRlclRoYW4gPSBXaGVyZVF1ZXJ5LnByb3RvdHlwZS5ndDtcclxuICAgIFdoZXJlUXVlcnkucHJvdG90eXBlLmdyZWF0ZXJUaGFuRXF1YWwgPSBXaGVyZVF1ZXJ5LnByb3RvdHlwZS5ndGU7XHJcbiAgICBXaGVyZVF1ZXJ5LnByb3RvdHlwZS5sZXNzVGhhbiA9IFdoZXJlUXVlcnkucHJvdG90eXBlLmx0O1xyXG4gICAgV2hlcmVRdWVyeS5wcm90b3R5cGUubGVzc1RoYW5FcXVhbCA9IFdoZXJlUXVlcnkucHJvdG90eXBlLmx0ZTtcclxuXHJcbiAgICByZXR1cm4gV2hlcmVRdWVyeTtcclxufSgpKTsiLCJ2YXIgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcclxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIGZ1bmN0aW9uIHJlcXdlc3Qob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBodHRwUmVxdWVzdE9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIHVybDogb3B0aW9ucy51cmwsXHJcbiAgICAgICAgICAgIG1ldGhvZDogb3B0aW9ucy5tZXRob2QsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVycyB8fCB7fVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLmRhdGEpIHtcclxuICAgICAgICAgICAgaHR0cFJlcXVlc3RPcHRpb25zLmNvbnRlbnQgPSBvcHRpb25zLmRhdGE7IC8vIE5PVEU6IElmIHdlIHBhc3MgbnVsbC91bmRlZmluZWQsIGl0IHdpbGwgcmFpc2UgYW4gZXhjZXB0aW9uIGluIHRoZSBodHRwIG1vZHVsZS5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGh0dHBSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzWydBY2NlcHQnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcclxuICAgICAgICBodHRwUmVxdWVzdE9wdGlvbnMuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XHJcblxyXG4gICAgICAgIHZhciBub29wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3MgfHwgbm9vcDtcclxuICAgICAgICB2YXIgZXJyb3IgPSBvcHRpb25zLmVycm9yIHx8IG5vb3A7XHJcblxyXG4gICAgICAgIHZhciByZXF1ZXN0U3VjY2Vzc0NhbGxiYWNrID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgIHZhciBjb250ZW50U3RyaW5nID0gcmVzcG9uc2UuY29udGVudC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA8IDQwMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gU3VjY2VzcyBjYWxsYmFjayBjYWxscyBhIGN1c3RvbSBwYXJzZSBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgc3VjY2Vzcyhjb250ZW50U3RyaW5nKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIEVycm9yIGNhbGxiYWNrIHJlbGllcyBvbiBhIEpTT04gT2JqZWN0IHdpdGggUmVzcG9uc2VUZXh0IGluc2lkZVxyXG4gICAgICAgICAgICAgICAgZXJyb3Ioe1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlVGV4dDogY29udGVudFN0cmluZ1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB2YXIgcmVxdWVzdEVycm9yQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgIC8vIGVycm9yOiBmdW5jdGlvbihqcVhIUiwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pXHJcbiAgICAgICAgICAgIC8vIHdoZW4gdGltZW91dGluZyBmb3IgZXhhbXBsZSAoaS5lLiBubyBpbnRlcm5ldCBjb25uZWN0aXZpdHkpLCB3ZSBnZXQgYW4gZXJyIHdpdGggY29udGVudCB7IG1lc3NhZ2U6IFwidGltZW91dC4uLlwiLCBzdGFjazogbnVsbCB9XHJcbiAgICAgICAgICAgIGVycm9yKHtcclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlVGV4dDogZXJyXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGh0dHAucmVxdWVzdChodHRwUmVxdWVzdE9wdGlvbnMpLnRoZW4ocmVxdWVzdFN1Y2Nlc3NDYWxsYmFjaywgcmVxdWVzdEVycm9yQ2FsbGJhY2spO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXF3ZXN0O1xyXG59KCkpOyIsInZhciB1cmwgPSByZXF1aXJlKCd1cmwnKTtcclxudmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XHJcbnZhciBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XHJcbnZhciByc3ZwID0gcmVxdWlyZSgncnN2cCcpO1xyXG52YXIgemxpYiA9IHJlcXVpcmUoJ3psaWInKTtcclxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgZnVuY3Rpb24gcmVxd2VzdChvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIHVybFBhcnRzID0gdXJsLnBhcnNlKG9wdGlvbnMudXJsKTtcclxuICAgICAgICB2YXIgcmVxdWVzdDtcclxuICAgICAgICBpZiAodXJsUGFydHMucHJvdG9jb2wgPT09ICdodHRwczonKSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3QgPSBodHRwcy5yZXF1ZXN0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVxdWVzdCA9IGh0dHAucmVxdWVzdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMgfHwge307XHJcbiAgICAgICAgb3B0aW9ucy5zdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzIHx8IF8ubm9vcDtcclxuICAgICAgICBvcHRpb25zLmVycm9yID0gb3B0aW9ucy5lcnJvciB8fCBfLm5vb3A7XHJcblxyXG4gICAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gb3B0aW9ucy5jb250ZW50VHlwZTtcclxuICAgICAgICB2YXIgcmVxID0gcmVxdWVzdCh7XHJcbiAgICAgICAgICAgIG1ldGhvZDogb3B0aW9ucy5tZXRob2QsXHJcbiAgICAgICAgICAgIGhvc3RuYW1lOiB1cmxQYXJ0cy5ob3N0bmFtZSxcclxuICAgICAgICAgICAgcG9ydDogdXJsUGFydHMucG9ydCxcclxuICAgICAgICAgICAgcGF0aDogdXJsUGFydHMucGF0aCxcclxuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyc1xyXG4gICAgICAgIH0sIGZ1bmN0aW9uIChyZXMpIHtcclxuICAgICAgICAgICAgdmFyIGpzb24gPSAnJztcclxuICAgICAgICAgICAgdmFyIGNvbnRlbnRFbmNvZGluZyA9IHJlcy5oZWFkZXJzWydjb250ZW50LWVuY29kaW5nJ107XHJcbiAgICAgICAgICAgIHZhciByZXNwb25zZVByb3h5O1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGNvbnRlbnRFbmNvZGluZyl7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdnemlwJzpcclxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVByb3h5ID0gemxpYi5jcmVhdGVHdW56aXAoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXMucGlwZShyZXNwb25zZVByb3h5KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm94eSA9IHJlcztcclxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVByb3h5LnNldEVuY29kaW5nKCd1dGY4Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJlc3BvbnNlUHJveHkub24oJ2RhdGEnLCBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAganNvbiArPSBkYXRhLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmVzcG9uc2VQcm94eS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgLy8gMXh4IEluZm9ybWF0aW9uYWwsIDJ4eCBTdWNjZXNzLCAzeHggUmVkaXJlY3Rpb24sIDR4eCBDbGllbnQgRXJyb3IsIDV4eCBTZXJ2ZXIgRXJyb3JcclxuICAgICAgICAgICAgICAgIGlmIChyZXMuc3RhdHVzQ29kZSA+PSAyMDAgJiYgcmVzLnN0YXR1c0NvZGUgPCA0MDApIHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnN1Y2Nlc3MoanNvbiwgcmVzKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpzb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5lcnJvcih7IHJlc3BvbnNlVGV4dDoganNvbiB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7IC8vIGVtcHR5IHJlc3BvbnNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignUmVzcG9uc2UgZXJyb3IuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLnN0YXR1c0NvZGUgPSByZXMuc3RhdHVzQ29kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5lcnJvcih7IHJlc3BvbnNlVGV4dDogZXJyb3IgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuZXJyb3IoeyByZXNwb25zZVRleHQ6IGUgfSk7IC8vIFRPRE9cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuZGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgY29udGVudEVuY29kaW5nID0gaGVhZGVyc1snY29udGVudC1lbmNvZGluZyddO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGNvbnRlbnRFbmNvZGluZyl7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdnemlwJzpcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihvcHRpb25zLmRhdGEsICd1dGYtOCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHpsaWIuZ3ppcChidWYsIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXEuZW5kKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJlcS5lbmQob3B0aW9ucy5kYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVxLmVuZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVxd2VzdDtcclxufSgpKTsiLCJ2YXIgYnVpbGRQcm9taXNlID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5idWlsZFByb21pc2U7XHJcbnZhciBEYXRhUXVlcnkgPSByZXF1aXJlKCcuLi9xdWVyeS9EYXRhUXVlcnknKTtcclxudmFyIFJlcXVlc3RPcHRpb25zQnVpbGRlciA9IHJlcXVpcmUoJy4uL3F1ZXJ5L1JlcXVlc3RPcHRpb25zQnVpbGRlcicpO1xyXG52YXIgcnN2cCA9IHJlcXVpcmUoJy4uL2NvbW1vbicpLnJzdnA7XHJcbnZhciBSZXF1ZXN0ID0gcmVxdWlyZSgnLi4vUmVxdWVzdCcpO1xyXG52YXIgaWRGaWVsZCA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpLmlkRmllbGQ7XHJcbnZhciBFdmVybGl2ZSA9IHJlcXVpcmUoJy4uL0V2ZXJsaXZlJyk7XHJcbnZhciBFdmVybGl2ZUVycm9yID0gcmVxdWlyZSgnLi4vRXZlcmxpdmVFcnJvcicpLkV2ZXJsaXZlRXJyb3I7XHJcbnZhciBFdmVybGl2ZUVycm9ycyA9IHJlcXVpcmUoJy4uL0V2ZXJsaXZlRXJyb3InKS5FdmVybGl2ZUVycm9ycztcclxudmFyIF8gPSByZXF1aXJlKCcuLi9jb21tb24nKS5fO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gbWVyZ2VSZXN1bHREYXRhKGRhdGEsIHN1Y2Nlc3MpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHJlcywgcmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgdmFyIGF0dHJzID0gcmVzLnJlc3VsdDtcclxuICAgICAgICAgICAgLy8gc3VwcG9ydCBmb3Iga2VuZG8gb2JzZXJ2YWJsZSBhcnJheVxyXG4gICAgICAgICAgICBpZiAoXy5pc0FycmF5KGRhdGEpIHx8IHR5cGVvZiBkYXRhLmxlbmd0aCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIF8uZWFjaChkYXRhLCBmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfLmV4dGVuZChpdGVtLCBhdHRyc1tpbmRleF0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfLmV4dGVuZChkYXRhLCBhdHRycyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHN1Y2Nlc3MocmVzLCByZXNwb25zZSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtZXJnZVVwZGF0ZVJlc3VsdERhdGEoZGF0YSwgc3VjY2Vzcykge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocmVzKSB7XHJcbiAgICAgICAgICAgIHZhciBtb2RpZmllZEF0ID0gcmVzLk1vZGlmaWVkQXQ7XHJcbiAgICAgICAgICAgIGRhdGEuTW9kaWZpZWRBdCA9IG1vZGlmaWVkQXQ7XHJcbiAgICAgICAgICAgIHN1Y2Nlc3MocmVzKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGNsYXNzIERhdGFcclxuICAgICAqIEBjbGFzc2Rlc2MgQSBjbGFzcyB0aGF0IHByb3ZpZGVzIG1ldGhvZHMgZm9yIGFsbCBDUlVEIG9wZXJhdGlvbnMgdG8gYSBnaXZlbiB7e3NpdGUuYnN9fSBkYXRhIHR5cGUuIENvdmVycyBhZHZhbmNlZCBzY2VuYXJpb3Mgd2l0aCBjdXN0b20gaGVhZGVycyBhbmQgc3BlY2lhbCBzZXJ2ZXItc2lkZSBmdW5jdGlvbmFsaXR5LlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHVwXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbk5hbWVcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gRGF0YShzZXR1cCwgY29sbGVjdGlvbk5hbWUsIG9mZmxpbmVTdG9yYWdlLCBldmVybGl2ZSkge1xyXG4gICAgICAgIHRoaXMuc2V0dXAgPSBzZXR1cDtcclxuICAgICAgICB0aGlzLmNvbGxlY3Rpb25OYW1lID0gY29sbGVjdGlvbk5hbWU7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gbnVsbDtcclxuICAgICAgICB0aGlzLm9mZmxpbmVTdG9yYWdlID0gb2ZmbGluZVN0b3JhZ2U7XHJcbiAgICAgICAgdGhpcy5ldmVybGl2ZSA9IGV2ZXJsaXZlO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBEYXRhLnByb3RvdHlwZSA9IHtcclxuICAgICAgICBfaXNPbmxpbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2ZmbGluZVN0b3JhZ2UgPyB0aGlzLm9mZmxpbmVTdG9yYWdlLmlzT25saW5lKCkgOiB0cnVlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9nZXRPZmZsaW5lQ3JlYXRlRGF0YTogZnVuY3Rpb24gKHF1ZXJ5LCByZXF1ZXN0UmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgdmFyIGNyZWF0ZURhdGE7XHJcbiAgICAgICAgICAgIGlmIChfLmlzQXJyYXkocXVlcnkuZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgIGNyZWF0ZURhdGEgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVlcnkuZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvYmplY3RUb0NyZWF0ZSA9IF8uZXh0ZW5kKHF1ZXJ5LmRhdGFbaV0sIHJlcXVlc3RSZXNwb25zZS5yZXN1bHRbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZURhdGEucHVzaChvYmplY3RUb0NyZWF0ZSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNyZWF0ZURhdGEgPSBfLmV4dGVuZChxdWVyeS5kYXRhLCByZXF1ZXN0UmVzcG9uc2UucmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZURhdGE7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfYXBwbHlPZmZsaW5lOiBmdW5jdGlvbiAocXVlcnksIHJlcXVlc3RSZXNwb25zZSkge1xyXG4gICAgICAgICAgICB2YXIgYXV0b1N5bmNFbmFibGVkID0gdGhpcy5vZmZsaW5lU3RvcmFnZSAmJiB0aGlzLm9mZmxpbmVTdG9yYWdlLnNldHVwLmF1dG9TeW5jO1xyXG4gICAgICAgICAgICBpZiAoYXV0b1N5bmNFbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHF1ZXJ5Lm9wZXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmVhZDpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIERhdGFRdWVyeS5vcGVyYXRpb25zLnJlYWRCeUlkOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3luY1JlYWRRdWVyeSA9IG5ldyBEYXRhUXVlcnkoXy5kZWZhdWx0cyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiByZXF1ZXN0UmVzcG9uc2UucmVzdWx0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTeW5jOiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHF1ZXJ5KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9mZmxpbmVTdG9yYWdlLmNyZWF0ZShzeW5jUmVhZFF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIERhdGFRdWVyeS5vcGVyYXRpb25zLmNyZWF0ZTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNyZWF0ZURhdGEgPSB0aGlzLl9nZXRPZmZsaW5lQ3JlYXRlRGF0YShxdWVyeSwgcmVxdWVzdFJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNyZWF0ZVF1ZXJ5ID0gbmV3IERhdGFRdWVyeShfLmRlZmF1bHRzKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGNyZWF0ZURhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1N5bmM6IHRydWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgcXVlcnkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2ZmbGluZVN0b3JhZ2UuY3JlYXRlKGNyZWF0ZVF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5pc1N5bmMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vZmZsaW5lU3RvcmFnZS5wcm9jZXNzUXVlcnkocXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHJzdnAuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9zZXRPcHRpb246IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IHRoaXMub3B0aW9ucyB8fCB7fTtcclxuICAgICAgICAgICAgaWYgKF8uaXNPYmplY3QodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNba2V5XSA9IF8uZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnNba2V5XSwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogTW9kaWZpZXMgd2hldGhlciB0aGUgcXVlcnkgc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIG9mZmxpbmUgc3RvcmFnZS5cclxuICAgICAgICAgKiBEZWZhdWx0IGlzIHRydWUuXHJcbiAgICAgICAgICogT25seSB2YWxpZCB3aGVuIG9mZmxpbmVTdG9yYWdlIGlzIGVuYWJsZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHdvcmtPZmZsaW5lXHJcbiAgICAgICAgICogQHJldHVybnMge0RhdGF9XHJcbiAgICAgICAgICogKi9cclxuICAgICAgICB1c2VPZmZsaW5lOiBmdW5jdGlvbiAodXNlT2ZmbGluZSkge1xyXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHNpbmdsZSB2YWx1ZSBpcyBleHBlY3RlZCBpbiB1c2VPZmZsaW5lKCkgcXVlcnkgbW9kaWZpZXInKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2V0T3B0aW9uKCd1c2VPZmZsaW5lJywgdXNlT2ZmbGluZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgaXNTeW5jOiBmdW5jdGlvbiAoaXNTeW5jKSB7XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Egc2luZ2xlIHZhbHVlIGlzIGV4cGVjdGVkIGluIGlzU3luYygpIHF1ZXJ5IG1vZGlmaWVyJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NldE9wdGlvbignaXNTeW5jJywgaXNTeW5jKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogTW9kaWZpZXMgd2hldGhlciB0aGUgcXVlcnkgc2hvdWxkIGludm9rZSB0aGUge3tAbGluayBBdXRoZW50aWNhdGlvbi5wcm90b3R5cGUuaGFzQXV0aGVudGljYXRpb25SZXF1aXJlbWVudH19LlxyXG4gICAgICAgICAqIERlZmF1bHQgaXMgZmFsc2UuXHJcbiAgICAgICAgICogT25seSB2YWxpZCB3aGVuIGF1dGhlbnRpY2F0aW9uIG1vZHVsZSBoYXMgYW4gb25BdXRoZW50aWNhdGlvblJlcXVpcmVkIGZ1bmN0aW9uIC5cclxuICAgICAgICAgKiBAcGFyYW0gc2tpcEF1dGhcclxuICAgICAgICAgKiBAcmV0dXJucyB7RGF0YX1cclxuICAgICAgICAgKiAqL1xyXG4gICAgICAgIHNraXBBdXRoOiBmdW5jdGlvbiAoc2tpcEF1dGgpIHtcclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSBzaW5nbGUgdmFsdWUgaXMgZXhwZWN0ZWQgaW4gc2tpcEF1dGgoKSBxdWVyeSBtb2RpZmllcicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZXRPcHRpb24oJ3NraXBBdXRoJywgc2tpcEF1dGgpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1vZGlmaWVzIHdoZXRoZXIgdGhlIHF1ZXJ5IHNob3VsZCBiZSBhcHBsaWVkIG9mZmxpbmUsIGlmIHRoZSBzZGsgaXMgY3VycmVudHkgd29ya2luZyBvbmxpbmUuXHJcbiAgICAgICAgICogRGVmYXVsdCBpcyB0cnVlLlxyXG4gICAgICAgICAqIE9ubHkgdmFsaWQgd2hlbiBvZmZsaW5lU3RvcmFnZSBpcyBlbmFibGVkLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAcGFyYW0gYXBwbHlPZmZsaW5lXHJcbiAgICAgICAgICogQHJldHVybnMge0RhdGF9XHJcbiAgICAgICAgICogKi9cclxuICAgICAgICBhcHBseU9mZmxpbmU6IGZ1bmN0aW9uIChhcHBseU9mZmxpbmUpIHtcclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSBzaW5nbGUgdmFsdWUgaXMgZXhwZWN0ZWQgaW4gYXBwbHlPZmZsaW5lKCkgcXVlcnkgbW9kaWZpZXInKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2V0T3B0aW9uKCdhcHBseU9mZmxpbmUnLCBhcHBseU9mZmxpbmUpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgYWRkaXRpb25hbCBub24tc3RhbmRhcmQgSFRUUCBoZWFkZXJzIGluIHRoZSBjdXJyZW50IGRhdGEgcmVxdWVzdC4gU2VlIFtMaXN0IG9mIE5vbi1TdGFuZGFyZCBIVFRQIEhlYWRlcnNde3slIHNsdWcgcmVzdC1hcGktaGVhZGVyc319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2RcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gaGVhZGVycyBBZGRpdGlvbmFsIGhlYWRlcnMgdG8gYmUgc2VudCB3aXRoIHRoZSBkYXRhIHJlcXVlc3QuXHJcbiAgICAgICAgICogQHJldHVybnMge0RhdGF9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgd2l0aEhlYWRlcnM6IGZ1bmN0aW9uIChoZWFkZXJzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZXRPcHRpb24oJ2hlYWRlcnMnLCBoZWFkZXJzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgYW4gZXhwYW5kIGV4cHJlc3Npb24gdG8gYmUgdXNlZCBpbiB0aGUgZGF0YSByZXF1ZXN0LiBUaGlzIGFsbG93cyB5b3UgdG8gcmV0cmlldmUgY29tcGxleCBkYXRhIHNldHMgdXNpbmcgYSBzaW5nbGUgcXVlcnkgYmFzZWQgb24gcmVsYXRpb25zIGJldHdlZW4gZGF0YSB0eXBlcy5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGV4cGFuZEV4cHJlc3Npb24gQW4gW2V4cGFuZCBleHByZXNzaW9uXSh7JSBzbHVnIGZlYXR1cmVzLWRhdGEtcmVsYXRpb25zLWRlZmluaW5nLWV4cGFuZCAlfSkgZGVmaW5pdGlvbi5cclxuICAgICAgICAgKiBAcmV0dXJucyB7RGF0YX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBleHBhbmQ6IGZ1bmN0aW9uIChleHBhbmRFeHByZXNzaW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBleHBhbmRIZWFkZXIgPSB7XHJcbiAgICAgICAgICAgICAgICAnWC1FdmVybGl2ZS1FeHBhbmQnOiBKU09OLnN0cmluZ2lmeShleHBhbmRFeHByZXNzaW9uKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aXRoSGVhZGVycyhleHBhbmRIZWFkZXIpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb2Nlc3NlcyBhIHF1ZXJ5IHdpdGggYWxsIG9mIGl0cyBvcHRpb25zLiBBcHBsaWVzIHRoZSBvcGVyYXRpb24gb25saW5lL29mZmxpbmVcclxuICAgICAgICAgKiBAcGFyYW0ge0RhdGFRdWVyeX0gcXVlcnkgVGhlIHF1ZXJ5IHRvIHByb2Nlc3NcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7RGF0YVF1ZXJ5fSBxdWVyeVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHByb2Nlc3NEYXRhUXVlcnk6IGZ1bmN0aW9uIChxdWVyeSkge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICB2YXIgb2ZmbGluZVN0b3JhZ2VFbmFibGVkID0gdGhpcy5ldmVybGl2ZS5faXNPZmZsaW5lU3RvcmFnZUVuYWJsZWQoKTtcclxuICAgICAgICAgICAgcXVlcnkudXNlT2ZmbGluZSA9IG9mZmxpbmVTdG9yYWdlRW5hYmxlZCA/ICF0aGlzLmV2ZXJsaXZlLmlzT25saW5lKCkgOiBmYWxzZTtcclxuICAgICAgICAgICAgcXVlcnkuYXBwbHlPZmZsaW5lID0gb2ZmbGluZVN0b3JhZ2VFbmFibGVkO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgcXVlcnkgPSBfLmRlZmF1bHRzKHRoaXMub3B0aW9ucywgcXVlcnkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoIXF1ZXJ5LnNraXBBdXRoICYmIHRoaXMuZXZlcmxpdmUuYXV0aGVudGljYXRpb24gJiYgdGhpcy5ldmVybGl2ZS5hdXRoZW50aWNhdGlvbi5pc0F1dGhlbnRpY2F0aW9uSW5Qcm9ncmVzcygpKSB7XHJcbiAgICAgICAgICAgICAgICBxdWVyeS5vbkVycm9yID0gXy53cmFwKHF1ZXJ5Lm9uRXJyb3IsIGZ1bmN0aW9uIChlcnJvckZ1bmMsIGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gRXZlcmxpdmVFcnJvcnMuaW52YWxpZFRva2VuLmNvZGUgfHwgZXJyLmNvZGUgPT09IEV2ZXJsaXZlRXJyb3JzLmV4cGlyZWRUb2tlbi5jb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3aGVuQXV0aGVudGljYXRlZFByb21pc2UgPSBzZWxmLmV2ZXJsaXZlLmF1dGhlbnRpY2F0aW9uLl9lbnN1cmVBdXRoZW50aWNhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXF1ZXJ5Lm5vUmV0cnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZW5BdXRoZW50aWNhdGVkUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5wcm9jZXNzRGF0YVF1ZXJ5KHF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JGdW5jLmNhbGwoc2VsZiwgZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2lmIHdlIGFyZSBjdXJyZW50bHkgYXV0aGVudGljYXRpbmcsIHF1ZXVlIHRoZSBkYXRhIHF1ZXJ5IGFmdGVyIHdlIGhhdmUgbG9nZ2VkIGluXHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5ldmVybGl2ZS5hdXRoZW50aWNhdGlvbi5pc0F1dGhlbnRpY2F0aW5nKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgd2hlbkF1dGhlbnRpY2F0ZWRQcm9taXNlID0gc2VsZi5ldmVybGl2ZS5hdXRoZW50aWNhdGlvbi5fZW5zdXJlQXV0aGVudGljYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXF1ZXJ5Lm5vUmV0cnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hlbkF1dGhlbnRpY2F0ZWRQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucHJvY2Vzc0RhdGFRdWVyeShxdWVyeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2hlbkF1dGhlbnRpY2F0ZWRQcm9taXNlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICgoIXF1ZXJ5LmlzU3luYyAmJiB0aGlzLm9mZmxpbmVTdG9yYWdlICYmIHRoaXMub2ZmbGluZVN0b3JhZ2UuaXNTeW5jaHJvbml6aW5nKCkpKSB7XHJcbiAgICAgICAgICAgICAgICBxdWVyeS5vbkVycm9yLmNhbGwodGhpcywgRXZlcmxpdmVFcnJvcnMuc3luY0luUHJvZ3Jlc3MpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFxdWVyeS51c2VPZmZsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxTdWNjZXNzID0gcXVlcnkub25TdWNjZXNzO1xyXG4gICAgICAgICAgICAgICAgcXVlcnkub25TdWNjZXNzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gYXJnc1swXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocXVlcnkuYXBwbHlPZmZsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9hcHBseU9mZmxpbmUocXVlcnksIGRhdGEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTdWNjZXNzLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5Lm9uRXJyb3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbFN1Y2Nlc3MuYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZ2V0UmVxdWVzdE9wdGlvbnNGcm9tUXVlcnkgPSBSZXF1ZXN0T3B0aW9uc0J1aWxkZXJbcXVlcnkub3BlcmF0aW9uXTtcclxuICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0T3B0aW9ucyA9IGdldFJlcXVlc3RPcHRpb25zRnJvbVF1ZXJ5KHF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QodGhpcy5zZXR1cCwgcmVxdWVzdE9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5zZW5kKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXF1ZXJ5LmFwcGx5T2ZmbGluZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBxdWVyeS5vbkVycm9yLmNhbGwodGhpcywgbmV3IEV2ZXJsaXZlRXJyb3IoJ1RoZSBhcHBseU9mZmxpbmUgbXVzdCBiZSBmYWxzZSB3aGVuIHdvcmtpbmcgb2ZmbGluZS4nKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgc2VsZi5vZmZsaW5lU3RvcmFnZS5wcm9jZXNzUXVlcnkocXVlcnkpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5Lm9uU3VjY2Vzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZXJyLmNvZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0gbmV3IEV2ZXJsaXZlRXJyb3IoZXJyLm1lc3NhZ2UsIEV2ZXJsaXZlRXJyb3JzLmdlbmVyYWxEYXRhYmFzZUVycm9yLmNvZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBxdWVyeS5vbkVycm9yLmNhbGwodGhpcywgZXJyKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBUT0RPIGltcGxlbWVudCBvcHRpb25zOiB7IHJlcXVlc3RTZXR0aW5nczogeyBleGVjdXRlU2VydmVyQ29kZTogZmFsc2UgfSB9LiBwb3dlciBmaWVsZHMgcXVlcmllcyBjb3VsZCBiZSBhZGRlZCB0byB0aGF0IG9wdGlvbnMgYXJndW1lbnRcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIGFsbCBkYXRhIGl0ZW1zIHRoYXQgbWF0Y2ggdGhlIGZpbHRlci4gVGhpcyBhbGxvd3MgeW91IHRvIHJldHJpZXZlIGEgc3Vic2V0IG9mIHRoZSBpdGVtcyBiYXNlZCBvbiB2YXJpb3VzIGZpbHRlcmluZyBjcml0ZXJpYS5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIGdldFxyXG4gICAgICAgICAqIEBuYW1lIGdldFxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fG51bGx9IGZpbHRlciBBIFtmaWx0ZXIgZXhwcmVzc2lvbl0oeyUgc2x1ZyByZXN0LWFwaS1xdWVyeWluZy1maWx0ZXJpbmcgJX0pIGRlZmluaXRpb24uXHJcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIGFsbCBkYXRhIGl0ZW1zIHRoYXQgbWF0Y2ggdGhlIGZpbHRlci4gVGhpcyBhbGxvd3MgeW91IHRvIHJldHJpZXZlIGEgc3Vic2V0IG9mIHRoZSBpdGVtcyBiYXNlZCBvbiB2YXJpb3VzIGZpbHRlcmluZyBjcml0ZXJpYS5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIGdldFxyXG4gICAgICAgICAqIEBuYW1lIGdldFxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fG51bGx9IGZpbHRlciBBIFtmaWx0ZXIgZXhwcmVzc2lvbl0oeyUgc2x1ZyByZXN0LWFwaS1xdWVyeWluZy1maWx0ZXJpbmcgJX0pIGRlZmluaXRpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKGZpbHRlciwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2Vzc0NiLCBlcnJvckNiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YVF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XHJcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy5yZWFkLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBzZWxmLmNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uU3VjY2Vzczogc3VjY2Vzc0NiLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IGVycm9yQ2JcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnByb2Nlc3NEYXRhUXVlcnkoZGF0YVF1ZXJ5KTtcclxuICAgICAgICAgICAgfSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gVE9ETyBoYW5kbGUgb3B0aW9uc1xyXG4gICAgICAgIC8vIFRPRE8gdGhpbmsgdG8gcGFzcyB0aGUgaWQgYXMgYSBmaWx0ZXJcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBhIGRhdGEgaXRlbSBieSBJRC5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIGdldEJ5SWRcclxuICAgICAgICAgKiBAbmFtZSBnZXRCeUlkXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBpdGVtLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBhbiBpdGVtIGJ5IElELlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgZ2V0QnlJZFxyXG4gICAgICAgICAqIEBuYW1lIGdldEJ5SWRcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgdGhlIGl0ZW0uXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICAgICAqICovXHJcbiAgICAgICAgZ2V0QnlJZDogZnVuY3Rpb24gKGlkLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzQ2IsIGVycm9yQ2IpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhUXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcclxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLnJlYWRCeUlkLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBzZWxmLmNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlOiBSZXF1ZXN0LnBhcnNlcnMuc2luZ2xlLFxyXG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxPcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBzdWNjZXNzQ2IsXHJcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcjogZXJyb3JDYlxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnByb2Nlc3NEYXRhUXVlcnkoZGF0YVF1ZXJ5KTtcclxuICAgICAgICAgICAgfSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGNvdW50IG9mIHRoZSBkYXRhIGl0ZW1zIHRoYXQgbWF0Y2ggdGhlIGZpbHRlci5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIGNvdW50XHJcbiAgICAgICAgICogQG5hbWUgY291bnRcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdHxudWxsfSBmaWx0ZXIgQSBbZmlsdGVyIGV4cHJlc3Npb25dKHslIHNsdWcgcmVzdC1hcGktcXVlcnlpbmctZmlsdGVyaW5nICV9KSBkZWZpbml0aW9uLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgY291bnQgb2YgdGhlIGl0ZW1zIHRoYXQgbWF0Y2ggdGhlIGZpbHRlci5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIGNvdW50XHJcbiAgICAgICAgICogQG5hbWUgY291bnRcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdHxudWxsfSBmaWx0ZXIgQSBbZmlsdGVyIGV4cHJlc3Npb25dKHslIHNsdWcgcmVzdC1hcGktcXVlcnlpbmctZmlsdGVyaW5nICV9KSBkZWZpbml0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjb3VudDogZnVuY3Rpb24gKGZpbHRlciwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjZXNzQ2IsIGVycm9yQ2IpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhUXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcclxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLmNvdW50LFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBzZWxmLmNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlOiBSZXF1ZXN0LnBhcnNlcnMuc2luZ2xlLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uU3VjY2Vzczogc3VjZXNzQ2IsXHJcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcjogZXJyb3JDYlxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5wcm9jZXNzRGF0YVF1ZXJ5KGRhdGFRdWVyeSk7XHJcbiAgICAgICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgZGF0YSBpdGVtLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgY3JlYXRlXHJcbiAgICAgICAgICogQG5hbWUgY3JlYXRlXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R8b2JqZWN0W119IGRhdGEgSXRlbSBvciBpdGVtcyB0aGF0IHdpbGwgYmUgY3JlYXRlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYW4gaXRlbS5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIGNyZWF0ZVxyXG4gICAgICAgICAqIEBuYW1lIGNyZWF0ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fG9iamVjdFtdfSBkYXRhIFRoZSBpdGVtIG9yIGl0ZW1zIHRoYXQgd2lsbCBiZSBjcmVhdGVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uIChkYXRhLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGFRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMuY3JlYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBzZWxmLmNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2U6IFJlcXVlc3QucGFyc2Vycy5zaW5nbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBtZXJnZVJlc3VsdERhdGEoZGF0YSwgc3VjY2VzcyksXHJcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcjogZXJyb3JcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5wcm9jZXNzRGF0YVF1ZXJ5KGRhdGFRdWVyeSk7XHJcbiAgICAgICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZXMgYWxsIG9iamVjdHMgdGhhdCBtYXRjaCBhIGZpbHRlciB3aXRoIHRoZSBzcGVjaWZpZWQgdXBkYXRlIGV4cHJlc3Npb24uXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCByYXdVcGRhdGVcclxuICAgICAgICAgKiBAbmFtZSByYXdVcGRhdGVcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gdXBkYXRlT2JqZWN0IFVwZGF0ZSBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgbmV3IHZhbHVlcy5cclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdHxudWxsfSBmaWx0ZXIgQSBbZmlsdGVyIGV4cHJlc3Npb25dKHslIHNsdWcgcmVzdC1hcGktcXVlcnlpbmctZmlsdGVyaW5nICV9KSBkZWZpbml0aW9uLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlcyBhbGwgb2JqZWN0cyB0aGF0IG1hdGNoIGEgZmlsdGVyIHdpdGggdGhlIHNwZWNpZmllZCB1cGRhdGUgZXhwcmVzc2lvbi5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHJhd1VwZGF0ZVxyXG4gICAgICAgICAqIEBuYW1lIHJhd1VwZGF0ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSB1cGRhdGVPYmplY3QgVXBkYXRlIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBuZXcgdmFsdWVzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fG51bGx9IGZpbHRlciBBIFtmaWx0ZXIgZXhwcmVzc2lvbl0oeyUgc2x1ZyByZXN0LWFwaS1xdWVyeWluZy1maWx0ZXJpbmcgJX0pIGRlZmluaXRpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZXMgYW4gb2JqZWN0IGJ5IElEIHdpdGggdGhlIHNwZWNpZmllZCB1cGRhdGUgZXhwcmVzc2lvbi5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHJhd1VwZGF0ZVxyXG4gICAgICAgICAqIEBuYW1lIHJhd1VwZGF0ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSB1cGRhdGVkT2JqZWN0IFVwZGF0ZWQgb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIG5ldyB2YWx1ZXMuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBJRCBvZiB0aGUgaXRlbS5cclxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZXMgYW4gb2JqZWN0IGJ5IElEIHdpdGggdGhlIHNwZWNpZmllZCB1cGRhdGUgZXhwcmVzc2lvbi5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHJhd1VwZGF0ZVxyXG4gICAgICAgICAqIEBuYW1lIHJhd1VwZGF0ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSB1cGRhdGVPYmplY3QgVXBkYXRlZCBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgbmV3IHZhbHVlcy5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIElEIG9mIHRoZSBpdGVtLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAgICAgKi9cclxuICAgICAgICByYXdVcGRhdGU6IGZ1bmN0aW9uIChhdHRycywgZmlsdGVyLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGFRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMucmF3VXBkYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBzZWxmLmNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGF0dHJzLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uU3VjY2Vzczogc3VjY2VzcyxcclxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiBlcnJvclxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5wcm9jZXNzRGF0YVF1ZXJ5KGRhdGFRdWVyeSk7XHJcbiAgICAgICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIFRPRE86IENoZWNrIGlmIHRoZXJlIGlzIGEgY2FzZSBpbiB3aGljaCByZXBsYWNlID0gdHJ1ZSBpcyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvblxyXG4gICAgICAgIF91cGRhdGU6IGZ1bmN0aW9uIChhdHRycywgZmlsdGVyLCBzaW5nbGUsIHJlcGxhY2UsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBidWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgZGF0YVtyZXBsYWNlID8gJyRyZXBsYWNlJyA6ICckc2V0J10gPSBhdHRycztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgdXBkYXRlIGlzIGZvciBhIHNpbmdsZSBpdGVtIC0gbWVyZ2UgdGhlIHVwZGF0ZSByZXN1bHQgYW5kIGFkZCB0aGUgTW9kaWZpZWRBdCBmaWVsZCB0byB0aGUgcmVzdWx0XHJcbiAgICAgICAgICAgICAgICB2YXIgb25TdWNjZXNzID0gc2luZ2xlID8gbWVyZ2VVcGRhdGVSZXN1bHREYXRhKGF0dHJzLCBzdWNjZXNzKSA6IHN1Y2Nlc3M7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGFRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogRGF0YVF1ZXJ5Lm9wZXJhdGlvbnMudXBkYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBzZWxmLmNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlOiBSZXF1ZXN0LnBhcnNlcnMudXBkYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbE9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHNpbmdsZSA/IGF0dHJzW2lkRmllbGRdIDogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IG9uU3VjY2VzcyxcclxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiBlcnJvclxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5wcm9jZXNzRGF0YVF1ZXJ5KGRhdGFRdWVyeSk7XHJcbiAgICAgICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGVzIGEgc2luZ2xlIGRhdGEgaXRlbS4gVGhpcyBvcGVyYXRpb24gdGFrZXMgYW4gb2JqZWN0IHRoYXQgc3BlY2lmaWVzIGJvdGggdGhlIGRhdGEgaXRlbSB0byBiZSB1cGRhdGVkIGFuZCB0aGUgdXBkYXRlZCB2YWx1ZXMuXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCB1cGRhdGVTaW5nbGVcclxuICAgICAgICAgKiBAbmFtZSB1cGRhdGVTaW5nbGVcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gaXRlbSBUaGUgaXRlbSB0aGF0IHdpbGwgYmUgdXBkYXRlZC4gTm90ZTogdGhlIElEIHByb3BlcnR5IG9mIHRoZSBpdGVtIHdpbGwgYmUgdXNlZCB0byBkZXRlcm1pbmUgd2hpY2ggaXRlbSB3aWxsIGJlIHVwZGF0ZWQuXHJcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGVzIHRoZSBwcm92aWRlZCBpdGVtLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2QgdXBkYXRlU2luZ2xlXHJcbiAgICAgICAgICogQG5hbWUgdXBkYXRlU2luZ2xlXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG1vZGVsIFRoZSBpdGVtIHRoYXQgd2lsbCBiZSB1cGRhdGVkLiBOb3RlOiB0aGUgSUQgcHJvcGVydHkgb2YgdGhlIGl0ZW0gd2lsbCBiZSB1c2VkIHRvIGRldGVybWluZSB3aGljaCBpdGVtIHdpbGwgYmUgdXBkYXRlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdXBkYXRlU2luZ2xlOiBmdW5jdGlvbiAobW9kZWwsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91cGRhdGUobW9kZWwsIG51bGwsIHRydWUsIGZhbHNlLCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlcyBhbGwgaXRlbXMgdGhhdCBtYXRjaCBhIGZpbHRlciB3aXRoIHRoZSBzcGVjaWZpZWQgdXBkYXRlIG9iamVjdC5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZVxyXG4gICAgICAgICAqIEBuYW1lIHVwZGF0ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSB1cGRhdGVPYmplY3QgVGhlIHVwZGF0ZSBvYmplY3QuXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R8bnVsbH0gZmlsdGVyIEEgW2ZpbHRlciBleHByZXNzaW9uXSh7JSBzbHVnIHJlc3QtYXBpLXF1ZXJ5aW5nLWZpbHRlcmluZyAlfSkgZGVmaW5pdGlvbi5cclxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZXMgYWxsIGl0ZW1zIHRoYXQgbWF0Y2ggdGhlIGZpbHRlciB3aXRoIHRoZSBzcGVjaWZpZWQgdXBkYXRlIG9iamVjdC5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZVxyXG4gICAgICAgICAqIEBuYW1lIHVwZGF0ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBtb2RlbCBUaGUgdXBkYXRlIG9iamVjdC5cclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdHxudWxsfSBmaWx0ZXIgQSBbZmlsdGVyIGV4cHJlc3Npb25dKHslIHNsdWcgcmVzdC1hcGktcXVlcnlpbmctZmlsdGVyaW5nICV9KSBkZWZpbml0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAgICAgKi9cclxuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChtb2RlbCwgZmlsdGVyLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlKG1vZGVsLCBmaWx0ZXIsIGZhbHNlLCBmYWxzZSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX2Rlc3Ryb3k6IGZ1bmN0aW9uIChhdHRycywgZmlsdGVyLCBzaW5nbGUsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBidWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YVF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XHJcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBzaW5nbGUgPyBEYXRhUXVlcnkub3BlcmF0aW9ucy5yZW1vdmVTaW5nbGUgOiBEYXRhUXVlcnkub3BlcmF0aW9ucy5yZW1vdmUsXHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbk5hbWU6IHNlbGYuY29sbGVjdGlvbk5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiBmaWx0ZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBzdWNjZXNzLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IGVycm9yLFxyXG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxPcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBzaW5nbGUgPyBhdHRyc1tpZEZpZWxkXSA6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucHJvY2Vzc0RhdGFRdWVyeShkYXRhUXVlcnkpO1xyXG4gICAgICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVsZXRlcyBhIHNpbmdsZSBkYXRhIGl0ZW0gYnkgSUQuXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBkZXN0cm95U2luZ2xlXHJcbiAgICAgICAgICogQG5hbWUgZGVzdHJveVNpbmdsZVxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpdGVtIE9iamVjdCBjb250YWluaW5nIHRoZSBpdGVtIElEIHRvIGJlIGRlbGV0ZWQuXHJcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWxldGVzIGEgc2luZ2xlIGRhdGEgaXRlbSBieSBJRC5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIGRlc3Ryb3lTaW5nbGVcclxuICAgICAgICAgKiBAbmFtZSBkZXN0cm95U2luZ2xlXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG1vZGVsIE9iamVjdCBjb250YWluaW5nIHRoZSBpdGVtIElEIHRvIGJlIGRlbGV0ZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRlc3Ryb3lTaW5nbGU6IGZ1bmN0aW9uIChtb2RlbCwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rlc3Ryb3kobW9kZWwsIG51bGwsIHRydWUsIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWxldGVzIGFsbCBkYXRhIGl0ZW1zIHRoYXQgbWF0Y2ggYSBmaWx0ZXIuXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBkZXN0cm95XHJcbiAgICAgICAgICogQG5hbWUgZGVzdHJveVxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fG51bGx9IGZpbHRlciBBIFtmaWx0ZXIgZXhwcmVzc2lvbl0oeyUgc2x1ZyByZXN0LWFwaS1xdWVyeWluZy1maWx0ZXJpbmcgJX0pIGRlZmluaXRpb24uXHJcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWxldGVzIGFsbCBpdGVtcyB0aGF0IG1hdGNoIHRoZSBmaWx0ZXIuXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBkZXN0cm95XHJcbiAgICAgICAgICogQG5hbWUgZGVzdHJveVxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fG51bGx9IGZpbHRlciBBIFtmaWx0ZXIgZXhwcmVzc2lvbl0oeyUgc2x1ZyByZXN0LWFwaS1xdWVyeWluZy1maWx0ZXJpbmcgJX0pIGRlZmluaXRpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIChmaWx0ZXIsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZXN0cm95KG51bGwsIGZpbHRlciwgZmFsc2UsIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBBY2Nlc3MgQ29udHJvbCBMaXN0IChBQ0wpIG9mIGEgc3BlY2lmaWVkIGRhdGEgaXRlbS5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHNldEFjbFxyXG4gICAgICAgICAqIEBuYW1lIHNldEFjbFxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhY2wgVGhlIGFjbCBvYmplY3QuXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGl0ZW0gVGhlIGl0ZW0gd2hvc2UgQUNMIHdpbGwgYmUgdXBkYXRlZC4gTm90ZTogdGhlIElEIHByb3BlcnR5IG9mIHRoZSBpdGVtIHdpbGwgYmUgdXNlZCB0byBkZXRlcm1pbmUgd2hpY2ggaXRlbSB3aWxsIGJlIGRlbGV0ZWQuXHJcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBBY2Nlc3MgQ29udHJvbCBMaXN0IChBQ0wpIG9mIGEgc3BlY2lmaWVkIGRhdGEgaXRlbS5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHNldEFjbFxyXG4gICAgICAgICAqIEBuYW1lIHNldEFjbFxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhY2wgVGhlIGFjbCBvYmplY3QuXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGl0ZW0gVGhlIGl0ZW0gd2hvc2UgQUNMIHdpbGwgYmUgdXBkYXRlZC4gTm90ZTogdGhlIElEIHByb3BlcnR5IG9mIHRoZSBpdGVtIHdpbGwgYmUgdXNlZCB0byBkZXRlcm1pbmUgd2hpY2ggaXRlbSB3aWxsIGJlIGRlbGV0ZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9wZXJhdGlvblBhcmFtZXRlcnMgQW4gb2JqZWN0IHdoaWNoIGFjY2VwdHMgb3BlcmF0aW9uIHBhcmFtZXRlcnNcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgQWNjZXNzIENvbnRyb2wgTGlzdCAoQUNMKSBvZiBhIHNwZWNpZmllZCBkYXRhIGl0ZW0uXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBzZXRBY2xcclxuICAgICAgICAgKiBAbmFtZSBzZXRBY2xcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gYWNsIFRoZSBhY2wgb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgSUQgb2YgdGhlIGl0ZW0uXHJcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBBY2Nlc3MgQ29udHJvbCBMaXN0IChBQ0wpIG9mIGFuIGl0ZW0gd2l0aCBhIHNwZWNpZmllZCBJRC5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHNldEFjbFxyXG4gICAgICAgICAqIEBuYW1lIHNldEFjbFxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhY2wgVGhlIGFjbCBvYmplY3QuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBJRCBvZiB0aGUgaXRlbS5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2V0QWNsOiBmdW5jdGlvbiAoYWNsLCBmaWx0ZXIsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBidWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YVF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XHJcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy5zZXRBY2wsXHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbk5hbWU6IHNlbGYuY29sbGVjdGlvbk5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2U6IFJlcXVlc3QucGFyc2Vycy5zaW5nbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiBmaWx0ZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbE9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWNsOiBhY2xcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIG9uU3VjY2Vzczogc3VjY2VzcyxcclxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiBlcnJvclxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucHJvY2Vzc0RhdGFRdWVyeShkYXRhUXVlcnkpO1xyXG4gICAgICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgb3duZXIgb2YgdGhlIHNwZWNpZmllZCBkYXRhIGl0ZW0uXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZCBzZXRPd25lclxyXG4gICAgICAgICAqIEBuYW1lIHNldE93bmVyXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFjbCBUaGUgbmV3IG93bmVyIElELlxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpdGVtIFRoZSBpdGVtIHdob3NlIG93bmVyIHdpbGwgYmUgdXBkYXRlZC4gTm90ZTogdGhlIElEIHByb3BlcnR5IG9mIHRoZSBpdGVtIHdpbGwgYmUgdXNlZCB0byBkZXRlcm1pbmUgd2hpY2ggaXRlbSB3aWxsIGJlIGRlbGV0ZWQuXHJcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBvd25lciBvZiB0aGUgc3BlY2lmaWVkIGRhdGEgaXRlbS5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHNldE93bmVyXHJcbiAgICAgICAgICogQG5hbWUgc2V0T3duZXJcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNsIFRoZSBuZXcgb3duZXIgSUQuXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGl0ZW0gVGhlIGl0ZW0gd2hvc2Ugb3duZXIgd2lsbCBiZSB1cGRhdGVkLiBOb3RlOiB0aGUgSUQgcHJvcGVydHkgb2YgdGhlIGl0ZW0gd2lsbCBiZSB1c2VkIHRvIGRldGVybWluZSB3aGljaCBpdGVtIHdpbGwgYmUgZGVsZXRlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gb3BlcmF0aW9uUGFyYW1ldGVycyBBbiBvYmplY3Qgd2hpY2ggYWNjZXB0cyBvcGVyYXRpb24gcGFyYW1ldGVyc1xyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcGVyYXRpb25QYXJhbWV0ZXJzLnN1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3BlcmF0aW9uUGFyYW1ldGVycy5lcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbb3BlcmF0aW9uUGFyYW1ldGVycy51c2VPZmZsaW5lXSBXaGV0aGVyIHRvIGludm9rZSB0aGUgb3BlcmF0aW9uIG9uIHRoZSBvZmZsaW5lIHN0b3JhZ2UuIERlZmF1bHQgaXMgYmFzZWQgb24gdGhlIGN1cnJlbnQgbW9kZSBvZiB0aGUgRXZlcmxpdmUgaW5zdGFuY2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbb3BlcmF0aW9uUGFyYW1ldGVycy5hcHBseU9mZmxpbmU9dHJ1ZV0gSWYgd29ya2luZyBvbmxpbmUsIHdoZXRoZXIgdG8gYWxzbyBhcHBseSB0aGUgb3BlcmF0aW9uIG9uIHRoZSBsb2NhbCBzdG9yYWdlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIG93bmVyIG9mIHRoZSBzcGVjaWZpZWQgZGF0YSBpdGVtLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2Qgc2V0T3duZXJcclxuICAgICAgICAgKiBAbmFtZSBzZXRPd25lclxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvd25lcklkIFRoZSBuZXcgb3duZXIgSUQuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBJRCBvZiB0aGUgaXRlbS5cclxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIG93bmVyIG9mIHRoZSBzcGVjaWZpZWQgZGF0YSBpdGVtLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2Qgc2V0T3duZXJcclxuICAgICAgICAgKiBAbmFtZSBzZXRPd25lclxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvd25lcklkIFRoZSBuZXcgb3duZXIgSUQuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBJRCBvZiB0aGUgaXRlbS5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2V0T3duZXI6IGZ1bmN0aW9uIChvd25lcklkLCBmaWx0ZXIsIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBidWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YVF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XHJcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy5zZXRPd25lcixcclxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogc2VsZi5jb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IGZpbHRlcixcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE93bmVyOiBvd25lcklkXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IHN1Y2Nlc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcjogZXJyb3JcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucHJvY2Vzc0RhdGFRdWVyeShkYXRhUXVlcnkpO1xyXG4gICAgICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTYXZlcyB0aGUgcHJvdmlkZWQgZGF0YSBpdGVtLiBUaGlzIG9wZXJhdGlvbiB3aWxsIGNyZWF0ZSBvciB1cGRhdGUgdGhlIGl0ZW0gZGVwZW5kaW5nIG9uIHdoZXRoZXIgaXQgaXMgbmV3IG9yIGV4aXN0aW5nLlxyXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBtZXRob2Qgc2F2ZVxyXG4gICAgICAgICAqIEBuYW1lIHNhdmVcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gaXRlbSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgaXRlbSB0aGF0IGlzIGJlaW5nIHNhdmVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2F2ZXMgdGhlIHByb3ZpZGVkIGRhdGEgaXRlbS4gVGhpcyBvcGVyYXRpb24gd2lsbCBjcmVhdGUgb3IgdXBkYXRlIHRoZSBpdGVtIGRlcGVuZGluZyBvbiB3aGV0aGVyIGl0IGlzIG5ldyBvciBleGlzdGluZy5cclxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAbWV0aG9kIHNhdmVcclxuICAgICAgICAgKiBAbmFtZSBzYXZlXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG1vZGVsIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBpdGVtIHRoYXQgaXMgYmVpbmcgc2F2ZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNhdmU6IGZ1bmN0aW9uIChtb2RlbCwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgaXNOZXcgPSB0aGlzLmlzTmV3KG1vZGVsKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBidWlsZFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzYXZlU3VjY2VzcyhyZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXMudHlwZSA9IGlzTmV3ID8gJ2NyZWF0ZScgOiAndXBkYXRlJztcclxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKHJlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2F2ZUVycm9yKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGVyci50eXBlID0gaXNOZXcgPyAnY3JlYXRlJyA6ICd1cGRhdGUnO1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yKGVycik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGlzTmV3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY3JlYXRlKG1vZGVsLCBzYXZlU3VjY2Vzcywgc2F2ZUVycm9yKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYudXBkYXRlU2luZ2xlKG1vZGVsLCBzYXZlU3VjY2Vzcywgc2F2ZUVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBzcGVjaWZpZWQgZGF0YSBpdGVtIGlzIG5ldyBvciBub3QuXHJcbiAgICAgICAgICogQG1lbWJlck9mIERhdGEucHJvdG90eXBlXHJcbiAgICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgICAqIEBwYXJhbSBtb2RlbCBJdGVtIHRvIGNoZWNrLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlzTmV3OiBmdW5jdGlvbiAobW9kZWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBtb2RlbFtpZEZpZWxkXSA9PT0gJ3VuZGVmaW5lZCc7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gRGF0YTtcclxufSgpKTtcclxuIiwiLyoqXHJcbiAqIEBjbGFzcyBGaWxlc1xyXG4gKiBAcHJvdGVjdGVkXHJcbiAqIEBleHRlbmRzIERhdGFcclxuICovXHJcblxyXG52YXIgYnVpbGRQcm9taXNlID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5idWlsZFByb21pc2U7XHJcbnZhciBEYXRhUXVlcnkgPSByZXF1aXJlKCcuLi9xdWVyeS9EYXRhUXVlcnknKTtcclxudmFyIFJlcXVlc3QgPSByZXF1aXJlKCcuLi9SZXF1ZXN0Jyk7XHJcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cy5hZGRGaWxlc0Z1bmN0aW9ucyA9IGZ1bmN0aW9uIGFkZEZpbGVzRnVuY3Rpb25zKG5zKSB7XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhIFVSTCB0aGF0IGNhbiBiZSB1c2VkIGFzIGFuIGVuZHBvaW50IGZvciB1cGxvYWRpbmcgYSBmaWxlLiBJdCBpcyBzcGVjaWZpYyB0byBlYWNoIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gYXBwLlxyXG4gICAgICogQG1lbWJlcm9mIEZpbGVzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBnZXRVcGxvYWRVcmxcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIG5zLmdldFVwbG9hZFVybCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdXRpbHMuYnVpbGRVcmwodGhpcy5zZXR1cCkgKyB0aGlzLmNvbGxlY3Rpb25OYW1lO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgZG93bmxvYWQgVVJMIGZvciBhIGZpbGUuXHJcbiAgICAgKiBAbWVtYmVyb2YgRmlsZXMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGdldERvd25sb2FkVXJsXHJcbiAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJZCBUaGUgSUQgb2YgdGhlIGZpbGUuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB1cmwgVGhlIGRvd25sb2FkIFVSTC5cclxuICAgICAqL1xyXG4gICAgbnMuZ2V0RG93bmxvYWRVcmwgPSBmdW5jdGlvbiAoZmlsZUlkKSB7XHJcbiAgICAgICAgcmV0dXJuIHV0aWxzLmJ1aWxkVXJsKHRoaXMuc2V0dXApICsgdGhpcy5jb2xsZWN0aW9uTmFtZSArICcvJyArIGZpbGVJZCArICcvRG93bmxvYWQnO1xyXG4gICAgfTtcclxuXHJcbiAgICBucy5fZ2V0VXBkYXRlVXJsID0gZnVuY3Rpb24gKGZpbGVJZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbGxlY3Rpb25OYW1lICsgJy8nICsgZmlsZUlkICsgJy9Db250ZW50JztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYSBVUkwgdGhhdCBjYW4gYmUgdXNlZCBhcyBhbiBlbmRwb2ludCBmb3IgdXBkYXRpbmcgYSBmaWxlLiBJdCBpcyBzcGVjaWZpYyB0byBlYWNoIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gYXBwLlxyXG4gICAgICogQG1lbWJlcm9mIEZpbGVzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBnZXRVcGRhdGVVcmxcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSWQgVGhlIElEIG9mIHRoZSBmaWxlLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gdXJsIFRoZSB1cGRhdGUgVVJMLlxyXG4gICAgICovXHJcbiAgICBucy5nZXRVcGRhdGVVcmwgPSBmdW5jdGlvbiAoZmlsZUlkKSB7XHJcbiAgICAgICAgcmV0dXJuIHV0aWxzLmJ1aWxkVXJsKHRoaXMuc2V0dXApICsgdGhpcy5fZ2V0VXBkYXRlVXJsKGZpbGVJZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBhIGZpbGUncyBjb250ZW50XHJcbiAgICAgKiBAbWVtYmVyb2YgRmlsZXMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZUNvbnRlbnRcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSWQgRmlsZSBJRC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlIEZpbGUgY29udGVudHMgaW4gYmFzZTY0IGVuY29kaW5nLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0XHJcbiAgICAgKi9cclxuICAgIG5zLnVwZGF0ZUNvbnRlbnQgPSBmdW5jdGlvbiAoZmlsZUlkLCBmaWxlLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGFRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy5maWxlc1VwZGF0ZUNvbnRlbnQsXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgcGFzc2VkIGZpbGUgY29udGVudCBpcyBiYXNlNjQgZW5jb2RlZFxyXG4gICAgICAgICAgICAgICAgZGF0YTogZmlsZSxcclxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBzZWxmLmNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgYWRkaXRpb25hbE9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICBpZDogZmlsZUlkXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgb25TdWNjZXNzOiBzdWNjZXNzLFxyXG4gICAgICAgICAgICAgICAgb25FcnJvcjogZXJyb3JcclxuICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHNlbGYucHJvY2Vzc0RhdGFRdWVyeShkYXRhUXVlcnkpO1xyXG4gICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBkb3dubG9hZCBVUkwgZm9yIGEgZmlsZSBieSBJRC5cclxuICAgICAqIEBtZW1iZXJvZiBGaWxlcy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgZ2V0RG93bmxvYWRVcmxCeUlkXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlkIEZpbGUgSUQuXHJcbiAgICAgKiBAcGFyYW0gb3BlcmF0aW9uUGFyYW1ldGVyc1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdFxyXG4gICAgICovXHJcbiAgICBucy5nZXREb3dubG9hZFVybEJ5SWQgPSBmdW5jdGlvbiAoZmlsZUlkLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGFRdWVyeSA9IG5ldyBEYXRhUXVlcnkoe1xyXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBEYXRhUXVlcnkub3BlcmF0aW9ucy5maWxlc0dldERvd25sb2FkVXJsQnlJZCxcclxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBzZWxmLmNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgYWRkaXRpb25hbE9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICBpZDogZmlsZUlkXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcGFyc2U6IFJlcXVlc3QucGFyc2Vycy5zaW5nbGUsXHJcbiAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyhkYXRhLnJlc3VsdC5VcmkpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG9uRXJyb3I6IGVycm9yXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnByb2Nlc3NEYXRhUXVlcnkoZGF0YVF1ZXJ5KTtcclxuICAgICAgICB9LCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9O1xyXG59OyIsIi8qKlxyXG4gKiBAY2xhc3MgVXNlcnNcclxuICogQGV4dGVuZHMgRGF0YVxyXG4gKiBAcHJvdGVjdGVkXHJcbiAqL1xyXG5cclxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcclxudmFyIGJ1aWxkUHJvbWlzZSA9IHV0aWxzLmJ1aWxkUHJvbWlzZTtcclxudmFyIGd1YXJkVW5zZXQgPSB1dGlscy5ndWFyZFVuc2V0O1xyXG52YXIgRGF0YVF1ZXJ5ID0gcmVxdWlyZSgnLi4vcXVlcnkvRGF0YVF1ZXJ5Jyk7XHJcbnZhciBSZXF1ZXN0ID0gcmVxdWlyZSgnLi4vUmVxdWVzdCcpO1xyXG52YXIgXyA9IHJlcXVpcmUoJy4uL2NvbW1vbicpLl87XHJcbnZhciBFdmVybGl2ZUVycm9yID0gcmVxdWlyZSgnLi4vRXZlcmxpdmVFcnJvcicpLkV2ZXJsaXZlRXJyb3I7XHJcbnZhciBFdmVybGl2ZUVycm9ycyA9IHJlcXVpcmUoJy4uL0V2ZXJsaXZlRXJyb3InKS5FdmVybGl2ZUVycm9ycztcclxuXHJcbm1vZHVsZS5leHBvcnRzLmFkZFVzZXJzRnVuY3Rpb25zID0gZnVuY3Rpb24gYWRkVXNlcnNGdW5jdGlvbnMobnMsIGV2ZXJsaXZlKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcnMgYSBuZXcgdXNlciB3aXRoIHVzZXJuYW1lIGFuZCBwYXNzd29yZC5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgcmVnaXN0ZXJcclxuICAgICAqIEBuYW1lIHJlZ2lzdGVyXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcm5hbWUgVGhlIG5ldyB1c2VyJ3MgdXNlcm5hbWUuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIG5ldyB1c2VyJ3MgcGFzc3dvcmQuXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdXNlckluZm8gQWRkaXRpb25hbCBpbmZvcm1hdGlvbiBmb3IgdGhlIHVzZXIgKGV4LiBEaXNwbGF5TmFtZSwgRW1haWwsIGV0Yy4pXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVycyBhIG5ldyB1c2VyIHVzaW5nIGEgdXNlcm5hbWUgYW5kIGEgcGFzc3dvcmQuXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIHJlZ2lzdGVyXHJcbiAgICAgKiBAbmFtZSByZWdpc3RlclxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJuYW1lIFRoZSBuZXcgdXNlcidzIHVzZXJuYW1lLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSBuZXcgdXNlcidzIHBhc3N3b3JkLlxyXG4gICAgICogQHBhcmFtIGF0dHJzXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgbnMucmVnaXN0ZXIgPSBmdW5jdGlvbiAodXNlcm5hbWUsIHBhc3N3b3JkLCBhdHRycywgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICBndWFyZFVuc2V0KHVzZXJuYW1lLCAndXNlcm5hbWUnKTtcclxuICAgICAgICBndWFyZFVuc2V0KHBhc3N3b3JkLCAncGFzc3dvcmQnKTtcclxuICAgICAgICB2YXIgdXNlciA9IHtcclxuICAgICAgICAgICAgVXNlcm5hbWU6IHVzZXJuYW1lLFxyXG4gICAgICAgICAgICBQYXNzd29yZDogcGFzc3dvcmRcclxuICAgICAgICB9O1xyXG4gICAgICAgIF8uZXh0ZW5kKHVzZXIsIGF0dHJzKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUodXNlciwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHVzZXIgdGhhdCBpcyBjdXJyZW50bHkgYXV0aGVudGljYXRlZCB0byB0aGUge3tzaXRlLmJzfX0gSmF2YVNjcmlwdCBTREsuXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGN1cnJlbnRVc2VyXHJcbiAgICAgKiBAbmFtZSBjdXJyZW50VXNlclxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGluZm9ybWF0aW9uIGFib3V0IHRoZSB1c2VyIHRoYXQgaXMgY3VycmVudGx5IGF1dGhlbnRpY2F0ZWQgdG8gdGhlIHt7c2l0ZS5ic319IEphdmFTY3JpcHQgU0RLLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBjdXJyZW50VXNlclxyXG4gICAgICogQG5hbWUgY3VycmVudFVzZXJcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICovXHJcbiAgICBucy5jdXJyZW50VXNlciA9IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICB2YXIgaWQgPSBzZWxmLmV2ZXJsaXZlLl9pc09mZmxpbmVTdG9yYWdlRW5hYmxlZCgpICYmIHNlbGYuZXZlcmxpdmUuaXNPZmZsaW5lKCkgPyBzZWxmLmV2ZXJsaXZlLnNldHVwLnByaW5jaXBhbElkIDogJ21lJztcclxuICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICBpZiAoaWQgPT09ICdtZScgJiYgIXNlbGYuZXZlcmxpdmUuc2V0dXAudG9rZW4gJiYgIXNlbGYuZXZlcmxpdmUuc2V0dXAubWFzdGVyS2V5IHx8ICFpZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3Moe3Jlc3VsdDogbnVsbH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzZWxmLmdldEJ5SWQoaWQpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzLnJlc3VsdCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzcyh7cmVzdWx0OiByZXMucmVzdWx0fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzcyh7cmVzdWx0OiBudWxsfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5ldmVybGl2ZS5hdXRoZW50aWNhdGlvbiAmJiBzZWxmLmV2ZXJsaXZlLmF1dGhlbnRpY2F0aW9uLmlzQXV0aGVudGljYXRpb25JblByb2dyZXNzKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzcyh7cmVzdWx0OiBudWxsfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlcnIuY29kZSA9PT0gNjAxKSB7IC8vIGludmFsaWQgcmVxdWVzdCwgaS5lLiB0aGUgYWNjZXNzIHRva2VuIGlzIG1pc3NpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzcyh7cmVzdWx0OiBudWxsfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlcnIuY29kZSA9PT0gODAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKEV2ZXJsaXZlRXJyb3JzLmludmFsaWRUb2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZXMgdGhlIHBhc3N3b3JkIG9mIGEgdXNlci5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgY2hhbmdlUGFzc3dvcmRcclxuICAgICAqIEBuYW1lIGNoYW5nZVBhc3N3b3JkXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcm5hbWUgVGhlIHVzZXIncyB1c2VybmFtZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgdXNlcidzIHBhc3N3b3JkLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ld1Bhc3N3b3JkIFRoZSB1c2VyJ3MgbmV3IHBhc3N3b3JkLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBrZWVwVG9rZW5zIElmIHNldCB0byB0cnVlLCB0aGUgdXNlciB0b2tlbnMgd2lsbCBiZSBwcmVzZXJ2ZWQgZXZlbiBhZnRlciB0aGUgcGFzc3dvcmQgY2hhbmdlLlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIHRoZSBwYXNzd29yZCBvZiBhIHVzZXIuXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGNoYW5nZVBhc3N3b3JkXHJcbiAgICAgKiBAbmFtZSBjaGFuZ2VQYXNzd29yZFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJuYW1lIFRoZSB1c2VyJ3MgdXNlcm5hbWUuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHVzZXIncyBwYXNzd29yZC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdQYXNzd29yZCBUaGUgdXNlcidzIG5ldyBwYXNzd29yZC5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0ga2VlcFRva2VucyBJZiBzZXQgdG8gdHJ1ZSwgdGhlIHVzZXIgdG9rZW5zIHdpbGwgYmUgcHJlc2VydmVkIGV2ZW4gYWZ0ZXIgdGhlIHBhc3N3b3JkIGNoYW5nZS5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICovXHJcbiAgICBucy5jaGFuZ2VQYXNzd29yZCA9IGZ1bmN0aW9uICh1c2VybmFtZSwgcGFzc3dvcmQsIG5ld1Bhc3N3b3JkLCBrZWVwVG9rZW5zLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICBzdWNjZXNzID0gXy53cmFwKHN1Y2Nlc3MsIGZ1bmN0aW9uIChzdWNjZXNzLCBkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLnJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgha2VlcFRva2Vucykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBucy5jbGVhckF1dGhvcml6YXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VjY2VzcyhkYXRhKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgZGF0YVF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJDaGFuZ2VQYXNzd29yZCxcclxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25OYW1lOiBzZWxmLmNvbGxlY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgICAgIFVzZXJuYW1lOiB1c2VybmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBQYXNzd29yZDogcGFzc3dvcmQsXHJcbiAgICAgICAgICAgICAgICAgICAgTmV3UGFzc3dvcmQ6IG5ld1Bhc3N3b3JkXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgYWRkaXRpb25hbE9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICBrZWVwVG9rZW5zOiBrZWVwVG9rZW5zXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc2tpcEF1dGg6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IHN1Y2Nlc3MsXHJcbiAgICAgICAgICAgICAgICBvbkVycm9yOiBlcnJvclxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnByb2Nlc3NEYXRhUXVlcnkoZGF0YVF1ZXJ5KVxyXG4gICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBMb2dzIGluIGEgdXNlciB1c2luZyBhIHVzZXJuYW1lIGFuZCBhIHBhc3N3b3JkIHRvIHRoZSBjdXJyZW50IHt7c2l0ZS5ic319IEphdmFTY3JpcHQgU0RLIGluc3RhbmNlLiBBbGwgcmVxdWVzdHMgaW5pdGlhdGVkIGJ5IHRoZSBjdXJyZW50IHt7c2l0ZS5ic319IEphdmFTY3JpcHQgU0RLIGluc3RhbmNlIHdpbGwgYmUgYXV0aGVudGljYXRlZCB3aXRoIHRoYXQgdXNlcidzIGNyZWRlbnRpYWxzLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsb2dpblxyXG4gICAgICogQG5hbWUgbG9naW5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VybmFtZSBUaGUgdXNlcidzIHVzZXJuYW1lLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSB1c2VyJ3MgcGFzc3dvcmQuXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIExvZ3MgaW4gYSB1c2VyIHVzaW5nIGEgdXNlcm5hbWUgYW5kIGEgcGFzc3dvcmQgdG8gdGhlIGN1cnJlbnQge3tzaXRlLmJzfX0gSmF2YVNjcmlwdCBTREsgaW5zdGFuY2UuIEFsbCByZXF1ZXN0cyBpbml0aWF0ZWQgYnkgdGhlIGN1cnJlbnQge3tzaXRlLmJzfX0gSmF2YVNjcmlwdCBTREsgaW5zdGFuY2Ugd2lsbCBiZSBhdXRoZW50aWNhdGVkIHdpdGggdGhhdCB1c2VyJ3MgY3JlZGVudGlhbHMuXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxvZ2luXHJcbiAgICAgKiBAbmFtZSBsb2dpblxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VybmFtZSBUaGUgdXNlcidzIHVzZXJuYW1lLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSB1c2VyJ3MgcGFzc3dvcmQuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgbnMubG9naW4gPSBmdW5jdGlvbiAodXNlcm5hbWUsIHBhc3N3b3JkLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHJldHVybiBldmVybGl2ZS5hdXRoZW50aWNhdGlvbi5sb2dpbih1c2VybmFtZSwgcGFzc3dvcmQsIHN1Y2Nlc3MsIGVycm9yKTtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9nIG91dCB0aGUgdXNlciB3aG8gaXMgY3VycmVudGx5IGxvZ2dlZCBpbi5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbG9nb3V0XHJcbiAgICAgKiBAbmFtZSBsb2dvdXRcclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIExvZyBvdXQgdGhlIHVzZXIgd2hvIGlzIGN1cnJlbnRseSBsb2dnZWQgaW4uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxvZ291dFxyXG4gICAgICogQG5hbWUgbG9nb3V0XHJcbiAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIG5zLmxvZ291dCA9IGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHJldHVybiBldmVybGl2ZS5hdXRoZW50aWNhdGlvbi5sb2dvdXQoc3VjY2VzcywgZXJyb3IpO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgaW4gYSB1c2VyIHVzaW5nIGFuIEZhY2Vib29rIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbG9naW5XaXRoRmFjZWJvb2tcclxuICAgICAqIEBuYW1lIGxvZ2luV2l0aEZhY2Vib29rXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gRmFjZWJvb2sgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgaW4gYSB1c2VyIHVzaW5nIGFuIEZhY2Vib29rIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbG9naW5XaXRoRmFjZWJvb2tcclxuICAgICAqIEBuYW1lIGxvZ2luV2l0aEZhY2Vib29rXHJcbiAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY2Vzc1Rva2VuIEZhY2Vib29rIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICovXHJcbiAgICBucy5sb2dpbldpdGhGYWNlYm9vayA9IGZ1bmN0aW9uIChhY2Nlc3NUb2tlbiwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gZXZlcmxpdmUuYXV0aGVudGljYXRpb24ubG9naW5XaXRoRmFjZWJvb2soYWNjZXNzVG9rZW4sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaW5rcyBhIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gdXNlciBhY2NvdW50IHRvIGEgRmFjZWJvb2sgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsaW5rV2l0aEZhY2Vib29rXHJcbiAgICAgKiBAbmFtZSBsaW5rV2l0aEZhY2Vib29rXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIFRoZSB1c2VyJ3MgSUQgaW4ge3tzaXRlLmJzfX0uXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gVGhlIEZhY2Vib29rIGFjY2VzcyB0b2tlbiB0aGF0IHdpbGwgYmUgbGlua2VkIHRvIHRoZSB7e3NpdGUuYnN9fSB1c2VyIGFjY291bnQuXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIExpbmtzIGEgQmFja2VuZCBTZXJ2aWNlcyB1c2VyIHdpdGggYSBGYWNlYm9vayBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxpbmtXaXRoRmFjZWJvb2tcclxuICAgICAqIEBuYW1lIGxpbmtXaXRoRmFjZWJvb2tcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBUaGUgRmFjZWJvb2sgYWNjZXNzIHRva2VuIHRoYXQgd2lsbCBiZSBsaW5rZWQgdG8gdGhlIHt7c2l0ZS5ic319IHVzZXIgYWNjb3VudC4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBhIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgbnMubGlua1dpdGhGYWNlYm9vayA9IGZ1bmN0aW9uICh1c2VySWQsIGFjY2Vzc1Rva2VuLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHZhciBpZGVudGl0eSA9IHtcclxuICAgICAgICAgICAgUHJvdmlkZXI6ICdGYWNlYm9vaycsXHJcbiAgICAgICAgICAgIFRva2VuOiBhY2Nlc3NUb2tlblxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIG5zLl9saW5rV2l0aFByb3ZpZGVyKGlkZW50aXR5LCB1c2VySWQsIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVbmxpbmtzIGEge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSB1c2VyIGFjY291bnQgZnJvbSB0aGUgRmFjZWJvb2sgdG9rZW4gdGhhdCBpdCBpcyBsaW5rZWQgdG8uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIHVubGlua0Zyb21GYWNlYm9va1xyXG4gICAgICogQG5hbWUgdW5saW5rRnJvbUZhY2Vib29rXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIFRoZSB1c2VyJ3MgSUQgaW4ge3tzaXRlLmJzfX0uXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIFVubGlua3MgYSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IHVzZXIgYWNjb3VudCBmcm9tIHRoZSBGYWNlYm9vayB0b2tlbiB0aGF0IGl0IGlzIGxpbmtlZCB0by5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgdW5saW5rRnJvbUZhY2Vib29rXHJcbiAgICAgKiBAbmFtZSB1bmxpbmtGcm9tRmFjZWJvb2tcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICovXHJcbiAgICBucy51bmxpbmtGcm9tRmFjZWJvb2sgPSBmdW5jdGlvbiAodXNlcklkLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHJldHVybiBucy5fdW5saW5rRnJvbVByb3ZpZGVyKCdGYWNlYm9vaycsIHVzZXJJZCwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExvZyBpbiBhIHVzZXIgdXNpbmcgYW4gQURGUyBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxvZ2luV2l0aEFERlNcclxuICAgICAqIEBuYW1lIGxvZ2luV2l0aEFERlNcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBBREZTIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogTG9nIGluIGEgdXNlciB1c2luZyBhbiBBREZTIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbG9naW5XaXRoQURGU1xyXG4gICAgICogQG5hbWUgbG9naW5XaXRoQURGU1xyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBBREZTIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICovXHJcbiAgICBucy5sb2dpbldpdGhBREZTID0gZnVuY3Rpb24gKGFjY2Vzc1Rva2VuLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHJldHVybiBldmVybGl2ZS5hdXRoZW50aWNhdGlvbi5sb2dpbldpdGhBREZTKGFjY2Vzc1Rva2VuLCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGlua3MgYSB7e3NpdGUuVGVsZXJpa0JhY2tlbmRTZXJ2aWNlc319IHVzZXIgYWNjb3VudCB0byBhbiBBREZTIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbGlua1dpdGhBREZTXHJcbiAgICAgKiBAbmFtZSBsaW5rV2l0aEFERlNcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBUaGUgQURGUyBhY2Nlc3MgdG9rZW4gdGhhdCB3aWxsIGJlIGxpbmtlZCB0byB0aGUge3tzaXRlLmJzfX0gdXNlciBhY2NvdW50LlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBMaW5rcyBhIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gdXNlciBhY2NvdW50IHRvIGFuIEFERlMgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsaW5rV2l0aEFERlNcclxuICAgICAqIEBuYW1lIGxpbmtXaXRoQURGU1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY2Vzc1Rva2VuIFRoZSBBREZTIGFjY2VzcyB0b2tlbiB0aGF0IHdpbGwgYmUgbGlua2VkIHRvIHRoZSB7e3NpdGUuYnN9fSB1c2VyIGFjY291bnQuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgbnMubGlua1dpdGhBREZTID0gZnVuY3Rpb24gKHVzZXJJZCwgYWNjZXNzVG9rZW4sIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdmFyIGlkZW50aXR5ID0ge1xyXG4gICAgICAgICAgICBQcm92aWRlcjogJ0FERlMnLFxyXG4gICAgICAgICAgICBUb2tlbjogYWNjZXNzVG9rZW5cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBucy5fbGlua1dpdGhQcm92aWRlcihpZGVudGl0eSwgdXNlcklkLCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVW5saW5rcyBhIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gdXNlciBhY2NvdW50IGZyb20gdGhlIEFERlMgdG9rZW4gdGhhdCBpdCBpcyBsaW5rZWQgdG8uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIHVubGlua0Zyb21BREZTXHJcbiAgICAgKiBAbmFtZSB1bmxpbmtGcm9tQURGU1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBVbmxpbmtzIGEge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSB1c2VyIGFjY291bnQgZnJvbSB0aGUgQURGUyB0b2tlbiB0aGF0IGl0IGlzIGxpbmtlZCB0by5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgdW5saW5rRnJvbUFERlNcclxuICAgICAqIEBuYW1lIHVubGlua0Zyb21BREZTXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIFRoZSB1c2VyJ3MgSUQgaW4ge3tzaXRlLmJzfX0uXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgbnMudW5saW5rRnJvbUFERlMgPSBmdW5jdGlvbiAodXNlcklkLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHJldHVybiBucy5fdW5saW5rRnJvbVByb3ZpZGVyKCdBREZTJywgdXNlcklkLCBzdWNjZXNzLCBlcnJvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9nIGluIGEgdXNlciB1c2luZyBhIExpdmVJRCBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxvZ2luV2l0aExpdmVJRFxyXG4gICAgICogQG5hbWUgbG9naW5XaXRoTGl2ZUlEXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gTGl2ZUlEIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogTG9nIGluIGEgdXNlciB1c2luZyBhIExpdmVJRCBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIGxvZ2luV2l0aExpdmVJRFxyXG4gICAgICogQG5hbWUgbG9naW5XaXRoTGl2ZUlEXHJcbiAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjY2Vzc1Rva2VuIExpdmVJRCBhY2Nlc3MgdG9rZW4uXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgbnMubG9naW5XaXRoTGl2ZUlEID0gZnVuY3Rpb24gKGFjY2Vzc1Rva2VuLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHJldHVybiBldmVybGl2ZS5hdXRoZW50aWNhdGlvbi5sb2dpbldpdGhMaXZlSUQoYWNjZXNzVG9rZW4sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaW5rcyBhIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gdXNlciBhY2NvdW50IHRvIGEgTGl2ZUlkIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbGlua1dpdGhMaXZlSURcclxuICAgICAqIEBuYW1lIGxpbmtXaXRoTGl2ZUlEXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIFRoZSB1c2VyJ3MgSUQgaW4ge3tzaXRlLmJzfX0uXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gVGhlIExpdmVJRCBhY2Nlc3MgdG9rZW4gdGhhdCB3aWxsIGJlIGxpbmtlZCB0byB0aGUge3tzaXRlLmJzfX0gdXNlciBhY2NvdW50LlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBMaW5rcyBhIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gdXNlciBhY2NvdW50IHRvIGEgTGl2ZUlkIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbGlua1dpdGhMaXZlSURcclxuICAgICAqIEBuYW1lIGxpbmtXaXRoTGl2ZUlEXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkIFRoZSB1c2VyJ3MgSUQgaW4ge3tzaXRlLmJzfX0uXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gVGhlIExpdmVJRCBhY2Nlc3MgdG9rZW4gdGhhdCB3aWxsIGJlIGxpbmtlZCB0byB0aGUge3tzaXRlLmJzfX0gdXNlciBhY2NvdW50LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIG5zLmxpbmtXaXRoTGl2ZUlEID0gZnVuY3Rpb24gKHVzZXJJZCwgYWNjZXNzVG9rZW4sIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgdmFyIGlkZW50aXR5ID0ge1xyXG4gICAgICAgICAgICBQcm92aWRlcjogJ0xpdmVJRCcsXHJcbiAgICAgICAgICAgIFRva2VuOiBhY2Nlc3NUb2tlblxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIG5zLl9saW5rV2l0aFByb3ZpZGVyKGlkZW50aXR5LCB1c2VySWQsIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVbmxpbmtzIGEge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSB1c2VyIGFjY291bnQgZnJvbSB0aGUgTGl2ZUlEIGFjY2VzcyB0b2tlbiB0aGF0IGl0IGlzIGxpbmtlZCB0by5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgdW5saW5rRnJvbUxpdmVJRFxyXG4gICAgICogQG5hbWUgdW5saW5rRnJvbUxpdmVJRFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBVbmxpbmtzIGEge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSB1c2VyIGFjY291bnQgZnJvbSB0aGUgTGl2ZUlEIGFjY2VzcyB0b2tlbiB0aGF0IGl0IGlzIGxpbmtlZCB0by5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgdW5saW5rRnJvbUxpdmVJRFxyXG4gICAgICogQG5hbWUgdW5saW5rRnJvbUxpdmVJRFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIG5zLnVubGlua0Zyb21MaXZlSUQgPSBmdW5jdGlvbiAodXNlcklkLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHJldHVybiBucy5fdW5saW5rRnJvbVByb3ZpZGVyKCdMaXZlSUQnLCB1c2VySWQsIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgaW4gYSB1c2VyIHVzaW5nIGEgR29vZ2xlIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbG9naW5XaXRoR29vZ2xlXHJcbiAgICAgKiBAbmFtZSBsb2dpbldpdGhHb29nbGVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBHb29nbGUgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgaW4gYSB1c2VyIHVzaW5nIGEgR29vZ2xlIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbG9naW5XaXRoR29vZ2xlXHJcbiAgICAgKiBAbmFtZSBsb2dpbldpdGhHb29nbGVcclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gR29vZ2xlIGFjY2VzcyB0b2tlbi5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICovXHJcbiAgICBucy5sb2dpbldpdGhHb29nbGUgPSBmdW5jdGlvbiAoYWNjZXNzVG9rZW4sIHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGV2ZXJsaXZlLmF1dGhlbnRpY2F0aW9uLmxvZ2luV2l0aEdvb2dsZShhY2Nlc3NUb2tlbiwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExpbmtzIGEge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSB1c2VyIGFjY291bnQgdG8gYSBHb29nbGUgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsaW5rV2l0aEdvb2dsZVxyXG4gICAgICogQG5hbWUgbGlua1dpdGhHb29nbGVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBUaGUgR29vZ2xlIGFjY2VzcyB0b2tlbiB0aGF0IHdpbGwgYmUgbGlua2VkIHRvIHRoZSB7e3NpdGUuYnN9fSB1c2VyIGFjY291bnQuXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIExpbmtzIGEge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSB1c2VyIGFjY291bnQgdG8gYSBHb29nbGUgYWNjZXNzIHRva2VuLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsaW5rV2l0aEdvb2dsZVxyXG4gICAgICogQG5hbWUgbGlua1dpdGhHb29nbGVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySWQgVGhlIHVzZXIncyBJRCBpbiB7e3NpdGUuYnN9fS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBUaGUgR29vZ2xlIGFjY2VzcyB0b2tlbiB0aGF0IHdpbGwgYmUgbGlua2VkIHRvIHRoZSB7e3NpdGUuYnN9fSB1c2VyIGFjY291bnQuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc3VjY2Vzc10gQSBzdWNjZXNzIGNhbGxiYWNrLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vycm9yXSBBbiBlcnJvciBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgbnMubGlua1dpdGhHb29nbGUgPSBmdW5jdGlvbiAodXNlcklkLCBhY2Nlc3NUb2tlbiwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB2YXIgaWRlbnRpdHkgPSB7XHJcbiAgICAgICAgICAgIFByb3ZpZGVyOiAnR29vZ2xlJyxcclxuICAgICAgICAgICAgVG9rZW46IGFjY2Vzc1Rva2VuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5zLl9saW5rV2l0aFByb3ZpZGVyKGlkZW50aXR5LCB1c2VySWQsIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVbmxpbmtzIGEge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSB1c2VyIGFjY291bnQgZnJvbSB0aGUgR29vZ2xlIGFjY2VzcyB0b2tlbiB0aGF0IGl0IGlzIGxpbmtlZCB0by5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgdW5saW5rRnJvbUdvb2dsZVxyXG4gICAgICogQG5hbWUgdW5saW5rRnJvbUdvb2dsZVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBVbmxpbmtzIGEge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSB1c2VyIGFjY291bnQgZnJvbSB0aGUgR29vZ2xlIGFjY2VzcyB0b2tlbiB0aGF0IGl0IGlzIGxpbmtlZCB0by5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgdW5saW5rRnJvbUdvb2dsZVxyXG4gICAgICogQG5hbWUgdW5saW5rRnJvbUdvb2dsZVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIG5zLnVubGlua0Zyb21Hb29nbGUgPSBmdW5jdGlvbiAodXNlcklkLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgIHJldHVybiBucy5fdW5saW5rRnJvbVByb3ZpZGVyKCdHb29nbGUnLCB1c2VySWQsIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2cgaW4gYSB1c2VyIHdpdGggYSBUd2l0dGVyIHRva2VuLiBBIHNlY3JldCB0b2tlbiBuZWVkcyB0byBiZSBwcm92aWRlZC5cclxuICAgICAqIEBtZW1iZXJPZiBVc2Vycy5wcm90b3R5cGVcclxuICAgICAqIEBtZXRob2QgbG9naW5XaXRoVHdpdHRlclxyXG4gICAgICogQG5hbWUgbG9naW5XaXRoVHdpdHRlclxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIFR3aXR0ZXIgdG9rZW4uXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5TZWNyZXQgVHdpdHRlciBzZWNyZXQgdG9rZW4uXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIExvZyBpbiBhIHVzZXIgd2l0aCBhIFR3aXR0ZXIgdG9rZW4uIEEgc2VjcmV0IHRva2VuIG5lZWRzIHRvIGJlIHByb3ZpZGVkLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsb2dpbldpdGhUd2l0dGVyXHJcbiAgICAgKiBAbmFtZSBsb2dpbldpdGhUd2l0dGVyXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gVHdpdHRlciB0b2tlbi5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlblNlY3JldCBUd2l0dGVyIHNlY3JldCB0b2tlbi5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtzdWNjZXNzXSBBIHN1Y2Nlc3MgY2FsbGJhY2suXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyb3JdIEFuIGVycm9yIGNhbGxiYWNrLlxyXG4gICAgICovXHJcbiAgICBucy5sb2dpbldpdGhUd2l0dGVyID0gZnVuY3Rpb24gKHRva2VuLCB0b2tlblNlY3JldCwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gZXZlcmxpdmUuYXV0aGVudGljYXRpb24ubG9naW5XaXRoVHdpdHRlcih0b2tlbiwgdG9rZW5TZWNyZXQsIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaW5rcyBhIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gdXNlciB0byBhIFR3aXR0ZXIgdG9rZW4uIEEgc2VjcmV0IHRva2VuIG5lZWRzIHRvIGJlIHByb3ZpZGVkLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsaW5rV2l0aFR3aXR0ZXJcclxuICAgICAqIEBuYW1lIGxpbmtXaXRoVHdpdHRlclxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIFRoZSBUd2l0dGVyIGFjY2VzcyB0b2tlbiB0aGF0IHdpbGwgYmUgbGlua2VkIHRvIHRoZSB7e3NpdGUuYnN9fSB1c2VyIGFjY291bnQuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5TZWNyZXQgVGhlIFR3aXR0ZXIgc2VjcmV0IHRva2VuLlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBMaW5rcyBhIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gdXNlciB0byBhIFR3aXR0ZXIgdG9rZW4uIEEgc2VjcmV0IHRva2VuIG5lZWRzIHRvIGJlIHByb3ZpZGVkLiAgICAgICAgICogTGlua3MgYSBCYWNrZW5kIFNlcnZpY2VzIHVzZXIgd2l0aCBhIFR3aXR0ZXIgdG9rZW4uIEEgc2VjcmV0IHRva2VuIG5lZWRzIHRvIGJlIHByb3ZpZGVkLlxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICogQG1ldGhvZCBsaW5rV2l0aFR3aXR0ZXJcclxuICAgICAqIEBuYW1lIGxpbmtXaXRoVHdpdHRlclxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIFRoZSBUd2l0dGVyIGFjY2VzcyB0b2tlbiB0aGF0IHdpbGwgYmUgbGlua2VkIHRvIHRoZSB7e3NpdGUuYnN9fSB1c2VyIGFjY291bnQuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5TZWNyZXQgVGhlIFR3aXR0ZXIgc2VjcmV0IHRva2VuLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIG5zLmxpbmtXaXRoVHdpdHRlciA9IGZ1bmN0aW9uICh1c2VySWQsIHRva2VuLCB0b2tlblNlY3JldCwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB2YXIgaWRlbnRpdHkgPSB7XHJcbiAgICAgICAgICAgIFByb3ZpZGVyOiAnVHdpdHRlcicsXHJcbiAgICAgICAgICAgIFRva2VuOiB0b2tlbixcclxuICAgICAgICAgICAgVG9rZW5TZWNyZXQ6IHRva2VuU2VjcmV0XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5zLl9saW5rV2l0aFByb3ZpZGVyKGlkZW50aXR5LCB1c2VySWQsIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVbmxpbmtzIGEge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSB1c2VyIGFjY291bnQgZnJvbSB0aGUgVHdpdHRlciBhY2Nlc3MgdG9rZW4gdGhhdCBpdCBpcyBsaW5rZWQgdG8uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIHVubGlua0Zyb21Ud2l0dGVyXHJcbiAgICAgKiBAbmFtZSB1bmxpbmtGcm9tVHdpdHRlclxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBVbmxpbmtzIGEge3tzaXRlLlRlbGVyaWtCYWNrZW5kU2VydmljZXN9fSB1c2VyIGFjY291bnQgZnJvbSB0aGUgVHdpdHRlciBhY2Nlc3MgdG9rZW4gdGhhdCBpdCBpcyBsaW5rZWQgdG8uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIHVubGlua0Zyb21Ud2l0dGVyXHJcbiAgICAgKiBAbmFtZSB1bmxpbmtGcm9tVHdpdHRlclxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCBUaGUgdXNlcidzIElEIGluIHt7c2l0ZS5ic319LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3N1Y2Nlc3NdIEEgc3VjY2VzcyBjYWxsYmFjay5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJvcl0gQW4gZXJyb3IgY2FsbGJhY2suXHJcbiAgICAgKi9cclxuICAgIG5zLnVubGlua0Zyb21Ud2l0dGVyID0gZnVuY3Rpb24gKHVzZXJJZCwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gbnMuX3VubGlua0Zyb21Qcm92aWRlcignVHdpdHRlcicsIHVzZXJJZCwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHRva2VuIGFuZCB0b2tlbiB0eXBlIHRoYXQgdGhlIHt7c2l0ZS5UZWxlcmlrQmFja2VuZFNlcnZpY2VzfX0gSmF2YVNjcmlwdCBTREsgd2lsbCB1c2UgZm9yIGF1dGhvcml6YXRpb24uXHJcbiAgICAgKiBAbWVtYmVyT2YgVXNlcnMucHJvdG90eXBlXHJcbiAgICAgKiBAbWV0aG9kIHNldEF1dGhvcml6YXRpb25cclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gVG9rZW4gdGhhdCB3aWxsIGJlIHVzZWQgZm9yIGF1dGhvcml6YXRpb24uXHJcbiAgICAgKiBAcGFyYW0ge0V2ZXJsaXZlLlRva2VuVHlwZX0gdG9rZW5UeXBlIFRva2VuIHR5cGUuIEN1cnJlbnRseSBvbmx5ICdiZWFyZXInIHRva2VuIGlzIHN1cHBvcnRlZC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcmluY2lwYWxJZCBUaGUgaWQgb2YgdGhlIHVzZXIgdGhhdCBpcyBsb2dnZWQgaW4uXHJcbiAgICAgKi9cclxuICAgIG5zLnNldEF1dGhvcml6YXRpb24gPSBmdW5jdGlvbiBzZXRBdXRob3JpemF0aW9uKHRva2VuLCB0b2tlblR5cGUsIHByaW5jaXBhbElkKSB7XHJcbiAgICAgICAgZXZlcmxpdmUuYXV0aGVudGljYXRpb24uc2V0QXV0aG9yaXphdGlvbih0b2tlbiwgdG9rZW5UeXBlLCBwcmluY2lwYWxJZClcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgdGhlIGF1dGhlbnRpY2F0aW9uIHRva2VuIHRoYXQgdGhlIHt7c2l0ZS5ic319IEphdmFTY3JpcHQgU0RLIGN1cnJlbnRseSB1c2VzLiBOb3RlIHRoYXQgdGhpcyBpcyBkaWZmZXJlbnQgdGhhbiBsb2dnaW5nIG91dCwgYmVjYXVzZSB0aGUgY3VycmVudCBhdXRob3JpemF0aW9uIHRva2VuIGlzIG5vdCBpbnZhbGlkYXRlZC5cclxuICAgICAqIEBtZXRob2QgY2xlYXJBdXRob3JpemF0aW9uXHJcbiAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICogQG1lbWJlck9mIFVzZXJzLnByb3RvdHlwZVxyXG4gICAgICovXHJcbiAgICBucy5jbGVhckF1dGhvcml6YXRpb24gPSBmdW5jdGlvbiBjbGVhckF1dGhvcml6YXRpb24oKSB7XHJcbiAgICAgICAgZXZlcmxpdmUuYXV0aGVudGljYXRpb24uc2V0QXV0aG9yaXphdGlvbihudWxsLCBudWxsLCBudWxsKTtcclxuICAgIH07XHJcblxyXG4gICAgbnMuX2xpbmtXaXRoUHJvdmlkZXIgPSBmdW5jdGlvbiAoaWRlbnRpdHksIHVzZXJJZCwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIGJ1aWxkUHJvbWlzZShmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gbmV3IERhdGFRdWVyeSh7XHJcbiAgICAgICAgICAgICAgICBhZGRpdGlvbmFsT3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkOiB1c2VySWRcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJMaW5rV2l0aFByb3ZpZGVyLFxyXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbk5hbWU6IHNlbGYuY29sbGVjdGlvbk5hbWUsXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBpZGVudGl0eSxcclxuICAgICAgICAgICAgICAgIHBhcnNlOiBSZXF1ZXN0LnBhcnNlcnMuc2luZ2xlLFxyXG4gICAgICAgICAgICAgICAgc2tpcEF1dGg6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IHN1Y2Nlc3MsXHJcbiAgICAgICAgICAgICAgICBvbkVycm9yOiBlcnJvclxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnByb2Nlc3NEYXRhUXVlcnkocXVlcnkpO1xyXG4gICAgICAgIH0sIHN1Y2Nlc3MsIGVycm9yKTtcclxuICAgIH07XHJcblxyXG4gICAgbnMuX3VubGlua0Zyb21Qcm92aWRlciA9IGZ1bmN0aW9uIChwcm92aWRlck5hbWUsIHVzZXJJZCwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgICAgICB2YXIgaWRlbnRpdHkgPSB7XHJcbiAgICAgICAgICAgIFByb3ZpZGVyOiBwcm92aWRlck5hbWVcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICByZXR1cm4gYnVpbGRQcm9taXNlKGZ1bmN0aW9uIChzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgcXVlcnkgPSBuZXcgRGF0YVF1ZXJ5KHtcclxuICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxPcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXNlcklkOiB1c2VySWRcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IERhdGFRdWVyeS5vcGVyYXRpb25zLnVzZXJVbmxpbmtGcm9tUHJvdmlkZXIsXHJcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTmFtZTogc2VsZi5jb2xsZWN0aW9uTmFtZSxcclxuICAgICAgICAgICAgICAgIGRhdGE6IGlkZW50aXR5LFxyXG4gICAgICAgICAgICAgICAgcGFyc2U6IFJlcXVlc3QucGFyc2Vycy5zaW5nbGUsXHJcbiAgICAgICAgICAgICAgICBza2lwQXV0aDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIG9uU3VjY2Vzczogc3VjY2VzcyxcclxuICAgICAgICAgICAgICAgIG9uRXJyb3I6IGVycm9yXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHNlbGYucHJvY2Vzc0RhdGFRdWVyeShxdWVyeSk7XHJcbiAgICAgICAgfSwgc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgfTtcclxufTsiLCJ2YXIgRXZlcmxpdmVFcnJvciA9IHJlcXVpcmUoJy4vRXZlcmxpdmVFcnJvcicpLkV2ZXJsaXZlRXJyb3I7XHJcbnZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xyXG52YXIgXyA9IGNvbW1vbi5fO1xyXG52YXIgcnN2cCA9IGNvbW1vbi5yc3ZwO1xyXG52YXIgRXZlcmxpdmUgPSByZXF1aXJlKCcuL0V2ZXJsaXZlJyk7XHJcbnZhciBpc05vZGVqcyA9IHJlcXVpcmUoJy4vZXZlcmxpdmUucGxhdGZvcm0nKS5pc05vZGVqcztcclxuXHJcbnZhciB1dGlscyA9IHt9O1xyXG5cclxudXRpbHMuZ3VhcmRVbnNldCA9IGZ1bmN0aW9uIGd1YXJkVW5zZXQodmFsdWUsIG5hbWUsIG1lc3NhZ2UpIHtcclxuICAgIGlmICghbWVzc2FnZSkge1xyXG4gICAgICAgIG1lc3NhZ2UgPSAnVGhlICcgKyBuYW1lICsgJyBpcyByZXF1aXJlZCc7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyB8fCB2YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFdmVybGl2ZUVycm9yKG1lc3NhZ2UpO1xyXG4gICAgfVxyXG59O1xyXG5cclxudXRpbHMucGFyc2VVdGlsaXRpZXMgPSB7XHJcbiAgICBnZXRSZXZpdmVyOiBmdW5jdGlvbiAocGFyc2VPbmx5Q29tcGxldGVEYXRlVGltZVN0cmluZykge1xyXG4gICAgICAgIHZhciBkYXRlUGFyc2VyO1xyXG4gICAgICAgIGlmIChwYXJzZU9ubHlDb21wbGV0ZURhdGVUaW1lU3RyaW5nKSB7XHJcbiAgICAgICAgICAgIGRhdGVQYXJzZXIgPSB1dGlscy5wYXJzZVV0aWxpdGllcy5wYXJzZUlzb0RhdGVTdHJpbmc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZGF0ZVBhcnNlciA9IHV0aWxzLnBhcnNlVXRpbGl0aWVzLnBhcnNlT25seUNvbXBsZXRlRGF0ZVRpbWVTdHJpbmc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRlID0gZGF0ZVBhcnNlcih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZGF0ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgcGFyc2VJc29EYXRlU3RyaW5nOiBmdW5jdGlvbiAoc3RyaW5nKSB7XHJcbiAgICAgICAgdmFyIG1hdGNoO1xyXG4gICAgICAgIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaCgvXihcXGR7NH0pKC0oXFxkezJ9KSgtKFxcZHsyfSkoVChcXGR7Mn0pOihcXGR7Mn0pKDooXFxkezJ9KShcXC4oXFxkKykpPyk/KFp8KChcXCt8LSkoXFxkezJ9KTooXFxkezJ9KSkpKT8pKSQvKSkge1xyXG4gICAgICAgICAgICAvLyBEYXRlVGltZVxyXG4gICAgICAgICAgICB2YXIgc2Vjb25kUGFydHMgPSBtYXRjaFsxMl07XHJcbiAgICAgICAgICAgIGlmIChzZWNvbmRQYXJ0cykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlY29uZFBhcnRzLmxlbmd0aCA+IDMpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWNvbmRQYXJ0cyA9IE1hdGgucm91bmQoTnVtYmVyKHNlY29uZFBhcnRzLnN1YnN0cigwLCAzKSArICcuJyArIHNlY29uZFBhcnRzLnN1YnN0cigzKSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2Vjb25kUGFydHMubGVuZ3RoIDwgMykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBzZWNvbmRQYXJ0cyBhcmUgb25lIG9yIHR3byBjaGFyYWN0ZXJzIHRoZW4gdHdvIG9yIG9uZSB6ZXJvcyBzaG91bGQgYmUgYXBwZW5kZWRcclxuICAgICAgICAgICAgICAgICAgICAvLyBpbiBvcmRlciB0byBoYXZlIHRoZSBjb3JyZWN0IG51bWJlciBmb3IgbWlsbGlzZWNvbmRzICgnLjY3JyBtZWFucyA2NzBtcyBub3QgNjdtcylcclxuICAgICAgICAgICAgICAgICAgICBzZWNvbmRQYXJ0cyArPSBzZWNvbmRQYXJ0cy5sZW5ndGggPT09IDIgPyAnMCcgOiAnMDAnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoXHJcbiAgICAgICAgICAgICAgICBEYXRlLlVUQyhcclxuICAgICAgICAgICAgICAgICAgICBOdW1iZXIobWF0Y2hbMV0pLCAvLyB5ZWFyXHJcbiAgICAgICAgICAgICAgICAgICAgKE51bWJlcihtYXRjaFszXSkgLSAxKSB8fCAwLCAvLyBtb250aFxyXG4gICAgICAgICAgICAgICAgICAgIE51bWJlcihtYXRjaFs1XSkgfHwgMCwgLy8gZGF5XHJcbiAgICAgICAgICAgICAgICAgICAgTnVtYmVyKG1hdGNoWzddKSB8fCAwLCAvLyBob3VyXHJcbiAgICAgICAgICAgICAgICAgICAgTnVtYmVyKG1hdGNoWzhdKSB8fCAwLCAvLyBtaW51dGVcclxuICAgICAgICAgICAgICAgICAgICBOdW1iZXIobWF0Y2hbMTBdKSB8fCAwLCAvLyBzZWNvbmRcclxuICAgICAgICAgICAgICAgICAgICBOdW1iZXIoc2Vjb25kUGFydHMpIHx8IDBcclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChtYXRjaFsxM10gJiYgbWF0Y2hbMTNdICE9PSBcIlpcIikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGggPSBOdW1iZXIobWF0Y2hbMTZdKSB8fCAwLFxyXG4gICAgICAgICAgICAgICAgICAgIG0gPSBOdW1iZXIobWF0Y2hbMTddKSB8fCAwO1xyXG5cclxuICAgICAgICAgICAgICAgIGggKj0gMzYwMDAwMDtcclxuICAgICAgICAgICAgICAgIG0gKj0gNjAwMDA7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IGggKyBtO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoWzE1XSA9PT0gXCIrXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gLW9mZnNldDtcclxuXHJcbiAgICAgICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoZGF0ZS52YWx1ZU9mKCkgKyBvZmZzZXQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZGF0ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHBhcnNlT25seUNvbXBsZXRlRGF0ZVRpbWVTdHJpbmc6IGZ1bmN0aW9uIChzdHJpbmcpIHtcclxuICAgICAgICBpZiAoL15cXGR7NH0tXFxkezJ9LVxcZHsyfSQvLnRlc3Qoc3RyaW5nKSkge1xyXG4gICAgICAgICAgICAvLyBEYXRlXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKC9eKFxcZHsyfSk6KFxcZHsyfSkoOihcXGR7Mn0pKFxcLihcXGQrKSk/KT8oWnwoKFxcK3wtKShcXGR7Mn0pOihcXGR7Mn0pKSk/JC8udGVzdChzdHJpbmcpKSB7XHJcbiAgICAgICAgICAgIC8vIFRpbWVcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdXRpbHMucGFyc2VVdGlsaXRpZXMucGFyc2VJc29EYXRlU3RyaW5nKHN0cmluZyk7XHJcbiAgICB9LFxyXG5cclxuICAgIHRyYXZlcnNlOiBmdW5jdGlvbiAob2JqLCBmdW5jKSB7XHJcbiAgICAgICAgdmFyIGtleSwgdmFsdWUsIG5ld1ZhbHVlO1xyXG4gICAgICAgIGZvciAoa2V5IGluIG9iaikge1xyXG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gb2JqW2tleV07XHJcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IGZ1bmMoa2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBuZXdWYWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXRpbHMucGFyc2VVdGlsaXRpZXMudHJhdmVyc2UodmFsdWUsIGZ1bmMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9LFxyXG5cclxuICAgIHRyYXZlcnNlQW5kUmV2aXZlOiBmdW5jdGlvbiAoZGF0YSwgcmV2aXZlcikge1xyXG4gICAgICAgIGlmICghcmV2aXZlcikge1xyXG4gICAgICAgICAgICByZXZpdmVyID0gdXRpbHMucGFyc2VVdGlsaXRpZXMuZ2V0UmV2aXZlcigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHV0aWxzLnBhcnNlVXRpbGl0aWVzLnRyYXZlcnNlKGRhdGEsIHJldml2ZXIpO1xyXG4gICAgfSxcclxuXHJcbiAgICBwYXJzZUVycm9yOiBmdW5jdGlvbiAocmV2aXZlciwgZXJyb3IpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJyAmJiBlcnJvci5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvciA9IEpTT04ucGFyc2UoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHttZXNzYWdlOiBlcnJvci5tZXNzYWdlLCBjb2RlOiBlcnJvci5lcnJvckNvZGV9O1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBfcGFyc2VJbnRlcm5hbDogZnVuY3Rpb24gKHJldml2ZXIsIGRhdGEpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnICYmIGRhdGEubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhLCByZXZpdmVyKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICB1dGlscy5wYXJzZVV0aWxpdGllcy50cmF2ZXJzZUFuZFJldml2ZShkYXRhLCByZXZpdmVyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfSxcclxuXHJcbiAgICBfdHJhbnNmb3JtUmVzdWx0OiBmdW5jdGlvbiAoZGF0YSwgYWRkaXRpb25hbFByb3BlcnRpZXMpIHtcclxuICAgICAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge3Jlc3VsdDogZGF0YS5SZXN1bHR9O1xyXG4gICAgICAgICAgICBfLmV4dGVuZChyZXN1bHQsIGFkZGl0aW9uYWxQcm9wZXJ0aWVzKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHBhcnNlUmVzdWx0OiBmdW5jdGlvbiAocmV2aXZlciwgZGF0YSkge1xyXG4gICAgICAgIGRhdGEgPSB1dGlscy5wYXJzZVV0aWxpdGllcy5fcGFyc2VJbnRlcm5hbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIHJldHVybiB1dGlscy5wYXJzZVV0aWxpdGllcy5fdHJhbnNmb3JtUmVzdWx0KGRhdGEsIHtjb3VudDogZGF0YS5Db3VudH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBwYXJzZVNpbmdsZVJlc3VsdDogZnVuY3Rpb24gKHJldml2ZXIsIGRhdGEpIHtcclxuICAgICAgICBkYXRhID0gdXRpbHMucGFyc2VVdGlsaXRpZXMuX3BhcnNlSW50ZXJuYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgICAgICByZXR1cm4gdXRpbHMucGFyc2VVdGlsaXRpZXMuX3RyYW5zZm9ybVJlc3VsdChkYXRhKTtcclxuICAgIH0sXHJcblxyXG4gICAgcGFyc2VVcGRhdGVSZXN1bHQ6IGZ1bmN0aW9uIChyZXZpdmVyLCBkYXRhKSB7XHJcbiAgICAgICAgZGF0YSA9IHV0aWxzLnBhcnNlVXRpbGl0aWVzLl9wYXJzZUludGVybmFsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgcmV0dXJuIHV0aWxzLnBhcnNlVXRpbGl0aWVzLl90cmFuc2Zvcm1SZXN1bHQoZGF0YSwge01vZGlmaWVkQXQ6IGRhdGEuTW9kaWZpZWRBdH0pO1xyXG4gICAgfVxyXG59O1xyXG5cclxudXRpbHMuYnVpbGRQcm9taXNlID0gZnVuY3Rpb24gYnVpbGRQcm9taXNlKG9wZXJhdGlvbiwgc3VjY2VzcywgZXJyb3IpIHtcclxuICAgIHZhciBjYWxsYmFja3MgPSB1dGlscy5nZXRDYWxsYmFja3Moc3VjY2VzcywgZXJyb3IpO1xyXG4gICAgb3BlcmF0aW9uKGNhbGxiYWNrcy5zdWNjZXNzLCBjYWxsYmFja3MuZXJyb3IpO1xyXG4gICAgcmV0dXJuIGNhbGxiYWNrcy5wcm9taXNlO1xyXG59O1xyXG5cclxudXRpbHMuZ2V0Q2FsbGJhY2tzID0gZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XHJcbiAgICB2YXIgcHJvbWlzZTtcclxuICAgIHZhciBjcmVhdGVQcm9taXNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgcnN2cC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgc3VjY2VzcyA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBlcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgaWYgKGlzTm9kZWpzKSB7XHJcbiAgICAgICAgLy8gbm9kZSBqcyBzdHlsZSBjb250aW51YXRpb25cclxuICAgICAgICBpZiAodHlwZW9mIHN1Y2Nlc3MgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGVycm9yICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IHN1Y2Nlc3M7XHJcbiAgICAgICAgICAgIHN1Y2Nlc3MgPSBmdW5jdGlvbiAoZGF0YSwgcmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEsIHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdWNjZXNzICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBlcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBwcm9taXNlID0gY3JlYXRlUHJvbWlzZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzdWNjZXNzICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBlcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBwcm9taXNlID0gY3JlYXRlUHJvbWlzZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge3Byb21pc2U6IHByb21pc2UsIHN1Y2Nlc3M6IHN1Y2Nlc3MsIGVycm9yOiBlcnJvcn07XHJcbn07XHJcblxyXG51dGlscy5idWlsZEF1dGhIZWFkZXIgPSBmdW5jdGlvbiBidWlsZEF1dGhIZWFkZXIoc2V0dXAsIG9wdGlvbnMpIHtcclxuICAgIHZhciBhdXRoSGVhZGVyVmFsdWUgPSBudWxsO1xyXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hdXRoSGVhZGVycyA9PT0gZmFsc2UpIHtcclxuICAgICAgICByZXR1cm4gYXV0aEhlYWRlclZhbHVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHNldHVwLnRva2VuKSB7XHJcbiAgICAgICAgYXV0aEhlYWRlclZhbHVlID0gKHNldHVwLnRva2VuVHlwZSB8fCAnYmVhcmVyJykgKyAnICcgKyBzZXR1cC50b2tlbjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNldHVwLm1hc3RlcktleSkge1xyXG4gICAgICAgIGF1dGhIZWFkZXJWYWx1ZSA9ICdtYXN0ZXJrZXkgJyArIHNldHVwLm1hc3RlcktleTtcclxuICAgIH1cclxuICAgIGlmIChhdXRoSGVhZGVyVmFsdWUpIHtcclxuICAgICAgICByZXR1cm4ge0F1dGhvcml6YXRpb246IGF1dGhIZWFkZXJWYWx1ZX07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59O1xyXG5cclxudXRpbHMuRGV2aWNlUmVnaXN0cmF0aW9uUmVzdWx0ID0gZnVuY3Rpb24gRGV2aWNlUmVnaXN0cmF0aW9uUmVzdWx0KHRva2VuKSB7XHJcbiAgICB0aGlzLnRva2VuID0gdG9rZW47XHJcbn07XHJcblxyXG51dGlscy5jbG9uZURhdGUgPSBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUpO1xyXG59O1xyXG5cclxudXRpbHMuYnVpbGRVcmwgPSBmdW5jdGlvbiAoc2V0dXApIHtcclxuICAgIHZhciB1cmwgPSAnJztcclxuICAgIGlmICh0eXBlb2Ygc2V0dXAuc2NoZW1lID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHVybCArPSBzZXR1cC5zY2hlbWUgKyAnOic7XHJcbiAgICB9XHJcbiAgICB1cmwgKz0gc2V0dXAudXJsO1xyXG4gICAgaWYgKHNldHVwLmFwaUtleSkge1xyXG4gICAgICAgIHVybCArPSBzZXR1cC5hcGlLZXkgKyAnLyc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdXJsO1xyXG59O1xyXG5cclxudXRpbHMuZ2V0RGJPcGVyYXRvcnMgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbiwgc2hhbGxvdykge1xyXG4gICAgdmFyIGRiT3BlcmF0b3JzID0gW107XHJcblxyXG4gICAgaWYgKHR5cGVvZiBleHByZXNzaW9uID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBkYk9wZXJhdG9ycztcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbW9kaWZpZXJLZXlzID0gT2JqZWN0LmtleXMoZXhwcmVzc2lvbik7XHJcbiAgICBfLmVhY2gobW9kaWZpZXJLZXlzLCBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgaWYgKGtleS5pbmRleE9mKCckJykgPT09IDApIHtcclxuICAgICAgICAgICAgZGJPcGVyYXRvcnMucHVzaChrZXkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cHJlc3Npb25ba2V5XSA9PT0gJ29iamVjdCcgJiYgIXNoYWxsb3cpIHtcclxuICAgICAgICAgICAgZGJPcGVyYXRvcnMgPSBkYk9wZXJhdG9ycy5jb25jYXQodXRpbHMuZ2V0RGJPcGVyYXRvcnMoZXhwcmVzc2lvbltrZXldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGRiT3BlcmF0b3JzO1xyXG59O1xyXG5cclxuXHJcbnZhciB1bnN1cHBvcnRlZERiT3BlcmF0b3JzID0gW1xyXG4gICAgJyRnZW9XaXRoaW4nLFxyXG4gICAgJyRnZW9JbnRlcnNlY3RzJyxcclxuICAgICckbmVhcicsXHJcbiAgICAnJHdpdGhpbicsXHJcbiAgICAnJG5lYXJTcGhlcmUnXHJcbl07XHJcblxyXG51dGlscy5nZXRVbnN1cHBvcnRlZE9wZXJhdG9ycyA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgIHZhciBkYk9wZXJhdG9ycyA9IHV0aWxzLmdldERiT3BlcmF0b3JzKGZpbHRlcik7XHJcbiAgICByZXR1cm4gXy5pbnRlcnNlY3Rpb24oZGJPcGVyYXRvcnMsIHVuc3VwcG9ydGVkRGJPcGVyYXRvcnMpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB1dGlscztcclxuIl19
if (typeof module === "object" && typeof exports === "object") { module.exports = Everlive; }